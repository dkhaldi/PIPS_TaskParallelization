static void daxpy_r(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dy[i] = dy[i]+da*dx[i];
}
static void daxpy_ur(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy, m;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%4;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dy[i] = dy[i]+da*dx[i];
      if (n<4) 
         return;
   }
   for(i = m; i <= n-1; i += 4) {
      dy[i] = dy[i]+da*dx[i];
      dy[i+1] = dy[i+1]+da*dx[i+1];
      dy[i+2] = dy[i+2]+da*dx[i+2];
      dy[i+3] = dy[i+3]+da*dx[i+3];
   }
}
static REAL ddot_r(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dtemp = dtemp+dx[i]*dy[i];
   return dtemp;
}
static REAL ddot_ur(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy, m;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%5;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dtemp = dtemp+dx[i]*dy[i];
      if (n<5) 
         return dtemp;
   }
   for(i = m; i <= n-1; i += 5)
      
      
      dtemp = dtemp+dx[i]*dy[i]+dx[i+1]*dy[i+1]+dx[i+2]*dy[i+2]+dx[i+3]*dy[i+3]+dx[i+4]*dy[i+4];
   return dtemp;
}
static void dgefa(REAL *a, int lda, int n, int *ipvt, int *info, int roll)
{
   REAL t;
   int j, k, kp1, l, nm1;
   
   /* gaussian elimination with partial pivoting */
   
   if (roll) {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_r(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
   else {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_ur(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
}
static void dgesl(REAL *a, int lda, int n, int *ipvt, REAL *b, int job, int roll)
{
   REAL t;
   int k, kb, l, nm1;

   if (roll) {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_r(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_r(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_r(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
   else {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_ur(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_ur(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_ur(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
}
static void dscal_r(int n, REAL da, REAL *dx, int incx)
{
   int i, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dx[i] = da*dx[i];
}
static void dscal_ur(int n, REAL da, REAL *dx, int incx)
{
   int i, m, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
   m = n%5;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dx[i] = da*dx[i];
      if (n<5) 
         return;
   }
   for(i = m; i <= n-1; i += 5) {
      dx[i] = da*dx[i];
      dx[i+1] = da*dx[i+1];
      dx[i+2] = da*dx[i+2];
      dx[i+3] = da*dx[i+3];
      dx[i+4] = da*dx[i+4];
   }
}
static int idamax(int n, REAL *dx, int incx)
{
   REAL dmax;
   int i, ix, itemp;

   if (n<1) 
      return -1;
   if (n==1) 
      return 0;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      ix = 1;
      dmax = fabs((double) dx[0]);
      ix = ix+incx;
      for(i = 1; i <= n-1; i += 1) {
         if (fabs((double) dx[ix])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[ix]);
         }
         ix = ix+incx;
      }
   }
   else {
      
      /* code for increment equal to 1 */
      
      itemp = 0;
      dmax = fabs((double) dx[0]);
      for(i = 1; i <= n-1; i += 1)
         if (fabs((double) dx[i])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[i]);
         }
   }
   return itemp;
}
static REAL linpack(long int nreps, int arsize)
{
   REAL *a, *b;
   REAL norma, t1, kflops, tdgesl, tdgefa, totalt, toverhead, ops;
   int *ipvt, n, info, lda;
   long int i, arsize2d;

   lda = arsize;
   n = arsize/2;
   arsize2d = (long int) arsize*(long int) arsize;
   ops = 2.0*n*n*n/3.0+2.0*n*n;
   a = (REAL *) mempool;
   b = a+arsize2d;
   ipvt = (int *) &b[arsize];
   tdgesl = 0;
   tdgefa = 0;
   totalt = second();
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      t1 = second();
      dgefa(a, lda, n, ipvt, &info, 1);
      tdgefa += second()-t1;
      t1 = second();
      dgesl(a, lda, n, ipvt, b, 0, 1);
      tdgesl += second()-t1;
   }
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      t1 = second();
      dgefa(a, lda, n, ipvt, &info, 0);
      tdgefa += second()-t1;
      t1 = second();
      dgesl(a, lda, n, ipvt, b, 0, 0);
      tdgesl += second()-t1;
   }
   totalt = second()-totalt;
   if (totalt<0.5||tdgefa+tdgesl<0.2) 
      return 0.;
   kflops = 2.*nreps*ops/(1000.*(tdgefa+tdgesl));
   toverhead = totalt-tdgefa-tdgesl;
   if (tdgefa<0.) 
      tdgefa = 0.;
   if (tdgesl<0.) 
      tdgesl = 0.;
   if (toverhead<0.) 
      toverhead = 0.;
   
   
   
   printf("%8ld %6.2f %6.2f%% %6.2f%% %6.2f%%  %9.3f\n", nreps, totalt, 100.*tdgefa/totalt, 100.*tdgesl/totalt, 100.*toverhead/totalt, kflops);
   return totalt;
}
static void matgen(REAL *a, int lda, int n, REAL *b, REAL *norma)
{
   int init, i, j;

   init = 1325;
   *norma = 0.0;
   for(j = 0; j <= n-1; j += 1)
      for(i = 0; i <= n-1; i += 1) {
         init = (int) ((long int) 3125*(long int) init%65536L);
         a[lda*j+i] = (init-32768.0)/16384.0;
         *norma = a[lda*j+i]>*norma?a[lda*j+i]:*norma;
      }
   for(i = 0; i <= n-1; i += 1)
      b[i] = 0.0;
   for(j = 0; j <= n-1; j += 1)
      for(i = 0; i <= n-1; i += 1)
         b[i] = b[i]+a[lda*j+i];
}
static REAL second(void)
{
   return (REAL) ((REAL) clock()/((REAL) 1000000l));
}
void main(void)
{
   char buf[80];
   int arsize;
   long int arsize2d, memreq, nreps;
   size_t malloc_arg;
l99999:   ;

   if (!1) goto break_1;
   printf("Enter array size (q to quit) [200]:  ");
   fgets(buf, 79, stdin);
   if (buf[0]=='q'||buf[0]=='Q') goto break_1;
   if (buf[0]=='\0'||buf[0]=='\n')
      arsize = 200;
   else
      arsize = atoi(buf);
   arsize /= 2;
   arsize *= 2;
   if (arsize<10)
      printf("Too small.\n");
   else {
      arsize2d = (long int) arsize*(long int) arsize;
      memreq = arsize2d*sizeof(REAL)+(long int) arsize*sizeof(REAL)+(long int) arsize*sizeof(int);
      printf("Memory required:  %ldK.\n", memreq+512L>>10);
      malloc_arg = (size_t) memreq;
      if (malloc_arg!=memreq||(mempool = malloc(malloc_arg))==(void *) 0)
         printf("Not enough memory available for given array size.\n\n");
      else {
         printf("\n\nLINPACK benchmark, %s precision.\n", "Single");
         printf("Machine precision:  %d digits.\n", 6);
         printf("Array size %d X %d.\n", arsize, arsize);
         printf("Average rolled and unrolled performance:\n\n");
         printf("    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS\n");
         printf("----------------------------------------------------\n");
         nreps = 1;
         while (linpack(nreps, arsize)<10.) 
            nreps *= 2;
         free(mempool);
         printf("\n");
      }
   }
loop_end_1:   ;
   goto l99999;
break_1:   ;
}
static void daxpy_r(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dy[i] = dy[i]+da*dx[i];
}
static void daxpy_ur(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy, m;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%4;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dy[i] = dy[i]+da*dx[i];
      if (n<4) 
         return;
   }
   for(i = m; i <= n-1; i += 4) {
      dy[i] = dy[i]+da*dx[i];
      dy[i+1] = dy[i+1]+da*dx[i+1];
      dy[i+2] = dy[i+2]+da*dx[i+2];
      dy[i+3] = dy[i+3]+da*dx[i+3];
   }
}
static REAL ddot_r(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dtemp = dtemp+dx[i]*dy[i];
   return dtemp;
}
static REAL ddot_ur(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy, m;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%5;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dtemp = dtemp+dx[i]*dy[i];
      if (n<5) 
         return dtemp;
   }
   for(i = m; i <= n-1; i += 5)
      
      
      dtemp = dtemp+dx[i]*dy[i]+dx[i+1]*dy[i+1]+dx[i+2]*dy[i+2]+dx[i+3]*dy[i+3]+dx[i+4]*dy[i+4];
   return dtemp;
}
static void dgefa(REAL *a, int lda, int n, int *ipvt, int *info, int roll)
{
   REAL t;
   int j, k, kp1, l, nm1;
   
   /* gaussian elimination with partial pivoting */
   
   if (roll) {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_r(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
   else {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_ur(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
}
static void dgesl(REAL *a, int lda, int n, int *ipvt, REAL *b, int job, int roll)
{
   REAL t;
   int k, kb, l, nm1;

   if (roll) {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_r(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_r(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_r(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
   else {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_ur(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_ur(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_ur(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
}
static void dscal_r(int n, REAL da, REAL *dx, int incx)
{
   int i, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dx[i] = da*dx[i];
}
static void dscal_ur(int n, REAL da, REAL *dx, int incx)
{
   int i, m, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
   m = n%5;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dx[i] = da*dx[i];
      if (n<5) 
         return;
   }
   for(i = m; i <= n-1; i += 5) {
      dx[i] = da*dx[i];
      dx[i+1] = da*dx[i+1];
      dx[i+2] = da*dx[i+2];
      dx[i+3] = da*dx[i+3];
      dx[i+4] = da*dx[i+4];
   }
}
static int idamax(int n, REAL *dx, int incx)
{
   REAL dmax;
   int i, ix, itemp;

   if (n<1) 
      return -1;
   if (n==1) 
      return 0;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      ix = 1;
      dmax = fabs((double) dx[0]);
      ix = ix+incx;
      for(i = 1; i <= n-1; i += 1) {
         if (fabs((double) dx[ix])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[ix]);
         }
         ix = ix+incx;
      }
   }
   else {
      
      /* code for increment equal to 1 */
      
      itemp = 0;
      dmax = fabs((double) dx[0]);
      for(i = 1; i <= n-1; i += 1)
         if (fabs((double) dx[i])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[i]);
         }
   }
   return itemp;
}
static REAL linpack(long int nreps, int arsize)
{
   REAL *a, *b;
   REAL norma, t1, kflops, tdgesl, tdgefa, totalt, toverhead, ops;
   int *ipvt, n, info, lda;
   long int i, arsize2d;

   lda = arsize;
   n = arsize/2;
   arsize2d = (long int) arsize*(long int) arsize;
   ops = 2.0*n*n*n/3.0+2.0*n*n;
   a = (REAL *) mempool;
   b = a+arsize2d;
   ipvt = (int *) &b[arsize];
   tdgesl = 0;
   tdgefa = 0;
   totalt = second();
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      t1 = second();
      dgefa(a, lda, n, ipvt, &info, 1);
      tdgefa += second()-t1;
      t1 = second();
      dgesl(a, lda, n, ipvt, b, 0, 1);
      tdgesl += second()-t1;
   }
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      t1 = second();
      dgefa(a, lda, n, ipvt, &info, 0);
      tdgefa += second()-t1;
      t1 = second();
      dgesl(a, lda, n, ipvt, b, 0, 0);
      tdgesl += second()-t1;
   }
   totalt = second()-totalt;
   if (totalt<0.5||tdgefa+tdgesl<0.2) 
      return 0.;
   kflops = 2.*nreps*ops/(1000.*(tdgefa+tdgesl));
   toverhead = totalt-tdgefa-tdgesl;
   if (tdgefa<0.) 
      tdgefa = 0.;
   if (tdgesl<0.) 
      tdgesl = 0.;
   if (toverhead<0.) 
      toverhead = 0.;
   
   
   
   printf("%8ld %6.2f %6.2f%% %6.2f%% %6.2f%%  %9.3f\n", nreps, totalt, 100.*tdgefa/totalt, 100.*tdgesl/totalt, 100.*toverhead/totalt, kflops);
   return totalt;
}
static void matgen(REAL *a, int lda, int n, REAL *b, REAL *norma)
{
   int init, i, j;

   init = 1325;
   *norma = 0.0;
   for(j = 0; j <= n-1; j += 1)
      for(i = 0; i <= n-1; i += 1) {
         init = (int) ((long int) 3125*(long int) init%65536L);
         a[lda*j+i] = (init-32768.0)/16384.0;
         *norma = a[lda*j+i]>*norma?a[lda*j+i]:*norma;
      }
   for(i = 0; i <= n-1; i += 1)
      b[i] = 0.0;
   for(j = 0; j <= n-1; j += 1)
      for(i = 0; i <= n-1; i += 1)
         b[i] = b[i]+a[lda*j+i];
}
static REAL second(void)
{
   return (REAL) ((REAL) clock()/((REAL) 1000000l));
}
void main(void)
{
   char buf[80];
   int arsize;
   long int arsize2d, memreq, nreps;
   size_t malloc_arg;
l99999:   ;

   if (!1) goto break_1;
   printf("Enter array size (q to quit) [200]:  ");
   fgets(buf, 79, stdin);
   if (buf[0]=='q'||buf[0]=='Q') goto break_1;
   if (buf[0]=='\0'||buf[0]=='\n')
      arsize = 200;
   else
      arsize = atoi(buf);
   arsize /= 2;
   arsize *= 2;
   if (arsize<10)
      printf("Too small.\n");
   else {
      arsize2d = (long int) arsize*(long int) arsize;
      memreq = arsize2d*sizeof(REAL)+(long int) arsize*sizeof(REAL)+(long int) arsize*sizeof(int);
      printf("Memory required:  %ldK.\n", memreq+512L>>10);
      malloc_arg = (size_t) memreq;
      if (malloc_arg!=memreq||(mempool = malloc(malloc_arg))==(void *) 0)
         printf("Not enough memory available for given array size.\n\n");
      else {
         printf("\n\nLINPACK benchmark, %s precision.\n", "Single");
         printf("Machine precision:  %d digits.\n", 6);
         printf("Array size %d X %d.\n", arsize, arsize);
         printf("Average rolled and unrolled performance:\n\n");
         printf("    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS\n");
         printf("----------------------------------------------------\n");
         nreps = 1;
         while (linpack(nreps, arsize)<10.) 
            nreps *= 2;
         free(mempool);
         printf("\n");
      }
   }
loop_end_1:   ;
   goto l99999;
break_1:   ;
}
static void daxpy_r(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
#pragma omp parallel for 
   for(i = 0; i <= n-1; i += 1)
      dy[i] = dy[i]+da*dx[i];
}
static void daxpy_ur(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy, m;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%4;
   if (m!=0) {
#pragma omp parallel for 
      for(i = 0; i <= m-1; i += 1)
         dy[i] = dy[i]+da*dx[i];
      if (n<4) 
         return;
   }
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i] = dy[i]+da*dx[i];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i+1] = dy[i+1]+da*dx[i+1];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i+2] = dy[i+2]+da*dx[i+2];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i+3] = dy[i+3]+da*dx[i+3];
}
static REAL ddot_r(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dtemp = dtemp+dx[i]*dy[i];
   return dtemp;
}
static REAL ddot_ur(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy, m;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%5;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dtemp = dtemp+dx[i]*dy[i];
      if (n<5) 
         return dtemp;
   }
   for(i = m; i <= n-1; i += 5)
      
      
      dtemp = dtemp+dx[i]*dy[i]+dx[i+1]*dy[i+1]+dx[i+2]*dy[i+2]+dx[i+3]*dy[i+3]+dx[i+4]*dy[i+4];
   return dtemp;
}
static void dgefa(REAL *a, int lda, int n, int *ipvt, int *info, int roll)
{
   REAL t;
   int j, k, kp1, l, nm1;
   
   /* gaussian elimination with partial pivoting */
   
   if (roll) {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_r(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
   else {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_ur(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
}
static void dgesl(REAL *a, int lda, int n, int *ipvt, REAL *b, int job, int roll)
{
   REAL t;
   int k, kb, l, nm1;

   if (roll) {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_r(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
#pragma omp parallel for private(t)
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_r(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_r(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
   else {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_ur(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
#pragma omp parallel for private(t)
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_ur(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_ur(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
}
static void dscal_r(int n, REAL da, REAL *dx, int incx)
{
   int i, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
#pragma omp parallel for 
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
#pragma omp parallel for 
   for(i = 0; i <= n-1; i += 1)
      dx[i] = da*dx[i];
}
static void dscal_ur(int n, REAL da, REAL *dx, int incx)
{
   int i, m, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
#pragma omp parallel for 
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
   m = n%5;
   if (m!=0) {
#pragma omp parallel for 
      for(i = 0; i <= m-1; i += 1)
         dx[i] = da*dx[i];
      if (n<5) 
         return;
   }
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i] = da*dx[i];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+1] = da*dx[i+1];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+2] = da*dx[i+2];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+3] = da*dx[i+3];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+4] = da*dx[i+4];
}
static int idamax(int n, REAL *dx, int incx)
{
   REAL dmax;
   int i, ix, itemp;

   if (n<1) 
      return -1;
   if (n==1) 
      return 0;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      ix = 1;
      dmax = fabs((double) dx[0]);
      ix = ix+incx;
      for(i = 1; i <= n-1; i += 1) {
         if (fabs((double) dx[ix])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[ix]);
         }
         ix = ix+incx;
      }
   }
   else {
      
      /* code for increment equal to 1 */
      
      itemp = 0;
      dmax = fabs((double) dx[0]);
      for(i = 1; i <= n-1; i += 1)
         if (fabs((double) dx[i])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[i]);
         }
   }
   return itemp;
}
static REAL linpack(long int nreps, int arsize)
{
   REAL *a, *b;
   REAL norma, t1, kflops, tdgesl, tdgefa, totalt, toverhead, ops;
   int *ipvt, n, info, lda;
   long int i, arsize2d;

   lda = arsize;
   n = arsize/2;
   arsize2d = (long int) arsize*(long int) arsize;
   ops = 2.0*n*n*n/3.0+2.0*n*n;
   a = (REAL *) mempool;
   b = a+arsize2d;
   ipvt = (int *) &b[arsize];
   tdgesl = 0;
   tdgefa = 0;
   totalt = second();
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      dgefa(a, lda, n, ipvt, &info, 1);
      dgesl(a, lda, n, ipvt, b, 0, 1);
   }
   for(i = 0; i <= nreps-1; i += 1) {
      t1 = second();
      tdgefa += second()-t1;
      t1 = second();
      tdgesl += second()-t1;
   }
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      dgefa(a, lda, n, ipvt, &info, 0);
      dgesl(a, lda, n, ipvt, b, 0, 0);
   }
   for(i = 0; i <= nreps-1; i += 1) {
      t1 = second();
      tdgefa += second()-t1;
      t1 = second();
      tdgesl += second()-t1;
   }
   totalt = second()-totalt;
   if (totalt<0.5||tdgefa+tdgesl<0.2) 
      return 0.;
   kflops = 2.*nreps*ops/(1000.*(tdgefa+tdgesl));
   toverhead = totalt-tdgefa-tdgesl;
   if (tdgefa<0.) 
      tdgefa = 0.;
   if (tdgesl<0.) 
      tdgesl = 0.;
   if (toverhead<0.) 
      toverhead = 0.;
   
   
   
   printf("%8ld %6.2f %6.2f%% %6.2f%% %6.2f%%  %9.3f\n", nreps, totalt, 100.*tdgefa/totalt, 100.*tdgesl/totalt, 100.*toverhead/totalt, kflops);
   return totalt;
}
static void matgen(REAL *a, int lda, int n, REAL *b, REAL *norma)
{
   int init, i, j;

   init = 1325;
   *norma = 0.0;
   for(j = 0; j <= n-1; j += 1)
      for(i = 0; i <= n-1; i += 1) {
         init = (int) ((long int) 3125*(long int) init%65536L);
         a[lda*j+i] = (init-32768.0)/16384.0;
         *norma = a[lda*j+i]>*norma?a[lda*j+i]:*norma;
      }
#pragma omp parallel for 
   for(i = 0; i <= n-1; i += 1)
      b[i] = 0.0;
   for(j = 0; j <= n-1; j += 1)
#pragma omp parallel for 
      for(i = 0; i <= n-1; i += 1)
         b[i] = b[i]+a[lda*j+i];
}
static REAL second(void)
{
   return (REAL) ((REAL) clock()/((REAL) 1000000l));
}
void main(void)
{
   char buf[80];
   int arsize;
   long int arsize2d, memreq, nreps;
   size_t malloc_arg;
l99999:   ;

   if (!1) goto break_1;
   printf("Enter array size (q to quit) [200]:  ");
   fgets(buf, 79, stdin);
   if (buf[0]=='q'||buf[0]=='Q') goto break_1;
   if (buf[0]=='\0'||buf[0]=='\n')
      arsize = 200;
   else
      arsize = atoi(buf);
   arsize /= 2;
   arsize *= 2;
   if (arsize<10)
      printf("Too small.\n");
   else {
      arsize2d = (long int) arsize*(long int) arsize;
      memreq = arsize2d*sizeof(REAL)+(long int) arsize*sizeof(REAL)+(long int) arsize*sizeof(int);
      printf("Memory required:  %ldK.\n", memreq+512L>>10);
      malloc_arg = (size_t) memreq;
      if (malloc_arg!=memreq||(mempool = malloc(malloc_arg))==(void *) 0)
         printf("Not enough memory available for given array size.\n\n");
      else {
         printf("\n\nLINPACK benchmark, %s precision.\n", "Single");
         printf("Machine precision:  %d digits.\n", 6);
         printf("Array size %d X %d.\n", arsize, arsize);
         printf("Average rolled and unrolled performance:\n\n");
         printf("    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS\n");
         printf("----------------------------------------------------\n");
         nreps = 1;
         while (linpack(nreps, arsize)<10.) 
            nreps *= 2;
         free(mempool);
         printf("\n");
      }
   }
loop_end_1:   ;
   goto l99999;
break_1:   ;
}
static void daxpy_r(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
#pragma omp parallel for 
   for(i = 0; i <= n-1; i += 1)
      dy[i] = dy[i]+da*dx[i];
}
static void daxpy_ur(int n, REAL da, REAL *dx, int incx, REAL *dy, int incy)
{
   int i, ix, iy, m;

   if (n<=0) 
      return;
   if (da==0.0) 
      return;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 1;
      iy = 1;
      if (incx<0) 
         ix = (-n+1)*incx+1;
      if (incy<0) 
         iy = (-n+1)*incy+1;
      for(i = 0; i <= n-1; i += 1) {
         dy[iy] = dy[iy]+da*dx[ix];
         ix = ix+incx;
         iy = iy+incy;
      }
      return;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%4;
   if (m!=0) {
#pragma omp parallel for 
      for(i = 0; i <= m-1; i += 1)
         dy[i] = dy[i]+da*dx[i];
      if (n<4) 
         return;
   }
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i] = dy[i]+da*dx[i];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i+1] = dy[i+1]+da*dx[i+1];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i+2] = dy[i+2]+da*dx[i+2];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 4)
      dy[i+3] = dy[i+3]+da*dx[i+3];
}
static REAL ddot_r(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   for(i = 0; i <= n-1; i += 1)
      dtemp = dtemp+dx[i]*dy[i];
   return dtemp;
}
static REAL ddot_ur(int n, REAL *dx, int incx, REAL *dy, int incy)
{
   REAL dtemp;
   int i, ix, iy, m;

   dtemp = 0.0;

   if (n<=0) 
      return 0.0;

   if (incx!=1||incy!=1) {
      
      /* code for unequal increments or equal increments != 1 */
      
      ix = 0;
      iy = 0;
      if (incx<0) 
         ix = (-n+1)*incx;
      if (incy<0) 
         iy = (-n+1)*incy;
      for(i = 0; i <= n-1; i += 1) {
         dtemp = dtemp+dx[ix]*dy[iy];
         ix = ix+incx;
         iy = iy+incy;
      }
      return dtemp;
   }
   
   /* code for both increments equal to 1 */
   
   m = n%5;
   if (m!=0) {
      for(i = 0; i <= m-1; i += 1)
         dtemp = dtemp+dx[i]*dy[i];
      if (n<5) 
         return dtemp;
   }
   for(i = m; i <= n-1; i += 5)
      
      
      dtemp = dtemp+dx[i]*dy[i]+dx[i+1]*dy[i+1]+dx[i+2]*dy[i+2]+dx[i+3]*dy[i+3]+dx[i+4]*dy[i+4];
   return dtemp;
}
static void dgefa(REAL *a, int lda, int n, int *ipvt, int *info, int roll)
{
   REAL t;
   int j, k, kp1, l, nm1;
   
   /* gaussian elimination with partial pivoting */
   
   if (roll) {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_r(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
   else {
      *info = 0;
      nm1 = n-1;
      if (nm1>=0)
         for(k = 0; k <= nm1-1; k += 1) {
            kp1 = k+1;
            
            /* find l = pivot index */
            
            l = idamax(n-k, &a[lda*k+k], 1)+k;
            ipvt[k] = l;
            
            /* zero pivot implies this column already
                               triangularized */
            
            if (a[lda*k+l]!=0.0) {
               
               /* interchange if necessary */
               
               if (l!=k) {
                  t = a[lda*k+l];
                  a[lda*k+l] = a[lda*k+k];
                  a[lda*k+k] = t;
               }
               
               /* compute multipliers */
               
               t = -(1.0/a[lda*k+k]);
               dscal_ur(n-(k+1), t, &a[lda*k+k+1], 1);
               
               /* row elimination with column indexing */
               
               for(j = kp1; j <= n-1; j += 1) {
                  t = a[lda*j+l];
                  if (l!=k) {
                     a[lda*j+l] = a[lda*j+k];
                     a[lda*j+k] = t;
                  }
                  daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &a[lda*j+k+1], 1);
               }
            }
            else
               *info = k;
         }
      ipvt[n-1] = n-1;
      if (a[lda*(n-1)+n-1]==0.0) 
         *info = n-1;
   }
}
static void dgesl(REAL *a, int lda, int n, int *ipvt, REAL *b, int job, int roll)
{
   REAL t;
   int k, kb, l, nm1;

   if (roll) {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_r(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_r(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
#pragma omp parallel for private(t)
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_r(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_r(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
   else {
      nm1 = n-1;
      if (job==0) {
         
         /* job = 0 , solve  a * x = b   */
         /* first solve  l*y = b         */
         
         if (nm1>=1)
            for(k = 0; k <= nm1-1; k += 1) {
               l = ipvt[k];
               t = b[l];
               if (l!=k) {
                  b[l] = b[k];
                  b[k] = t;
               }
               daxpy_ur(n-(k+1), t, &a[lda*k+k+1], 1, &b[k+1], 1);
            }
         
         /* now solve  u*x = y */
         
         for(kb = 0; kb <= n-1; kb += 1) {
            k = n-(kb+1);
            b[k] = b[k]/a[lda*k+k];
            t = -b[k];
            daxpy_ur(k, t, &a[lda*k+0], 1, &b[0], 1);
         }
      }
      else {
         
         /* job = nonzero, solve  trans(a) * x = b  */
         /* first solve  trans(u)*y = b             */
         
#pragma omp parallel for private(t)
         for(k = 0; k <= n-1; k += 1) {
            t = ddot_ur(k, &a[lda*k+0], 1, &b[0], 1);
            b[k] = (b[k]-t)/a[lda*k+k];
         }
         
         /* now solve trans(l)*x = y     */
         
         if (nm1>=1)
            for(kb = 1; kb <= nm1-1; kb += 1) {
               k = n-(kb+1);
               b[k] = b[k]+ddot_ur(n-(k+1), &a[lda*k+k+1], 1, &b[k+1], 1);
               l = ipvt[k];
               if (l!=k) {
                  t = b[l];
                  b[l] = b[k];
                  b[k] = t;
               }
            }
      }
   }
}
static void dscal_r(int n, REAL da, REAL *dx, int incx)
{
   int i, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
#pragma omp parallel for 
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
#pragma omp parallel for 
   for(i = 0; i <= n-1; i += 1)
      dx[i] = da*dx[i];
}
static void dscal_ur(int n, REAL da, REAL *dx, int incx)
{
   int i, m, nincx;

   if (n<=0) 
      return;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      nincx = n*incx;
#pragma omp parallel for 
      for(i = 0; i <= nincx-1; i += incx)
         dx[i] = da*dx[i];
      return;
   }
   
   /* code for increment equal to 1 */
   
   m = n%5;
   if (m!=0) {
#pragma omp parallel for 
      for(i = 0; i <= m-1; i += 1)
         dx[i] = da*dx[i];
      if (n<5) 
         return;
   }
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i] = da*dx[i];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+1] = da*dx[i+1];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+2] = da*dx[i+2];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+3] = da*dx[i+3];
#pragma omp parallel for 
   for(i = m; i <= n-1; i += 5)
      dx[i+4] = da*dx[i+4];
}
static int idamax(int n, REAL *dx, int incx)
{
   REAL dmax;
   int i, ix, itemp;

   if (n<1) 
      return -1;
   if (n==1) 
      return 0;
   if (incx!=1) {
      
      /* code for increment not equal to 1 */
      
      ix = 1;
      dmax = fabs((double) dx[0]);
      ix = ix+incx;
      for(i = 1; i <= n-1; i += 1) {
         if (fabs((double) dx[ix])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[ix]);
         }
         ix = ix+incx;
      }
   }
   else {
      
      /* code for increment equal to 1 */
      
      itemp = 0;
      dmax = fabs((double) dx[0]);
      for(i = 1; i <= n-1; i += 1)
         if (fabs((double) dx[i])>dmax) {
            itemp = i;
            dmax = fabs((double) dx[i]);
         }
   }
   return itemp;
}
static REAL linpack(long int nreps, int arsize)
{
   REAL *a, *b;
   REAL norma, t1, kflops, tdgesl, tdgefa, totalt, toverhead, ops;
   int *ipvt, n, info, lda;
   long int i, arsize2d;

   lda = arsize;
   n = arsize/2;
   arsize2d = (long int) arsize*(long int) arsize;
   ops = 2.0*n*n*n/3.0+2.0*n*n;
   a = (REAL *) mempool;
   b = a+arsize2d;
   ipvt = (int *) &b[arsize];
   tdgesl = 0;
   tdgefa = 0;
   totalt = second();
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      dgefa(a, lda, n, ipvt, &info, 1);
      dgesl(a, lda, n, ipvt, b, 0, 1);
   }
   for(i = 0; i <= nreps-1; i += 1) {
      t1 = second();
      tdgefa += second()-t1;
      t1 = second();
      tdgesl += second()-t1;
   }
   for(i = 0; i <= nreps-1; i += 1) {
      matgen(a, lda, n, b, &norma);
      dgefa(a, lda, n, ipvt, &info, 0);
      dgesl(a, lda, n, ipvt, b, 0, 0);
   }
   for(i = 0; i <= nreps-1; i += 1) {
      t1 = second();
      tdgefa += second()-t1;
      t1 = second();
      tdgesl += second()-t1;
   }
   totalt = second()-totalt;
   if (totalt<0.5||tdgefa+tdgesl<0.2) 
      return 0.;
   kflops = 2.*nreps*ops/(1000.*(tdgefa+tdgesl));
   toverhead = totalt-tdgefa-tdgesl;
   if (tdgefa<0.) 
      tdgefa = 0.;
   if (tdgesl<0.) 
      tdgesl = 0.;
   if (toverhead<0.) 
      toverhead = 0.;
   
   
   
   printf("%8ld %6.2f %6.2f%% %6.2f%% %6.2f%%  %9.3f\n", nreps, totalt, 100.*tdgefa/totalt, 100.*tdgesl/totalt, 100.*toverhead/totalt, kflops);
   return totalt;
}
static void matgen(REAL *a, int lda, int n, REAL *b, REAL *norma)
{
   int init, i, j;

   init = 1325;
   *norma = 0.0;
   for(j = 0; j <= n-1; j += 1)
      for(i = 0; i <= n-1; i += 1) {
         init = (int) ((long int) 3125*(long int) init%65536L);
         a[lda*j+i] = (init-32768.0)/16384.0;
         *norma = a[lda*j+i]>*norma?a[lda*j+i]:*norma;
      }
#pragma omp parallel for 
   for(i = 0; i <= n-1; i += 1)
      b[i] = 0.0;
   for(j = 0; j <= n-1; j += 1)
#pragma omp parallel for 
      for(i = 0; i <= n-1; i += 1)
         b[i] = b[i]+a[lda*j+i];
}
static REAL second(void)
{
   return (REAL) ((REAL) clock()/((REAL) 1000000l));
}
void main(void)
{
   char buf[80];
   int arsize;
   long int arsize2d, memreq, nreps;
   size_t malloc_arg;
l99999:   ;

   if (!1) goto break_1;
   printf("Enter array size (q to quit) [200]:  ");
   fgets(buf, 79, stdin);
   if (buf[0]=='q'||buf[0]=='Q') goto break_1;
   if (buf[0]=='\0'||buf[0]=='\n')
      arsize = 200;
   else
      arsize = atoi(buf);
   arsize /= 2;
   arsize *= 2;
   if (arsize<10)
      printf("Too small.\n");
   else {
      arsize2d = (long int) arsize*(long int) arsize;
      memreq = arsize2d*sizeof(REAL)+(long int) arsize*sizeof(REAL)+(long int) arsize*sizeof(int);
      printf("Memory required:  %ldK.\n", memreq+512L>>10);
      malloc_arg = (size_t) memreq;
      if (malloc_arg!=memreq||(mempool = malloc(malloc_arg))==(void *) 0)
         printf("Not enough memory available for given array size.\n\n");
      else {
         printf("\n\nLINPACK benchmark, %s precision.\n", "Single");
         printf("Machine precision:  %d digits.\n", 6);
         printf("Array size %d X %d.\n", arsize, arsize);
         printf("Average rolled and unrolled performance:\n\n");
         printf("    Reps Time(s) DGEFA   DGESL  OVERHEAD    KFLOPS\n");
         printf("----------------------------------------------------\n");
         nreps = 1;
         while (linpack(nreps, arsize)<10.) 
            nreps *= 2;
         free(mempool);
         printf("\n");
      }
   }
loop_end_1:   ;
   goto l99999;
break_1:   ;
}
