#
# file generated by logfile_to_tpips for workspace pips_c2openmp30232
#
delete conv-cpu-array-1000
create conv-cpu-array-1000 conv-cpu-array-1000.c
setproperty ABORT_ON_USER_ERROR TRUE
module main


# mandatory for A&K (Rice) parallization on C files
setproperty MEMORY_EFFECTS_ONLY FALSE


echo Select the most precise analysis:
activate MUST_REGIONS
activate TRANSFORMERS_INTER_FULL
activate INTERPROCEDURAL_SUMMARY_PRECONDITION
activate PRECONDITIONS_INTER_FULL
activate REGION_CHAINS


echo Compute the intraprocedural preconditions at the same time as
echo   transformers and use them to improve the accuracy of expression
echo   and statement transformers:
setproperty SEMANTICS_COMPUTE_TRANSFORMERS_IN_CONTEXT TRUE
setproperty SEMANTICS_FIX_POINT_OPERATOR "derivative"


echo Try to restructure the code for more precision:
setproperty UNSPAGHETTIFY_TEST_RESTRUCTURING=TRUE
setproperty UNSPAGHETTIFY_RECURSIVE_DECOMPOSITION=TRUE


echo Privatize scalar variables on all the modules of the program:
apply PRIVATIZE_MODULE[conv_cpu]
apply PRIVATIZE_MODULE[main]


echo Ask for some statistics about the job to be done:
setproperty PARALLELIZATION_STATISTICS=TRUE


echo Ask for the parallelization of all the modules of the program with OpenMP output:
activate RICE_ALL_DEPENDENCE
activate PRINT_PARALLELIZEDOMP_CODE

display PARALLELPRINTED_FILE[conv_cpu]
display PARALLELPRINTED_FILE[main]

echo Consider the generated parallel as the sequential code now:
capply INTERNALIZE_PARALLEL_CODE[conv_cpu,main]

echo Ask for some statistics about the job to be done:
setproperty PARALLELIZATION_STATISTICS=TRUE

echo Ask for the parallelization of all the modules of the program with OpenMP output:
capply COARSE_GRAIN_PARALLELIZATION[conv_cpu,main]
display PRINTED_FILE[conv_cpu]
display PRINTED_FILE[main]

#echo Regenerate the sources from the PIPS transformed code:
#apply UNSPLIT

close
delete conv-cpu-array-1000
quit
# EOF
