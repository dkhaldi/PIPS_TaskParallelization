accurate analysis
by pass some subscripts
restructuring
proper effects
static boolean compress_data(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;
   /* index of current MCU within row */
//             <    is read   >: cinfo cinfo[0].MCUs_per_row
//             <    is written>: last_MCU_col
   JDIMENSION last_MCU_col = cinfo->MCUs_per_row-1;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: last_iMCU_row
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows-1;
   int blkn, bi, ci, yindex, yoffset, blockcnt;
   JDIMENSION ypos, xpos;
   jpeg_component_info *compptr;
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: yoffset
   
   /* Loop to write as much as one whole iMCU row */
   for(yoffset = coef->MCU_vert_offset; yoffset <= coef->MCU_rows_per_iMCU_row-1; yoffset += 1) {
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col
//             <    is written>: MCU_col_num
      for(MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col; MCU_col_num += 1) {
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col
//             <    is written>: blkn
         /* Determine where data comes from in input_buf and do the DCT thing.
                * Each call on forward_DCT processes a horizontal row of DCT blocks
                * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks
                * sequentially.  Dummy blocks at the right or bottom edge are filled in
                * specially.  The data in them does not matter for image reconstruction,
                * so we fill them with values that will encode to the smallest amount of
                * data, viz: all zeroes in the AC entries, DC entries equal to previous
                * block's DC value.  (Thanks to Thomas Kinsman for this idea.)
                */
         blkn = 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col
//             <    is written>: ci
         for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci] coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col
//             <    is written>: compptr
            compptr = (cinfo->cur_comp_info)[ci];
//             <may be read   >: compptr[0].MCU_width 
//                               compptr[0].last_col_width
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr last_MCU_col
//             <    is written>: blockcnt
            blockcnt = MCU_col_num<last_MCU_col?compptr->MCU_width:compptr->last_col_width;
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_sample_width 
//                               last_MCU_col
//             <    is written>: xpos
            xpos = MCU_col_num*compptr->MCU_sample_width;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col yoffset
//             <    is written>: ypos
            ypos = yoffset*8;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height last_MCU_col
//             <    is written>: yindex
            /* ypos == (yoffset+yindex) * DCTSIZE */
            for(yindex = 0; yindex <= compptr->MCU_height-1; yindex += 1) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].iMCU_row_num coef[0].mcu_ctr 
//                               compptr compptr[0].MCU_height 
//                               compptr[0].last_row_height 
//                               last_MCU_col last_iMCU_row yindex 
//                               yoffset

               if (coef->iMCU_row_num<last_iMCU_row||yoffset+yindex<compptr->last_row_height) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

                  (*cinfo->fdct->forward_DCT)(cinfo,compptr,input_buf[ci],(coef->MCU_buffer)[blkn],ypos,xpos,(JDIMENSION) blockcnt);
//             <    is read   >: blockcnt cinfo cinfo[0].comps_in_scan
//                               coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
                  if (blockcnt<compptr->MCU_width) {
//             <may be written>: 
//                               coef[0].MCU_buffer[blkn+blockcnt][*][
//                               *]
//             <    is read   >: blkn blockcnt cinfo 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_buffer[blkn+blockcnt] 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
                     /* Create some dummy blocks at the right edge of the image. */
                     
                     jzero_far((void *) (coef->MCU_buffer)[blkn+blockcnt], (compptr->MCU_width-blockcnt)*(size_t) sizeof(JBLOCK));
//             <    is read   >: blockcnt cinfo cinfo[0].comps_in_scan
//                               coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
//             <    is written>: bi
                     for(bi = blockcnt; bi <= compptr->MCU_width-1; bi += 1)
//             <    is read   >: bi blkn blockcnt cinfo 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_buffer[blkn+bi] 
//                               coef[0].MCU_buffer[blkn+bi-1] 
//                               coef[0].MCU_buffer[blkn+bi-1][0][0] 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
//             <    is written>: coef[0].MCU_buffer[blkn+bi][0][0]
                        (((coef->MCU_buffer)[blkn+bi])[0])[0] = (((coef->MCU_buffer)[blkn+bi-1])[0])[0];
                  }
               }
               else {
//             <may be written>: coef[0].MCU_buffer[blkn][*][*]
//             <    is read   >: blkn cinfo cinfo[0].comps_in_scan 
//                               coef coef[0].MCU_buffer[blkn] 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
                  /* Create a row of dummy blocks at the bottom of the image. */
                  
                  jzero_far((void *) (coef->MCU_buffer)[blkn], compptr->MCU_width*(size_t) sizeof(JBLOCK));
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
//             <    is written>: bi
                  for(bi = 0; bi <= compptr->MCU_width-1; bi += 1)
//             <    is read   >: bi blkn cinfo cinfo[0].comps_in_scan 
//                               coef coef[0].MCU_buffer[blkn+bi] 
//                               coef[0].MCU_buffer[blkn-1] 
//                               coef[0].MCU_buffer[blkn-1][0][0] 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
//             <    is written>: coef[0].MCU_buffer[blkn+bi][0][0]
                     (((coef->MCU_buffer)[blkn+bi])[0])[0] = (((coef->MCU_buffer)[blkn-1])[0])[0];
               }
//             <    is read   >: blkn cinfo cinfo[0].comps_in_scan 
//                               coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
//             <    is written>: blkn
               blkn += compptr->MCU_width;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height last_MCU_col 
//                               ypos
//             <    is written>: ypos
               ypos += 8;
            }
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Try to write the MCU.  In event of a suspension failure, we will
                * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
                */
         if (!(*cinfo->entropy->encode_mcu)(cinfo,coef->MCU_buffer)) {
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col yoffset
//             <    is written>: coef[0].MCU_vert_offset
            /* Suspension forced; update state counters and exit */
            coef->MCU_vert_offset = yoffset;
//             <    is read   >: MCU_col_num coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col
//             <    is written>: coef[0].mcu_ctr
            coef->mcu_ctr = MCU_col_num;
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr last_MCU_col
            return 0;
         }
      }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: coef[0].mcu_ctr
      /* Completed an MCU row, but perhaps not an iMCU row */
      coef->mcu_ctr = 0;
   }
//             <    is read   >: coef coef[0].iMCU_row_num
//             <    is written>: coef[0].iMCU_row_num
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
//             <may be read   >: cinfo[0].coef[0].iMCU_row_num 
//                               cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset 
//                               cinfo[0].coef[0].mcu_ctr
   start_iMCU_row(cinfo);
   return 1;
}
static boolean compress_first_pass(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: last_iMCU_row
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows-1;
   JDIMENSION blocks_across, MCUs_across, MCUindex;
   int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
   JCOEF lastDC;
   jpeg_component_info *compptr;
   JBLOCKARRAY buffer;
   JBLOCKROW thisblockrow, lastblockrow;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      /* Align the virtual buffer for this component. */
      buffer = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[ci],coef->iMCU_row_num*compptr->v_samp_factor,(JDIMENSION) compptr->v_samp_factor,1);
//             <    is read   >: cinfo cinfo[0].num_components coef 
//                               coef[0].iMCU_row_num last_iMCU_row
      /* Count non-dummy DCT block rows in this iMCU row. */
      if (coef->iMCU_row_num<last_iMCU_row)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
         block_rows = compptr->v_samp_factor;
      else {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].height_in_blocks 
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
         /* NB: can't use last_row_height here, since may not be set! */
         block_rows = (int) (compptr->height_in_blocks%compptr->v_samp_factor);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
         if (block_rows==0)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
            block_rows = compptr->v_samp_factor;
      }
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].width_in_blocks
//             <    is written>: blocks_across
      blocks_across = compptr->width_in_blocks;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].h_samp_factor
//             <    is written>: h_samp_factor
      h_samp_factor = compptr->h_samp_factor;
//             <    is read   >: blocks_across cinfo 
//                               cinfo[0].num_components h_samp_factor
//             <    is written>: ndummy
      /* Count number of dummy blocks to be added at the right margin. */
      ndummy = (int) (blocks_across%h_samp_factor);
//             <    is read   >: cinfo cinfo[0].num_components ndummy
      if (ndummy>0)
//             <    is read   >: cinfo cinfo[0].num_components 
//                               h_samp_factor ndummy
//             <    is written>: ndummy
         ndummy = h_samp_factor-ndummy;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: block_row
      /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
           * on forward_DCT processes a complete horizontal row of DCT blocks.
           */
      for(block_row = 0; block_row <= block_rows-1; block_row += 1) {
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row] cinfo 
//                               cinfo[0].num_components
//             <    is written>: thisblockrow
         thisblockrow = buffer[block_row];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->fdct->forward_DCT)(cinfo,compptr,input_buf[ci],thisblockrow,(JDIMENSION) (block_row*8),(JDIMENSION) 0,blocks_across);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components ndummy
         if (ndummy>0) {
//             <    is read   >: block_rows blocks_across cinfo 
//                               cinfo[0].num_components thisblockrow
//             <    is written>: thisblockrow
            /* Create dummy blocks at the right edge of the image. */
            thisblockrow += blocks_across;
//             <may be written>: thisblockrow[*][*]
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components ndummy 
//                               thisblockrow
            /* => first dummy block */
            jzero_far((void *) thisblockrow, ndummy*(size_t) sizeof(JBLOCK));
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components thisblockrow 
//                               thisblockrow[-1][0]
//             <    is written>: lastDC
            lastDC = thisblockrow[-1][0];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components ndummy
//             <    is written>: bi
            for(bi = 0; bi <= ndummy-1; bi += 1)
//             <    is read   >: bi block_rows cinfo 
//                               cinfo[0].num_components lastDC ndummy
//                               thisblockrow
//             <    is written>: thisblockrow[bi][0]
               thisblockrow[bi][0] = lastDC;
         }
      }
//             <    is read   >: cinfo cinfo[0].num_components coef 
//                               coef[0].iMCU_row_num last_iMCU_row
      /* If at end of image, create dummy block rows as needed.
           * The tricky part here is that within each MCU, we want the DC values
           * of the dummy blocks to match the last real block's DC value.
           * This squeezes a few more bytes out of the resulting file...
           */
      if (coef->iMCU_row_num==last_iMCU_row) {
//             <    is read   >: blocks_across cinfo 
//                               cinfo[0].num_components ndummy
//             <    is written>: blocks_across
         blocks_across += ndummy;
//             <    is read   >: blocks_across cinfo 
//                               cinfo[0].num_components h_samp_factor
//             <    is written>: MCUs_across
         /* include lower right corner */
         MCUs_across = blocks_across/h_samp_factor;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: block_row
         for(block_row = block_rows; block_row <= compptr->v_samp_factor-1; block_row += 1) {
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row] cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: thisblockrow
            thisblockrow = buffer[block_row];
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row-1] cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: lastblockrow
            lastblockrow = buffer[block_row-1];
//             <may be written>: thisblockrow[*][*]
//             <    is read   >: block_rows blocks_across cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor thisblockrow
            jzero_far((void *) thisblockrow, (size_t) (blocks_across*(size_t) sizeof(JBLOCK)));
//             <    is read   >: MCUs_across block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: MCUindex
            for(MCUindex = 0; MCUindex <= MCUs_across-1; MCUindex += 1) {
//             <    is read   >: MCUs_across block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor 
//                               h_samp_factor lastblockrow 
//                               lastblockrow[h_samp_factor-1][0]
//             <    is written>: lastDC
               lastDC = lastblockrow[h_samp_factor-1][0];
//             <    is read   >: MCUs_across block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor 
//                               h_samp_factor
//             <    is written>: bi
               for(bi = 0; bi <= h_samp_factor-1; bi += 1)
//             <    is read   >: MCUs_across bi block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor 
//                               h_samp_factor lastDC thisblockrow
//             <    is written>: thisblockrow[bi][0]
                  thisblockrow[bi][0] = lastDC;
//             <    is read   >: MCUs_across block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor 
//                               h_samp_factor thisblockrow
//             <    is written>: thisblockrow
               thisblockrow += h_samp_factor;
//             <    is read   >: MCUs_across block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor 
//                               h_samp_factor lastblockrow
//             <    is written>: lastblockrow
               /* advance to next MCU in row */
               lastblockrow += h_samp_factor;
            }
         }
      }
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* NB: compress_output will increment iMCU_row_num if successful.
      * A suspension return will result in redoing all the work above next time.
      */
   
   /* Emit data to the entropy encoder, sharing code with subsequent passes */
   return compress_output(cinfo, input_buf);
}
static boolean compress_output(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;
   /* index of current MCU within row */
   int blkn, ci, xindex, yindex, yoffset;
   JDIMENSION start_col;
   JBLOCKARRAY buffer[4];
   JBLOCKROW buffer_ptr;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Align the virtual buffers for the components used in this scan.
      * NB: during first pass, this is safe only because the buffers will
      * already be aligned properly, so jmemmgr.c won't need to do any I/O.
      */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      buffer[ci] = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[compptr->component_index],coef->iMCU_row_num*compptr->v_samp_factor,(JDIMENSION) compptr->v_samp_factor,0);
   }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: yoffset
   
   /* Loop to process one whole iMCU row */
   for(yoffset = coef->MCU_vert_offset; yoffset <= coef->MCU_rows_per_iMCU_row-1; yoffset += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: MCU_col_num
      for(MCU_col_num = coef->mcu_ctr; MCU_col_num <= cinfo->MCUs_per_row-1; MCU_col_num += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: blkn
         /* Construct list of pointers to DCT blocks belonging to this MCU */
         blkn = 0;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: ci
         /* index of current DCT block within MCU */
         for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci] coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: compptr
            compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_width
//             <    is written>: start_col
            start_col = MCU_col_num*compptr->MCU_width;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height
//             <    is written>: yindex
            for(yindex = 0; yindex <= compptr->MCU_height-1; yindex += 1) {
//             <    is read   >: buffer[ci] buffer[ci][yindex+yoffset]
//                               ci cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height start_col 
//                               yindex yoffset
//             <    is written>: buffer_ptr
               buffer_ptr = buffer[ci][yindex+yoffset]+start_col;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width
//             <    is written>: xindex
               for(xindex = 0; xindex <= compptr->MCU_width-1; xindex += 1)
//             <    is read   >: blkn buffer_ptr cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width
//             <    is written>: blkn buffer_ptr 
//                               coef[0].MCU_buffer[blkn++]
                  (coef->MCU_buffer)[blkn++] = buffer_ptr++;
            }
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Try to write the MCU. */
         if (!(*cinfo->entropy->encode_mcu)(cinfo,coef->MCU_buffer)) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr yoffset
//             <    is written>: coef[0].MCU_vert_offset
            /* Suspension forced; update state counters and exit */
            coef->MCU_vert_offset = yoffset;
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: coef[0].mcu_ctr
            coef->mcu_ctr = MCU_col_num;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
            return 0;
         }
      }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: coef[0].mcu_ctr
      /* Completed an MCU row, but perhaps not an iMCU row */
      coef->mcu_ctr = 0;
   }
//             <    is read   >: coef coef[0].iMCU_row_num
//             <    is written>: coef[0].iMCU_row_num
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
//             <may be read   >: cinfo[0].coef[0].iMCU_row_num 
//                               cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset 
//                               cinfo[0].coef[0].mcu_ctr
   start_iMCU_row(cinfo);
   return 1;
}
static void start_iMCU_row(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
   
   /* In an interleaved scan, an MCU row is the same as an iMCU row.
      * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
      * But at the bottom of the image, process only what's left.
      */
   if (cinfo->comps_in_scan>1)
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = 1;
   else if (coef->iMCU_row_num<cinfo->total_iMCU_rows-1)
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info)[0]->v_samp_factor;
   else
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info)[0]->last_row_height;
//             <    is read   >: coef
//             <    is written>: coef[0].mcu_ctr

   coef->mcu_ctr = 0;
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_vert_offset
   coef->MCU_vert_offset = 0;
}
static void start_pass_coef(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: coef
//             <    is written>: coef[0].iMCU_row_num

   coef->iMCU_row_num = 0;
//             <may be read   >: cinfo[0].coef[0].iMCU_row_num 
//                               cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset 
//                               cinfo[0].coef[0].mcu_ctr
   start_iMCU_row(cinfo);
//             <    is read   >: pass_mode

   if (pass_mode==JBUF_PASS_THRU) {
_switch_1_case_JBUF_PASS_THRU:      ;
//             <    is read   >: coef coef[0].whole_image[0]
      if ((coef->whole_image)[0]!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: coef
//             <    is written>: coef[0].pub.compress_data
      coef->pub.compress_data = compress_data;
   }
   else if (pass_mode==JBUF_SAVE_AND_PASS) {

_switch_1_case_JBUF_SAVE_AND_PASS:      ;
//             <    is read   >: coef coef[0].whole_image[0]
      if ((coef->whole_image)[0]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: coef
//             <    is written>: coef[0].pub.compress_data
      coef->pub.compress_data = compress_first_pass;
   }
   else if (pass_mode==JBUF_CRANK_DEST) {
_switch_1_case_JBUF_CRANK_DEST:      ;
//             <    is read   >: coef coef[0].whole_image[0]
      if ((coef->whole_image)[0]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: coef
//             <    is written>: coef[0].pub.compress_data
      coef->pub.compress_data = compress_output;
   }
   else {

_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
}
static void cmyk_ycck_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf, JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   register int r, g, b;
//             <    is read   >: cconvert cconvert[0].rgb_ycc_tab
//             <    is written>: ctab
   register INT32 *ctab = cconvert->rgb_ycc_tab;
   register JSAMPROW inptr;
   register JSAMPROW outptr0, outptr1, outptr2, outptr3;
   register JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->image_width;
//             <    is read   >: num_rows
//             <    is written>: num_rows

   while (--num_rows>=0) {
//             <    is read   >: input_buf input_buf[0]
//             <    is written>: inptr input_buf
      inptr = *input_buf++;
//             <    is read   >: output_buf output_buf[0] 
//                               output_buf[0][output_row] output_row
//             <    is written>: outptr0
      outptr0 = output_buf[0][output_row];
//             <    is read   >: output_buf output_buf[1] 
//                               output_buf[1][output_row] output_row
//             <    is written>: outptr1
      outptr1 = output_buf[1][output_row];
//             <    is read   >: output_buf output_buf[2] 
//                               output_buf[2][output_row] output_row
//             <    is written>: outptr2
      outptr2 = output_buf[2][output_row];
//             <    is read   >: output_buf output_buf[3] 
//                               output_buf[3][output_row] output_row
//             <    is written>: outptr3
      outptr3 = output_buf[3][output_row];
//             <    is read   >: output_row
//             <    is written>: output_row
      output_row++;
//             <    is read   >: num_cols
//             <    is written>: col
      for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: inptr inptr[0] num_cols
//             <    is written>: r
         r = 255-((int) inptr[0]);
//             <    is read   >: inptr inptr[1] num_cols
//             <    is written>: g
         g = 255-((int) inptr[1]);
//             <    is read   >: inptr inptr[2] num_cols
//             <    is written>: b
         b = 255-((int) inptr[2]);
//             <    is read   >: col inptr inptr[3] num_cols outptr3
//             <    is written>: outptr3[col]
         /* K passes through as-is */
         outptr3[col] = inptr[3];
//             <    is read   >: inptr num_cols
//             <    is written>: inptr
         /* don't need GETJSAMPLE here */
         inptr += 4;
//             <    is read   >: b col ctab ctab[b+2*(255+1)
//                               ] ctab[g+1*(255+1)
//                               ] ctab[r+0] g num_cols outptr0 r
//             <    is written>: outptr0[col]
         /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
                * must be too; we do not need an explicit range-limiting operation.
                * Hence the value being shifted is never negative, and we don't
                * need the general RIGHT_SHIFT macro.
                */
         /* Y */
         
         outptr0[col] = (JSAMPLE) (ctab[r+0]+ctab[g+1*(255+1)]+ctab[b+2*(255+1)]>>16);
//             <    is read   >: b col ctab ctab[b+5*(255+1)
//                               ] ctab[g+4*(255+1)] ctab[r+3*(255+1)
//                               ] g num_cols outptr1 r
//             <    is written>: outptr1[col]
         /* Cb */
         
         outptr1[col] = (JSAMPLE) (ctab[r+3*(255+1)]+ctab[g+4*(255+1)]+ctab[b+5*(255+1)]>>16);
//             <    is read   >: b col ctab ctab[b+7*(255+1)
//                               ] ctab[g+6*(255+1)] ctab[r+5*(255+1)
//                               ] g num_cols outptr2 r
//             <    is written>: outptr2[col]
         /* Cr */
         
         outptr2[col] = (JSAMPLE) (ctab[r+5*(255+1)]+ctab[g+6*(255+1)]+ctab[b+7*(255+1)]>>16);
      }
   }
}
static void grayscale_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf, JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)
{
   register JSAMPROW inptr;
   register JSAMPROW outptr;
   register JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->image_width;
//             <    is read   >: cinfo cinfo[0].input_components
//             <    is written>: instride
   int instride = cinfo->input_components;
//             <    is read   >: num_rows
//             <    is written>: num_rows

   while (--num_rows>=0) {
//             <    is read   >: input_buf input_buf[0]
//             <    is written>: inptr input_buf
      inptr = *input_buf++;
//             <    is read   >: output_buf output_buf[0] 
//                               output_buf[0][output_row] output_row
//             <    is written>: outptr
      outptr = output_buf[0][output_row];
//             <    is read   >: output_row
//             <    is written>: output_row
      output_row++;
//             <    is read   >: num_cols
//             <    is written>: col
      for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: col inptr inptr[0] num_cols outptr
//             <    is written>: outptr[col]
         outptr[col] = inptr[0];
//             <    is read   >: inptr instride num_cols
//             <    is written>: inptr
         /* don't need GETJSAMPLE() here */
         inptr += instride;
      }
   }
}
static void null_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf, JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)
{
   register JSAMPROW inptr;
   register JSAMPROW outptr;
   register JDIMENSION col;
   register int ci;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: nc
   int nc = cinfo->num_components;
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->image_width;
//             <    is read   >: num_rows
//             <    is written>: num_rows

   while (--num_rows>=0) {
//             <    is read   >: nc
//             <    is written>: ci
      /* It seems fastest to make a separate pass for each component. */
      for(ci = 0; ci <= nc-1; ci += 1) {
//             <    is read   >: input_buf input_buf[0] nc
//             <    is written>: inptr
         inptr = *input_buf;
//             <    is read   >: ci nc output_buf output_buf[ci] 
//                               output_buf[ci][output_row] output_row
//             <    is written>: outptr
         outptr = output_buf[ci][output_row];
//             <    is read   >: nc num_cols
//             <    is written>: col
         for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: ci col inptr inptr[ci] nc num_cols 
//                               outptr
//             <    is written>: outptr[col]
            outptr[col] = inptr[ci];
//             <    is read   >: inptr nc num_cols
//             <    is written>: inptr
            /* don't need GETJSAMPLE() here */
            inptr += nc;
         }
      }
//             <    is read   >: input_buf
//             <    is written>: input_buf
      input_buf++;
//             <    is read   >: output_row
//             <    is written>: output_row
      output_row++;
   }
}
static void null_method(j_compress_ptr cinfo)
{
}
static void rgb_gray_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf, JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   register int r, g, b;
//             <    is read   >: cconvert cconvert[0].rgb_ycc_tab
//             <    is written>: ctab
   register INT32 *ctab = cconvert->rgb_ycc_tab;
   register JSAMPROW inptr;
   register JSAMPROW outptr;
   register JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->image_width;
//             <    is read   >: num_rows
//             <    is written>: num_rows

   while (--num_rows>=0) {
//             <    is read   >: input_buf input_buf[0]
//             <    is written>: inptr input_buf
      inptr = *input_buf++;
//             <    is read   >: output_buf output_buf[0] 
//                               output_buf[0][output_row] output_row
//             <    is written>: outptr
      outptr = output_buf[0][output_row];
//             <    is read   >: output_row
//             <    is written>: output_row
      output_row++;
//             <    is read   >: num_cols
//             <    is written>: col
      for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: inptr inptr[0] num_cols
//             <    is written>: r
         r = (int) inptr[0];
//             <    is read   >: inptr inptr[1] num_cols
//             <    is written>: g
         g = (int) inptr[1];
//             <    is read   >: inptr inptr[2] num_cols
//             <    is written>: b
         b = (int) inptr[2];
//             <    is read   >: inptr num_cols
//             <    is written>: inptr
         inptr += 3;
//             <    is read   >: b col ctab ctab[b+2*(255+1)
//                               ] ctab[g+1*(255+1)
//                               ] ctab[r+0] g num_cols outptr r
//             <    is written>: outptr[col]
         /* Y */
         
         outptr[col] = (JSAMPLE) (ctab[r+0]+ctab[g+1*(255+1)]+ctab[b+2*(255+1)]>>16);
      }
   }
}
static void rgb_ycc_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf, JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   register int r, g, b;
//             <    is read   >: cconvert cconvert[0].rgb_ycc_tab
//             <    is written>: ctab
   register INT32 *ctab = cconvert->rgb_ycc_tab;
   register JSAMPROW inptr;
   register JSAMPROW outptr0, outptr1, outptr2;
   register JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->image_width;
//             <    is read   >: num_rows
//             <    is written>: num_rows

   while (--num_rows>=0) {
//             <    is read   >: input_buf input_buf[0]
//             <    is written>: inptr input_buf
      inptr = *input_buf++;
//             <    is read   >: output_buf output_buf[0] 
//                               output_buf[0][output_row] output_row
//             <    is written>: outptr0
      outptr0 = output_buf[0][output_row];
//             <    is read   >: output_buf output_buf[1] 
//                               output_buf[1][output_row] output_row
//             <    is written>: outptr1
      outptr1 = output_buf[1][output_row];
//             <    is read   >: output_buf output_buf[2] 
//                               output_buf[2][output_row] output_row
//             <    is written>: outptr2
      outptr2 = output_buf[2][output_row];
//             <    is read   >: output_row
//             <    is written>: output_row
      output_row++;
//             <    is read   >: num_cols
//             <    is written>: col
      for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: inptr inptr[0] num_cols
//             <    is written>: r
         r = (int) inptr[0];
//             <    is read   >: inptr inptr[1] num_cols
//             <    is written>: g
         g = (int) inptr[1];
//             <    is read   >: inptr inptr[2] num_cols
//             <    is written>: b
         b = (int) inptr[2];
//             <    is read   >: inptr num_cols
//             <    is written>: inptr
         inptr += 3;
//             <    is read   >: b col ctab ctab[b+2*(255+1)
//                               ] ctab[g+1*(255+1)
//                               ] ctab[r+0] g num_cols outptr0 r
//             <    is written>: outptr0[col]
         /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
                * must be too; we do not need an explicit range-limiting operation.
                * Hence the value being shifted is never negative, and we don't
                * need the general RIGHT_SHIFT macro.
                */
         /* Y */
         
         outptr0[col] = (JSAMPLE) (ctab[r+0]+ctab[g+1*(255+1)]+ctab[b+2*(255+1)]>>16);
//             <    is read   >: b col ctab ctab[b+5*(255+1)
//                               ] ctab[g+4*(255+1)] ctab[r+3*(255+1)
//                               ] g num_cols outptr1 r
//             <    is written>: outptr1[col]
         /* Cb */
         
         outptr1[col] = (JSAMPLE) (ctab[r+3*(255+1)]+ctab[g+4*(255+1)]+ctab[b+5*(255+1)]>>16);
//             <    is read   >: b col ctab ctab[b+7*(255+1)
//                               ] ctab[g+6*(255+1)] ctab[r+5*(255+1)
//                               ] g num_cols outptr2 r
//             <    is written>: outptr2[col]
         /* Cr */
         
         outptr2[col] = (JSAMPLE) (ctab[r+5*(255+1)]+ctab[g+6*(255+1)]+ctab[b+7*(255+1)]>>16);
      }
   }
}
static void rgb_ycc_start(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   INT32 *rgb_ycc_tab;
   INT32 i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Allocate and fill in the conversion tables. */
   
   cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,8*(255+1)*(size_t) sizeof(INT32));
//             <    is written>: i

   for(i = 0; i <= 255; i += 1) {
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+0]
      rgb_ycc_tab[i+0] = (INT32) (0.29900*(1L<<16)+0.5)*i;
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+1*(255+1)]
      rgb_ycc_tab[i+1*(255+1)] = (INT32) (0.58700*(1L<<16)+0.5)*i;
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+2*(255+1)]
      rgb_ycc_tab[i+2*(255+1)] = (INT32) (0.11400*(1L<<16)+0.5)*i+((INT32) 1<<16-1);
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+3*(255+1)]
      rgb_ycc_tab[i+3*(255+1)] = -((INT32) (0.16874*(1L<<16)+0.5))*i;
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+4*(255+1)]
      rgb_ycc_tab[i+4*(255+1)] = -((INT32) (0.33126*(1L<<16)+0.5))*i;
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+5*(255+1)]
      /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
           * This ensures that the maximum output will round to MAXJSAMPLE
           * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
           */
      rgb_ycc_tab[i+5*(255+1)] = (INT32) (0.50000*(1L<<16)+0.5)*i+((INT32) 128<<16)+((INT32) 1<<16-1)-1;
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+6*(255+1)]
      /*  B=>Cb and R=>Cr tables are the same
          rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
      */
      rgb_ycc_tab[i+6*(255+1)] = -((INT32) (0.41869*(1L<<16)+0.5))*i;
//             <    is read   >: i rgb_ycc_tab
//             <    is written>: rgb_ycc_tab[i+7*(255+1)]
      rgb_ycc_tab[i+7*(255+1)] = -((INT32) (0.08131*(1L<<16)+0.5))*i;
   }
}
static void forward_DCT(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY sample_data, JBLOCKROW coef_blocks, JDIMENSION start_row, JDIMENSION start_col, JDIMENSION num_blocks)
{
   /* This routine is heavily used, so it's worth coding it tightly. */
//             <    is read   >: cinfo cinfo[0].fdct
//             <    is written>: fdct
   my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
//             <    is read   >: fdct fdct[0].do_dct
//             <    is written>: do_dct
   forward_DCT_method_ptr do_dct = fdct->do_dct;
//             <    is read   >: compptr compptr[0].quant_tbl_no fdct 
//                               fdct[0].divisors[compptr->quant_tbl_n
//                               o]
//             <    is written>: divisors
   DCTELEM *divisors = (fdct->divisors)[compptr->quant_tbl_no];
   DCTELEM workspace[64];
   /* work area for FDCT subroutine */
   JDIMENSION bi;
//             <    is read   >: sample_data start_row
//             <    is written>: sample_data

   sample_data += start_row;
//             <    is read   >: num_blocks
//             <    is written>: bi
   /* fold in the vertical offset once */
   
   for(bi = 0; bi <= num_blocks-1; bi += 1) {
      {
         register DCTELEM *workspaceptr;
         register JSAMPROW elemptr;
         register int elemr;
//             <    is read   >: num_blocks
//             <    is written>: workspaceptr

         workspaceptr = workspace;
//             <    is read   >: num_blocks
//             <    is written>: elemr
         for(elemr = 0; elemr <= 7; elemr += 1) {
//             <    is read   >: elemr num_blocks sample_data 
//                               sample_data[elemr] start_col
//             <    is written>: elemptr
            elemptr = sample_data[elemr]+start_col;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (int) *elemptr++-128;
         }
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      /* Perform the DCT */
      (*do_dct)(workspace);
      {
         register DCTELEM temp, qval;
         register int i;
//             <    is read   >: bi coef_blocks coef_blocks[bi]
//             <    is written>: output_ptr
         register JCOEFPTR output_ptr = coef_blocks[bi];
//             <    is read   >: num_blocks
//             <    is written>: i

         for(i = 0; i <= 63; i += 1) {
//             <    is read   >: divisors divisors[i] i num_blocks
//             <    is written>: qval
            qval = divisors[i];
//             <    is read   >: i num_blocks workspace[i]
//             <    is written>: temp
            temp = workspace[i];
//             <    is read   >: num_blocks temp
            /* Divide the coefficient value by qval, ensuring proper rounding.
            	 * Since C does not specify the direction of rounding for negative
            	 * quotients, we have to force the dividend positive for portability.
            	 *
            	 * In most files, at least half of the output values will be zero
            	 * (at default quantization settings, more like three-quarters...)
            	 * so we should ensure that this case is fast.  On many machines,
            	 * a comparison is enough cheaper than a divide to make a special test
            	 * a win.  Since both inputs will be nonnegative, we need only test
            	 * for a < b to discover whether a/b is 0.
            	 * If your machine's division is fast enough, define FAST_DIVIDE.
            	 */
            
            
            
            
            
            if (temp<0) {
//             <    is read   >: num_blocks temp
//             <    is written>: temp
               temp = -temp;
//             <    is read   >: num_blocks qval temp
//             <    is written>: temp
               temp += qval>>1;
//             <    is read   >: num_blocks qval temp
               /* for rounding */
               if (temp>=qval)
//             <    is read   >: num_blocks qval temp
//             <    is written>: temp
                  temp /= qval;
               else
//             <    is read   >: num_blocks
//             <    is written>: temp
                  temp = 0;
//             <    is read   >: num_blocks temp
//             <    is written>: temp
               temp = -temp;
            }
            else {
//             <    is read   >: num_blocks qval temp
//             <    is written>: temp
               temp += qval>>1;
//             <    is read   >: num_blocks qval temp
               /* for rounding */
               if (temp>=qval)
//             <    is read   >: num_blocks qval temp
//             <    is written>: temp
                  temp /= qval;
               else
//             <    is read   >: num_blocks
//             <    is written>: temp
                  temp = 0;
            }
//             <    is read   >: i num_blocks output_ptr temp
//             <    is written>: output_ptr[i]
            output_ptr[i] = (JCOEF) temp;
         }
      }
//             <    is read   >: num_blocks start_col
//             <    is written>: start_col
      start_col += 8;
   }
}
static void forward_DCT_float(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY sample_data, JBLOCKROW coef_blocks, JDIMENSION start_row, JDIMENSION start_col, JDIMENSION num_blocks)
{
   /* This routine is heavily used, so it's worth coding it tightly. */
//             <    is read   >: cinfo cinfo[0].fdct
//             <    is written>: fdct
   my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
//             <    is read   >: fdct fdct[0].do_float_dct
//             <    is written>: do_dct
   float_DCT_method_ptr do_dct = fdct->do_float_dct;
//             <    is read   >: compptr compptr[0].quant_tbl_no fdct 
//                               fdct[0].float_divisors[compptr->quant
//                               _tbl_no]
//             <    is written>: divisors
   float *divisors = (fdct->float_divisors)[compptr->quant_tbl_no];
   float workspace[64];
   /* work area for FDCT subroutine */
   JDIMENSION bi;
//             <    is read   >: sample_data start_row
//             <    is written>: sample_data

   sample_data += start_row;
//             <    is read   >: num_blocks
//             <    is written>: bi
   /* fold in the vertical offset once */
   
   for(bi = 0; bi <= num_blocks-1; bi += 1) {
      {
         register float *workspaceptr;
         register JSAMPROW elemptr;
         register int elemr;
//             <    is read   >: num_blocks
//             <    is written>: workspaceptr

         workspaceptr = workspace;
//             <    is read   >: num_blocks
//             <    is written>: elemr
         for(elemr = 0; elemr <= 7; elemr += 1) {
//             <    is read   >: elemr num_blocks sample_data 
//                               sample_data[elemr] start_col
//             <    is written>: elemptr
            elemptr = sample_data[elemr]+start_col;
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
//             <    is read   >: elemptr elemptr[0] num_blocks 
//                               workspaceptr
//             <    is written>: elemptr workspaceptr workspaceptr[0]
            *workspaceptr++ = (float) ((int) *elemptr++-128);
         }
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      /* Perform the DCT */
      (*do_dct)(workspace);
      {
         register float temp;
         register int i;
//             <    is read   >: bi coef_blocks coef_blocks[bi]
//             <    is written>: output_ptr
         register JCOEFPTR output_ptr = coef_blocks[bi];
//             <    is read   >: num_blocks
//             <    is written>: i

         for(i = 0; i <= 63; i += 1) {
//             <    is read   >: divisors divisors[i] i num_blocks 
//                               workspace[i]
//             <    is written>: temp
            /* Apply the quantization and scaling factor */
            temp = workspace[i]*divisors[i];
//             <    is read   >: i num_blocks output_ptr temp
//             <    is written>: output_ptr[i]
            /* Round to nearest integer.
            	 * Since C does not specify the direction of rounding for negative
            	 * quotients, we have to force the dividend positive for portability.
            	 * The maximum coefficient size is +-16K (for 12-bit data), so this
            	 * code should work for either 16-bit or 32-bit ints.
            	 */
            output_ptr[i] = (JCOEF) ((int) (temp+(float) 16384.5)-16384);
         }
      }
//             <    is read   >: num_blocks start_col
//             <    is written>: start_col
      start_col += 8;
   }
}
static void start_pass_fdctmgr(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].fdct
//             <    is written>: fdct
   my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
   int ci, qtblno, i;
   jpeg_component_info *compptr;
   JQUANT_TBL *qtbl;
   DCTELEM *dtbl;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].quant_tbl_no
//             <    is written>: qtblno
      qtblno = compptr->quant_tbl_no;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].quant_tbl_ptrs[qtblno] 
//                               qtblno
      /* Make sure specified quantization table is present */
      
      if (qtblno<0||qtblno>=4||(cinfo->quant_tbl_ptrs)[qtblno]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_QUANT_TABLE, (cinfo->err->msg_parm.i)[0] = qtblno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].quant_tbl_ptrs[qtblno] 
//                               qtblno
//             <    is written>: qtbl
      qtbl = (cinfo->quant_tbl_ptrs)[qtblno];
//             <    is read   >: cinfo cinfo[0].dct_method 
//                               cinfo[0].num_components
      /* Compute divisors for this quant table */
      /* We may do this more than once for same table, but it's not a big deal */
      if (cinfo->dct_method==JDCT_ISLOW) {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_2_case_JDCT_ISLOW:         ;
//             <    is read   >: cinfo cinfo[0].num_components fdct 
//                               fdct[0].divisors[qtblno] qtblno
         /* For LL&M IDCT method, divisors are equal to raw quantization
                * coefficients multiplied by 8 (to counteract scaling).
                */
         if ((fdct->divisors)[qtblno]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (fdct->divisors)[qtblno] = (DCTELEM *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,64*(size_t) sizeof(DCTELEM));
//             <    is read   >: cinfo cinfo[0].num_components fdct 
//                               fdct[0].divisors[qtblno] qtblno
//             <    is written>: dtbl
         dtbl = (fdct->divisors)[qtblno];
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i
         for(i = 0; i <= 63; i += 1)
//             <    is read   >: cinfo cinfo[0].num_components dtbl i 
//                               qtbl qtbl[0].quantval[i]
//             <    is written>: dtbl[i]
            dtbl[i] = (DCTELEM) (qtbl->quantval)[i]<<3;
      }
      else if (cinfo->dct_method==JDCT_IFAST) {
//             <    is read   >: cinfo cinfo[0].num_components
         
         
_switch_2_case_JDCT_IFAST:         ;
         {
            /* For AA&N IDCT method, divisors are equal to quantization
            	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
            	 *   scalefactor[0] = 1
            	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
            	 * We apply a further scale factor of 8.
            	 */
            
            
            /* precomputed values scaled up by 14 bits */
            
            
            
            
            
            
            
            
            static const  INT16 aanscales[64] = {16384, 22725, 21407, 19266, 16384, 12873, 8867, 4520, 22725, 31521, 29692, 26722, 22725, 17855, 12299, 6270, 21407, 29692, 27969, 25172, 21407, 16819, 11585, 5906, 19266, 26722, 25172, 22654, 19266, 15137, 10426, 5315, 16384, 22725, 21407, 19266, 16384, 12873, 8867, 4520, 12873, 17855, 16819, 15137, 12873, 10114, 6967, 3552, 8867, 12299, 11585, 10426, 8867, 6967, 4799, 2446, 4520, 6270, 5906, 5315, 4520, 3552, 2446, 1247};
//             <    is read   >: cinfo cinfo[0].num_components fdct 
//                               fdct[0].divisors[qtblno] qtblno
            if ((fdct->divisors)[qtblno]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               (fdct->divisors)[qtblno] = (DCTELEM *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,64*(size_t) sizeof(DCTELEM));
//             <    is read   >: cinfo cinfo[0].num_components fdct 
//                               fdct[0].divisors[qtblno] qtblno
//             <    is written>: dtbl
            dtbl = (fdct->divisors)[qtblno];
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i
            for(i = 0; i <= 63; i += 1)
//             <    is read   >: aanscales[i] cinfo 
//                               cinfo[0].num_components dtbl i qtbl 
//                               qtbl[0].quantval[i]
//             <    is written>: dtbl[i]

               dtbl[i] = (DCTELEM) ((INT32) (qtbl->quantval)[i]*(INT32) aanscales[i]+((INT32) 1<<14-3-1)>>14-3);
         }
      }
      else if (cinfo->dct_method==JDCT_FLOAT) {
//             <    is read   >: cinfo cinfo[0].num_components
         
         
_switch_2_case_JDCT_FLOAT:         ;
         {
            /* For float AA&N IDCT method, divisors are equal to quantization
            	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
            	 *   scalefactor[0] = 1
            	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
            	 * We apply a further scale factor of 8.
            	 * What's actually stored is 1/divisor so that the inner loop can
            	 * use a multiplication rather than a division.
            	 */
            float *fdtbl;
            int row, col;
            
            
            
            static const  double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379};
//             <    is read   >: cinfo cinfo[0].num_components fdct 
//                               fdct[0].float_divisors[qtblno] qtblno
            if ((fdct->float_divisors)[qtblno]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               (fdct->float_divisors)[qtblno] = (float *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,64*(size_t) sizeof(float));
//             <    is read   >: cinfo cinfo[0].num_components fdct 
//                               fdct[0].float_divisors[qtblno] qtblno
//             <    is written>: fdtbl
            fdtbl = (fdct->float_divisors)[qtblno];
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i
            i = 0;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: row
            for(row = 0; row <= 7; row += 1)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: col
               for(col = 0; col <= 7; col += 1) {
//             <    is read   >: aanscalefactor[col] 
//                               aanscalefactor[row] cinfo 
//                               cinfo[0].num_components col fdtbl i 
//                               qtbl qtbl[0].quantval[i] row
//             <    is written>: fdtbl[i]
                  fdtbl[i] = (float) (1.0/((double) (qtbl->quantval)[i]*aanscalefactor[row]*aanscalefactor[col]*8.0));
//             <    is read   >: cinfo cinfo[0].num_components i
//             <    is written>: i
                  i++;
               }
         }
      }
      else {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_2_default:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NOT_COMPILED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
//             <    is read   >: cinfo cinfo[0].num_components
_break_2:      ;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static boolean dump_buffer(working_state *state)
{
//             <    is read   >: state state[0].cinfo 
//                               state[0].cinfo[0].dest
//             <    is written>: dest
   struct jpeg_destination_mgr *dest = state->cinfo->dest;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!(*dest->empty_output_buffer)(state->cinfo))
      return 0;
//             <    is read   >: dest dest[0].next_output_byte state
//             <    is written>: state[0].next_output_byte
   /* After a successful buffer dump, must reset buffer pointers */
   state->next_output_byte = dest->next_output_byte;
//             <    is read   >: dest dest[0].free_in_buffer state
//             <    is written>: state[0].free_in_buffer
   state->free_in_buffer = dest->free_in_buffer;
   return 1;
}
static boolean emit_bits(working_state *state, unsigned int code, int size)
{
   /* This routine is heavily used, so it's worth coding tightly. */
//             <    is read   >: code
//             <    is written>: put_buffer
   register INT32 put_buffer = (INT32) code;
//             <    is read   >: state state[0].cur.put_bits
//             <    is written>: put_bits
   register int put_bits = state->cur.put_bits;
//             <    is read   >: size
   
   /* if size is 0, caller used an invalid Huffman table entry */
   if (size==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      state->cinfo->err->msg_code = JERR_HUFF_MISSING_CODE, (*state->cinfo->err->error_exit)((j_common_ptr) state->cinfo);
//             <    is read   >: put_buffer size
//             <    is written>: put_buffer
   put_buffer &= ((INT32) 1<<size)-1;
//             <    is read   >: put_bits size
//             <    is written>: put_bits
   /* mask off any extra bits in code */
   
   put_bits += size;
//             <    is read   >: put_bits put_buffer
//             <    is written>: put_buffer
   /* new number of bits in buffer */
   
   put_buffer <<= 24-put_bits;
//             <    is read   >: put_buffer state 
//                               state[0].cur.put_buffer
//             <    is written>: put_buffer
   /* align incoming bits */
   
   put_buffer |= state->cur.put_buffer;
//             <    is read   >: put_bits
   /* and merge with old buffer contents */
   
   while (put_bits>=8) {
//             <    is read   >: put_buffer
//             <    is written>: c
      int c = (int) (put_buffer>>16&0xFF);
//             <    is read   >: c state state[0].next_output_byte
//             <    is written>: state[0].next_output_byte 
//                               state[0].next_output_byte[0]
      *state->next_output_byte++ = (JOCTET) c;
//             <    is read   >: state state[0].free_in_buffer
//             <    is written>: state[0].free_in_buffer
      if (--state->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!dump_buffer(state))
            return 0;
//             <    is read   >: c
      if (c==0xFF) {
//             <    is read   >: state state[0].next_output_byte
//             <    is written>: state[0].next_output_byte 
//                               state[0].next_output_byte[0]
         *state->next_output_byte++ = (JOCTET) 0;
//             <    is read   >: state state[0].free_in_buffer
//             <    is written>: state[0].free_in_buffer
         if (--state->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!dump_buffer(state))
               return 0;
      }
//             <    is read   >: put_buffer
//             <    is written>: put_buffer
      put_buffer <<= 8;
//             <    is read   >: put_bits
//             <    is written>: put_bits
      put_bits -= 8;
   }
//             <    is read   >: put_buffer state
//             <    is written>: state[0].cur.put_buffer

   state->cur.put_buffer = put_buffer;
//             <    is read   >: put_bits state
//             <    is written>: state[0].cur.put_bits
   /* update state variables */
   state->cur.put_bits = put_bits;

   return 1;
}
static boolean emit_restart(working_state *state, int restart_num)
{
   int ci;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   if (!flush_bits(state))
      return 0;
//             <    is read   >: state state[0].next_output_byte
//             <    is written>: state[0].next_output_byte 
//                               state[0].next_output_byte[0]
   *state->next_output_byte++ = (JOCTET) 0xFF;
//             <    is read   >: state state[0].free_in_buffer
//             <    is written>: state[0].free_in_buffer
   if (--state->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!dump_buffer(state))
         return 0;
//             <    is read   >: restart_num state 
//                               state[0].next_output_byte
//             <    is written>: state[0].next_output_byte 
//                               state[0].next_output_byte[0]
   *state->next_output_byte++ = (JOCTET) (0xD0+restart_num);
//             <    is read   >: state state[0].free_in_buffer
//             <    is written>: state[0].free_in_buffer
   if (--state->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!dump_buffer(state))
         return 0;
//             <    is read   >: state state[0].cinfo 
//                               state[0].cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Re-initialize DC predictions to 0 */
   for(ci = 0; ci <= state->cinfo->comps_in_scan-1; ci += 1)
//             <    is read   >: ci state state[0].cinfo 
//                               state[0].cinfo[0].comps_in_scan
//             <    is written>: state[0].cur.last_dc_val[ci]
      (state->cur.last_dc_val)[ci] = 0;
   
   /* The restart counter is not updated until we successfully write the MCU. */
   
   return 1;
}
static boolean encode_mcu_gather(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   int blkn, ci;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Take care of restart intervals if needed */
   if (cinfo->restart_interval) {
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
         /* Re-initialize DC predictions to 0 */
         for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
            (entropy->saved.last_dc_val)[ci] = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
         /* Update restart state */
         entropy->restarts_to_go = cinfo->restart_interval;
      }
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
      entropy->restarts_to_go--;
   }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn

   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: blkn cinfo 
//                               cinfo[0].MCU_membership[blkn] 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: ci
      ci = (cinfo->MCU_membership)[blkn];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      htest_one_block(MCU_data[blkn][0], (entropy->saved.last_dc_val)[ci], (entropy->dc_count_ptrs)[compptr->dc_tbl_no], (entropy->ac_count_ptrs)[compptr->ac_tbl_no]);
//             <    is read   >: MCU_data MCU_data[blkn] 
//                               MCU_data[blkn][0][0] blkn ci cinfo 
//                               cinfo[0].blocks_in_MCU entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
      (entropy->saved.last_dc_val)[ci] = MCU_data[blkn][0][0];
   }

   return 1;
}
static boolean encode_mcu_huff(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   working_state state;
   int blkn, ci;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte
//             <    is written>: state.next_output_byte
   
   /* Load up working state */
   state.next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer
//             <    is written>: state.free_in_buffer
   state.free_in_buffer = cinfo->dest->free_in_buffer;
//             <may be read   >: entropy[0].saved.last_dc_val[*]
//             <may be written>: state.cur.last_dc_val[*]
//             <    is read   >: entropy entropy[0].saved.put_bits 
//                               entropy[0].saved.put_buffer
//             <    is written>: state.cur.put_bits 
//                               state.cur.put_buffer
   state.cur = entropy->saved;
//             <    is read   >: cinfo
//             <    is written>: state.cinfo
   state.cinfo = cinfo;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!emit_restart(&state, entropy->next_restart_num))
            return 0;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn
   
   /* Encode the MCU data blocks */
   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: blkn cinfo 
//                               cinfo[0].MCU_membership[blkn] 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: ci
      ci = (cinfo->MCU_membership)[blkn];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      
      if (!encode_one_block(&state, MCU_data[blkn][0], (state.cur.last_dc_val)[ci], (entropy->dc_derived_tbls)[compptr->dc_tbl_no], (entropy->ac_derived_tbls)[compptr->ac_tbl_no]))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
         return 0;
//             <    is read   >: MCU_data MCU_data[blkn] 
//                               MCU_data[blkn][0][0] blkn ci cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: state.cur.last_dc_val[ci]
      /* Update last_dc_val */
      (state.cur.last_dc_val)[ci] = MCU_data[blkn][0][0];
   }
//             <    is read   >: cinfo cinfo[0].dest 
//                               state.next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte
   
   /* Completed MCU, so update state */
   cinfo->dest->next_output_byte = state.next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               state.free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = state.free_in_buffer;
//             <may be read   >: state.cur.last_dc_val[*]
//             <may be written>: entropy[0].saved.last_dc_val[*]
//             <    is read   >: entropy state.cur.put_bits 
//                               state.cur.put_buffer
//             <    is written>: entropy[0].saved.put_bits 
//                               entropy[0].saved.put_buffer
   entropy->saved = state.cur;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0) {
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
         entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num++;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num &= 7;
      }
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
      entropy->restarts_to_go--;
   }

   return 1;
}
static boolean encode_one_block(working_state *state, JCOEFPTR block, int last_dc_val, c_derived_tbl *dctbl, c_derived_tbl *actbl)
{
   register int temp, temp2;
   register int nbits;
   register int k, r, i;
//             <    is read   >: block block[0] last_dc_val
//             <    is written>: temp temp2
   
   /* Encode the DC coefficient difference per section F.1.2.1 */
   
   temp = temp2 = block[0]-last_dc_val;
//             <    is read   >: temp

   if (temp<0) {
//             <    is read   >: temp
//             <    is written>: temp
      temp = -temp;
//             <    is read   >: temp2
//             <    is written>: temp2
      /* temp is abs value of input */
      /* For a negative input, want temp2 = bitwise complement of abs(input) */
      /* This code assumes we are on a two's complement machine */
      temp2--;
   }
//             <    is written>: nbits
   
   /* Find the number of bits needed for the magnitude of the coefficient */
   nbits = 0;
//             <    is read   >: temp
   while (temp) {
//             <    is read   >: nbits
//             <    is written>: nbits
      nbits++;
//             <    is read   >: temp
//             <    is written>: temp
      temp >>= 1;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Emit the Huffman-coded symbol for the number of bits */
   if (!emit_bits(state, (dctbl->ehufco)[nbits], (dctbl->ehufsi)[nbits]))
      return 0;
//             <    is read   >: nbits
   
   /* Emit that number of bits of the value, if positive, */
   /* or the complement of its magnitude, if negative. */
   if (nbits)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* emit_bits rejects calls with size 0 */
      if (!emit_bits(state, (unsigned int) temp2, nbits))
         return 0;
//             <    is written>: r
   
   /* Encode the AC coefficients per section F.1.2.2 */
   
   r = 0;
//             <    is written>: k
   /* r = run length of zeros */
   
   for(k = 1; k <= 63; k += 1)
//             <    is read   >: block block[jpeg_natural_order[k]] 
//                               jpeg_natural_order[k] k
//             <    is written>: temp
      if ((temp = block[jpeg_natural_order[k]])==0)
//             <    is read   >: r
//             <    is written>: r
         r++;
      else {
//             <    is read   >: r
         /* if run length > 15, must emit special run-length-16 codes (0xF0) */
         while (r>15) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!emit_bits(state, (actbl->ehufco)[0xF0], (actbl->ehufsi)[0xF0]))
               return 0;
//             <    is read   >: r
//             <    is written>: r
            r -= 16;
         }
//             <    is read   >: temp
//             <    is written>: temp2

         temp2 = temp;
//             <    is read   >: temp
         if (temp<0) {
//             <    is read   >: temp
//             <    is written>: temp
            temp = -temp;
//             <    is read   >: temp2
//             <    is written>: temp2
            /* temp is abs value of input */
            /* This code assumes we are on a two's complement machine */
            temp2--;
         }
//             <    is written>: nbits
         
         /* Find the number of bits needed for the magnitude of the coefficient */
         nbits = 1;
//             <    is read   >: temp
//             <    is written>: temp
         /* there must be at least one 1 bit */
         while (temp >>= 1)
//             <    is read   >: nbits
//             <    is written>: nbits
            nbits++;
//             <    is read   >: nbits r
//             <    is written>: i
         
         /* Emit Huffman symbol for run length / number of bits */
         i = (r<<4)+nbits;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!emit_bits(state, (actbl->ehufco)[i], (actbl->ehufsi)[i]))
            return 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         /* Emit that number of bits of the value, if positive, */
         /* or the complement of its magnitude, if negative. */
         if (!emit_bits(state, (unsigned int) temp2, nbits))
            return 0;
//             <    is written>: r

         r = 0;
      }
//             <    is read   >: r
   
   /* If the last coef(s) were zero, emit an end-of-block code */
   if (r>0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!emit_bits(state, (actbl->ehufco)[0], (actbl->ehufsi)[0]))
         return 0;

   return 1;
}
static void finish_pass_gather(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   int ci, dctbl, actbl;
   jpeg_component_info *compptr;
   JHUFF_TBL **htblptr;
   boolean did_dc[4];
   boolean did_ac[4];
//             <may be written>: did_dc[*]
   
   /* It's important not to apply jpeg_gen_optimal_table more than once
      * per table, because it clobbers the input frequency counts!
      */
   memset((void *) did_dc, 0, (size_t) (size_t) sizeof(did_dc));
//             <may be written>: did_ac[*]
   memset((void *) did_ac, 0, (size_t) (size_t) sizeof(did_ac));
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: dctbl
      dctbl = compptr->dc_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no
//             <    is written>: actbl
      actbl = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan dctbl 
//                               did_dc[dctbl]
      if (!did_dc[dctbl]) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan dctbl
//             <    is written>: htblptr
         htblptr = &(cinfo->dc_huff_tbl_ptrs)[dctbl];
//             <    is read   >: cinfo cinfo[0].comps_in_scan htblptr 
//                               htblptr[0]
         if (*htblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         jpeg_gen_optimal_table(cinfo, *htblptr, (entropy->dc_count_ptrs)[dctbl]);
//             <    is read   >: cinfo cinfo[0].comps_in_scan dctbl
//             <    is written>: did_dc[dctbl]
         did_dc[dctbl] = 1;
      }
//             <    is read   >: actbl cinfo cinfo[0].comps_in_scan 
//                               did_ac[actbl]
      if (!did_ac[actbl]) {
//             <    is read   >: actbl cinfo cinfo[0].comps_in_scan
//             <    is written>: htblptr
         htblptr = &(cinfo->ac_huff_tbl_ptrs)[actbl];
//             <    is read   >: cinfo cinfo[0].comps_in_scan htblptr 
//                               htblptr[0]
         if (*htblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         jpeg_gen_optimal_table(cinfo, *htblptr, (entropy->ac_count_ptrs)[actbl]);
//             <    is read   >: actbl cinfo cinfo[0].comps_in_scan
//             <    is written>: did_ac[actbl]
         did_ac[actbl] = 1;
      }
   }
}
static void finish_pass_huff(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   working_state state;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte
//             <    is written>: state.next_output_byte
   
   /* Load up working state ... flush_bits needs it */
   state.next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer
//             <    is written>: state.free_in_buffer
   state.free_in_buffer = cinfo->dest->free_in_buffer;
//             <may be read   >: entropy[0].saved.last_dc_val[*]
//             <may be written>: state.cur.last_dc_val[*]
//             <    is read   >: entropy entropy[0].saved.put_bits 
//                               entropy[0].saved.put_buffer
//             <    is written>: state.cur.put_bits 
//                               state.cur.put_buffer
   state.cur = entropy->saved;
//             <    is read   >: cinfo
//             <    is written>: state.cinfo
   state.cinfo = cinfo;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Flush out the last data */
   if (!flush_bits(&state))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_CANT_SUSPEND, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].dest 
//                               state.next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte
   
   /* Update state */
   cinfo->dest->next_output_byte = state.next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               state.free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = state.free_in_buffer;
//             <may be read   >: state.cur.last_dc_val[*]
//             <may be written>: entropy[0].saved.last_dc_val[*]
//             <    is read   >: entropy state.cur.put_bits 
//                               state.cur.put_buffer
//             <    is written>: entropy[0].saved.put_bits 
//                               entropy[0].saved.put_buffer
   entropy->saved = state.cur;
}
static boolean flush_bits(working_state *state)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!emit_bits(state, 0x7F, 7))
      /* fill any partial byte with ones */
      return 0;
//             <    is read   >: state
//             <    is written>: state[0].cur.put_buffer
   state->cur.put_buffer = 0;
//             <    is read   >: state
//             <    is written>: state[0].cur.put_bits
   /* and reset bit-buffer to empty */
   state->cur.put_bits = 0;
   return 1;
}
static void htest_one_block(JCOEFPTR block, int last_dc_val, long int dc_counts[], long int ac_counts[])
{
   register int temp;
   register int nbits;
   register int k, r;
//             <    is read   >: block block[0] last_dc_val
//             <    is written>: temp
   
   /* Encode the DC coefficient difference per section F.1.2.1 */
   
   temp = block[0]-last_dc_val;
//             <    is read   >: temp
   if (temp<0)
//             <    is read   >: temp
//             <    is written>: temp
      temp = -temp;
//             <    is written>: nbits
   
   /* Find the number of bits needed for the magnitude of the coefficient */
   nbits = 0;
//             <    is read   >: temp
   while (temp) {
//             <    is read   >: nbits
//             <    is written>: nbits
      nbits++;
//             <    is read   >: temp
//             <    is written>: temp
      temp >>= 1;
   }
//             <    is read   >: dc_counts[nbits] nbits
//             <    is written>: dc_counts[nbits]
   
   /* Count the Huffman symbol for the number of bits */
   dc_counts[nbits]++;
//             <    is written>: r
   
   /* Encode the AC coefficients per section F.1.2.2 */
   
   r = 0;
//             <    is written>: k
   /* r = run length of zeros */
   
   for(k = 1; k <= 63; k += 1)
//             <    is read   >: block block[jpeg_natural_order[k]] 
//                               jpeg_natural_order[k] k
//             <    is written>: temp
      if ((temp = block[jpeg_natural_order[k]])==0)
//             <    is read   >: r
//             <    is written>: r
         r++;
      else {
//             <    is read   >: r
         /* if run length > 15, must emit special run-length-16 codes (0xF0) */
         while (r>15) {
//             <    is read   >: ac_counts[0xF0]
//             <    is written>: ac_counts[0xF0]
            ac_counts[0xF0]++;
//             <    is read   >: r
//             <    is written>: r
            r -= 16;
         }
//             <    is read   >: temp
         
         /* Find the number of bits needed for the magnitude of the coefficient */
         if (temp<0)
//             <    is read   >: temp
//             <    is written>: temp
            temp = -temp;
//             <    is written>: nbits
         
         /* Find the number of bits needed for the magnitude of the coefficient */
         nbits = 1;
//             <    is read   >: temp
//             <    is written>: temp
         /* there must be at least one 1 bit */
         while (temp >>= 1)
//             <    is read   >: nbits
//             <    is written>: nbits
            nbits++;
//             <    is read   >: ac_counts[(r<<4)+nbits] nbits r
//             <    is written>: ac_counts[(r<<4)+nbits]
         
         /* Count Huffman symbol for run length / number of bits */
         ac_counts[(r<<4)+nbits]++;
//             <    is written>: r

         r = 0;
      }
//             <    is read   >: r
   
   /* If the last coef(s) were zero, emit an end-of-block code */
   if (r>0)
//             <    is read   >: ac_counts[0]
//             <    is written>: ac_counts[0]
      ac_counts[0]++;
}
static void start_pass_huff(j_compress_ptr cinfo, boolean gather_statistics)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   int ci, dctbl, actbl;
   jpeg_component_info *compptr;
//             <    is read   >: gather_statistics

   if (gather_statistics) {
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.encode_mcu

      entropy->pub.encode_mcu = encode_mcu_gather;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.finish_pass
      entropy->pub.finish_pass = finish_pass_gather;
   }
   else {
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.encode_mcu
      entropy->pub.encode_mcu = encode_mcu_huff;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.finish_pass
      entropy->pub.finish_pass = finish_pass_huff;
   }
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: dctbl
      dctbl = compptr->dc_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no
//             <    is written>: actbl
      actbl = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].dc_huff_tbl_ptrs[dctbl] 
//                               dctbl gather_statistics
      /* Make sure requested tables are present */
      /* (In gather mode, tables need not be allocated yet) */
      
      if (dctbl<0||dctbl>=4||(cinfo->dc_huff_tbl_ptrs)[dctbl]==(void *) 0&&!gather_statistics)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = dctbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: actbl cinfo 
//                               cinfo[0].ac_huff_tbl_ptrs[actbl] 
//                               cinfo[0].comps_in_scan 
//                               gather_statistics
      if (actbl<0||actbl>=4||(cinfo->ac_huff_tbl_ptrs)[actbl]==(void *) 0&&!gather_statistics)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = actbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               gather_statistics
      if (gather_statistics) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan dctbl 
//                               entropy 
//                               entropy[0].dc_count_ptrs[dctbl]
         
         /* Allocate and zero the statistics tables */
         /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
         if ((entropy->dc_count_ptrs)[dctbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (entropy->dc_count_ptrs)[dctbl] = (long int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,257*(size_t) sizeof(long int));
//             <may be written>: entropy[0].dc_count_ptrs[dctbl][*]
//             <    is read   >: cinfo cinfo[0].comps_in_scan dctbl 
//                               entropy 
//                               entropy[0].dc_count_ptrs[dctbl]
         memset((void *) (entropy->dc_count_ptrs)[dctbl], 0, (size_t) (257*(size_t) sizeof(long int)));
//             <    is read   >: actbl cinfo cinfo[0].comps_in_scan 
//                               entropy 
//                               entropy[0].ac_count_ptrs[actbl]
         if ((entropy->ac_count_ptrs)[actbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (entropy->ac_count_ptrs)[actbl] = (long int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,257*(size_t) sizeof(long int));
//             <may be written>: entropy[0].ac_count_ptrs[actbl][*]
//             <    is read   >: actbl cinfo cinfo[0].comps_in_scan 
//                               entropy 
//                               entropy[0].ac_count_ptrs[actbl]
         memset((void *) (entropy->ac_count_ptrs)[actbl], 0, (size_t) (257*(size_t) sizeof(long int)));
      }
      else {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Compute derived values for Huffman tables */
         /* We may do this more than once for a table, but it's not expensive */
         
         jpeg_make_c_derived_tbl(cinfo, (cinfo->dc_huff_tbl_ptrs)[dctbl], &(entropy->dc_derived_tbls)[dctbl]);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

         jpeg_make_c_derived_tbl(cinfo, (cinfo->ac_huff_tbl_ptrs)[actbl], &(entropy->ac_derived_tbls)[actbl]);
      }
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
      /* Initialize DC predictions to 0 */
      (entropy->saved.last_dc_val)[ci] = 0;
   }
//             <    is read   >: entropy
//             <    is written>: entropy[0].saved.put_buffer
   
   /* Initialize bit buffer to empty */
   entropy->saved.put_buffer = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].saved.put_bits
   entropy->saved.put_bits = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
   
   /* Initialize restart stuff */
   entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy
//             <    is written>: entropy[0].next_restart_num
   entropy->next_restart_num = 0;
}
static void process_data_simple_main(j_compress_ptr cinfo, JSAMPARRAY input_buf, JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows main 
//                               main[0].cur_iMCU_row

   while (main->cur_iMCU_row<cinfo->total_iMCU_rows) {
//             <    is read   >: main main[0].rowgroup_ctr
      /* Read input data if we haven't filled the main buffer yet */
      if (main->rowgroup_ctr<8)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         (*cinfo->prep->pre_process_data)(cinfo,input_buf,in_row_ctr,in_rows_avail,main->buffer,&main->rowgroup_ctr,(JDIMENSION) 8);
//             <    is read   >: main main[0].rowgroup_ctr
      
      /* If we don't have a full iMCU row buffered, return to application for
           * more data.  Note that preprocessor will always pad to fill the iMCU row
           * at the bottom of the image.
           */
      if (main->rowgroup_ctr!=8)
         return;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*cinfo->coef->compress_data)(cinfo,main->buffer)) {
//             <    is read   >: main main[0].suspended
         /* If compressor did not consume the whole row, then we must need to
                * suspend processing and return to the application.  In this situation
                * we pretend we didn't yet consume the last input row; otherwise, if
                * it happened to be the last row of the image, the application would
                * think we were done.
                */
         
         /* Send the completed row to the compressor */
         if (!main->suspended) {
//             <    is read   >: in_row_ctr in_row_ctr[0]
//             <    is written>: in_row_ctr[0]
            (*in_row_ctr)--;
//             <    is read   >: main
//             <    is written>: main[0].suspended
            main->suspended = 1;
         }
         return;
      }
//             <    is read   >: main main[0].suspended
      /* We did finish the row.  Undo our little suspension hack if a previous
           * call suspended; then mark the main buffer empty.
           */
      if (main->suspended) {
//             <    is read   >: in_row_ctr in_row_ctr[0]
//             <    is written>: in_row_ctr[0]
         (*in_row_ctr)++;
//             <    is read   >: main
//             <    is written>: main[0].suspended
         main->suspended = 0;
      }
//             <    is read   >: main
//             <    is written>: main[0].rowgroup_ctr
      main->rowgroup_ctr = 0;
//             <    is read   >: main main[0].cur_iMCU_row
//             <    is written>: main[0].cur_iMCU_row
      main->cur_iMCU_row++;
   }
}
static void start_pass_main(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
//             <    is read   >: cinfo cinfo[0].raw_data_in
   
   /* Do nothing in raw-data mode. */
   if (cinfo->raw_data_in)
      return;
//             <    is read   >: main
//             <    is written>: main[0].cur_iMCU_row

   main->cur_iMCU_row = 0;
//             <    is read   >: main
//             <    is written>: main[0].rowgroup_ctr
   /* initialize counters */
   main->rowgroup_ctr = 0;
//             <    is read   >: main
//             <    is written>: main[0].suspended
   main->suspended = 0;
//             <    is read   >: main pass_mode
//             <    is written>: main[0].pass_mode
   main->pass_mode = pass_mode;
//             <    is read   >: pass_mode
   /* save mode for use by process_data */
   
   if (pass_mode==JBUF_PASS_THRU) {
_switch_1_case_JBUF_PASS_THRU:      ;
//             <    is read   >: main
//             <    is written>: main[0].pub.process_data
      
      
      
      
      main->pub.process_data = process_data_simple_main;
   }
   else {
_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
}
static void emit_2bytes(j_compress_ptr cinfo, int value)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, value>>8&0xFF);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, value&0xFF);
}
static void emit_adobe_app14(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /*
      * Length of APP14 block	(2 bytes)
      * Block ID			(5 bytes - ASCII "Adobe")
      * Version Number		(2 bytes - currently 100)
      * Flags0			(2 bytes - currently 0)
      * Flags1			(2 bytes - currently 0)
      * Color transform		(1 byte)
      *
      * Although Adobe TN 5116 mentions Version = 101, all the Adobe files
      * now in circulation seem to use Version = 100, so that's what we write.
      *
      * We write the color transform byte as 1 if the JPEG color space is
      * YCbCr, 2 if it's YCCK, 0 otherwise.  Adobe's definition has to do with
      * whether the encoder performed a transformation, which is pretty useless.
      */
   
   emit_marker(cinfo, M_APP14);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_2bytes(cinfo, 2+5+2+2+2+1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* length */
   
   emit_byte(cinfo, 0x41);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Identifier: ASCII "Adobe" */
   emit_byte(cinfo, 0x64);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0x6F);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0x62);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0x65);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_2bytes(cinfo, 100);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Version */
   emit_2bytes(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Flags0 */
   emit_2bytes(cinfo, 0);
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
   /* Flags1 */
   if (cinfo->jpeg_color_space==JCS_YCbCr) {
_switch_1_case_JCS_YCbCr:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, 1);
      /* Color transform = 1 */
      ;
   }
   else if (cinfo->jpeg_color_space==JCS_YCCK) {
_switch_1_case_JCS_YCCK:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, 2);
      /* Color transform = 2 */
      ;
   }
   else {
_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, 0);
      /* Color transform = 0 */
      ;
   }
}
static void emit_byte(j_compress_ptr cinfo, int val)
{
//             <    is read   >: cinfo cinfo[0].dest
//             <    is written>: dest
   struct jpeg_destination_mgr *dest = cinfo->dest;
//             <    is read   >: dest dest[0].next_output_byte val
//             <    is written>: dest[0].next_output_byte 
//                               dest[0].next_output_byte[0]
   *dest->next_output_byte++ = (JOCTET) val;
//             <    is read   >: dest dest[0].free_in_buffer
//             <    is written>: dest[0].free_in_buffer
   if (--dest->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*dest->empty_output_buffer)(cinfo))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CANT_SUSPEND, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
static void emit_dac(j_compress_ptr cinfo)
{
}
static void emit_dht(j_compress_ptr cinfo, int index, boolean is_ac)
{
   JHUFF_TBL *htbl;
   int length, i;
//             <    is read   >: is_ac

   if (is_ac) {
//             <    is read   >: cinfo 
//                               cinfo[0].ac_huff_tbl_ptrs[index] 
//                               index
//             <    is written>: htbl
      htbl = (cinfo->ac_huff_tbl_ptrs)[index];
//             <    is read   >: index
//             <    is written>: index
      index += 0x10;
   }
   else
//             <    is read   >: cinfo 
//                               cinfo[0].dc_huff_tbl_ptrs[index] 
//                               index
//             <    is written>: htbl
      htbl = (cinfo->dc_huff_tbl_ptrs)[index];
//             <    is read   >: htbl
   if (htbl==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = index, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: htbl htbl[0].sent_table

   if (!htbl->sent_table) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_marker(cinfo, M_DHT);
//             <    is written>: length

      length = 0;
//             <    is written>: i
      for(i = 1; i <= 16; i += 1)
//             <    is read   >: htbl htbl[0].bits[i] i length
//             <    is written>: length
         length += (htbl->bits)[i];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      emit_2bytes(cinfo, length+2+1+16);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, index);
//             <    is written>: i

      for(i = 1; i <= 16; i += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_byte(cinfo, (htbl->bits)[i]);
//             <    is read   >: length
//             <    is written>: i

      for(i = 0; i <= length-1; i += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_byte(cinfo, (htbl->huffval)[i]);
//             <    is read   >: htbl
//             <    is written>: htbl[0].sent_table

      htbl->sent_table = 1;
   }
}
static int emit_dqt(j_compress_ptr cinfo, int index)
{
//             <    is read   >: cinfo cinfo[0].quant_tbl_ptrs[index] 
//                               index
//             <    is written>: qtbl
   JQUANT_TBL *qtbl = (cinfo->quant_tbl_ptrs)[index];
   int prec;
   int i;
//             <    is read   >: qtbl
   if (qtbl==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_NO_QUANT_TABLE, (cinfo->err->msg_parm.i)[0] = index, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is written>: prec

   prec = 0;
//             <    is written>: i
   for(i = 0; i <= 63; i += 1)
//             <    is read   >: i qtbl qtbl[0].quantval[i]
      if ((qtbl->quantval)[i]>255)
//             <    is written>: prec
         prec = 1;
//             <    is read   >: qtbl qtbl[0].sent_table

   if (!qtbl->sent_table) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_marker(cinfo, M_DQT);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      emit_2bytes(cinfo, prec?64*2+1+2:64+1+2);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, index+(prec<<4));
//             <    is written>: i

      for(i = 0; i <= 63; i += 1) {
         /* The table entries must be emitted in zigzag order. */
//             <    is read   >: i jpeg_natural_order[i] qtbl 
//                               qtbl[0].quantval[jpeg_natural_order[i
//                               ]]
//             <    is written>: qval
         unsigned int qval = (qtbl->quantval)[jpeg_natural_order[i]];
//             <    is read   >: prec
         if (prec)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            emit_byte(cinfo, qval>>8);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_byte(cinfo, qval&0xFF);
      }
//             <    is read   >: qtbl
//             <    is written>: qtbl[0].sent_table

      qtbl->sent_table = 1;
   }
//             <    is read   >: prec

   return prec;
}
static void emit_dri(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_marker(cinfo, M_DRI);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_2bytes(cinfo, 4);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* fixed length */
   
   emit_2bytes(cinfo, (int) cinfo->restart_interval);
}
static void emit_jfif_app0(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /*
      * Length of APP0 block	(2 bytes)
      * Block ID			(4 bytes - ASCII "JFIF")
      * Zero byte			(1 byte to terminate the ID string)
      * Version Major, Minor	(2 bytes - 0x01, 0x01)
      * Units			(1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
      * Xdpu			(2 bytes - dots per unit horizontal)
      * Ydpu			(2 bytes - dots per unit vertical)
      * Thumbnail X size		(1 byte)
      * Thumbnail Y size		(1 byte)
      */
   
   emit_marker(cinfo, M_APP0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_2bytes(cinfo, 2+4+1+2+1+2+2+1+1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* length */
   
   emit_byte(cinfo, 0x4A);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Identifier: ASCII "JFIF" */
   emit_byte(cinfo, 0x46);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0x49);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0x46);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* We currently emit version code 1.01 since we use no 1.02 features.
      * This may avoid complaints from some older decoders.
      */
   emit_byte(cinfo, 1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Major version */
   emit_byte(cinfo, 1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Minor version */
   emit_byte(cinfo, cinfo->density_unit);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Pixel size information */
   emit_2bytes(cinfo, (int) cinfo->X_density);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_2bytes(cinfo, (int) cinfo->Y_density);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* No thumbnail image */
   emit_byte(cinfo, 0);
}
static void emit_marker(j_compress_ptr cinfo, JPEG_MARKER mark)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, 0xFF);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, (int) mark);
}
static void emit_sof(j_compress_ptr cinfo, JPEG_MARKER code)
{
   int ci;
   jpeg_component_info *compptr;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_marker(cinfo, code);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_2bytes(cinfo, 3*cinfo->num_components+2+5+1);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].image_width
   /* length */
   
   /* Make sure image isn't bigger than SOF field can handle */
   
   if ((long int) cinfo->image_height>65535L||(long int) cinfo->image_width>65535L)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_IMAGE_TOO_BIG, (cinfo->err->msg_parm.i)[0] = (unsigned int) 65535, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_byte(cinfo, cinfo->data_precision);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_2bytes(cinfo, (int) cinfo->image_height);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_2bytes(cinfo, (int) cinfo->image_width);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_byte(cinfo, cinfo->num_components);
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, compptr->component_id);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, (compptr->h_samp_factor<<4)+compptr->v_samp_factor);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, compptr->quant_tbl_no);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void emit_sos(j_compress_ptr cinfo)
{
   int i, td, ta;
   jpeg_component_info *compptr;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_marker(cinfo, M_SOS);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_2bytes(cinfo, 2*cinfo->comps_in_scan+2+1+3);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* length */
   
   emit_byte(cinfo, cinfo->comps_in_scan);
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: i

   for(i = 0; i <= cinfo->comps_in_scan-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[i] i
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[i];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, compptr->component_id);
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: td
      td = compptr->dc_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no
//             <    is written>: ta
      ta = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].progressive_mode
      if (cinfo->progressive_mode)
//             <    is read   >: cinfo cinfo[0].Ss 
//                               cinfo[0].comps_in_scan
         /* Progressive mode: only DC or only AC tables are used in one scan;
                * furthermore, Huffman coding of DC refinement uses no table at all.
                * We emit 0 for unused field(s); this is recommended by the P&M text
                * but does not seem to be specified in the standard.
                */
         if (cinfo->Ss==0) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ta
            ta = 0;
//             <    is read   >: cinfo cinfo[0].Ah cinfo[0].arith_code
//                               cinfo[0].comps_in_scan
            /* DC scan */
            if (cinfo->Ah!=0&&!cinfo->arith_code)
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: td
               td = 0;
         }
         else
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: td
            td = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_byte(cinfo, (td<<4)+ta);
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_byte(cinfo, cinfo->Ss);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, cinfo->Se);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_byte(cinfo, (cinfo->Ah<<4)+cinfo->Al);
}
static void write_any_marker(j_compress_ptr cinfo, int marker, const JOCTET *dataptr, unsigned int datalen)
{
//             <    is read   >: datalen
   if (datalen<=(unsigned int) 65533) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* safety check */
      emit_marker(cinfo, (JPEG_MARKER) marker);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_2bytes(cinfo, (int) (datalen+2));
//             <    is read   >: datalen
//             <    is written>: datalen
      /* total length */
      
      while (datalen--) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_byte(cinfo, *dataptr);
//             <    is read   >: dataptr
//             <    is written>: dataptr
         dataptr++;
      }
   }
}
static void write_file_header(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_marker(cinfo, M_SOI);
//             <    is read   >: cinfo cinfo[0].write_JFIF_header
   /* first the SOI */
   
   if (cinfo->write_JFIF_header)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* next an optional JFIF APP0 */
      emit_jfif_app0(cinfo);
//             <    is read   >: cinfo cinfo[0].write_Adobe_marker
   if (cinfo->write_Adobe_marker)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* next an optional Adobe APP14 */
      emit_adobe_app14(cinfo);
}
static void write_file_trailer(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_marker(cinfo, M_EOI);
}
static void write_frame_header(j_compress_ptr cinfo)
{
   int ci, prec;
   boolean is_baseline;
   jpeg_component_info *compptr;
//             <    is written>: prec
   
   /* Emit DQT for each quantization table.
      * Note that emit_dqt() suppresses any duplicate tables.
      */
   prec = 0;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      prec += emit_dqt(cinfo, compptr->quant_tbl_no);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].arith_code 
//                               cinfo[0].data_precision 
//                               cinfo[0].progressive_mode
   /* now prec is nonzero iff there are any 16-bit quant tables. */
   
   /* Check for a non-baseline specification.
      * Note we assume that Huffman table numbers won't be changed later.
      */
   
   if (cinfo->arith_code||cinfo->progressive_mode||cinfo->data_precision!=8)
//             <    is written>: is_baseline
      is_baseline = 0;
   else {
//             <    is written>: is_baseline
      is_baseline = 1;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
      compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].ac_tbl_no 
//                               compptr[0].dc_tbl_no
         if (compptr->dc_tbl_no>1||compptr->ac_tbl_no>1)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: is_baseline
            is_baseline = 0;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
         compptr++;
      }
//             <    is read   >: is_baseline prec
      if (prec&&is_baseline) {
//             <    is written>: is_baseline
         is_baseline = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JTRC_16BIT_TABLES, (*cinfo->err->emit_message)((j_common_ptr) cinfo,0);
      }
   }
//             <    is read   >: cinfo cinfo[0].arith_code
   
   /* Emit the proper SOF marker */
   if (cinfo->arith_code)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_sof(cinfo, M_SOF9);
   else if (cinfo->progressive_mode)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_sof(cinfo, M_SOF2);
   else if (is_baseline)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_sof(cinfo, M_SOF0);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_sof(cinfo, M_SOF1);
}
static void write_scan_header(j_compress_ptr cinfo)
{
   int i;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].arith_code

   if (cinfo->arith_code)
//             <    is read   >: cinfo
      /* Emit arith conditioning info.  We may have some duplication
           * if the file has multiple scans, but it's so small it's hardly
           * worth worrying about.
           */
      emit_dac(cinfo);
   else
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: i
      /* Emit Huffman tables.
           * Note that emit_dht() suppresses any duplicate tables.
           */
      for(i = 0; i <= cinfo->comps_in_scan-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[i] i
//             <    is written>: compptr
         compptr = (cinfo->cur_comp_info)[i];
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].progressive_mode
         if (cinfo->progressive_mode)
//             <    is read   >: cinfo cinfo[0].Ss 
//                               cinfo[0].comps_in_scan
            /* Progressive mode: only DC or only AC tables are used in one scan */
//             <    is read   >: cinfo cinfo[0].Ah 
//                               cinfo[0].comps_in_scan
               if (cinfo->Ah==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
                  /* DC needs no table for refinement scan */
                  emit_dht(cinfo, compptr->dc_tbl_no, 0);
            else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               emit_dht(cinfo, compptr->ac_tbl_no, 1);
         else {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* Sequential mode: need both DC and AC tables */
            emit_dht(cinfo, compptr->dc_tbl_no, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            emit_dht(cinfo, compptr->ac_tbl_no, 1);
         }
      }
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Emit DRI if required --- note that DRI value could change for each scan.
      * If it doesn't, a tiny amount of space is wasted in multiple-scan files.
      * We assume DRI will never be nonzero for one scan and zero for a later one.
      */
   if (cinfo->restart_interval)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_dri(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_sos(cinfo);
}
static void write_tables_only(j_compress_ptr cinfo)
{
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_marker(cinfo, M_SOI);
//             <    is written>: i

   for(i = 0; i <= 3; i += 1)
//             <    is read   >: cinfo cinfo[0].quant_tbl_ptrs[i] i
      if ((cinfo->quant_tbl_ptrs)[i]!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (void) emit_dqt(cinfo, i);
//             <    is read   >: cinfo cinfo[0].arith_code

   if (!cinfo->arith_code)
//             <    is written>: i
      for(i = 0; i <= 3; i += 1) {
//             <    is read   >: cinfo cinfo[0].dc_huff_tbl_ptrs[i] i
         if ((cinfo->dc_huff_tbl_ptrs)[i]!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            emit_dht(cinfo, i, 0);
//             <    is read   >: cinfo cinfo[0].ac_huff_tbl_ptrs[i] i
         if ((cinfo->ac_huff_tbl_ptrs)[i]!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            emit_dht(cinfo, i, 1);
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_marker(cinfo, M_EOI);
}
static void finish_pass_master(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
   my_master_ptr master = (my_master_ptr) cinfo->master;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* The entropy coder always needs an end-of-pass call,
      * either to analyze statistics or to flush its output buffer.
      */
   (*cinfo->entropy->finish_pass)(cinfo);
//             <    is read   >: master master[0].pass_type
   
   /* Update state for next pass */
   if (master->pass_type==main_pass) {
//             <    is read   >: master
//             <    is written>: master[0].pass_type
      /* next pass is either output of scan 0 (after optimization)
           * or output of scan 1 (if no optimization).
           */
      master->pass_type = output_pass;
//             <    is read   >: cinfo cinfo[0].optimize_coding
      if (!cinfo->optimize_coding)
//             <    is read   >: master master[0].scan_number
//             <    is written>: master[0].scan_number
         master->scan_number++;
   }
   else if (master->pass_type==huff_opt_pass) {
_switch_1_case_huff_opt_pass:      ;
//             <    is read   >: master
//             <    is written>: master[0].pass_type
      /* next pass is always output of current scan */
      master->pass_type = output_pass;
   }
   else if (master->pass_type==output_pass) {
_switch_1_case_output_pass:      ;
//             <    is read   >: cinfo cinfo[0].optimize_coding
      /* next pass is either optimization or output of next scan */
      if (cinfo->optimize_coding)
//             <    is read   >: master
//             <    is written>: master[0].pass_type
         master->pass_type = huff_opt_pass;
//             <    is read   >: master master[0].scan_number
//             <    is written>: master[0].scan_number
      master->scan_number++;
   }
_break_1:   ;
//             <    is read   >: master master[0].pass_number
//             <    is written>: master[0].pass_number

   master->pass_number++;
}
static void initial_setup(j_compress_ptr cinfo)
{
   int ci;
   jpeg_component_info *compptr;
   long int samplesperrow;
   JDIMENSION jd_samplesperrow;
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].image_width 
//                               cinfo[0].input_components 
//                               cinfo[0].num_components
   
   /* Sanity check on image dimensions */
   
   if (cinfo->image_height<=0||cinfo->image_width<=0||cinfo->num_components<=0||cinfo->input_components<=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_EMPTY_IMAGE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].image_width
   
   /* Make sure image isn't bigger than I can handle */
   
   if ((long int) cinfo->image_height>(long int) 65500L||(long int) cinfo->image_width>(long int) 65500L)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_IMAGE_TOO_BIG, (cinfo->err->msg_parm.i)[0] = (unsigned int) 65500L, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].input_components
//             <    is written>: samplesperrow
   
   /* Width of an input scanline must be representable as JDIMENSION. */
   samplesperrow = (long int) cinfo->image_width*(long int) cinfo->input_components;
//             <    is read   >: samplesperrow
//             <    is written>: jd_samplesperrow
   jd_samplesperrow = (JDIMENSION) samplesperrow;
//             <    is read   >: jd_samplesperrow samplesperrow
   if ((long int) jd_samplesperrow!=samplesperrow)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_WIDTH_OVERFLOW, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].data_precision
   
   /* For now, precision must match compiled-in value... */
   if (cinfo->data_precision!=8)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_PRECISION, (cinfo->err->msg_parm.i)[0] = cinfo->data_precision, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components
   
   /* Check that number of components won't exceed internal array sizes */
   if (cinfo->num_components>10)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = cinfo->num_components, (cinfo->err->msg_parm.i)[1] = 10, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].max_h_samp_factor
   
   /* Compute maximum sampling factors; check factor validity */
   cinfo->max_h_samp_factor = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].max_v_samp_factor
   cinfo->max_v_samp_factor = 1;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].h_samp_factor 
//                               compptr[0].h_samp_factor 
//                               compptr[0].v_samp_factor 
//                               compptr[0].v_samp_factor

      if (compptr->h_samp_factor<=0||compptr->h_samp_factor>4||compptr->v_samp_factor<=0||compptr->v_samp_factor>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_SAMPLING, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: cinfo[0].max_h_samp_factor
      cinfo->max_h_samp_factor = cinfo->max_h_samp_factor>compptr->h_samp_factor?cinfo->max_h_samp_factor:compptr->h_samp_factor;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: cinfo[0].max_v_samp_factor
      cinfo->max_v_samp_factor = cinfo->max_v_samp_factor>compptr->v_samp_factor?cinfo->max_v_samp_factor:compptr->v_samp_factor;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* Compute dimensions of components */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               compptr
//             <    is written>: compptr[0].component_index
      /* Fill in the correct component_index value; don't rely on application */
      compptr->component_index = ci;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr[0].DCT_scaled_size
      /* For compression, we never do DCT scaling. */
      compptr->DCT_scaled_size = 8;
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].width_in_blocks
      /* Size in DCT blocks */
      
      
      compptr->width_in_blocks = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width*(long int) compptr->h_samp_factor, (long int) (cinfo->max_h_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].height_in_blocks
      compptr->height_in_blocks = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height*(long int) compptr->v_samp_factor, (long int) (cinfo->max_v_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].downsampled_width
      /* Size in samples */
      
      
      compptr->downsampled_width = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width*(long int) compptr->h_samp_factor, (long int) cinfo->max_h_samp_factor);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].downsampled_height
      
      
      compptr->downsampled_height = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height*(long int) compptr->v_samp_factor, (long int) cinfo->max_v_samp_factor);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr[0].component_needed
      /* Mark component needed (this flag isn't actually used for compression) */
      compptr->component_needed = 1;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor
//             <    is written>: cinfo[0].total_iMCU_rows
   
   /* Compute number of fully interleaved MCU rows (number of times that
      * main controller will call coefficient controller).
      */
   
   
   cinfo->total_iMCU_rows = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, (long int) (cinfo->max_v_samp_factor*8));
}
static void pass_startup(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: cinfo[0].master[0].call_pass_startup
   cinfo->master->call_pass_startup = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* reset flag so call only once */
   
   (*cinfo->marker->write_frame_header)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->marker->write_scan_header)(cinfo);
}
static void per_scan_setup(j_compress_ptr cinfo)
{
   int ci, mcublks, tmp;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comps_in_scan

   if (cinfo->comps_in_scan==1) {
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0]
//             <    is written>: compptr
      
      /* Noninterleaved (single-component) scan */
      compptr = (cinfo->cur_comp_info)[0];
//             <    is read   >: cinfo compptr 
//                               compptr[0].width_in_blocks
//             <    is written>: cinfo[0].MCUs_per_row
      
      /* Overall image size in MCUs */
      cinfo->MCUs_per_row = compptr->width_in_blocks;
//             <    is read   >: cinfo compptr 
//                               compptr[0].height_in_blocks
//             <    is written>: cinfo[0].MCU_rows_in_scan
      cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_width
      
      /* For noninterleaved scan, always one block per MCU */
      compptr->MCU_width = 1;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_height
      compptr->MCU_height = 1;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_blocks
      compptr->MCU_blocks = 1;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_sample_width
      compptr->MCU_sample_width = 8;
//             <    is read   >: compptr
//             <    is written>: compptr[0].last_col_width
      compptr->last_col_width = 1;
//             <    is read   >: compptr compptr[0].height_in_blocks 
//                               compptr[0].v_samp_factor
//             <    is written>: tmp
      /* For noninterleaved scans, it is convenient to define last_row_height
           * as the number of block rows present in the last iMCU row.
           */
      tmp = (int) (compptr->height_in_blocks%compptr->v_samp_factor);
//             <    is read   >: tmp
      if (tmp==0)
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: tmp
         tmp = compptr->v_samp_factor;
//             <    is read   >: compptr tmp
//             <    is written>: compptr[0].last_row_height
      compptr->last_row_height = tmp;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].blocks_in_MCU
      
      /* Prepare array describing MCU composition */
      cinfo->blocks_in_MCU = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].MCU_membership[0]
      (cinfo->MCU_membership)[0] = 0;
   }
   else {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].comps_in_scan
      
      /* Interleaved (multi-component) scan */
      if (cinfo->comps_in_scan<=0||cinfo->comps_in_scan>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = cinfo->comps_in_scan, (cinfo->err->msg_parm.i)[1] = 4, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor
//             <    is written>: cinfo[0].MCUs_per_row
      
      /* Overall image size in MCUs */
      
      
      cinfo->MCUs_per_row = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width, (long int) (cinfo->max_h_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor
//             <    is written>: cinfo[0].MCU_rows_in_scan
      cinfo->MCU_rows_in_scan = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, (long int) (cinfo->max_v_samp_factor*8));
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].blocks_in_MCU

      cinfo->blocks_in_MCU = 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

      for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
         compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].MCU_width
         /* Sampling factors give # of blocks of component in each MCU */
         compptr->MCU_width = compptr->h_samp_factor;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].MCU_height
         compptr->MCU_height = compptr->v_samp_factor;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width
//             <    is written>: compptr[0].MCU_blocks
         compptr->MCU_blocks = compptr->MCU_width*compptr->MCU_height;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_width
//             <    is written>: compptr[0].MCU_sample_width
         compptr->MCU_sample_width = compptr->MCU_width*8;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_width 
//                               compptr[0].width_in_blocks
//             <    is written>: tmp
         /* Figure number of non-dummy blocks in last MCU column & row */
         tmp = (int) (compptr->width_in_blocks%compptr->MCU_width);
//             <    is read   >: cinfo cinfo[0].comps_in_scan tmp
         if (tmp==0)
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_width
//             <    is written>: tmp
            tmp = compptr->MCU_width;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               tmp
//             <    is written>: compptr[0].last_col_width
         compptr->last_col_width = tmp;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].height_in_blocks
//             <    is written>: tmp
         tmp = (int) (compptr->height_in_blocks%compptr->MCU_height);
//             <    is read   >: cinfo cinfo[0].comps_in_scan tmp
         if (tmp==0)
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_height
//             <    is written>: tmp
            tmp = compptr->MCU_height;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               tmp
//             <    is written>: compptr[0].last_row_height
         compptr->last_row_height = tmp;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_blocks
//             <    is written>: mcublks
         /* Prepare array describing MCU composition */
         mcublks = compptr->MCU_blocks;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].comps_in_scan mcublks
         if (cinfo->blocks_in_MCU+mcublks>10)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_BAD_MCU_SIZE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: mcublks
//             <    is written>: mcublks
         while (mcublks-->0)
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].MCU_membership[cinfo->blocks
//                               _in_MCU++] cinfo[0].blocks_in_MCU
            (cinfo->MCU_membership)[cinfo->blocks_in_MCU++] = ci;
      }
   }
//             <    is read   >: cinfo cinfo[0].restart_in_rows
   
   /* Convert restart specified in rows to actual MCU count. */
   /* Note that count must fit in 16 bits, so we provide limiting. */
   if (cinfo->restart_in_rows>0) {
//             <    is read   >: cinfo cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].restart_in_rows
//             <    is written>: nominal
      long int nominal = (long int) cinfo->restart_in_rows*(long int) cinfo->MCUs_per_row;
//             <    is read   >: cinfo nominal
//             <    is written>: cinfo[0].restart_interval
      cinfo->restart_interval = (unsigned int) (nominal<65535L?nominal:65535L);
   }
}
static void prepare_for_pass(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
   my_master_ptr master = (my_master_ptr) cinfo->master;
//             <    is read   >: master master[0].pass_type

   if (master->pass_type==main_pass) goto _switch_1_case_main_pass;
//             <    is read   >: master master[0].pass_type
   if (master->pass_type==huff_opt_pass) goto _switch_1_case_huff_opt_pass;
//             <    is read   >: master master[0].pass_type
   if (master->pass_type==output_pass) goto _switch_1_case_output_pass;
_switch_1_default:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JERR_NOT_COMPILED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;
   /*FALLTHROUGH*/
   
_switch_1_case_output_pass:   ;
//             <    is read   >: cinfo cinfo[0].optimize_coding
   /* Do a data-output pass. */
   /* We need not repeat per-scan setup if prior optimization pass did it. */
   if (!cinfo->optimize_coding) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      select_scan_parameters(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      per_scan_setup(cinfo);
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->entropy->start_pass)(cinfo,0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->coef->start_pass)(cinfo,JBUF_CRANK_DEST);
//             <    is read   >: master master[0].scan_number
   /* We emit frame/scan headers now */
   if (master->scan_number==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->marker->write_frame_header)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->marker->write_scan_header)(cinfo);
//             <    is read   >: master
//             <    is written>: master[0].pub.call_pass_startup
   master->pub.call_pass_startup = 0;
   goto _break_1;

_switch_1_case_huff_opt_pass:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Do Huffman optimization for a scan after the first one. */
   select_scan_parameters(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   per_scan_setup(cinfo);
//             <    is read   >: cinfo cinfo[0].Ah cinfo[0].Ss 
//                               cinfo[0].arith_code
   if (cinfo->Ss!=0||cinfo->Ah==0||cinfo->arith_code) goto l99999;
//             <    is read   >: master
//             <    is written>: master[0].pass_type
   /* Special case: Huffman DC refinement scans need no Huffman table
        * and therefore we can skip the optimization pass for them.
        */
   master->pass_type = output_pass;
//             <    is read   >: master master[0].pass_number
//             <    is written>: master[0].pass_number
   master->pass_number++;
   goto _switch_1_case_output_pass;
l99999:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->entropy->start_pass)(cinfo,1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->coef->start_pass)(cinfo,JBUF_CRANK_DEST);
//             <    is read   >: master
//             <    is written>: master[0].pub.call_pass_startup
   master->pub.call_pass_startup = 0;
   goto _break_1;
_switch_1_case_main_pass:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Initial pass: will collect input data, and do either Huffman
        * optimization or data output for the first scan.
        */
   select_scan_parameters(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   per_scan_setup(cinfo);
//             <    is read   >: cinfo cinfo[0].raw_data_in
   if (!cinfo->raw_data_in) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->cconvert->start_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->downsample->start_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->prep->start_pass)(cinfo,JBUF_PASS_THRU);
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->fdct->start_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->entropy->start_pass)(cinfo,cinfo->optimize_coding);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->coef->start_pass)(cinfo,master->total_passes>1?JBUF_SAVE_AND_PASS:JBUF_PASS_THRU);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->main->start_pass)(cinfo,JBUF_PASS_THRU);
//             <    is read   >: cinfo cinfo[0].optimize_coding
   if (cinfo->optimize_coding)
//             <    is read   >: master
//             <    is written>: master[0].pub.call_pass_startup
      /* No immediate data output; postpone writing frame/scan headers */
      master->pub.call_pass_startup = 0;
   else
//             <    is read   >: master
//             <    is written>: master[0].pub.call_pass_startup
      /* Will write frame/scan headers at first jpeg_write_scanlines call */
      master->pub.call_pass_startup = 1;
_break_1:   ;
//             <    is read   >: master master[0].pass_number 
//                               master[0].total_passes
//             <    is written>: master[0].pub.is_last_pass
   master->pub.is_last_pass = master->pass_number==master->total_passes-1;
//             <    is read   >: cinfo cinfo[0].progress
   
   /* Set up progress monitor's pass info if present */
   if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].progress master 
//                               master[0].pass_number
//             <    is written>: cinfo[0].progress[0].completed_passes
      cinfo->progress->completed_passes = master->pass_number;
//             <    is read   >: cinfo cinfo[0].progress master 
//                               master[0].total_passes
//             <    is written>: cinfo[0].progress[0].total_passes
      cinfo->progress->total_passes = master->total_passes;
   }
}
static void select_scan_parameters(j_compress_ptr cinfo)
{
   int ci;
//             <    is read   >: cinfo cinfo[0].scan_info
   if (cinfo->scan_info!=(void *) 0) {
      /* Prepare for current scan --- the script is already validated */
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
      my_master_ptr master = (my_master_ptr) cinfo->master;
//             <    is read   >: cinfo cinfo[0].scan_info master 
//                               master[0].scan_number
//             <    is written>: scanptr
      const jpeg_scan_info *scanptr = cinfo->scan_info+master->scan_number;
//             <    is read   >: cinfo scanptr 
//                               scanptr[0].comps_in_scan
//             <    is written>: cinfo[0].comps_in_scan

      cinfo->comps_in_scan = scanptr->comps_in_scan;
//             <    is read   >: scanptr scanptr[0].comps_in_scan
//             <    is written>: ci
      for(ci = 0; ci <= scanptr->comps_in_scan-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comp_info scanptr 
//                               scanptr[0].component_index[ci] 
//                               scanptr[0].comps_in_scan
//             <    is written>: cinfo[0].cur_comp_info[ci]

         (cinfo->cur_comp_info)[ci] = &(cinfo->comp_info)[(scanptr->component_index)[ci]];
//             <    is read   >: cinfo scanptr scanptr[0].Ss
//             <    is written>: cinfo[0].Ss
      cinfo->Ss = scanptr->Ss;
//             <    is read   >: cinfo scanptr scanptr[0].Se
//             <    is written>: cinfo[0].Se
      cinfo->Se = scanptr->Se;
//             <    is read   >: cinfo scanptr scanptr[0].Ah
//             <    is written>: cinfo[0].Ah
      cinfo->Ah = scanptr->Ah;
//             <    is read   >: cinfo scanptr scanptr[0].Al
//             <    is written>: cinfo[0].Al
      cinfo->Al = scanptr->Al;
   }
   else {
//             <    is read   >: cinfo cinfo[0].num_components
      /* Prepare for single sequential-JPEG scan containing all components */
      if (cinfo->num_components>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = cinfo->num_components, (cinfo->err->msg_parm.i)[1] = 4, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: cinfo[0].comps_in_scan
      cinfo->comps_in_scan = cinfo->num_components;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comp_info 
//                               cinfo[0].num_components
//             <    is written>: cinfo[0].cur_comp_info[ci]
         (cinfo->cur_comp_info)[ci] = &(cinfo->comp_info)[ci];
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Ss
      cinfo->Ss = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Se
      cinfo->Se = 64-1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Ah
      cinfo->Ah = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Al
      cinfo->Al = 0;
   }
}
static void validate_script(j_compress_ptr cinfo)
{
   const jpeg_scan_info *scanptr;
   int scanno, ncomps, ci, coefi, thisi;
   int Ss, Se, Ah, Al;
   boolean component_sent[10];

   int *last_bitpos_ptr;
   int last_bitpos[10][64];
//             <    is read   >: cinfo cinfo[0].num_scans
   /* -1 until that coefficient has been seen; then last Al for it */
   
   
   if (cinfo->num_scans<=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_SCAN_SCRIPT, (cinfo->err->msg_parm.i)[0] = 0, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].scan_info
//             <    is written>: scanptr
   
   /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
      * for progressive JPEG, no scan can have this.
      */
   scanptr = cinfo->scan_info;
//             <    is read   >: scanptr scanptr[0].Se scanptr[0].Ss
   if (scanptr->Ss!=0||scanptr->Se!=64-1) {
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].progressive_mode

      cinfo->progressive_mode = 1;
//             <    is written>: last_bitpos_ptr
      last_bitpos_ptr = &last_bitpos[0][0];
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: coefi
         for(coefi = 0; coefi <= 63; coefi += 1)
//             <    is read   >: cinfo cinfo[0].num_components 
//                               last_bitpos_ptr
//             <    is written>: last_bitpos_ptr last_bitpos_ptr[0]
            *last_bitpos_ptr++ = -1;
   }
   else {
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].progressive_mode
      cinfo->progressive_mode = 0;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].num_components
//             <    is written>: component_sent[ci]
         component_sent[ci] = 0;
   }
//             <    is read   >: cinfo cinfo[0].num_scans
//             <    is written>: scanno

   for(scanno = 1; scanno <= cinfo->num_scans; scanno += 1) {
//             <    is read   >: cinfo cinfo[0].num_scans scanptr 
//                               scanptr[0].comps_in_scan
//             <    is written>: ncomps
      /* Validate component indexes */
      ncomps = scanptr->comps_in_scan;
//             <    is read   >: cinfo cinfo[0].num_scans ncomps
      if (ncomps<=0||ncomps>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = ncomps, (cinfo->err->msg_parm.i)[1] = 4, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_scans ncomps
//             <    is written>: ci
      for(ci = 0; ci <= ncomps-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].num_scans ncomps 
//                               scanptr 
//                               scanptr[0].component_index[ci]
//             <    is written>: thisi
         thisi = (scanptr->component_index)[ci];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].num_scans ncomps thisi
         if (thisi<0||thisi>=cinfo->num_components)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_BAD_SCAN_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: ci cinfo cinfo[0].num_scans ncomps 
//                               scanptr 
//                               scanptr[0].component_index[ci-1] 
//                               thisi
         /* Components must appear in SOF order within each scan */
         if (ci>0&&thisi<=(scanptr->component_index)[ci-1])
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_BAD_SCAN_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
//             <    is read   >: cinfo cinfo[0].num_scans scanptr 
//                               scanptr[0].Ss
//             <    is written>: Ss
      /* Validate progression parameters */
      Ss = scanptr->Ss;
//             <    is read   >: cinfo cinfo[0].num_scans scanptr 
//                               scanptr[0].Se
//             <    is written>: Se
      Se = scanptr->Se;
//             <    is read   >: cinfo cinfo[0].num_scans scanptr 
//                               scanptr[0].Ah
//             <    is written>: Ah
      Ah = scanptr->Ah;
//             <    is read   >: cinfo cinfo[0].num_scans scanptr 
//                               scanptr[0].Al
//             <    is written>: Al
      Al = scanptr->Al;
//             <    is read   >: cinfo cinfo[0].num_scans 
//                               cinfo[0].progressive_mode
      if (cinfo->progressive_mode) {
//             <    is read   >: Ah Al Se Ss cinfo cinfo[0].num_scans
         
         
         if (Ss<0||Ss>=64||Se<Ss||Se>=64||Ah<0||Ah>13||Al<0||Al>13)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: Ss cinfo cinfo[0].num_scans
         if (Ss==0)
//             <    is read   >: Se cinfo cinfo[0].num_scans
            if (Se!=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               /* DC and AC together not OK */
               cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
         else if (ncomps!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* AC scans must be for only one component */
            cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_scans ncomps
//             <    is written>: ci
         for(ci = 0; ci <= ncomps-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].num_scans ncomps 
//                               scanptr 
//                               scanptr[0].component_index[ci]
//             <    is written>: last_bitpos_ptr
            last_bitpos_ptr = &last_bitpos[(scanptr->component_index)[ci]][0];
//             <    is read   >: Ss cinfo cinfo[0].num_scans 
//                               last_bitpos_ptr last_bitpos_ptr[0] 
//                               ncomps
            if (Ss!=0&&last_bitpos_ptr[0]<0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               /* AC without prior DC scan */
               cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: Se Ss cinfo cinfo[0].num_scans ncomps
//             <    is written>: coefi
            for(coefi = Ss; coefi <= Se; coefi += 1) {
//             <    is read   >: Se Ss cinfo cinfo[0].num_scans coefi 
//                               last_bitpos_ptr 
//                               last_bitpos_ptr[coefi] ncomps
               if (last_bitpos_ptr[coefi]<0) {
//             <    is read   >: Ah Se Ss cinfo cinfo[0].num_scans 
//                               ncomps
                  /* first scan of this coefficient */
                  if (Ah!=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
                     cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
               }
               else
//             <    is read   >: Ah Al Se Ss cinfo cinfo[0].num_scans 
//                               coefi last_bitpos_ptr 
//                               last_bitpos_ptr[coefi] ncomps
                  /* not first scan */
                  if (Ah!=last_bitpos_ptr[coefi]||Al!=Ah-1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
                     cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: Al Se Ss cinfo cinfo[0].num_scans 
//                               coefi last_bitpos_ptr ncomps
//             <    is written>: last_bitpos_ptr[coefi]
               last_bitpos_ptr[coefi] = Al;
            }
         }
      }
      else {
//             <    is read   >: Ah Al Se Ss cinfo cinfo[0].num_scans
         /* For sequential JPEG, all progression parameters must be these: */
         if (Ss!=0||Se!=64-1||Ah!=0||Al!=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_BAD_PROG_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_scans ncomps
//             <    is written>: ci
         /* Make sure components are not sent twice */
         for(ci = 0; ci <= ncomps-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].num_scans ncomps 
//                               scanptr 
//                               scanptr[0].component_index[ci]
//             <    is written>: thisi
            thisi = (scanptr->component_index)[ci];
//             <    is read   >: cinfo cinfo[0].num_scans 
//                               component_sent[thisi] ncomps thisi
            if (component_sent[thisi])
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               cinfo->err->msg_code = JERR_BAD_SCAN_SCRIPT, (cinfo->err->msg_parm.i)[0] = scanno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_scans ncomps thisi
//             <    is written>: component_sent[thisi]
            component_sent[thisi] = 1;
         }
      }
//             <    is read   >: cinfo cinfo[0].num_scans scanptr
//             <    is written>: scanptr
      scanptr++;
   }
//             <    is read   >: cinfo cinfo[0].progressive_mode
   
   /* Now verify that everything got sent. */
   if (cinfo->progressive_mode)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      
      /* For progressive mode, we only check that at least some DC data
           * got sent for each component; the spec does not require that all bits
           * of all coefficients be transmitted.  Would it be wiser to enforce
           * transmission of all coefficient bits??
           */
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               last_bitpos[ci][0]
         if (last_bitpos[ci][0]<0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_MISSING_DATA, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   else
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               component_sent[ci]
         if (!component_sent[ci])
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_MISSING_DATA, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
void jcopy_block_row(JBLOCKROW input_row, JBLOCKROW output_row, JDIMENSION num_blocks)
{
//             <may be read   >: input_row[*][*]
//             <may be written>: output_row[*][*]
//             <    is read   >: input_row num_blocks output_row
   memcpy((void *) output_row, (void *) input_row, (size_t) (num_blocks*64*(size_t) sizeof(JCOEF)));
}
void jcopy_sample_rows(JSAMPARRAY input_array, int source_row, JSAMPARRAY output_array, int dest_row, int num_rows, JDIMENSION num_cols)
{
   register JSAMPROW inptr, outptr;
//             <    is read   >: num_cols
//             <    is written>: count
   register size_t count = (size_t) (num_cols*(size_t) sizeof(JSAMPLE));
   
   
   
   register int row;
//             <    is read   >: input_array source_row
//             <    is written>: input_array

   input_array += source_row;
//             <    is read   >: dest_row output_array
//             <    is written>: output_array
   output_array += dest_row;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = num_rows; row >= 1; row += -1) {
//             <    is read   >: input_array input_array[0] num_rows
//             <    is written>: inptr input_array
      inptr = *input_array++;
//             <    is read   >: num_rows output_array output_array[0]
//             <    is written>: outptr output_array
      outptr = *output_array++;
//             <may be read   >: inptr[*]
//             <may be written>: outptr[*]
//             <    is read   >: count inptr num_rows outptr
      memcpy((void *) outptr, (void *) inptr, (size_t) count);
   }
}
static void add_huff_table(j_compress_ptr cinfo, JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
{
//             <    is read   >: htblptr htblptr[0]
   if (*htblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
//             <may be read   >: bits[*]
//             <may be written>: htblptr[0][0].bits[*]
//             <    is read   >: bits htblptr htblptr[0]
   memcpy((void *) (*htblptr)->bits, (void *) bits, (size_t) (size_t) sizeof((*htblptr)->bits));
//             <may be read   >: val[*]
//             <may be written>: htblptr[0][0].huffval[*]
//             <    is read   >: htblptr htblptr[0] val
   memcpy((void *) (*htblptr)->huffval, (void *) val, (size_t) (size_t) sizeof((*htblptr)->huffval));
//             <    is read   >: htblptr htblptr[0]
//             <    is written>: htblptr[0][0].sent_table
   
   /* Initialize sent_table FALSE so table will be written to JPEG file. */
   (*htblptr)->sent_table = 0;
}
static jpeg_scan_info * fill_a_scan(jpeg_scan_info *scanptr, int ci, int Ss, int Se, int Ah, int Al)
{
//             <    is read   >: scanptr
//             <    is written>: scanptr[0].comps_in_scan
   scanptr->comps_in_scan = 1;
//             <    is read   >: ci scanptr
//             <    is written>: scanptr[0].component_index[0]
   (scanptr->component_index)[0] = ci;
//             <    is read   >: Ss scanptr
//             <    is written>: scanptr[0].Ss
   scanptr->Ss = Ss;
//             <    is read   >: Se scanptr
//             <    is written>: scanptr[0].Se
   scanptr->Se = Se;
//             <    is read   >: Ah scanptr
//             <    is written>: scanptr[0].Ah
   scanptr->Ah = Ah;
//             <    is read   >: Al scanptr
//             <    is written>: scanptr[0].Al
   scanptr->Al = Al;
//             <    is read   >: scanptr
//             <    is written>: scanptr
   scanptr++;
//             <    is read   >: scanptr
   return scanptr;
}
static jpeg_scan_info * fill_dc_scans(jpeg_scan_info *scanptr, int ncomps, int Ah, int Al)
{
   int ci;
//             <    is read   >: ncomps

   if (ncomps<=4) {
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr[0].comps_in_scan
      /* Single interleaved DC scan */
      scanptr->comps_in_scan = ncomps;
//             <    is read   >: ncomps
//             <    is written>: ci
      for(ci = 0; ci <= ncomps-1; ci += 1)
//             <    is read   >: ci ncomps scanptr
//             <    is written>: scanptr[0].component_index[ci]
         (scanptr->component_index)[ci] = ci;
//             <    is read   >: scanptr
//             <    is written>: scanptr[0].Se scanptr[0].Ss
      scanptr->Ss = scanptr->Se = 0;
//             <    is read   >: Ah scanptr
//             <    is written>: scanptr[0].Ah
      scanptr->Ah = Ah;
//             <    is read   >: Al scanptr
//             <    is written>: scanptr[0].Al
      scanptr->Al = Al;
//             <    is read   >: scanptr
//             <    is written>: scanptr
      scanptr++;
   }
   else
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: Ah Al ncomps scanptr
//             <    is written>: scanptr
      /* Noninterleaved DC scan for each component */
      scanptr = fill_scans(scanptr, ncomps, 0, 0, Ah, Al);
//             <    is read   >: scanptr
   return scanptr;
}
static jpeg_scan_info * fill_scans(jpeg_scan_info *scanptr, int ncomps, int Ss, int Se, int Ah, int Al)
{
   int ci;
//             <    is read   >: ncomps
//             <    is written>: ci

   for(ci = 0; ci <= ncomps-1; ci += 1) {
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr[0].comps_in_scan
      scanptr->comps_in_scan = 1;
//             <    is read   >: ci ncomps scanptr
//             <    is written>: scanptr[0].component_index[0]
      (scanptr->component_index)[0] = ci;
//             <    is read   >: Ss ncomps scanptr
//             <    is written>: scanptr[0].Ss
      scanptr->Ss = Ss;
//             <    is read   >: Se ncomps scanptr
//             <    is written>: scanptr[0].Se
      scanptr->Se = Se;
//             <    is read   >: Ah ncomps scanptr
//             <    is written>: scanptr[0].Ah
      scanptr->Ah = Ah;
//             <    is read   >: Al ncomps scanptr
//             <    is written>: scanptr[0].Al
      scanptr->Al = Al;
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      scanptr++;
   }
//             <    is read   >: scanptr
   return scanptr;
}
static void std_huff_tables(j_compress_ptr cinfo)
{
   
   /* 0-base */
   static const  UINT8 bits_dc_luminance[17] = {0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0};

   static const  UINT8 val_dc_luminance[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
   
   
   /* 0-base */
   static const  UINT8 bits_dc_chrominance[17] = {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};

   static const  UINT8 val_dc_chrominance[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
   
   
   /* 0-base */
   static const  UINT8 bits_ac_luminance[17] = {0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d};
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   static const  UINT8 val_ac_luminance[] = {0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa};
   
   
   /* 0-base */
   static const  UINT8 bits_ac_chrominance[17] = {0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77};
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   static const  UINT8 val_ac_chrominance[] = {0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa};
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   
   add_huff_table(cinfo, &(cinfo->dc_huff_tbl_ptrs)[0], bits_dc_luminance, val_dc_luminance);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   add_huff_table(cinfo, &(cinfo->ac_huff_tbl_ptrs)[0], bits_ac_luminance, val_ac_luminance);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   add_huff_table(cinfo, &(cinfo->dc_huff_tbl_ptrs)[1], bits_dc_chrominance, val_dc_chrominance);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   add_huff_table(cinfo, &(cinfo->ac_huff_tbl_ptrs)[1], bits_ac_chrominance, val_ac_chrominance);
}
static void dump_buffer(phuff_entropy_ptr entropy)
{
//             <    is read   >: entropy entropy[0].cinfo 
//                               entropy[0].cinfo[0].dest
//             <    is written>: dest
   struct jpeg_destination_mgr *dest = entropy->cinfo->dest;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!(*dest->empty_output_buffer)(entropy->cinfo))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      entropy->cinfo->err->msg_code = JERR_CANT_SUSPEND, (*entropy->cinfo->err->error_exit)((j_common_ptr) entropy->cinfo);
//             <    is read   >: dest dest[0].next_output_byte entropy
//             <    is written>: entropy[0].next_output_byte
   /* After a successful buffer dump, must reset buffer pointers */
   entropy->next_output_byte = dest->next_output_byte;
//             <    is read   >: dest dest[0].free_in_buffer entropy
//             <    is written>: entropy[0].free_in_buffer
   entropy->free_in_buffer = dest->free_in_buffer;
}
static void emit_bits(phuff_entropy_ptr entropy, unsigned int code, int size)
{
   /* This routine is heavily used, so it's worth coding tightly. */
//             <    is read   >: code
//             <    is written>: put_buffer
   register INT32 put_buffer = (INT32) code;
//             <    is read   >: entropy entropy[0].put_bits
//             <    is written>: put_bits
   register int put_bits = entropy->put_bits;
//             <    is read   >: size
   
   /* if size is 0, caller used an invalid Huffman table entry */
   if (size==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      entropy->cinfo->err->msg_code = JERR_HUFF_MISSING_CODE, (*entropy->cinfo->err->error_exit)((j_common_ptr) entropy->cinfo);
//             <    is read   >: entropy entropy[0].gather_statistics

   if (entropy->gather_statistics)
      return;
//             <    is read   >: put_buffer size
//             <    is written>: put_buffer
   /* do nothing if we're only getting stats */
   
   put_buffer &= ((INT32) 1<<size)-1;
//             <    is read   >: put_bits size
//             <    is written>: put_bits
   /* mask off any extra bits in code */
   
   put_bits += size;
//             <    is read   >: put_bits put_buffer
//             <    is written>: put_buffer
   /* new number of bits in buffer */
   
   put_buffer <<= 24-put_bits;
//             <    is read   >: entropy entropy[0].put_buffer 
//                               put_buffer
//             <    is written>: put_buffer
   /* align incoming bits */
   
   put_buffer |= entropy->put_buffer;
//             <    is read   >: put_bits
   /* and merge with old buffer contents */
   
   while (put_bits>=8) {
//             <    is read   >: put_buffer
//             <    is written>: c
      int c = (int) (put_buffer>>16&0xFF);
//             <    is read   >: c entropy entropy[0].next_output_byte
//             <    is written>: entropy[0].next_output_byte 
//                               entropy[0].next_output_byte[0]
      *entropy->next_output_byte++ = (JOCTET) c;
//             <    is read   >: entropy entropy[0].free_in_buffer
//             <    is written>: entropy[0].free_in_buffer
      if (--entropy->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         dump_buffer(entropy);
//             <    is read   >: c
      if (c==0xFF) {
//             <    is read   >: entropy entropy[0].next_output_byte
//             <    is written>: entropy[0].next_output_byte 
//                               entropy[0].next_output_byte[0]
         *entropy->next_output_byte++ = (JOCTET) 0;
//             <    is read   >: entropy entropy[0].free_in_buffer
//             <    is written>: entropy[0].free_in_buffer
         if (--entropy->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            dump_buffer(entropy);
      }
//             <    is read   >: put_buffer
//             <    is written>: put_buffer
      put_buffer <<= 8;
//             <    is read   >: put_bits
//             <    is written>: put_bits
      put_bits -= 8;
   }
//             <    is read   >: entropy put_buffer
//             <    is written>: entropy[0].put_buffer

   entropy->put_buffer = put_buffer;
//             <    is read   >: entropy put_bits
//             <    is written>: entropy[0].put_bits
   /* update variables */
   entropy->put_bits = put_bits;
}
static void emit_buffered_bits(phuff_entropy_ptr entropy, char *bufstart, unsigned int nbits)
{
//             <    is read   >: entropy entropy[0].gather_statistics
   if (entropy->gather_statistics)
      return;
//             <    is read   >: nbits
   /* no real work */
   
   while (nbits>0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_bits(entropy, (unsigned int) *bufstart, 1);
//             <    is read   >: bufstart
//             <    is written>: bufstart
      bufstart++;
//             <    is read   >: nbits
//             <    is written>: nbits
      nbits--;
   }
}
static void emit_eobrun(phuff_entropy_ptr entropy)
{
   register int temp, nbits;
//             <    is read   >: entropy entropy[0].EOBRUN

   if (entropy->EOBRUN>0) {
//             <    is read   >: entropy entropy[0].EOBRUN
//             <    is written>: temp
      /* if there is any pending EOBRUN */
      temp = entropy->EOBRUN;
//             <    is written>: nbits
      nbits = 0;
//             <    is read   >: temp
//             <    is written>: temp
      while (temp >>= 1)
//             <    is read   >: nbits
//             <    is written>: nbits
         nbits++;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      emit_symbol(entropy, entropy->ac_tbl_no, nbits<<4);
//             <    is read   >: nbits
      if (nbits)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_bits(entropy, entropy->EOBRUN, nbits);
//             <    is read   >: entropy
//             <    is written>: entropy[0].EOBRUN

      entropy->EOBRUN = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      /* Emit any buffered correction bits */
      emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);
//             <    is read   >: entropy
//             <    is written>: entropy[0].BE
      entropy->BE = 0;
   }
}
static void emit_restart(phuff_entropy_ptr entropy, int restart_num)
{
   int ci;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   emit_eobrun(entropy);
//             <    is read   >: entropy entropy[0].gather_statistics

   if (!entropy->gather_statistics) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      flush_bits(entropy);
//             <    is read   >: entropy entropy[0].next_output_byte
//             <    is written>: entropy[0].next_output_byte 
//                               entropy[0].next_output_byte[0]
      *entropy->next_output_byte++ = (JOCTET) 0xFF;
//             <    is read   >: entropy entropy[0].free_in_buffer
//             <    is written>: entropy[0].free_in_buffer
      if (--entropy->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         dump_buffer(entropy);
//             <    is read   >: entropy entropy[0].next_output_byte 
//                               restart_num
//             <    is written>: entropy[0].next_output_byte 
//                               entropy[0].next_output_byte[0]
      *entropy->next_output_byte++ = (JOCTET) (0xD0+restart_num);
//             <    is read   >: entropy entropy[0].free_in_buffer
//             <    is written>: entropy[0].free_in_buffer
      if (--entropy->free_in_buffer==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         dump_buffer(entropy);
   }
//             <    is read   >: entropy entropy[0].cinfo 
//                               entropy[0].cinfo[0].Ss

   if (entropy->cinfo->Ss==0)
//             <    is read   >: entropy entropy[0].cinfo 
//                               entropy[0].cinfo[0].comps_in_scan
//             <    is written>: ci
      /* Re-initialize DC predictions to 0 */
      for(ci = 0; ci <= entropy->cinfo->comps_in_scan-1; ci += 1)
//             <    is read   >: ci entropy entropy[0].cinfo 
//                               entropy[0].cinfo[0].comps_in_scan
//             <    is written>: entropy[0].last_dc_val[ci]
         (entropy->last_dc_val)[ci] = 0;
   else {
//             <    is read   >: entropy
//             <    is written>: entropy[0].EOBRUN
      /* Re-initialize all AC-related fields to 0 */
      entropy->EOBRUN = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].BE
      entropy->BE = 0;
   }
}
static void emit_symbol(phuff_entropy_ptr entropy, int tbl_no, int symbol)
{
//             <    is read   >: entropy entropy[0].gather_statistics
   if (entropy->gather_statistics)
//             <    is read   >: entropy entropy[0].count_ptrs[tbl_no]
//                               entropy[0].count_ptrs[tbl_no] 
//                               entropy[0].count_ptrs[tbl_no][symbol]
//                               symbol tbl_no
//             <    is written>: entropy[0].count_ptrs[tbl_no][symbol]
      ((entropy->count_ptrs)[tbl_no])[symbol]++;
   else {
//             <    is read   >: entropy 
//                               entropy[0].derived_tbls[tbl_no] 
//                               tbl_no
//             <    is written>: tbl
      c_derived_tbl *tbl = (entropy->derived_tbls)[tbl_no];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_bits(entropy, (tbl->ehufco)[symbol], (tbl->ehufsi)[symbol]);
   }
}
static boolean encode_mcu_AC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   register int temp, temp2;
   register int nbits;
   register int r, k;
//             <    is read   >: cinfo cinfo[0].Se
//             <    is written>: Se
   int Se = cinfo->Se;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: Al
   int Al = cinfo->Al;
   JBLOCKROW block;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte 
//                               entropy
//             <    is written>: entropy[0].next_output_byte

   entropy->next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer 
//                               entropy
//             <    is written>: entropy[0].free_in_buffer
   entropy->free_in_buffer = cinfo->dest->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_restart(entropy, entropy->next_restart_num);
//             <    is read   >: MCU_data MCU_data[0]
//             <    is written>: block
   
   /* Encode the MCU data block */
   block = MCU_data[0];
//             <    is written>: r
   
   /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
   
   r = 0;
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: k
   /* r = run length of zeros */
   
   for(k = cinfo->Ss; k <= Se; k += 1) {
//             <    is read   >: Se block 
//                               block[0][jpeg_natural_order[k]] cinfo
//                               cinfo[0].Ss jpeg_natural_order[k] k
//             <    is written>: temp
      if ((temp = (*block)[jpeg_natural_order[k]])==0)
//             <    is read   >: Se cinfo cinfo[0].Ss r
//             <    is written>: r
         r++;
      else {
//             <    is read   >: Se cinfo cinfo[0].Ss temp
         /* We must apply the point transform by Al.  For AC coefficients this
              * is an integer division with rounding towards 0.  To do this portably
              * in C, we shift after obtaining the absolute value; so the code is
              * interwoven with finding the abs value (temp) and output bits (temp2).
              */
         if (temp<0) {
//             <    is read   >: Se cinfo cinfo[0].Ss temp
//             <    is written>: temp
            temp = -temp;
//             <    is read   >: Al Se cinfo cinfo[0].Ss temp
//             <    is written>: temp
            /* temp is abs value of input */
            temp >>= Al;
//             <    is read   >: Se cinfo cinfo[0].Ss temp
//             <    is written>: temp2
            /* apply the point transform */
            /* For a negative coef, want temp2 = bitwise complement of abs(coef) */
            temp2 = ~temp;
         }
         else {
//             <    is read   >: Al Se cinfo cinfo[0].Ss temp
//             <    is written>: temp
            temp >>= Al;
//             <    is read   >: Se cinfo cinfo[0].Ss temp
//             <    is written>: temp2
            /* apply the point transform */
            temp2 = temp;
         }
//             <    is read   >: Se cinfo cinfo[0].Ss temp
         /* Watch out for case that nonzero coef is zero after point transform */
         if (temp==0)
//             <    is read   >: Se cinfo cinfo[0].Ss r
//             <    is written>: r
            r++;
         else {
//             <    is read   >: Se cinfo cinfo[0].Ss entropy 
//                               entropy[0].EOBRUN
            
            /* Emit any pending EOBRUN */
            if (entropy->EOBRUN>0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               emit_eobrun(entropy);
//             <    is read   >: r
            /* if run length > 15, must emit special run-length-16 codes (0xF0) */
            while (r>15) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
//             <    is read   >: Se cinfo cinfo[0].Ss r
//             <    is written>: r
               r -= 16;
            }
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: nbits
            
            /* Find the number of bits needed for the magnitude of the coefficient */
            nbits = 1;
//             <    is read   >: temp
//             <    is written>: temp
            /* there must be at least one 1 bit */
            while (temp >>= 1)
//             <    is read   >: Se cinfo cinfo[0].Ss nbits
//             <    is written>: nbits
               nbits++;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            
            /* Count/emit Huffman symbol for run length / number of bits */
            emit_symbol(entropy, entropy->ac_tbl_no, (r<<4)+nbits);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            
            /* Emit that number of bits of the value, if positive, */
            /* or the complement of its magnitude, if negative. */
            emit_bits(entropy, (unsigned int) temp2, nbits);
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: r

            r = 0;
         }
      }
//             <    is read   >: Se cinfo cinfo[0].Ss
_loop_end_1:      ;
   }
//             <    is read   >: r

   if (r>0) {
//             <    is read   >: entropy entropy[0].EOBRUN
//             <    is written>: entropy[0].EOBRUN
      /* If there are trailing zeroes, */
      entropy->EOBRUN++;
//             <    is read   >: entropy entropy[0].EOBRUN
      /* count an EOB */
      if (entropy->EOBRUN==0x7FFF)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_eobrun(entropy);
   }
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte

   cinfo->dest->next_output_byte = entropy->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = entropy->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0) {
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
         entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num++;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num &= 7;
      }
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
      entropy->restarts_to_go--;
   }

   return 1;
}
static boolean encode_mcu_AC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   register int temp;
   register int r, k;
   int EOB;
   char *BR_buffer;
   unsigned int BR;
//             <    is read   >: cinfo cinfo[0].Se
//             <    is written>: Se
   int Se = cinfo->Se;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: Al
   int Al = cinfo->Al;
   JBLOCKROW block;
   int absvalues[64];
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte 
//                               entropy
//             <    is written>: entropy[0].next_output_byte

   entropy->next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer 
//                               entropy
//             <    is written>: entropy[0].free_in_buffer
   entropy->free_in_buffer = cinfo->dest->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_restart(entropy, entropy->next_restart_num);
//             <    is read   >: MCU_data MCU_data[0]
//             <    is written>: block
   
   /* Encode the MCU data block */
   block = MCU_data[0];
//             <    is written>: EOB
   
   /* It is convenient to make a pre-pass to determine the transformed
      * coefficients' absolute values and the EOB position.
      */
   EOB = 0;
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: k
   for(k = cinfo->Ss; k <= Se; k += 1) {
//             <    is read   >: Se block 
//                               block[0][jpeg_natural_order[k]] cinfo
//                               cinfo[0].Ss jpeg_natural_order[k] k
//             <    is written>: temp
      temp = (*block)[jpeg_natural_order[k]];
//             <    is read   >: Se cinfo cinfo[0].Ss temp
      /* We must apply the point transform by Al.  For AC coefficients this
           * is an integer division with rounding towards 0.  To do this portably
           * in C, we shift after obtaining the absolute value.
           */
      if (temp<0)
//             <    is read   >: Se cinfo cinfo[0].Ss temp
//             <    is written>: temp
         temp = -temp;
//             <    is read   >: Al Se cinfo cinfo[0].Ss temp
//             <    is written>: temp
      /* temp is abs value of input */
      temp >>= Al;
//             <    is read   >: Se cinfo cinfo[0].Ss k temp
//             <    is written>: absvalues[k]
      /* apply the point transform */
      absvalues[k] = temp;
//             <    is read   >: Se cinfo cinfo[0].Ss temp
      /* save abs value for main pass */
      if (temp==1)
//             <    is read   >: Se cinfo cinfo[0].Ss k
//             <    is written>: EOB
         EOB = k;
   }
//             <    is written>: r
   
   /* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
   
   r = 0;
//             <    is written>: BR
   /* r = run length of zeros */
   BR = 0;
//             <    is read   >: entropy entropy[0].BE 
//                               entropy[0].bit_buffer
//             <    is written>: BR_buffer
   /* BR = count of buffered bits added now */
   BR_buffer = entropy->bit_buffer+entropy->BE;
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: k
   /* Append bits to buffer */
   
   for(k = cinfo->Ss; k <= Se; k += 1) {
//             <    is read   >: Se absvalues[k] cinfo cinfo[0].Ss k
//             <    is written>: temp
      if ((temp = absvalues[k])==0)
//             <    is read   >: Se cinfo cinfo[0].Ss r
//             <    is written>: r
         r++;
      else {
//             <    is read   >: EOB k r
         
         /* Emit any required ZRLs, but not if they can be folded into EOB */
         while (r>15&&k<=EOB) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* emit any pending EOBRUN and the BE correction bits */
            emit_eobrun(entropy);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* Emit ZRL */
            emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
//             <    is read   >: Se cinfo cinfo[0].Ss r
//             <    is written>: r
            r -= 16;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* Emit buffered correction bits that must be associated with ZRL */
            emit_buffered_bits(entropy, BR_buffer, BR);
//             <    is read   >: Se cinfo cinfo[0].Ss entropy 
//                               entropy[0].bit_buffer
//             <    is written>: BR_buffer
            BR_buffer = entropy->bit_buffer;
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: BR
            /* BE bits are gone now */
            BR = 0;
         }
//             <    is read   >: Se cinfo cinfo[0].Ss temp
         
         /* If the coef was previously nonzero, it only needs a correction bit.
              * NOTE: a straight translation of the spec's figure G.7 would suggest
              * that we also need to test r > 15.  But if r > 15, we can only get here
              * if k > EOB, which implies that this coefficient is not 1.
              */
         if (temp>1)
//             <    is read   >: BR BR_buffer Se cinfo cinfo[0].Ss 
//                               temp
//             <    is written>: BR BR_buffer[BR++]
            /* The correction bit is the next bit of the absolute value. */
            BR_buffer[BR++] = (char) (temp&1);
         else {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            
            /* Emit any pending EOBRUN and the BE correction bits */
            emit_eobrun(entropy);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            
            /* Count/emit Huffman symbol for run length / number of bits */
            emit_symbol(entropy, entropy->ac_tbl_no, (r<<4)+1);
//             <    is read   >: Se block 
//                               block[0][jpeg_natural_order[k]] cinfo
//                               cinfo[0].Ss jpeg_natural_order[k] k
//             <    is written>: temp
            
            /* Emit output bit for newly-nonzero coef */
            temp = (*block)[jpeg_natural_order[k]]<0?0:1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            emit_bits(entropy, (unsigned int) temp, 1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            
            /* Emit buffered correction bits that must be associated with this code */
            emit_buffered_bits(entropy, BR_buffer, BR);
//             <    is read   >: Se cinfo cinfo[0].Ss entropy 
//                               entropy[0].bit_buffer
//             <    is written>: BR_buffer
            BR_buffer = entropy->bit_buffer;
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: BR
            /* BE bits are gone now */
            BR = 0;
//             <    is read   >: Se cinfo cinfo[0].Ss
//             <    is written>: r
            r = 0;
         }
      }
//             <    is read   >: Se cinfo cinfo[0].Ss
_loop_end_2:      ;
   }
//             <    is read   >: BR r

   if (r>0||BR>0) {
//             <    is read   >: entropy entropy[0].EOBRUN
//             <    is written>: entropy[0].EOBRUN
      /* If there are trailing zeroes, */
      entropy->EOBRUN++;
//             <    is read   >: BR entropy entropy[0].BE
//             <    is written>: entropy[0].BE
      /* count an EOB */
      entropy->BE += BR;
//             <    is read   >: entropy entropy[0].BE 
//                               entropy[0].EOBRUN
      /* concat my correction bits to older ones */
      /* We force out the EOB if we risk either:
           * 1. overflow of the EOB counter;
           * 2. overflow of the correction bit buffer during the next MCU.
           */
      if (entropy->EOBRUN==0x7FFF||entropy->BE>1000-64+1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_eobrun(entropy);
   }
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte

   cinfo->dest->next_output_byte = entropy->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = entropy->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0) {
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
         entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num++;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num &= 7;
      }
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
      entropy->restarts_to_go--;
   }

   return 1;
}
static boolean encode_mcu_DC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   register int temp, temp2;
   register int nbits;
   int blkn, ci;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: Al
   int Al = cinfo->Al;
   JBLOCKROW block;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte 
//                               entropy
//             <    is written>: entropy[0].next_output_byte
   
   
   entropy->next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer 
//                               entropy
//             <    is written>: entropy[0].free_in_buffer
   entropy->free_in_buffer = cinfo->dest->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_restart(entropy, entropy->next_restart_num);
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn
   
   /* Encode the MCU data blocks */
   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: MCU_data MCU_data[blkn] blkn cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: block
      block = MCU_data[blkn];
//             <    is read   >: blkn cinfo 
//                               cinfo[0].MCU_membership[blkn] 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: ci
      ci = (cinfo->MCU_membership)[blkn];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: Al block block[0][0] cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: temp2
      
      /* Compute the DC value after the required point transform by Al.
           * This is simply an arithmetic right shift.
           */
      temp2 = (int) (*block)[0]>>Al;
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               entropy entropy[0].last_dc_val[ci] 
//                               temp2
//             <    is written>: temp
      
      /* DC differences are figured on the point-transformed values. */
      temp = temp2-(entropy->last_dc_val)[ci];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               entropy temp2
//             <    is written>: entropy[0].last_dc_val[ci]
      (entropy->last_dc_val)[ci] = temp2;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU temp
//             <    is written>: temp2
      
      /* Encode the DC coefficient difference per section G.1.2.1 */
      temp2 = temp;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU temp
      if (temp<0) {
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU temp
//             <    is written>: temp
         temp = -temp;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU temp2
//             <    is written>: temp2
         /* temp is abs value of input */
         /* For a negative input, want temp2 = bitwise complement of abs(input) */
         /* This code assumes we are on a two's complement machine */
         temp2--;
      }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: nbits
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      nbits = 0;
//             <    is read   >: temp
      while (temp) {
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU nbits
//             <    is written>: nbits
         nbits++;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU temp
//             <    is written>: temp
         temp >>= 1;
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      /* Count/emit the Huffman-coded symbol for the number of bits */
      emit_symbol(entropy, compptr->dc_tbl_no, nbits);
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU nbits
      
      /* Emit that number of bits of the value, if positive, */
      /* or the complement of its magnitude, if negative. */
      if (nbits)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* emit_bits rejects calls with size 0 */
         emit_bits(entropy, (unsigned int) temp2, nbits);
   }
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte

   cinfo->dest->next_output_byte = entropy->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = entropy->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0) {
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
         entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num++;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num &= 7;
      }
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
      entropy->restarts_to_go--;
   }

   return 1;
}
static boolean encode_mcu_DC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   register int temp;
   int blkn;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: Al
   int Al = cinfo->Al;
   JBLOCKROW block;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte 
//                               entropy
//             <    is written>: entropy[0].next_output_byte

   entropy->next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer 
//                               entropy
//             <    is written>: entropy[0].free_in_buffer
   entropy->free_in_buffer = cinfo->dest->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         emit_restart(entropy, entropy->next_restart_num);
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn
   
   /* Encode the MCU data blocks */
   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: MCU_data MCU_data[blkn] blkn cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: block
      block = MCU_data[blkn];
//             <    is read   >: block block[0][0] cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: temp
      
      /* We simply emit the Al'th bit of the DC coefficient value. */
      temp = (*block)[0];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      emit_bits(entropy, (unsigned int) (temp>>Al), 1);
   }
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte

   cinfo->dest->next_output_byte = entropy->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = entropy->free_in_buffer;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0) {
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
         entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num++;
//             <    is read   >: entropy entropy[0].next_restart_num
//             <    is written>: entropy[0].next_restart_num
         entropy->next_restart_num &= 7;
      }
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
      entropy->restarts_to_go--;
   }

   return 1;
}
static void finish_pass_gather_phuff(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   boolean is_DC_band;
   int ci, tbl;
   jpeg_component_info *compptr;
   JHUFF_TBL **htblptr;
   boolean did[4];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Flush out buffered data (all we care about is counting the EOB symbol) */
   emit_eobrun(entropy);
//             <    is read   >: cinfo cinfo[0].Ss
//             <    is written>: is_DC_band
   is_DC_band = cinfo->Ss==0;
//             <may be written>: did[*]
   
   /* It's important not to apply jpeg_gen_optimal_table more than once
      * per table, because it clobbers the input frequency counts!
      */
   memset((void *) did, 0, (size_t) (size_t) sizeof(did));
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               is_DC_band
      if (is_DC_band) goto l99999;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no
//             <    is written>: tbl
      tbl = compptr->ac_tbl_no;
l99997:      ;
//             <    is read   >: cinfo cinfo[0].comps_in_scan did[tbl]
//                               tbl
      if (!did[tbl]) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               is_DC_band
         if (is_DC_band)
//             <    is read   >: cinfo cinfo[0].comps_in_scan tbl
//             <    is written>: htblptr
            htblptr = &(cinfo->dc_huff_tbl_ptrs)[tbl];
         else
//             <    is read   >: cinfo cinfo[0].comps_in_scan tbl
//             <    is written>: htblptr
            htblptr = &(cinfo->ac_huff_tbl_ptrs)[tbl];
//             <    is read   >: cinfo cinfo[0].comps_in_scan htblptr 
//                               htblptr[0]
         if (*htblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         jpeg_gen_optimal_table(cinfo, *htblptr, (entropy->count_ptrs)[tbl]);
//             <    is read   >: cinfo cinfo[0].comps_in_scan tbl
//             <    is written>: did[tbl]
         did[tbl] = 1;
      }
      goto _loop_end_1;
l99999:      ;
//             <    is read   >: cinfo cinfo[0].Ah 
//                               cinfo[0].comps_in_scan
      if (cinfo->Ah!=0) goto l99998;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: tbl
      tbl = compptr->dc_tbl_no;
      goto l99997;
l99998:      ;
      /* DC refinement needs no table */
      ;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
_loop_end_1:      ;
   }
}
static void finish_pass_phuff(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].next_output_byte 
//                               entropy
//             <    is written>: entropy[0].next_output_byte

   entropy->next_output_byte = cinfo->dest->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest 
//                               cinfo[0].dest[0].free_in_buffer 
//                               entropy
//             <    is written>: entropy[0].free_in_buffer
   entropy->free_in_buffer = cinfo->dest->free_in_buffer;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Flush out any buffered data */
   emit_eobrun(entropy);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   flush_bits(entropy);
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].next_output_byte
//             <    is written>: cinfo[0].dest[0].next_output_byte

   cinfo->dest->next_output_byte = entropy->next_output_byte;
//             <    is read   >: cinfo cinfo[0].dest entropy 
//                               entropy[0].free_in_buffer
//             <    is written>: cinfo[0].dest[0].free_in_buffer
   cinfo->dest->free_in_buffer = entropy->free_in_buffer;
}
static void flush_bits(phuff_entropy_ptr entropy)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   emit_bits(entropy, 0x7F, 7);
//             <    is read   >: entropy
//             <    is written>: entropy[0].put_buffer
   /* fill any partial byte with ones */
   entropy->put_buffer = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].put_bits
   /* and reset bit-buffer to empty */
   entropy->put_bits = 0;
}
static void start_pass_phuff(j_compress_ptr cinfo, boolean gather_statistics)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   boolean is_DC_band;
   int ci, tbl;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo entropy
//             <    is written>: entropy[0].cinfo

   entropy->cinfo = cinfo;
//             <    is read   >: entropy gather_statistics
//             <    is written>: entropy[0].gather_statistics
   entropy->gather_statistics = gather_statistics;
//             <    is read   >: cinfo cinfo[0].Ss
//             <    is written>: is_DC_band
   is_DC_band = cinfo->Ss==0;
//             <    is read   >: cinfo cinfo[0].Ah
   
   /* We assume jcmaster.c already validated the scan parameters. */
   
   /* Select execution routines */
   if (cinfo->Ah==0)
//             <    is read   >: is_DC_band
      if (is_DC_band)
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.encode_mcu
         entropy->pub.encode_mcu = encode_mcu_DC_first;
      else
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.encode_mcu
         entropy->pub.encode_mcu = encode_mcu_AC_first;
   else if (is_DC_band)
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.encode_mcu
      entropy->pub.encode_mcu = encode_mcu_DC_refine;
   else {
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.encode_mcu
      entropy->pub.encode_mcu = encode_mcu_AC_refine;
//             <    is read   >: entropy entropy[0].bit_buffer
      /* AC refinement needs a correction bit buffer */
      if (entropy->bit_buffer==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         entropy->bit_buffer = (char *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,1000*(size_t) sizeof(char));
   }
//             <    is read   >: gather_statistics
   if (gather_statistics)
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.finish_pass
      entropy->pub.finish_pass = finish_pass_gather_phuff;
   else
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.finish_pass
      entropy->pub.finish_pass = finish_pass_phuff;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
      * for AC coefficients.
      */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].last_dc_val[ci]
      /* Initialize DC predictions to 0 */
      (entropy->last_dc_val)[ci] = 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               is_DC_band
/* Make sure requested tables are present */
/* (In gather mode, tables need not be allocated yet) */
      if (is_DC_band) goto l99999;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no entropy
//             <    is written>: entropy[0].ac_tbl_no tbl
      entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].ac_huff_tbl_ptrs[tbl] 
//                               cinfo[0].comps_in_scan 
//                               gather_statistics tbl
      if (tbl<0||tbl>=4||(cinfo->ac_huff_tbl_ptrs)[tbl]==(void *) 0&&!gather_statistics)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = tbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
l99997:      ;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               gather_statistics
      if (gather_statistics) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan entropy 
//                               entropy[0].count_ptrs[tbl] tbl
         /* Allocate and zero the statistics tables */
         /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
         if ((entropy->count_ptrs)[tbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (entropy->count_ptrs)[tbl] = (long int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,257*(size_t) sizeof(long int));
//             <may be written>: entropy[0].count_ptrs[tbl][*]
//             <    is read   >: cinfo cinfo[0].comps_in_scan entropy 
//                               entropy[0].count_ptrs[tbl] tbl
         memset((void *) (entropy->count_ptrs)[tbl], 0, (size_t) (257*(size_t) sizeof(long int)));
      }
      else
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               is_DC_band
         /* Compute derived values for Huffman tables */
         /* We may do this more than once for a table, but it's not expensive */
         if (is_DC_band)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

            jpeg_make_c_derived_tbl(cinfo, (cinfo->dc_huff_tbl_ptrs)[tbl], &(entropy->derived_tbls)[tbl]);
         else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

            jpeg_make_c_derived_tbl(cinfo, (cinfo->ac_huff_tbl_ptrs)[tbl], &(entropy->derived_tbls)[tbl]);
      goto _loop_end_1;
l99999:      ;
//             <    is read   >: cinfo cinfo[0].Ah 
//                               cinfo[0].comps_in_scan
      if (cinfo->Ah!=0) goto l99998;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: tbl
      tbl = compptr->dc_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].dc_huff_tbl_ptrs[tbl] 
//                               gather_statistics tbl
      if (tbl<0||tbl>=4||(cinfo->dc_huff_tbl_ptrs)[tbl]==(void *) 0&&!gather_statistics)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = tbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      goto l99997;
l99998:      ;
      /* DC refinement needs no table */
      ;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
_loop_end_1:      ;
   }
//             <    is read   >: entropy
//             <    is written>: entropy[0].EOBRUN
   
   /* Initialize AC stuff */
   entropy->EOBRUN = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].BE
   entropy->BE = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].put_buffer
   
   /* Initialize bit buffer to empty */
   entropy->put_buffer = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].put_bits
   entropy->put_bits = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
   
   /* Initialize restart stuff */
   entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy
//             <    is written>: entropy[0].next_restart_num
   entropy->next_restart_num = 0;
}
static void create_context_buffer(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].prep
//             <    is written>: prep
   my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor
//             <    is written>: rgroup_height
   int rgroup_height = cinfo->max_v_samp_factor;
   int ci, i;
   jpeg_component_info *compptr;
   JSAMPARRAY true_buffer, fake_buffer;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Grab enough space for fake row pointers for all the components;
      * we need five row groups' worth of pointers for each component.
      */
   
   fake_buffer = (JSAMPARRAY) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,cinfo->num_components*5*rgroup_height*(size_t) sizeof(JSAMPROW));
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Allocate the actual buffer space (3 row groups) for this component.
           * We make the buffer wide enough to allow the downsampler to edge-expand
           * horizontally within the buffer, if it so chooses.
           */
      true_buffer = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,(JDIMENSION) ((long int) compptr->width_in_blocks*8*cinfo->max_h_samp_factor/(compptr->h_samp_factor)),(JDIMENSION) (3*rgroup_height));
//             <may be read   >: true_buffer[*] true_buffer[*][*]
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: cinfo cinfo[0].num_components 
//                               fake_buffer rgroup_height true_buffer
      /* Copy true buffer row pointers into the middle of the fake row array */
      memcpy((void *) (fake_buffer+rgroup_height), (void *) true_buffer, (size_t) (3*rgroup_height*(size_t) sizeof(JSAMPROW)));
//             <    is read   >: cinfo cinfo[0].num_components 
//                               rgroup_height
//             <    is written>: i
      /* Fill in the above and below wraparound pointers */
      for(i = 0; i <= rgroup_height-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].num_components 
//                               fake_buffer i rgroup_height 
//                               true_buffer 
//                               true_buffer[2*rgroup_height+i]
//             <    is written>: fake_buffer[i]
         fake_buffer[i] = true_buffer[2*rgroup_height+i];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               fake_buffer i rgroup_height 
//                               true_buffer true_buffer[i]
//             <    is written>: fake_buffer[4*rgroup_height+i]
         fake_buffer[4*rgroup_height+i] = true_buffer[i];
      }
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               fake_buffer prep rgroup_height
//             <    is written>: prep[0].color_buf[ci]
      (prep->color_buf)[ci] = fake_buffer+rgroup_height;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               fake_buffer rgroup_height
//             <    is written>: fake_buffer
      fake_buffer += 5*rgroup_height;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void expand_bottom_edge(JSAMPARRAY image_data, JDIMENSION num_cols, int input_rows, int output_rows)
{
   register int row;
//             <    is read   >: input_rows output_rows
//             <    is written>: row

   for(row = input_rows; row <= output_rows-1; row += 1)
//             <may be read   >: image_data[0] image_data[0]
//             <    is read   >: image_data input_rows num_cols 
//                               output_rows row

      jcopy_sample_rows(image_data, input_rows-1, image_data, row, 1, num_cols);
}
static void pre_process_context(j_compress_ptr cinfo, JSAMPARRAY input_buf, JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail, JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr, JDIMENSION out_row_groups_avail)
{
//             <    is read   >: cinfo cinfo[0].prep
//             <    is written>: prep
   my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
   int numrows, ci;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor
//             <    is written>: buf_height
   int buf_height = cinfo->max_v_samp_factor*3;
   JDIMENSION inrows;
l99998:   ;
//             <    is read   >: out_row_group_ctr 
//                               out_row_group_ctr[0] 
//                               out_row_groups_avail

   if (!(*out_row_group_ctr<out_row_groups_avail)) goto _break_1;
//             <    is read   >: in_row_ctr in_row_ctr[0] 
//                               in_rows_avail
   if (*in_row_ctr<in_rows_avail) goto l99999;
//             <    is read   >: prep prep[0].rows_to_go
/* Return for more data, unless we are at the bottom of the image. */
   if (prep->rows_to_go!=0) goto _break_1;
//             <    is read   >: prep prep[0].next_buf_row 
//                               prep[0].next_buf_stop
   /* When at bottom of image, pad to fill the conversion buffer. */
   if (prep->next_buf_row<prep->next_buf_stop) {
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*

         expand_bottom_edge((prep->color_buf)[ci], cinfo->image_width, prep->next_buf_row, prep->next_buf_stop);
//             <    is read   >: prep prep[0].next_buf_stop
//             <    is written>: prep[0].next_buf_row
      prep->next_buf_row = prep->next_buf_stop;
   }
l99997:   ;
//             <    is read   >: prep prep[0].next_buf_row 
//                               prep[0].next_buf_stop
   /* If we've gotten enough data, downsample a row group. */
   if (prep->next_buf_row==prep->next_buf_stop) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      (*cinfo->downsample->downsample)(cinfo,prep->color_buf,(JDIMENSION) prep->this_row_group,output_buf,*out_row_group_ctr);
//             <    is read   >: out_row_group_ctr 
//                               out_row_group_ctr[0]
//             <    is written>: out_row_group_ctr[0]
      (*out_row_group_ctr)++;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//                               prep[0].this_row_group
//             <    is written>: prep[0].this_row_group
      /* Advance pointers with wraparound as necessary. */
      prep->this_row_group += cinfo->max_v_samp_factor;
//             <    is read   >: buf_height prep 
//                               prep[0].this_row_group
      if (prep->this_row_group>=buf_height)
//             <    is read   >: prep
//             <    is written>: prep[0].this_row_group
         prep->this_row_group = 0;
//             <    is read   >: buf_height prep prep[0].next_buf_row
      if (prep->next_buf_row>=buf_height)
//             <    is read   >: prep
//             <    is written>: prep[0].next_buf_row
         prep->next_buf_row = 0;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//                               prep[0].next_buf_row
//             <    is written>: prep[0].next_buf_stop
      prep->next_buf_stop = prep->next_buf_row+cinfo->max_v_samp_factor;
   }
   goto l99998;
l99999:   ;
//             <    is read   >: in_row_ctr in_row_ctr[0] 
//                               in_rows_avail
//             <    is written>: inrows
   /* Do color conversion to fill the conversion buffer. */
   inrows = in_rows_avail-*in_row_ctr;
//             <    is read   >: prep prep[0].next_buf_row 
//                               prep[0].next_buf_stop
//             <    is written>: numrows
   numrows = prep->next_buf_stop-prep->next_buf_row;
//             <    is read   >: inrows numrows
//             <    is written>: numrows
   numrows = (int) ((JDIMENSION) numrows<inrows?(JDIMENSION) numrows:inrows);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   
   (*cinfo->cconvert->color_convert)(cinfo,input_buf+*in_row_ctr,prep->color_buf,(JDIMENSION) prep->next_buf_row,numrows);
//             <    is read   >: cinfo cinfo[0].image_height prep 
//                               prep[0].rows_to_go
   /* Pad at top of image, if first time through */
   if (prep->rows_to_go==cinfo->image_height)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
         int row;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components
//             <    is written>: row
         for(row = 1; row <= cinfo->max_v_samp_factor; row += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
            
            
            jcopy_sample_rows((prep->color_buf)[ci], 0, (prep->color_buf)[ci], -row, 1, cinfo->image_width);
      }
//             <    is read   >: in_row_ctr in_row_ctr[0] numrows
//             <    is written>: in_row_ctr[0]
   *in_row_ctr += numrows;
//             <    is read   >: numrows prep prep[0].next_buf_row
//             <    is written>: prep[0].next_buf_row
   prep->next_buf_row += numrows;
//             <    is read   >: numrows prep prep[0].rows_to_go
//             <    is written>: prep[0].rows_to_go
   prep->rows_to_go -= numrows;
   goto l99997;
_break_1:   ;
}
static void pre_process_data(j_compress_ptr cinfo, JSAMPARRAY input_buf, JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail, JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr, JDIMENSION out_row_groups_avail)
{
//             <    is read   >: cinfo cinfo[0].prep
//             <    is written>: prep
   my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
   int numrows, ci;
   JDIMENSION inrows;
   jpeg_component_info *compptr;
l99999:   ;
//             <    is read   >: in_row_ctr in_row_ctr[0] 
//                               in_rows_avail out_row_group_ctr 
//                               out_row_group_ctr[0] 
//                               out_row_groups_avail


   if (!(*in_row_ctr<in_rows_avail&&*out_row_group_ctr<out_row_groups_avail)) goto _break_1;
//             <    is read   >: in_row_ctr in_row_ctr[0] 
//                               in_rows_avail
//             <    is written>: inrows
   /* Do color conversion to fill the conversion buffer. */
   inrows = in_rows_avail-*in_row_ctr;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//                               prep[0].next_buf_row
//             <    is written>: numrows
   numrows = cinfo->max_v_samp_factor-prep->next_buf_row;
//             <    is read   >: inrows numrows
//             <    is written>: numrows
   numrows = (int) ((JDIMENSION) numrows<inrows?(JDIMENSION) numrows:inrows);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   
   (*cinfo->cconvert->color_convert)(cinfo,input_buf+*in_row_ctr,prep->color_buf,(JDIMENSION) prep->next_buf_row,numrows);
//             <    is read   >: in_row_ctr in_row_ctr[0] numrows
//             <    is written>: in_row_ctr[0]
   *in_row_ctr += numrows;
//             <    is read   >: numrows prep prep[0].next_buf_row
//             <    is written>: prep[0].next_buf_row
   prep->next_buf_row += numrows;
//             <    is read   >: numrows prep prep[0].rows_to_go
//             <    is written>: prep[0].rows_to_go
   prep->rows_to_go -= numrows;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//                               prep[0].next_buf_row 
//                               prep[0].rows_to_go
   /* If at bottom of image, pad to fill the conversion buffer. */
   
   if (prep->rows_to_go==0&&prep->next_buf_row<cinfo->max_v_samp_factor) {
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*

         expand_bottom_edge((prep->color_buf)[ci], cinfo->image_width, prep->next_buf_row, cinfo->max_v_samp_factor);
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//             <    is written>: prep[0].next_buf_row
      prep->next_buf_row = cinfo->max_v_samp_factor;
   }
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//                               prep[0].next_buf_row
   /* If we've filled the conversion buffer, empty it. */
   if (prep->next_buf_row==cinfo->max_v_samp_factor) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      (*cinfo->downsample->downsample)(cinfo,prep->color_buf,(JDIMENSION) 0,output_buf,*out_row_group_ctr);
//             <    is read   >: prep
//             <    is written>: prep[0].next_buf_row
      prep->next_buf_row = 0;
//             <    is read   >: out_row_group_ctr 
//                               out_row_group_ctr[0]
//             <    is written>: out_row_group_ctr[0]
      (*out_row_group_ctr)++;
   }
//             <    is read   >: out_row_group_ctr 
//                               out_row_group_ctr[0] 
//                               out_row_groups_avail prep 
//                               prep[0].rows_to_go
/* If at bottom of image, pad the output to a full iMCU height.
     * Note we assume the caller is providing a one-iMCU-height output buffer!
     */

   if (prep->rows_to_go==0&&*out_row_group_ctr<out_row_groups_avail) {
   }
   else {
      goto l99999;
   }
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: output_buf[ci][0]
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               compptr compptr[0].v_samp_factor 
//                               compptr[0].v_samp_factor 
//                               compptr[0].width_in_blocks 
//                               out_row_group_ctr 
//                               out_row_group_ctr[0] 
//                               out_row_groups_avail output_buf 
//                               output_buf[ci]
      expand_bottom_edge(output_buf[ci], compptr->width_in_blocks*8, (int) (*out_row_group_ctr*compptr->v_samp_factor), (int) (out_row_groups_avail*compptr->v_samp_factor));
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: out_row_group_ctr 
//                               out_row_groups_avail
//             <    is written>: out_row_group_ctr[0]
   *out_row_group_ctr = out_row_groups_avail;
_break_1:   ;
}
static void start_pass_prep(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
//             <    is read   >: cinfo cinfo[0].prep
//             <    is written>: prep
   my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
//             <    is read   >: pass_mode

   if (pass_mode!=JBUF_PASS_THRU)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_height prep
//             <    is written>: prep[0].rows_to_go
   
   /* Initialize total-height counter for detecting bottom of image */
   prep->rows_to_go = cinfo->image_height;
//             <    is read   >: prep
//             <    is written>: prep[0].next_buf_row
   /* Mark the conversion buffer empty */
   prep->next_buf_row = 0;
//             <    is read   >: prep
//             <    is written>: prep[0].this_row_group
   
   /* Preset additional state variables for context mode.
      * These aren't used in non-context mode, so we needn't test which mode.
      */
   prep->this_row_group = 0;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor prep
//             <    is written>: prep[0].next_buf_stop
   /* Set next_buf_stop to stop after two row groups have been read in. */
   prep->next_buf_stop = 2*cinfo->max_v_samp_factor;
}
static void expand_right_edge(JSAMPARRAY image_data, int num_rows, JDIMENSION input_cols, JDIMENSION output_cols)
{
   register JSAMPROW ptr;
   register JSAMPLE pixval;
   register int count;
   int row;
//             <    is read   >: input_cols output_cols
//             <    is written>: numcols
   int numcols = (int) (output_cols-input_cols);
//             <    is read   >: numcols

   if (numcols>0)
//             <    is read   >: num_rows
//             <    is written>: row
      for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: image_data image_data[row] input_cols
//                               num_rows row
//             <    is written>: ptr
         ptr = image_data[row]+input_cols;
//             <    is read   >: num_rows ptr ptr[-1]
//             <    is written>: pixval
         pixval = ptr[-1];
//             <    is read   >: num_rows numcols
//             <    is written>: count
         /* don't need GETJSAMPLE() here */
         for(count = numcols; count >= 1; count += -1)
//             <    is read   >: num_rows numcols pixval ptr
//             <    is written>: ptr ptr[0]
            *ptr++ = pixval;
      }
}
static void fullsize_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY output_data)
{
//             <may be read   >: input_data[0] output_data[0]
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_v_samp_factor input_data
//                               output_data
   /* Copy the data */
   
   jcopy_sample_rows(input_data, 0, output_data, 0, cinfo->max_v_samp_factor, cinfo->image_width);
//             <may be read   >: output_data[*]
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_v_samp_factor compptr 
//                               compptr[0].width_in_blocks 
//                               output_data
   /* Edge-expand */
   
   expand_right_edge(output_data, cinfo->max_v_samp_factor, cinfo->image_width, compptr->width_in_blocks*8);
}
static void fullsize_smooth_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY output_data)
{
   int outrow;
   JDIMENSION colctr;
//             <    is read   >: compptr compptr[0].width_in_blocks
//             <    is written>: output_cols
   JDIMENSION output_cols = compptr->width_in_blocks*8;
   register JSAMPROW inptr, above_ptr, below_ptr, outptr;
   INT32 membersum, neighsum, memberscale, neighscale;
   int colsum, lastcolsum, nextcolsum;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Expand input data enough to let all the output samples be generated
      * by the standard loop.  Special-casing padded output would be more
      * efficient.
      */
   
   expand_right_edge(input_data-1, cinfo->max_v_samp_factor+2, cinfo->image_width, output_cols);
//             <    is read   >: cinfo cinfo[0].smoothing_factor
//             <    is written>: memberscale
   
   /* Each of the eight neighbor pixels contributes a fraction SF to the
      * smoothed pixel, while the main pixel contributes (1-8*SF).  In order
      * to use integer arithmetic, these factors are multiplied by 2^16 = 65536.
      * Also recall that SF = smoothing_factor / 1024.
      */
   
   memberscale = 65536L-cinfo->smoothing_factor*512L;
//             <    is read   >: cinfo cinfo[0].smoothing_factor
//             <    is written>: neighscale
   /* scaled 1-8*SF */
   neighscale = cinfo->smoothing_factor*64;
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: outrow
   /* scaled SF */
   
   for(outrow = 0; outrow <= compptr->v_samp_factor-1; outrow += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[outrow] outrow
//             <    is written>: inptr
      inptr = input_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[outrow-1] 
//                               outrow
//             <    is written>: above_ptr
      above_ptr = input_data[outrow-1];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[outrow+1] 
//                               outrow
//             <    is written>: below_ptr
      below_ptr = input_data[outrow+1];
//             <    is read   >: above_ptr above_ptr[0] below_ptr 
//                               below_ptr[0] compptr 
//                               compptr[0].v_samp_factor inptr 
//                               inptr[0]
//             <    is written>: above_ptr below_ptr colsum
      
      /* Special case for first column */
      colsum = (int) *above_ptr++ +(int) *below_ptr++ +(int) *inptr;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr inptr[0]
//             <    is written>: inptr membersum
      membersum = (int) *inptr++;
//             <    is read   >: above_ptr above_ptr[0] below_ptr 
//                               below_ptr[0] compptr 
//                               compptr[0].v_samp_factor inptr 
//                               inptr[0]
//             <    is written>: nextcolsum
      nextcolsum = (int) *above_ptr+(int) *below_ptr+(int) *inptr;
//             <    is read   >: colsum compptr 
//                               compptr[0].v_samp_factor membersum 
//                               nextcolsum
//             <    is written>: neighsum
      neighsum = colsum+(colsum-membersum)+nextcolsum;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               memberscale membersum neighscale 
//                               neighsum
//             <    is written>: membersum
      membersum = membersum*memberscale+neighsum*neighscale;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               membersum outptr
//             <    is written>: outptr outptr[0]
      *outptr++ = (JSAMPLE) (membersum+32768>>16);
//             <    is read   >: colsum compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: lastcolsum
      lastcolsum = colsum;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               nextcolsum
//             <    is written>: colsum
      colsum = nextcolsum;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols
//             <    is written>: colctr

      for(colctr = output_cols-2; colctr >= 1; colctr += -1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr inptr[0] output_cols
//             <    is written>: inptr membersum
         membersum = (int) *inptr++;
//             <    is read   >: above_ptr compptr 
//                               compptr[0].v_samp_factor output_cols
//             <    is written>: above_ptr
         above_ptr++;
//             <    is read   >: below_ptr compptr 
//                               compptr[0].v_samp_factor output_cols
//             <    is written>: below_ptr
         below_ptr++;
//             <    is read   >: above_ptr above_ptr[0] below_ptr 
//                               below_ptr[0] compptr 
//                               compptr[0].v_samp_factor inptr 
//                               inptr[0] output_cols
//             <    is written>: nextcolsum
         nextcolsum = (int) *above_ptr+(int) *below_ptr+(int) *inptr;
//             <    is read   >: colsum compptr 
//                               compptr[0].v_samp_factor lastcolsum 
//                               membersum nextcolsum output_cols
//             <    is written>: neighsum
         neighsum = lastcolsum+(colsum-membersum)+nextcolsum;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               memberscale membersum neighscale 
//                               neighsum output_cols
//             <    is written>: membersum
         membersum = membersum*memberscale+neighsum*neighscale;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               membersum outptr output_cols
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) (membersum+32768>>16);
//             <    is read   >: colsum compptr 
//                               compptr[0].v_samp_factor output_cols
//             <    is written>: lastcolsum
         lastcolsum = colsum;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               nextcolsum output_cols
//             <    is written>: colsum
         colsum = nextcolsum;
      }
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr inptr[0]
//             <    is written>: membersum
      
      /* Special case for last column */
      membersum = (int) *inptr;
//             <    is read   >: colsum compptr 
//                               compptr[0].v_samp_factor lastcolsum 
//                               membersum
//             <    is written>: neighsum
      neighsum = lastcolsum+(colsum-membersum)+colsum;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               memberscale membersum neighscale 
//                               neighsum
//             <    is written>: membersum
      membersum = membersum*memberscale+neighsum*neighscale;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               membersum outptr
//             <    is written>: outptr[0]
      *outptr = (JSAMPLE) (membersum+32768>>16);
   }
}
static void h2v1_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY output_data)
{
   int outrow;
   JDIMENSION outcol;
//             <    is read   >: compptr compptr[0].width_in_blocks
//             <    is written>: output_cols
   JDIMENSION output_cols = compptr->width_in_blocks*8;
   register JSAMPROW inptr, outptr;
   register int bias;
//             <may be read   >: input_data[*]
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_v_samp_factor input_data
//                               output_cols
   
   /* Expand input data enough to let all the output samples be generated
      * by the standard loop.  Special-casing padded output would be more
      * efficient.
      */
   
   expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width, output_cols*2);
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: outrow

   for(outrow = 0; outrow <= compptr->v_samp_factor-1; outrow += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[outrow] outrow
//             <    is written>: inptr
      inptr = input_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: bias
      bias = 0;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols
//             <    is written>: outcol
      /* bias = 0,1,0,1,... for successive samples */
      for(outcol = 0; outcol <= output_cols-1; outcol += 1) {
//             <    is read   >: bias compptr compptr[0].v_samp_factor
//                               inptr inptr[0] inptr[1] outptr 
//                               output_cols
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) ((int) *inptr+(int) inptr[1]+bias>>1);
//             <    is read   >: bias compptr compptr[0].v_samp_factor
//                               output_cols
//             <    is written>: bias
         bias ^= 1;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr output_cols
//             <    is written>: inptr
         /* 0=>1, 1=>0 */
         inptr += 2;
      }
   }
}
static void h2v2_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY output_data)
{
   int inrow, outrow;
   JDIMENSION outcol;
//             <    is read   >: compptr compptr[0].width_in_blocks
//             <    is written>: output_cols
   JDIMENSION output_cols = compptr->width_in_blocks*8;
   register JSAMPROW inptr0, inptr1, outptr;
   register int bias;
//             <may be read   >: input_data[*]
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_v_samp_factor input_data
//                               output_cols
   
   /* Expand input data enough to let all the output samples be generated
      * by the standard loop.  Special-casing padded output would be more
      * efficient.
      */
   
   expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width, output_cols*2);
//             <    is written>: inrow

   inrow = 0;
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: outrow
   for(outrow = 0; outrow <= compptr->v_samp_factor-1; outrow += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow] inrow
//             <    is written>: inptr0
      inptr0 = input_data[inrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow+1] inrow
//             <    is written>: inptr1
      inptr1 = input_data[inrow+1];
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: bias
      bias = 1;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols
//             <    is written>: outcol
      /* bias = 1,2,1,2,... for successive samples */
      for(outcol = 0; outcol <= output_cols-1; outcol += 1) {
//             <    is read   >: bias compptr compptr[0].v_samp_factor
//                               inptr0 inptr0[0] inptr0[1] inptr1 
//                               inptr1[0] inptr1[1] outptr 
//                               output_cols
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) ((int) *inptr0+(int) inptr0[1]+(int) *inptr1+(int) inptr1[1]+bias>>2);
//             <    is read   >: bias compptr compptr[0].v_samp_factor
//                               output_cols
//             <    is written>: bias
         bias ^= 3;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr0 output_cols
//             <    is written>: inptr0
         /* 1=>2, 2=>1 */
         inptr0 += 2;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr1 output_cols
//             <    is written>: inptr1
         inptr1 += 2;
      }
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inrow
//             <    is written>: inrow
      inrow += 2;
   }
}
static void h2v2_smooth_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY output_data)
{
   int inrow, outrow;
   JDIMENSION colctr;
//             <    is read   >: compptr compptr[0].width_in_blocks
//             <    is written>: output_cols
   JDIMENSION output_cols = compptr->width_in_blocks*8;
   register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
   INT32 membersum, neighsum, memberscale, neighscale;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Expand input data enough to let all the output samples be generated
      * by the standard loop.  Special-casing padded output would be more
      * efficient.
      */
   
   expand_right_edge(input_data-1, cinfo->max_v_samp_factor+2, cinfo->image_width, output_cols*2);
//             <    is read   >: cinfo cinfo[0].smoothing_factor
//             <    is written>: memberscale
   
   /* We don't bother to form the individual "smoothed" input pixel values;
      * we can directly compute the output which is the average of the four
      * smoothed values.  Each of the four member pixels contributes a fraction
      * (1-8*SF) to its own smoothed image and a fraction SF to each of the three
      * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
      * output.  The four corner-adjacent neighbor pixels contribute a fraction
      * SF to just one smoothed pixel, or SF/4 to the final output; while the
      * eight edge-adjacent neighbors contribute SF to each of two smoothed
      * pixels, or SF/2 overall.  In order to use integer arithmetic, these
      * factors are scaled by 2^16 = 65536.
      * Also recall that SF = smoothing_factor / 1024.
      */
   
   memberscale = 16384-cinfo->smoothing_factor*80;
//             <    is read   >: cinfo cinfo[0].smoothing_factor
//             <    is written>: neighscale
   /* scaled (1-5*SF)/4 */
   neighscale = cinfo->smoothing_factor*16;
//             <    is written>: inrow
   /* scaled SF/4 */
   
   inrow = 0;
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: outrow
   for(outrow = 0; outrow <= compptr->v_samp_factor-1; outrow += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow] inrow
//             <    is written>: inptr0
      inptr0 = input_data[inrow];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow+1] inrow
//             <    is written>: inptr1
      inptr1 = input_data[inrow+1];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow-1] inrow
//             <    is written>: above_ptr
      above_ptr = input_data[inrow-1];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow+2] inrow
//             <    is written>: below_ptr
      below_ptr = input_data[inrow+2];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr0 inptr0[0] inptr0[1] inptr1 
//                               inptr1[0] inptr1[1]
//             <    is written>: membersum
      
      /* Special case for first column: pretend column -1 is same as column 0 */
      membersum = (int) *inptr0+(int) inptr0[1]+(int) *inptr1+(int) inptr1[1];
//             <    is read   >: above_ptr above_ptr[0] above_ptr[1] 
//                               below_ptr below_ptr[0] below_ptr[1] 
//                               compptr compptr[0].v_samp_factor 
//                               inptr0 inptr0[0] inptr0[2] inptr1 
//                               inptr1[0] inptr1[2]
//             <    is written>: neighsum
      neighsum = (int) *above_ptr+(int) above_ptr[1]+(int) *below_ptr+(int) below_ptr[1]+(int) *inptr0+(int) inptr0[2]+(int) *inptr1+(int) inptr1[2];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               neighsum
//             <    is written>: neighsum
      neighsum += neighsum;
//             <    is read   >: above_ptr above_ptr[0] above_ptr[2] 
//                               below_ptr below_ptr[0] below_ptr[2] 
//                               compptr compptr[0].v_samp_factor 
//                               neighsum
//             <    is written>: neighsum
      neighsum += (int) *above_ptr+(int) above_ptr[2]+(int) *below_ptr+(int) below_ptr[2];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               memberscale membersum neighscale 
//                               neighsum
//             <    is written>: membersum
      membersum = membersum*memberscale+neighsum*neighscale;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               membersum outptr
//             <    is written>: outptr outptr[0]
      *outptr++ = (JSAMPLE) (membersum+32768>>16);
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr0
//             <    is written>: inptr0
      inptr0 += 2;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr1
//             <    is written>: inptr1
      inptr1 += 2;
//             <    is read   >: above_ptr compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: above_ptr
      above_ptr += 2;
//             <    is read   >: below_ptr compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: below_ptr
      below_ptr += 2;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols
//             <    is written>: colctr

      for(colctr = output_cols-2; colctr >= 1; colctr += -1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr0 inptr0[0] inptr0[1] inptr1 
//                               inptr1[0] inptr1[1] output_cols
//             <    is written>: membersum
         /* sum of pixels directly mapped to this output element */
         membersum = (int) *inptr0+(int) inptr0[1]+(int) *inptr1+(int) inptr1[1];
//             <    is read   >: above_ptr above_ptr[0] above_ptr[1] 
//                               below_ptr below_ptr[0] below_ptr[1] 
//                               compptr compptr[0].v_samp_factor 
//                               inptr0 inptr0[-1] inptr0[2] inptr1 
//                               inptr1[-1] inptr1[2] output_cols
//             <    is written>: neighsum
         /* sum of edge-neighbor pixels */
         neighsum = (int) *above_ptr+(int) above_ptr[1]+(int) *below_ptr+(int) below_ptr[1]+(int) inptr0[-1]+(int) inptr0[2]+(int) inptr1[-1]+(int) inptr1[2];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               neighsum output_cols
//             <    is written>: neighsum
         /* The edge-neighbors count twice as much as corner-neighbors */
         neighsum += neighsum;
//             <    is read   >: above_ptr above_ptr[-1] above_ptr[2] 
//                               below_ptr below_ptr[-1] below_ptr[2] 
//                               compptr compptr[0].v_samp_factor 
//                               neighsum output_cols
//             <    is written>: neighsum
         /* Add in the corner-neighbors */
         neighsum += (int) above_ptr[-1]+(int) above_ptr[2]+(int) below_ptr[-1]+(int) below_ptr[2];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               memberscale membersum neighscale 
//                               neighsum output_cols
//             <    is written>: membersum
         /* form final output scaled up by 2^16 */
         membersum = membersum*memberscale+neighsum*neighscale;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               membersum outptr output_cols
//             <    is written>: outptr outptr[0]
         /* round, descale and output it */
         *outptr++ = (JSAMPLE) (membersum+32768>>16);
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr0 output_cols
//             <    is written>: inptr0
         inptr0 += 2;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr1 output_cols
//             <    is written>: inptr1
         inptr1 += 2;
//             <    is read   >: above_ptr compptr 
//                               compptr[0].v_samp_factor output_cols
//             <    is written>: above_ptr
         above_ptr += 2;
//             <    is read   >: below_ptr compptr 
//                               compptr[0].v_samp_factor output_cols
//             <    is written>: below_ptr
         below_ptr += 2;
      }
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inptr0 inptr0[0] inptr0[1] inptr1 
//                               inptr1[0] inptr1[1]
//             <    is written>: membersum
      
      /* Special case for last column */
      membersum = (int) *inptr0+(int) inptr0[1]+(int) *inptr1+(int) inptr1[1];
//             <    is read   >: above_ptr above_ptr[0] above_ptr[1] 
//                               below_ptr below_ptr[0] below_ptr[1] 
//                               compptr compptr[0].v_samp_factor 
//                               inptr0 inptr0[-1] inptr0[1] inptr1 
//                               inptr1[-1] inptr1[1]
//             <    is written>: neighsum
      neighsum = (int) *above_ptr+(int) above_ptr[1]+(int) *below_ptr+(int) below_ptr[1]+(int) inptr0[-1]+(int) inptr0[1]+(int) inptr1[-1]+(int) inptr1[1];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               neighsum
//             <    is written>: neighsum
      neighsum += neighsum;
//             <    is read   >: above_ptr above_ptr[-1] above_ptr[1] 
//                               below_ptr below_ptr[-1] below_ptr[1] 
//                               compptr compptr[0].v_samp_factor 
//                               neighsum
//             <    is written>: neighsum
      neighsum += (int) above_ptr[-1]+(int) above_ptr[1]+(int) below_ptr[-1]+(int) below_ptr[1];
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               memberscale membersum neighscale 
//                               neighsum
//             <    is written>: membersum
      membersum = membersum*memberscale+neighsum*neighscale;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               membersum outptr
//             <    is written>: outptr[0]
      *outptr = (JSAMPLE) (membersum+32768>>16);
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inrow
//             <    is written>: inrow

      inrow += 2;
   }
}
static void int_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY output_data)
{
   int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;
   JDIMENSION outcol, outcol_h;
   /* outcol_h == outcol*h_expand */
//             <    is read   >: compptr compptr[0].width_in_blocks
//             <    is written>: output_cols
   JDIMENSION output_cols = compptr->width_in_blocks*8;
   JSAMPROW inptr, outptr;
   INT32 outvalue;
//             <    is read   >: cinfo cinfo[0].max_h_samp_factor 
//                               compptr compptr[0].h_samp_factor
//             <    is written>: h_expand

   h_expand = cinfo->max_h_samp_factor/(compptr->h_samp_factor);
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               compptr compptr[0].v_samp_factor
//             <    is written>: v_expand
   v_expand = cinfo->max_v_samp_factor/(compptr->v_samp_factor);
//             <    is read   >: h_expand v_expand
//             <    is written>: numpix
   numpix = h_expand*v_expand;
//             <    is read   >: numpix
//             <    is written>: numpix2
   numpix2 = numpix/2;
//             <may be read   >: input_data[*]
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_v_samp_factor h_expand 
//                               input_data output_cols
   
   /* Expand input data enough to let all the output samples be generated
      * by the standard loop.  Special-casing padded output would be more
      * efficient.
      */
   
   expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width, output_cols*h_expand);
//             <    is written>: inrow

   inrow = 0;
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: outrow
   for(outrow = 0; outrow <= compptr->v_samp_factor-1; outrow += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: outcol_h
      outcol_h = 0;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols
//             <    is written>: outcol
      for(outcol = 0; outcol <= output_cols-1; outcol += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols
//             <    is written>: outvalue
         outvalue = 0;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               output_cols v_expand
//             <    is written>: v
         for(v = 0; v <= v_expand-1; v += 1) {
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               input_data input_data[inrow+v] inrow 
//                               outcol_h output_cols v v_expand
//             <    is written>: inptr
            inptr = input_data[inrow+v]+outcol_h;
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               h_expand output_cols v_expand
//             <    is written>: h
            for(h = 0; h <= h_expand-1; h += 1)
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               h_expand inptr inptr[0] output_cols 
//                               outvalue v_expand
//             <    is written>: inptr outvalue
               outvalue += (INT32) (int) *inptr++;
         }
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               numpix numpix2 outptr output_cols 
//                               outvalue
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) ((outvalue+numpix2)/numpix);
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               h_expand outcol_h output_cols
//             <    is written>: outcol_h
         outcol_h += h_expand;
      }
//             <    is read   >: compptr compptr[0].v_samp_factor 
//                               inrow v_expand
//             <    is written>: inrow
      inrow += v_expand;
   }
}
static void sep_downsample(j_compress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION in_row_index, JSAMPIMAGE output_buf, JDIMENSION out_row_group_index)
{
//             <    is read   >: cinfo cinfo[0].downsample
//             <    is written>: downsample
   my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
   int ci;
   jpeg_component_info *compptr;
   JSAMPARRAY in_ptr, out_ptr;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               in_row_index input_buf input_buf[ci]
//             <    is written>: in_ptr
      in_ptr = input_buf[ci]+in_row_index;
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               compptr compptr[0].v_samp_factor 
//                               out_row_group_index output_buf 
//                               output_buf[ci]
//             <    is written>: out_ptr
      out_ptr = output_buf[ci]+out_row_group_index*compptr->v_samp_factor;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*(downsample->methods)[ci])(cinfo,compptr,in_ptr,out_ptr);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void start_pass_downsample(j_compress_ptr cinfo)
{
}
static boolean compress_output(j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;
   /* index of current MCU within row */
//             <    is read   >: cinfo cinfo[0].MCUs_per_row
//             <    is written>: last_MCU_col
   JDIMENSION last_MCU_col = cinfo->MCUs_per_row-1;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: last_iMCU_row
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows-1;
   int blkn, ci, xindex, yindex, yoffset, blockcnt;
   JDIMENSION start_col;
   JBLOCKARRAY buffer[4];
   JBLOCKROW MCU_buffer[10];
   JBLOCKROW buffer_ptr;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Align the virtual buffers for the components used in this scan. */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      buffer[ci] = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[compptr->component_index],coef->iMCU_row_num*compptr->v_samp_factor,(JDIMENSION) compptr->v_samp_factor,0);
   }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: yoffset
   
   /* Loop to process one whole iMCU row */
   for(yoffset = coef->MCU_vert_offset; yoffset <= coef->MCU_rows_per_iMCU_row-1; yoffset += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: MCU_col_num
      for(MCU_col_num = coef->mcu_ctr; MCU_col_num <= cinfo->MCUs_per_row-1; MCU_col_num += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: blkn
         /* Construct list of pointers to DCT blocks belonging to this MCU */
         blkn = 0;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: ci
         /* index of current DCT block within MCU */
         for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci] coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: compptr
            compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_width
//             <    is written>: start_col
            start_col = MCU_col_num*compptr->MCU_width;
//             <may be read   >: compptr[0].MCU_width 
//                               compptr[0].last_col_width
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr last_MCU_col
//             <    is written>: blockcnt
            blockcnt = MCU_col_num<last_MCU_col?compptr->MCU_width:compptr->last_col_width;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height
//             <    is written>: yindex
            for(yindex = 0; yindex <= compptr->MCU_height-1; yindex += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].iMCU_row_num coef[0].mcu_ctr 
//                               compptr compptr[0].MCU_height 
//                               compptr[0].last_row_height 
//                               last_iMCU_row yindex yoffset

               if (coef->iMCU_row_num<last_iMCU_row||yindex+yoffset<compptr->last_row_height) {
//             <    is read   >: buffer[ci] buffer[ci][yindex+yoffset]
//                               ci cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height start_col 
//                               yindex yoffset
//             <    is written>: buffer_ptr
                  /* Fill in pointers to real blocks in this row */
                  buffer_ptr = buffer[ci][yindex+yoffset]+start_col;
//             <    is read   >: blockcnt cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height
//             <    is written>: xindex
                  for(xindex = 0; xindex <= blockcnt-1; xindex += 1)
//             <    is read   >: blkn blockcnt buffer_ptr cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height
//             <    is written>: MCU_buffer[blkn++] blkn buffer_ptr
                     MCU_buffer[blkn++] = buffer_ptr++;
               }
               else
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height
//             <    is written>: xindex
                  /* At bottom of image, need a whole row of dummy blocks */
                  xindex = 0;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width xindex
//             <    is written>: xindex
               /* Fill in any dummy blocks needed in this row.
               	   * Dummy blocks are filled in the same way as in jccoefct.c:
               	   * all zeroes in the AC entries, DC entries equal to previous
               	   * block's DC value.  The init routine has already zeroed the
               	   * AC entries, so we need only set the DC entries correctly.
               	   */
               for(xindex = xindex; xindex <= compptr->MCU_width-1; xindex += 1) {
//             <    is read   >: blkn cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].dummy_buffer[blkn] 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width xindex
//             <    is written>: MCU_buffer[blkn]
                  MCU_buffer[blkn] = (coef->dummy_buffer)[blkn];
//             <    is read   >: MCU_buffer[blkn] MCU_buffer[blkn-1] 
//                               MCU_buffer[blkn-1][0][0] blkn cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width xindex
//             <    is written>: MCU_buffer[blkn][0][0]
                  MCU_buffer[blkn][0][0] = MCU_buffer[blkn-1][0][0];
//             <    is read   >: blkn cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width xindex
//             <    is written>: blkn
                  blkn++;
               }
            }
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Try to write the MCU. */
         if (!(*cinfo->entropy->encode_mcu)(cinfo,MCU_buffer)) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr yoffset
//             <    is written>: coef[0].MCU_vert_offset
            /* Suspension forced; update state counters and exit */
            coef->MCU_vert_offset = yoffset;
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
//             <    is written>: coef[0].mcu_ctr
            coef->mcu_ctr = MCU_col_num;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset 
//                               coef[0].mcu_ctr
            return 0;
         }
      }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: coef[0].mcu_ctr
      /* Completed an MCU row, but perhaps not an iMCU row */
      coef->mcu_ctr = 0;
   }
//             <    is read   >: coef coef[0].iMCU_row_num
//             <    is written>: coef[0].iMCU_row_num
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
//             <may be read   >: cinfo[0].coef[0].iMCU_row_num 
//                               cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset 
//                               cinfo[0].coef[0].mcu_ctr
   start_iMCU_row(cinfo);
   return 1;
}
static void start_iMCU_row(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
   
   /* In an interleaved scan, an MCU row is the same as an iMCU row.
      * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
      * But at the bottom of the image, process only what's left.
      */
   if (cinfo->comps_in_scan>1)
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = 1;
   else if (coef->iMCU_row_num<cinfo->total_iMCU_rows-1)
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info)[0]->v_samp_factor;
   else
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info)[0]->last_row_height;
//             <    is read   >: coef
//             <    is written>: coef[0].mcu_ctr

   coef->mcu_ctr = 0;
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_vert_offset
   coef->MCU_vert_offset = 0;
}
static void start_pass_coef(j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: pass_mode

   if (pass_mode!=JBUF_CRANK_DEST)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: coef
//             <    is written>: coef[0].iMCU_row_num

   coef->iMCU_row_num = 0;
//             <may be read   >: cinfo[0].coef[0].iMCU_row_num 
//                               cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset 
//                               cinfo[0].coef[0].mcu_ctr
   start_iMCU_row(cinfo);
}
static void transencode_coef_controller(j_compress_ptr cinfo, jvirt_barray_ptr *coef_arrays)
{
   my_coef_ptr coef;
   JBLOCKROW buffer;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   coef = (my_coef_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_coef_controller));
//             <    is read   >: cinfo coef
//             <    is written>: cinfo[0].coef
   cinfo->coef = (struct jpeg_c_coef_controller *) coef;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.start_pass
   coef->pub.start_pass = start_pass_coef;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.compress_data
   coef->pub.compress_data = compress_output;
//             <    is read   >: coef coef_arrays
//             <    is written>: coef[0].whole_image
   
   /* Save pointer to virtual arrays */
   coef->whole_image = coef_arrays;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Allocate and pre-zero space for dummy DCT blocks. */
   
   buffer = (JBLOCKROW) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,10*(size_t) sizeof(JBLOCK));
//             <may be written>: buffer[*][*]
//             <    is read   >: buffer
   jzero_far((void *) buffer, 10*(size_t) sizeof(JBLOCK));
//             <    is written>: i
   for(i = 0; i <= 9; i += 1)
//             <    is read   >: buffer coef i
//             <    is written>: coef[0].dummy_buffer[i]
      (coef->dummy_buffer)[i] = buffer+i;
}
static void transencode_master_selection(j_compress_ptr cinfo, jvirt_barray_ptr *coef_arrays)
{
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].input_components
   /* Although we don't actually use input_components for transcoding,
      * jcmaster.c's initial_setup will complain if input_components is 0.
      */
   cinfo->input_components = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Initialize master control (includes parameter checking/processing) */
   /* transcode only */
   jinit_c_master_control(cinfo, 1);
//             <    is read   >: cinfo cinfo[0].arith_code
   
   /* Entropy encoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_ARITH_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   else if (cinfo->progressive_mode)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      jinit_phuff_encoder(cinfo);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_huff_encoder(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* We need a special coefficient buffer controller. */
   transencode_coef_controller(cinfo, coef_arrays);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   jinit_marker_writer(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* We can now tell the memory manager to allocate virtual arrays. */
   (*cinfo->mem->realize_virt_arrays)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Write the datastream header (SOI) immediately.
      * Frame and scan headers are postponed till later.
      * This lets application insert special markers after the SOI.
      */
   (*cinfo->marker->write_file_header)(cinfo);
}
static void default_decompress_parms(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].num_components
   /* Guess the input colorspace, and set output colorspace accordingly. */
   /* (Wish JPEG committee had provided a real way to specify this...) */
   /* Note application may override our guesses. */
   if (cinfo->num_components==1) {
_switch_1_case_1:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
      cinfo->jpeg_color_space = JCS_GRAYSCALE;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_space
      cinfo->out_color_space = JCS_GRAYSCALE;
   }
   else if (cinfo->num_components==3) {

_switch_1_case_3:      ;
//             <    is read   >: cinfo cinfo[0].saw_JFIF_marker
      if (cinfo->saw_JFIF_marker)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
         cinfo->jpeg_color_space = JCS_YCbCr;
      else if (cinfo->saw_Adobe_marker) {
//             <    is read   >: cinfo cinfo[0].Adobe_transform
         if (cinfo->Adobe_transform==0) {
_switch_2_case_0:            ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_RGB;
         }
         else if (cinfo->Adobe_transform==1) {
_switch_2_case_1:            ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_YCbCr;
         }
         else {
_switch_2_default:            ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JWRN_ADOBE_XFORM, (cinfo->err->msg_parm.i)[0] = cinfo->Adobe_transform, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_YCbCr;
            /* assume it's YCbCr */
            ;
         }
_break_2:         ;
      }
      else {
         /* Saw no special markers, try to guess from the component IDs */
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].comp_info[0].component_id
//             <    is written>: cid0
         int cid0 = (cinfo->comp_info)[0].component_id;
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].comp_info[1].component_id
//             <    is written>: cid1
         int cid1 = (cinfo->comp_info)[1].component_id;
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].comp_info[2].component_id
//             <    is written>: cid2
         int cid2 = (cinfo->comp_info)[2].component_id;
//             <    is read   >: cid0 cid1 cid2

         if (cid0==1&&cid1==2&&cid2==3)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_YCbCr;
         else if (cid0==82&&cid1==71&&cid2==66)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_RGB;
         else {
            do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: _mp
               int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: _mp cid0
//             <    is written>: _mp[0]
               _mp[0] = cid0;
//             <    is read   >: _mp cid1
//             <    is written>: _mp[1]
               _mp[1] = cid1;
//             <    is read   >: _mp cid2
//             <    is written>: _mp[2]
               _mp[2] = cid2;
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
               cinfo->err->msg_code = JTRC_UNKNOWN_IDS;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
            }
            while (0);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_YCbCr;
         }
      }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_space
      /* Always guess RGB is proper output colorspace. */
      cinfo->out_color_space = JCS_RGB;
   }
   else if (cinfo->num_components==4) {

_switch_1_case_4:      ;
//             <    is read   >: cinfo cinfo[0].saw_Adobe_marker
      if (cinfo->saw_Adobe_marker) {
//             <    is read   >: cinfo cinfo[0].Adobe_transform
         if (cinfo->Adobe_transform==0) {
_switch_4_case_0:            ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_CMYK;
         }
         else if (cinfo->Adobe_transform==2) {
_switch_4_case_2:            ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_YCCK;
         }
         else {
_switch_4_default:            ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JWRN_ADOBE_XFORM, (cinfo->err->msg_parm.i)[0] = cinfo->Adobe_transform, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
            cinfo->jpeg_color_space = JCS_YCCK;
            /* assume it's YCCK */
            ;
         }
_break_4:         ;
      }
      else
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
         /* No special markers, assume straight CMYK. */
         cinfo->jpeg_color_space = JCS_CMYK;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_space
      cinfo->out_color_space = JCS_CMYK;
   }
   else {

_switch_1_default:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
      cinfo->jpeg_color_space = JCS_UNKNOWN;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_space
      cinfo->out_color_space = JCS_UNKNOWN;
   }
_break_1:   ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].scale_num
   
   /* Set defaults for other decompression parameters. */
   cinfo->scale_num = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].scale_denom
   /* 1:1 scaling */
   cinfo->scale_denom = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].output_gamma
   cinfo->output_gamma = 1.0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].buffered_image
   cinfo->buffered_image = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].raw_data_out
   cinfo->raw_data_out = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].dct_method
   cinfo->dct_method = JDCT_ISLOW;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].do_fancy_upsampling
   cinfo->do_fancy_upsampling = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].do_block_smoothing
   cinfo->do_block_smoothing = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].quantize_colors
   cinfo->quantize_colors = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].dither_mode
   /* We set these in case application only sets quantize_colors. */
   cinfo->dither_mode = JDITHER_FS;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].two_pass_quantize

   cinfo->two_pass_quantize = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].desired_number_of_colors
   
   
   
   cinfo->desired_number_of_colors = 256;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].colormap
   cinfo->colormap = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_1pass_quant
   /* Initialize for no mode change in buffered-image mode. */
   cinfo->enable_1pass_quant = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_external_quant
   cinfo->enable_external_quant = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_2pass_quant
   cinfo->enable_2pass_quant = 0;
}
static boolean output_pass_setup(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state!=204) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* First call: do pass setup */
      (*cinfo->master->prepare_for_output_pass)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].output_scanline
      cinfo->output_scanline = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      cinfo->global_state = 204;
   }
//             <    is read   >: cinfo cinfo[0].master 
//                               cinfo[0].master[0].is_dummy_pass
   /* Loop over any required dummy passes */
   while (cinfo->master->is_dummy_pass) {
//             <    is read   >: cinfo cinfo cinfo[0].output_height 
//                               cinfo[0].output_scanline
      
      /* Crank through the dummy pass */
      while (cinfo->output_scanline<cinfo->output_height) {
         JDIMENSION last_scanline;
//             <    is read   >: cinfo cinfo[0].progress
         /* Call progress monitor hook if present */
         if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].output_scanline 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
            cinfo->progress->pass_counter = (long int) cinfo->output_scanline;
//             <    is read   >: cinfo cinfo[0].output_height 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_limit
            cinfo->progress->pass_limit = (long int) cinfo->output_height;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
         }
//             <    is read   >: cinfo cinfo[0].output_scanline
//             <    is written>: last_scanline
         /* Process some data */
         last_scanline = cinfo->output_scanline;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->main->process_data)(cinfo,(JSAMPARRAY) (void *) 0,&cinfo->output_scanline,(JDIMENSION) 0);
//             <    is read   >: cinfo cinfo[0].output_scanline 
//                               last_scanline
         if (cinfo->output_scanline==last_scanline)
            return 0;
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Finish up dummy pass, and set up for another one */
      (*cinfo->master->finish_output_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->prepare_for_output_pass)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].output_scanline
      cinfo->output_scanline = 0;
   }
//             <    is read   >: cinfo cinfo[0].raw_data_out
//             <    is written>: cinfo[0].global_state
   /* Ready for application to drive output pass through
      * jpeg_read_scanlines or jpeg_read_raw_data.
      */
   cinfo->global_state = cinfo->raw_data_out?206:205;
   return 1;
}
static boolean empty_output_buffer(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].dest
//             <    is written>: dest
   my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
//             <may be read   >: dest[0].buffer[*] dest[0].outfile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <may be written>: dest[0].outfile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <    is read   >: dest dest[0].buffer dest[0].outfile
   if ((size_t) fwrite((void *) dest->buffer, (size_t) 1, (size_t) 4096, dest->outfile)!=(size_t) 4096)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_FILE_WRITE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: dest dest[0].buffer
//             <    is written>: dest[0].pub.next_output_byte

   dest->pub.next_output_byte = dest->buffer;
//             <    is read   >: dest
//             <    is written>: dest[0].pub.free_in_buffer
   dest->pub.free_in_buffer = 4096;

   return 1;
}
static void init_destination(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].dest
//             <    is written>: dest
   my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Allocate the output buffer --- it will be released when done with image */
   
   dest->buffer = (JOCTET *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,4096*(size_t) sizeof(JOCTET));
//             <    is read   >: dest dest[0].buffer
//             <    is written>: dest[0].pub.next_output_byte

   dest->pub.next_output_byte = dest->buffer;
//             <    is read   >: dest
//             <    is written>: dest[0].pub.free_in_buffer
   dest->pub.free_in_buffer = 4096;
}
static void term_destination(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].dest
//             <    is written>: dest
   my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
//             <    is read   >: dest dest[0].pub.free_in_buffer
//             <    is written>: datacount
   size_t datacount = 4096-dest->pub.free_in_buffer;
//             <    is read   >: datacount
   
   /* Write any data remaining in the buffer */
   if (datacount>0)
//             <may be read   >: dest[0].buffer[*] dest[0].outfile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <may be written>: dest[0].outfile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <    is read   >: datacount dest dest[0].buffer 
//                               dest[0].outfile
      if ((size_t) fwrite((void *) dest->buffer, (size_t) 1, (size_t) datacount, dest->outfile)!=datacount)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_FILE_WRITE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   fflush(dest->outfile);
//             <may be read   >: dest[0].outfile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <may be written>: dest[0].outfile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <    is read   >: dest dest[0].outfile
   /* Make sure we wrote the output file OK */
   if (ferror(dest->outfile))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_FILE_WRITE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
static boolean fill_input_buffer(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: src
   my_src_ptr src = (my_src_ptr) cinfo->src;
   size_t nbytes;
//             <may be read   >: src[0].infile[0] __IO_EFFECTS:LUNS[*]
//             <may be written>: src[0].buffer[*] src[0].infile[0] 
//                               __IO_EFFECTS:LUNS[*]
//             <    is read   >: src src[0].buffer src[0].infile
//             <    is written>: nbytes
   nbytes = (size_t) fread((void *) src->buffer, (size_t) 1, (size_t) 4096, src->infile);
//             <    is read   >: nbytes

   if (nbytes<=0) {
//             <    is read   >: src src[0].start_of_file
      if (src->start_of_file)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Treat empty input file as fatal error */
         cinfo->err->msg_code = JERR_INPUT_EMPTY, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_JPEG_EOF, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: src src[0].buffer
//             <    is written>: src[0].buffer[0]
      /* Insert a fake EOI marker */
      (src->buffer)[0] = (JOCTET) 0xFF;
//             <    is read   >: src src[0].buffer
//             <    is written>: src[0].buffer[1]
      (src->buffer)[1] = (JOCTET) 0xD9;
//             <    is written>: nbytes
      nbytes = 2;
   }
//             <    is read   >: src src[0].buffer
//             <    is written>: src[0].pub.next_input_byte

   src->pub.next_input_byte = src->buffer;
//             <    is read   >: nbytes src
//             <    is written>: src[0].pub.bytes_in_buffer
   src->pub.bytes_in_buffer = nbytes;
//             <    is read   >: src
//             <    is written>: src[0].start_of_file
   src->start_of_file = 0;

   return 1;
}
static void init_source(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: src
   my_src_ptr src = (my_src_ptr) cinfo->src;
//             <    is read   >: src
//             <    is written>: src[0].start_of_file
   
   /* We reset the empty-input-file flag for each image,
      * but we don't clear the input buffer.
      * This is correct behavior for reading a series of images from one source.
      */
   src->start_of_file = 1;
}
static void skip_input_data(j_decompress_ptr cinfo, long int num_bytes)
{
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: src
   my_src_ptr src = (my_src_ptr) cinfo->src;
//             <    is read   >: num_bytes
   
   /* Just a dumb implementation for now.  Could use fseek() except
      * it doesn't work on pipes.  Not clear that being smart is worth
      * any trouble anyway --- large skips are infrequent.
      */
   if (num_bytes>0) {
//             <    is read   >: num_bytes src 
//                               src[0].pub.bytes_in_buffer
      while (num_bytes>(long int) src->pub.bytes_in_buffer) {
//             <    is read   >: num_bytes src 
//                               src[0].pub.bytes_in_buffer
//             <    is written>: num_bytes
         num_bytes -= (long int) src->pub.bytes_in_buffer;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               __IO_EFFECTS:LUNS[*]
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               __IO_EFFECTS:LUNS[*]
         (void) fill_input_buffer(cinfo);
      }
//             <    is read   >: num_bytes src 
//                               src[0].pub.next_input_byte
//             <    is written>: src[0].pub.next_input_byte
      src->pub.next_input_byte += (size_t) num_bytes;
//             <    is read   >: num_bytes src 
//                               src[0].pub.bytes_in_buffer
//             <    is written>: src[0].pub.bytes_in_buffer
      src->pub.bytes_in_buffer -= (size_t) num_bytes;
   }
}
static void term_source(j_decompress_ptr cinfo)
{
}
static int consume_data(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;
   /* index of current MCU within row */
   int blkn, ci, xindex, yindex, yoffset;
   JDIMENSION start_col;
   JBLOCKARRAY buffer[4];
   JBLOCKROW buffer_ptr;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Align the virtual buffers for the components used in this scan. */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      
      buffer[ci] = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[compptr->component_index],cinfo->input_iMCU_row*compptr->v_samp_factor,(JDIMENSION) compptr->v_samp_factor,1);
   }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: yoffset
   
   /* Loop to process one whole iMCU row */
   for(yoffset = coef->MCU_vert_offset; yoffset <= coef->MCU_rows_per_iMCU_row-1; yoffset += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: MCU_col_num
      for(MCU_col_num = coef->MCU_ctr; MCU_col_num <= cinfo->MCUs_per_row-1; MCU_col_num += 1) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: blkn
         /* Construct list of pointers to DCT blocks belonging to this MCU */
         blkn = 0;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: ci
         /* index of current DCT block within MCU */
         for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci] coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: compptr
            compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_width
//             <    is written>: start_col
            start_col = MCU_col_num*compptr->MCU_width;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height
//             <    is written>: yindex
            for(yindex = 0; yindex <= compptr->MCU_height-1; yindex += 1) {
//             <    is read   >: buffer[ci] buffer[ci][yindex+yoffset]
//                               ci cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height start_col 
//                               yindex yoffset
//             <    is written>: buffer_ptr
               buffer_ptr = buffer[ci][yindex+yoffset]+start_col;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width
//             <    is written>: xindex
               for(xindex = 0; xindex <= compptr->MCU_width-1; xindex += 1)
//             <    is read   >: blkn buffer_ptr cinfo 
//                               cinfo[0].MCUs_per_row 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width
//             <    is written>: blkn buffer_ptr 
//                               coef[0].MCU_buffer[blkn++]
                  (coef->MCU_buffer)[blkn++] = buffer_ptr++;
            }
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Try to fetch the MCU. */
         if (!(*cinfo->entropy->decode_mcu)(cinfo,coef->MCU_buffer)) {
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset yoffset
//             <    is written>: coef[0].MCU_vert_offset
            /* Suspension forced; update state counters and exit */
            coef->MCU_vert_offset = yoffset;
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: coef[0].MCU_ctr
            coef->MCU_ctr = MCU_col_num;
//             <    is read   >: cinfo cinfo[0].MCUs_per_row coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
            return 0;
         }
      }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: coef[0].MCU_ctr
      /* Completed an MCU row, but perhaps not an iMCU row */
      coef->MCU_ctr = 0;
   }
//             <    is read   >: cinfo cinfo[0].input_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].input_iMCU_row
   /* Completed the iMCU row, advance counters for next one */
   if (++cinfo->input_iMCU_row<cinfo->total_iMCU_rows) {
//             <may be read   >: cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].input_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: cinfo[0].coef[0].MCU_ctr 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset
      start_iMCU_row(cinfo);
      return 3;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Completed the scan */
   (*cinfo->inputctl->finish_input_pass)(cinfo);
   return 4;
}
static int decompress_data(j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: last_iMCU_row
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows-1;
   JDIMENSION block_num;
   int ci, block_row, block_rows;
   JBLOCKARRAY buffer;
   JBLOCKROW buffer_ptr;
   JSAMPARRAY output_ptr;
   JDIMENSION output_col;
   jpeg_component_info *compptr;
   inverse_DCT_method_ptr inverse_DCT;
//             <    is read   >: cinfo cinfo cinfo cinfo cinfo cinfo 
//                               cinfo[0].input_iMCU_row 
//                               cinfo[0].input_scan_number 
//                               cinfo[0].input_scan_number 
//                               cinfo[0].output_iMCU_row 
//                               cinfo[0].output_scan_number 
//                               cinfo[0].output_scan_number
   while (cinfo->input_scan_number<cinfo->output_scan_number||cinfo->input_scan_number==cinfo->output_scan_number&&cinfo->input_iMCU_row<=cinfo->output_iMCU_row)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      /* Force some input to be done if we are getting ahead of the input. */
      
      
      if ((*cinfo->inputctl->consume_input)(cinfo)==0)
         return 0;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* OK, output from the virtual arrays. */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].component_needed
      /* Don't bother to IDCT an uninteresting component. */
      if (!compptr->component_needed)
         ;
      else {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         /* Align the virtual buffer for this component. */
         buffer = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[ci],cinfo->output_iMCU_row*compptr->v_samp_factor,(JDIMENSION) compptr->v_samp_factor,0);
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].output_iMCU_row 
//                               last_iMCU_row
         /* Count non-dummy DCT block rows in this iMCU row. */
         if (cinfo->output_iMCU_row<last_iMCU_row)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
            block_rows = compptr->v_samp_factor;
         else {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].height_in_blocks 
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
            /* NB: can't use last_row_height here; it is input-side-dependent! */
            block_rows = (int) (compptr->height_in_blocks%compptr->v_samp_factor);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
            if (block_rows==0)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
               block_rows = compptr->v_samp_factor;
         }
//             <    is read   >: ci cinfo cinfo[0].idct 
//                               cinfo[0].idct[0].inverse_DCT[ci] 
//                               cinfo[0].num_components
//             <    is written>: inverse_DCT
         inverse_DCT = (cinfo->idct->inverse_DCT)[ci];
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               output_buf output_buf[ci]
//             <    is written>: output_ptr
         output_ptr = output_buf[ci];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: block_row
         /* Loop over all DCT blocks to be processed. */
         for(block_row = 0; block_row <= block_rows-1; block_row += 1) {
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row] cinfo 
//                               cinfo[0].num_components
//             <    is written>: buffer_ptr
            buffer_ptr = buffer[block_row];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: output_col
            output_col = 0;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].width_in_blocks
//             <    is written>: block_num
            for(block_num = 0; block_num <= compptr->width_in_blocks-1; block_num += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               (*inverse_DCT)(cinfo,compptr,(JCOEFPTR) buffer_ptr,output_ptr,output_col);
//             <    is read   >: block_rows buffer_ptr cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].width_in_blocks
//             <    is written>: buffer_ptr
               buffer_ptr++;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].width_in_blocks output_col
//             <    is written>: output_col
               output_col += compptr->DCT_scaled_size;
            }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size output_ptr
//             <    is written>: output_ptr
            output_ptr += compptr->DCT_scaled_size;
         }
      }
//             <    is read   >: cinfo cinfo[0].num_components
_loop_end_2:      ;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].output_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].output_iMCU_row
   if (++cinfo->output_iMCU_row<cinfo->total_iMCU_rows)
      return 3;
   return 4;
}
static int decompress_onepass(j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
   JDIMENSION MCU_col_num;
   /* index of current MCU within row */
//             <    is read   >: cinfo cinfo[0].MCUs_per_row
//             <    is written>: last_MCU_col
   JDIMENSION last_MCU_col = cinfo->MCUs_per_row-1;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: last_iMCU_row
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows-1;
   int blkn, ci, xindex, yindex, yoffset, useful_width;
   JSAMPARRAY output_ptr;
   JDIMENSION start_col, output_col;
   jpeg_component_info *compptr;
   inverse_DCT_method_ptr inverse_DCT;
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: yoffset
   
   /* Loop to process as much as one whole iMCU row */
   for(yoffset = coef->MCU_vert_offset; yoffset <= coef->MCU_rows_per_iMCU_row-1; yoffset += 1) {
//             <    is read   >: coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
//             <    is written>: MCU_col_num
      for(MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col; MCU_col_num += 1) {
//             <may be written>: coef[0].MCU_buffer[0][*][*]
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU coef 
//                               coef[0].MCU_buffer[0] coef[0].MCU_ctr
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
         /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
         
         jzero_far((void *) (coef->MCU_buffer)[0], (size_t) (cinfo->blocks_in_MCU*(size_t) sizeof(JBLOCK)));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*cinfo->entropy->decode_mcu)(cinfo,coef->MCU_buffer)) {
//             <    is read   >: coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col 
//                               yoffset
//             <    is written>: coef[0].MCU_vert_offset
            /* Suspension forced; update state counters and exit */
            coef->MCU_vert_offset = yoffset;
//             <    is read   >: MCU_col_num coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
//             <    is written>: coef[0].MCU_ctr
            coef->MCU_ctr = MCU_col_num;
//             <    is read   >: coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
            return 0;
         }
//             <    is read   >: coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
//             <    is written>: blkn
         /* Determine where data should go in output_buf and do the IDCT thing.
                * We skip dummy blocks at the right and bottom edges (but blkn gets
                * incremented past them!).  Note the inner loop relies on having
                * allocated the MCU_buffer[] blocks sequentially.
                */
         blkn = 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
//             <    is written>: ci
         /* index of current DCT block within MCU */
         for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci] coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
//             <    is written>: compptr
            compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].component_needed 
//                               last_MCU_col
            /* Don't bother to IDCT an uninteresting component. */
            if (!compptr->component_needed)
//             <    is read   >: blkn cinfo cinfo[0].comps_in_scan 
//                               coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_blocks last_MCU_col
//             <    is written>: blkn
               blkn += compptr->MCU_blocks;
            else {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].idct 
//                               cinfo[0].idct[0].inverse_DCT[compptr-
//                               >component_index] coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].component_index 
//                               last_MCU_col
//             <    is written>: inverse_DCT
               inverse_DCT = (cinfo->idct->inverse_DCT)[compptr->component_index];
//             <may be read   >: compptr[0].MCU_width 
//                               compptr[0].last_col_width
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               last_MCU_col
//             <    is written>: useful_width
               useful_width = MCU_col_num<last_MCU_col?compptr->MCU_width:compptr->last_col_width;
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].DCT_scaled_size 
//                               last_MCU_col output_buf 
//                               output_buf[ci] yoffset
//             <    is written>: output_ptr
               output_ptr = output_buf[ci]+yoffset*compptr->DCT_scaled_size;
//             <    is read   >: MCU_col_num cinfo 
//                               cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_sample_width 
//                               last_MCU_col
//             <    is written>: start_col
               start_col = MCU_col_num*compptr->MCU_sample_width;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height last_MCU_col
//             <    is written>: yindex
               for(yindex = 0; yindex <= compptr->MCU_height-1; yindex += 1) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].input_iMCU_row coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].last_row_height 
//                               last_MCU_col last_iMCU_row yindex 
//                               yoffset

                  if (cinfo->input_iMCU_row<last_iMCU_row||yoffset+yindex<compptr->last_row_height) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height last_MCU_col 
//                               start_col
//             <    is written>: output_col
                     output_col = start_col;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height last_MCU_col 
//                               useful_width
//             <    is written>: xindex
                     for(xindex = 0; xindex <= useful_width-1; xindex += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

                        (*inverse_DCT)(cinfo,compptr,(JCOEFPTR) (coef->MCU_buffer)[blkn+xindex],output_ptr,output_col);
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].MCU_height last_MCU_col 
//                               output_col useful_width
//             <    is written>: output_col
                        output_col += compptr->DCT_scaled_size;
                     }
                  }
//             <    is read   >: blkn cinfo cinfo[0].comps_in_scan 
//                               coef coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width last_MCU_col
//             <    is written>: blkn
                  blkn += compptr->MCU_width;
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].MCU_height last_MCU_col 
//                               output_ptr
//             <    is written>: output_ptr
                  output_ptr += compptr->DCT_scaled_size;
               }
            }
//             <    is read   >: cinfo cinfo[0].comps_in_scan coef 
//                               coef[0].MCU_ctr 
//                               coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset last_MCU_col
_loop_end_3:            ;
         }
      }
//             <    is read   >: coef coef[0].MCU_rows_per_iMCU_row 
//                               coef[0].MCU_vert_offset
//             <    is written>: coef[0].MCU_ctr
      /* Completed an MCU row, but perhaps not an iMCU row */
      coef->MCU_ctr = 0;
   }
//             <    is read   >: cinfo cinfo[0].output_iMCU_row
//             <    is written>: cinfo[0].output_iMCU_row
   /* Completed the iMCU row, advance counters for next one */
   cinfo->output_iMCU_row++;
//             <    is read   >: cinfo cinfo[0].input_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].input_iMCU_row
   if (++cinfo->input_iMCU_row<cinfo->total_iMCU_rows) {
//             <may be read   >: cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].input_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: cinfo[0].coef[0].MCU_ctr 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset
      start_iMCU_row(cinfo);
      return 3;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Completed the scan */
   (*cinfo->inputctl->finish_input_pass)(cinfo);
   return 4;
}
static int decompress_smooth_data(j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: last_iMCU_row
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows-1;
   JDIMENSION block_num, last_block_column;
   int ci, block_row, block_rows, access_rows;
   JBLOCKARRAY buffer;
   JBLOCKROW buffer_ptr, prev_block_row, next_block_row;
   JSAMPARRAY output_ptr;
   JDIMENSION output_col;
   jpeg_component_info *compptr;
   inverse_DCT_method_ptr inverse_DCT;
   boolean first_row, last_row;
   JBLOCK workspace;
   int *coef_bits;
   JQUANT_TBL *quanttbl;
   INT32 Q00, Q01, Q02, Q10, Q11, Q20, num;
   int DC1, DC2, DC3, DC4, DC5, DC6, DC7, DC8, DC9;
   int Al, pred;
l99998:   ;
//             <    is read   >: cinfo cinfo[0].input_scan_number 
//                               cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].eoi_reached 
//                               cinfo[0].output_scan_number

/* Force some input to be done if we are getting ahead of the input. */

   if (!(cinfo->input_scan_number<=cinfo->output_scan_number&&!cinfo->inputctl->eoi_reached)) goto _break_1;
//             <    is read   >: cinfo cinfo[0].input_scan_number 
//                               cinfo[0].output_scan_number
   if (cinfo->input_scan_number==cinfo->output_scan_number) goto l99999;
l99997:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if ((*cinfo->inputctl->consume_input)(cinfo)==0)
      return 0;
   goto l99998;
l99999:   ;
   /* If input is working on current scan, we ordinarily want it to
          * have completed the current row.  But if input scan is DC,
          * we want it to keep one row ahead so that next block row's DC
          * values are up to date.
          */
//             <    is read   >: cinfo cinfo[0].Ss
//             <    is written>: delta
   JDIMENSION delta = cinfo->Ss==0?1:0;
//             <    is read   >: cinfo cinfo[0].input_iMCU_row 
//                               cinfo[0].output_iMCU_row delta
   if (cinfo->input_iMCU_row>cinfo->output_iMCU_row+delta) {
   }
   else {
      goto l99997;
   }
_break_1:   ;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* OK, output from the virtual arrays. */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].component_needed
      /* Don't bother to IDCT an uninteresting component. */
      if (!compptr->component_needed)
         ;
      else {
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].output_iMCU_row 
//                               last_iMCU_row
         /* Count non-dummy DCT block rows in this iMCU row. */
         if (cinfo->output_iMCU_row<last_iMCU_row) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
            block_rows = compptr->v_samp_factor;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: access_rows
            access_rows = block_rows*2;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: last_row
            /* this and next iMCU row */
            last_row = 0;
         }
         else {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].height_in_blocks 
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
            /* NB: can't use last_row_height here; it is input-side-dependent! */
            block_rows = (int) (compptr->height_in_blocks%compptr->v_samp_factor);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
            if (block_rows==0)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: block_rows
               block_rows = compptr->v_samp_factor;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: access_rows
            access_rows = block_rows;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: last_row
            /* this iMCU row only */
            last_row = 1;
         }
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].output_iMCU_row
         /* Align the virtual buffer for this component. */
         if (cinfo->output_iMCU_row>0) {
//             <    is read   >: access_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: access_rows
            access_rows += compptr->v_samp_factor;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* prior iMCU row too */
            buffer = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[ci],(cinfo->output_iMCU_row-1)*compptr->v_samp_factor,(JDIMENSION) access_rows,0);
//             <    is read   >: buffer cinfo cinfo[0].num_components 
//                               compptr compptr[0].v_samp_factor
//             <    is written>: buffer
            buffer += compptr->v_samp_factor;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: first_row
            /* point to current iMCU row */
            first_row = 0;
         }
         else {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

            buffer = (*cinfo->mem->access_virt_barray)((j_common_ptr) cinfo,(coef->whole_image)[ci],(JDIMENSION) 0,(JDIMENSION) access_rows,0);
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: first_row
            first_row = 1;
         }
//             <    is read   >: ci cinfo cinfo[0].num_components coef
//                               coef[0].coef_bits_latch
//             <    is written>: coef_bits
         /* Fetch component-dependent info */
         coef_bits = coef->coef_bits_latch+ci*6;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].quant_table
//             <    is written>: quanttbl
         quanttbl = compptr->quant_table;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               quanttbl quanttbl[0].quantval[0]
//             <    is written>: Q00
         Q00 = (quanttbl->quantval)[0];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               quanttbl quanttbl[0].quantval[1]
//             <    is written>: Q01
         Q01 = (quanttbl->quantval)[1];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               quanttbl quanttbl[0].quantval[8]
//             <    is written>: Q10
         Q10 = (quanttbl->quantval)[8];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               quanttbl quanttbl[0].quantval[16]
//             <    is written>: Q20
         Q20 = (quanttbl->quantval)[16];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               quanttbl quanttbl[0].quantval[9]
//             <    is written>: Q11
         Q11 = (quanttbl->quantval)[9];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               quanttbl quanttbl[0].quantval[2]
//             <    is written>: Q02
         Q02 = (quanttbl->quantval)[2];
//             <    is read   >: ci cinfo cinfo[0].idct 
//                               cinfo[0].idct[0].inverse_DCT[ci] 
//                               cinfo[0].num_components
//             <    is written>: inverse_DCT
         inverse_DCT = (cinfo->idct->inverse_DCT)[ci];
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               output_buf output_buf[ci]
//             <    is written>: output_ptr
         output_ptr = output_buf[ci];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: block_row
         /* Loop over all DCT blocks to be processed. */
         for(block_row = 0; block_row <= block_rows-1; block_row += 1) {
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row] cinfo 
//                               cinfo[0].num_components
//             <    is written>: buffer_ptr
            buffer_ptr = buffer[block_row];
//             <    is read   >: block_row block_rows cinfo 
//                               cinfo[0].num_components first_row
            if (first_row&&block_row==0)
//             <    is read   >: block_rows buffer_ptr cinfo 
//                               cinfo[0].num_components
//             <    is written>: prev_block_row
               prev_block_row = buffer_ptr;
            else
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row-1] cinfo 
//                               cinfo[0].num_components
//             <    is written>: prev_block_row
               prev_block_row = buffer[block_row-1];
//             <    is read   >: block_row block_rows cinfo 
//                               cinfo[0].num_components last_row
            if (last_row&&block_row==block_rows-1)
//             <    is read   >: block_rows buffer_ptr cinfo 
//                               cinfo[0].num_components
//             <    is written>: next_block_row
               next_block_row = buffer_ptr;
            else
//             <    is read   >: block_row block_rows buffer 
//                               buffer[block_row+1] cinfo 
//                               cinfo[0].num_components
//             <    is written>: next_block_row
               next_block_row = buffer[block_row+1];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               prev_block_row prev_block_row[0][0]
//             <    is written>: DC1 DC2 DC3
            /* We fetch the surrounding DC values using a sliding-register approach.
                   * Initialize all nine here so as to do the right thing on narrow pics.
                   */
            DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
//             <    is read   >: block_rows buffer_ptr 
//                               buffer_ptr[0][0] cinfo 
//                               cinfo[0].num_components
//             <    is written>: DC4 DC5 DC6
            DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               next_block_row next_block_row[0][0]
//             <    is written>: DC7 DC8 DC9
            DC7 = DC8 = DC9 = (int) next_block_row[0][0];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: output_col
            output_col = 0;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].width_in_blocks
//             <    is written>: last_block_column
            last_block_column = compptr->width_in_blocks-1;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: block_num
            for(block_num = 0; block_num <= last_block_column; block_num += 1) {
//             <may be read   >: buffer_ptr[*][*]
//             <may be written>: workspace[*]
//             <    is read   >: block_rows buffer_ptr cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
               /* Fetch current DCT block into workspace so we can modify it. */
               jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
//             <    is read   >: block_num block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
               /* Update DC values */
               if (block_num<last_block_column) {
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column prev_block_row 
//                               prev_block_row[1][0]
//             <    is written>: DC3
                  DC3 = (int) prev_block_row[1][0];
//             <    is read   >: block_rows buffer_ptr 
//                               buffer_ptr[1][0] cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC6
                  DC6 = (int) buffer_ptr[1][0];
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column next_block_row 
//                               next_block_row[1][0]
//             <    is written>: DC9
                  DC9 = (int) next_block_row[1][0];
               }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components coef_bits 
//                               coef_bits[1] last_block_column 
//                               workspace[1]
//             <    is written>: Al
               if ((Al = coef_bits[1])!=0&&workspace[1]==0) {
//             <    is read   >: DC4 DC6 Q00 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: num
                  num = 36*Q00*(DC4-DC6);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
                  if (num>=0) {
//             <    is read   >: Q01 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q01<<7)+num)/(Q01<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     /* Compute coefficient estimates per K.8.
                     	 * An estimate is applied only if coefficient is still zero,
                     	 * and is not known to be fully accurate.
                     	 */
                     /* AC01 */
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
                  }
                  else {
//             <    is read   >: Q01 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q01<<7)-num)/(Q01<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: pred
                     pred = -pred;
                  }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: workspace[1]
                  workspace[1] = (JCOEF) pred;
               }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components coef_bits 
//                               coef_bits[2] last_block_column 
//                               workspace[8]
//             <    is written>: Al
               if ((Al = coef_bits[2])!=0&&workspace[8]==0) {
//             <    is read   >: DC2 DC8 Q00 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: num
                  num = 36*Q00*(DC2-DC8);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
                  if (num>=0) {
//             <    is read   >: Q10 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q10<<7)+num)/(Q10<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     /* AC10 */
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
                  }
                  else {
//             <    is read   >: Q10 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q10<<7)-num)/(Q10<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: pred
                     pred = -pred;
                  }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: workspace[8]
                  workspace[8] = (JCOEF) pred;
               }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components coef_bits 
//                               coef_bits[3] last_block_column 
//                               workspace[16]
//             <    is written>: Al
               if ((Al = coef_bits[3])!=0&&workspace[16]==0) {
//             <    is read   >: DC2 DC5 DC8 Q00 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: num
                  num = 9*Q00*(DC2+DC8-2*DC5);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
                  if (num>=0) {
//             <    is read   >: Q20 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q20<<7)+num)/(Q20<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     /* AC20 */
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
                  }
                  else {
//             <    is read   >: Q20 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q20<<7)-num)/(Q20<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: pred
                     pred = -pred;
                  }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: workspace[16]
                  workspace[16] = (JCOEF) pred;
               }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components coef_bits 
//                               coef_bits[4] last_block_column 
//                               workspace[9]
//             <    is written>: Al
               if ((Al = coef_bits[4])!=0&&workspace[9]==0) {
//             <    is read   >: DC1 DC3 DC7 DC9 Q00 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: num
                  num = 5*Q00*(DC1-DC3-DC7+DC9);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
                  if (num>=0) {
//             <    is read   >: Q11 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q11<<7)+num)/(Q11<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     /* AC11 */
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
                  }
                  else {
//             <    is read   >: Q11 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q11<<7)-num)/(Q11<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: pred
                     pred = -pred;
                  }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: workspace[9]
                  workspace[9] = (JCOEF) pred;
               }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components coef_bits 
//                               coef_bits[5] last_block_column 
//                               workspace[2]
//             <    is written>: Al
               if ((Al = coef_bits[5])!=0&&workspace[2]==0) {
//             <    is read   >: DC4 DC5 DC6 Q00 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: num
                  num = 9*Q00*(DC4+DC6-2*DC5);
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
                  if (num>=0) {
//             <    is read   >: Q02 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q02<<7)+num)/(Q02<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     /* AC02 */
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
                  }
                  else {
//             <    is read   >: Q02 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column num
//             <    is written>: pred
                     pred = (int) (((Q02<<7)-num)/(Q02<<8));
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
                     if (Al>0&&pred>=1<<Al)
//             <    is read   >: Al block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: pred
                        pred = (1<<Al)-1;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: pred
                     pred = -pred;
                  }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column pred
//             <    is written>: workspace[2]
                  workspace[2] = (JCOEF) pred;
               }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               /* OK, do the IDCT */
               (*inverse_DCT)(cinfo,compptr,(JCOEFPTR) workspace,output_ptr,output_col);
//             <    is read   >: DC2 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC1
               /* Advance for next column */
               DC1 = DC2;
//             <    is read   >: DC3 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC2
               DC2 = DC3;
//             <    is read   >: DC5 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC4
               DC4 = DC5;
//             <    is read   >: DC6 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC5
               DC5 = DC6;
//             <    is read   >: DC8 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC7
               DC7 = DC8;
//             <    is read   >: DC9 block_rows cinfo 
//                               cinfo[0].num_components 
//                               last_block_column
//             <    is written>: DC8
               DC8 = DC9;
//             <    is read   >: block_rows buffer_ptr cinfo 
//                               cinfo[0].num_components 
//                               last_block_column next_block_row 
//                               prev_block_row
//             <    is written>: buffer_ptr next_block_row 
//                               prev_block_row
               buffer_ptr++, prev_block_row++, next_block_row++;
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               last_block_column output_col
//             <    is written>: output_col

               output_col += compptr->DCT_scaled_size;
            }
//             <    is read   >: block_rows cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size output_ptr
//             <    is written>: output_ptr
            output_ptr += compptr->DCT_scaled_size;
         }
      }
//             <    is read   >: cinfo cinfo[0].num_components
_loop_end_2:      ;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].output_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].output_iMCU_row
   if (++cinfo->output_iMCU_row<cinfo->total_iMCU_rows)
      return 3;
   return 4;
}
static int dummy_consume_data(j_decompress_ptr cinfo)
{
   return 0;
}
static boolean smoothing_ok(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is written>: smoothing_useful
   boolean smoothing_useful = 0;
   int ci, coefi;
   jpeg_component_info *compptr;
   JQUANT_TBL *qtable;
   int *coef_bits;
   int *coef_bits_latch;
//             <    is read   >: cinfo cinfo[0].coef_bits 
//                               cinfo[0].progressive_mode
   if (!cinfo->progressive_mode||cinfo->coef_bits==(void *) 0)
      return 0;
//             <    is read   >: coef coef[0].coef_bits_latch
   
   /* Allocate latch area if not already done */
   if (coef->coef_bits_latch==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      coef->coef_bits_latch = (int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,cinfo->num_components*6*(size_t) sizeof(int));
//             <    is read   >: coef coef[0].coef_bits_latch
//             <    is written>: coef_bits_latch
   coef_bits_latch = coef->coef_bits_latch;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].quant_table
//             <    is written>: qtable
      /* All components' quantization values must already be latched. */
      if ((qtable = compptr->quant_table)==(void *) 0)
//             <    is read   >: cinfo cinfo[0].num_components
         return 0;
//             <    is read   >: cinfo cinfo[0].num_components qtable 
//                               qtable[0].quantval[0] 
//                               qtable[0].quantval[1] 
//                               qtable[0].quantval[2] 
//                               qtable[0].quantval[8] 
//                               qtable[0].quantval[9] 
//                               qtable[0].quantval[16]
      /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
      
      
      
      
      
      if ((qtable->quantval)[0]==0||(qtable->quantval)[1]==0||(qtable->quantval)[8]==0||(qtable->quantval)[16]==0||(qtable->quantval)[9]==0||(qtable->quantval)[2]==0)
//             <    is read   >: cinfo cinfo[0].num_components
         return 0;
//             <    is read   >: ci cinfo cinfo[0].coef_bits 
//                               cinfo[0].num_components
//             <    is written>: coef_bits
      /* DC values must be at least partly known for all components. */
      coef_bits = (cinfo->coef_bits)[ci];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               coef_bits coef_bits[0]
      if (coef_bits[0]<0)
//             <    is read   >: cinfo cinfo[0].num_components
         return 0;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: coefi
      /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
      for(coefi = 1; coefi <= 5; coefi += 1) {
//             <    is read   >: cinfo cinfo[0].num_components 
//                               coef_bits coef_bits[coefi] 
//                               coef_bits_latch coefi
//             <    is written>: coef_bits_latch[coefi]
         coef_bits_latch[coefi] = coef_bits[coefi];
//             <    is read   >: cinfo cinfo[0].num_components 
//                               coef_bits coef_bits[coefi] coefi
         if (coef_bits[coefi]!=0)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: smoothing_useful
            smoothing_useful = 1;
      }
//             <    is read   >: cinfo cinfo[0].num_components 
//                               coef_bits_latch
//             <    is written>: coef_bits_latch
      coef_bits_latch += 6;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: smoothing_useful

   return smoothing_useful;
}
static void start_iMCU_row(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
   
   /* In an interleaved scan, an MCU row is the same as an iMCU row.
      * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
      * But at the bottom of the image, process only what's left.
      */
   if (cinfo->comps_in_scan>1)
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = 1;
   else if (cinfo->input_iMCU_row<cinfo->total_iMCU_rows-1)
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info)[0]->v_samp_factor;
   else
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height coef
//             <    is written>: coef[0].MCU_rows_per_iMCU_row
      coef->MCU_rows_per_iMCU_row = (cinfo->cur_comp_info)[0]->last_row_height;
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_ctr

   coef->MCU_ctr = 0;
//             <    is read   >: coef
//             <    is written>: coef[0].MCU_vert_offset
   coef->MCU_vert_offset = 0;
}
static void start_input_pass(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].input_iMCU_row
   cinfo->input_iMCU_row = 0;
//             <may be read   >: cinfo[0].cur_comp_info[0] 
//                               cinfo[0].cur_comp_info[0][0].last_row
//                               _height 
//                               cinfo[0].cur_comp_info[0][0].v_samp_f
//                               actor cinfo[0].input_iMCU_row 
//                               cinfo[0].total_iMCU_rows
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].comps_in_scan
//             <    is written>: cinfo[0].coef[0].MCU_ctr 
//                               cinfo[0].coef[0].MCU_rows_per_iMCU_ro
//                               w cinfo[0].coef[0].MCU_vert_offset
   start_iMCU_row(cinfo);
}
static void start_output_pass(j_decompress_ptr cinfo)
{

//             <    is read   >: cinfo cinfo[0].coef
//             <    is written>: coef
   my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
//             <    is read   >: coef coef[0].pub.coef_arrays
   if (coef->pub.coef_arrays!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      
      /* If multipass, check to see whether to use block smoothing on this pass */
      if (cinfo->do_block_smoothing&&smoothing_ok(cinfo))
//             <    is read   >: coef
//             <    is written>: coef[0].pub.decompress_data
         coef->pub.decompress_data = decompress_smooth_data;
      else
//             <    is read   >: coef
//             <    is written>: coef[0].pub.decompress_data
         coef->pub.decompress_data = decompress_data;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].output_iMCU_row

   cinfo->output_iMCU_row = 0;
}
static void build_ycc_rgb_table(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   int i;
   INT32 x;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cconvert->Cr_r_tab = (int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(int));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cconvert->Cb_b_tab = (int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(int));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cconvert->Cr_g_tab = (INT32 *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(INT32));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cconvert->Cb_g_tab = (INT32 *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(INT32));
//             <    is written>: x
   x = -128;
//             <    is written>: i

   for(i = 0; i <= 255; i += 1) {
//             <    is read   >: cconvert cconvert[0].Cr_r_tab i x
//             <    is written>: cconvert[0].Cr_r_tab[i]
      /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
      /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
      /* Cr=>R value is nearest int to 1.40200 * x */
      
      (cconvert->Cr_r_tab)[i] = (int) ((INT32) (1.40200*(1L<<16)+0.5)*x+((INT32) 1<<16-1)>>16);
//             <    is read   >: cconvert cconvert[0].Cb_b_tab i x
//             <    is written>: cconvert[0].Cb_b_tab[i]
      /* Cb=>B value is nearest int to 1.77200 * x */
      
      (cconvert->Cb_b_tab)[i] = (int) ((INT32) (1.77200*(1L<<16)+0.5)*x+((INT32) 1<<16-1)>>16);
//             <    is read   >: cconvert cconvert[0].Cr_g_tab i x
//             <    is written>: cconvert[0].Cr_g_tab[i]
      /* Cr=>G value is scaled-up -0.71414 * x */
      (cconvert->Cr_g_tab)[i] = -((INT32) (0.71414*(1L<<16)+0.5))*x;
//             <    is read   >: cconvert cconvert[0].Cb_g_tab i x
//             <    is written>: cconvert[0].Cb_g_tab[i]
      /* Cb=>G value is scaled-up -0.34414 * x */
      /* We also add in ONE_HALF so that need not do it in inner loop */
      (cconvert->Cb_g_tab)[i] = -((INT32) (0.34414*(1L<<16)+0.5))*x+((INT32) 1<<16-1);
//             <    is read   >: x
//             <    is written>: x
      x++;
   }
}
static void grayscale_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION input_row, JSAMPARRAY output_buf, int num_rows)
{
//             <may be read   >: input_buf[0][0] output_buf[0]
//             <    is read   >: cinfo cinfo[0].output_width input_buf
//                               input_buf[0] input_row num_rows 
//                               output_buf

   jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0, num_rows, cinfo->output_width);
}
static void null_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION input_row, JSAMPARRAY output_buf, int num_rows)
{
   register JSAMPROW inptr, outptr;
   register JDIMENSION count;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: num_components
   register int num_components = cinfo->num_components;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->output_width;
   int ci;
//             <    is read   >: num_rows
//             <    is written>: num_rows

   while (--num_rows>=0) {
//             <    is read   >: num_components
//             <    is written>: ci
      for(ci = 0; ci <= num_components-1; ci += 1) {
//             <    is read   >: ci input_buf input_buf[ci] 
//                               input_buf[ci][input_row] input_row 
//                               num_components
//             <    is written>: inptr
         inptr = input_buf[ci][input_row];
//             <    is read   >: ci num_components output_buf 
//                               output_buf[0]
//             <    is written>: outptr
         outptr = output_buf[0]+ci;
//             <    is read   >: num_cols num_components
//             <    is written>: count
         for(count = num_cols; count >= 1; count += -1) {
//             <    is read   >: inptr inptr[0] num_cols 
//                               num_components outptr
//             <    is written>: inptr outptr[0]
            *outptr = *inptr++;
//             <    is read   >: num_cols num_components outptr
//             <    is written>: outptr
            /* needn't bother with GETJSAMPLE() here */
            outptr += num_components;
         }
      }
//             <    is read   >: input_row
//             <    is written>: input_row
      input_row++;
//             <    is read   >: output_buf
//             <    is written>: output_buf
      output_buf++;
   }
}
static void start_pass_dcolor(j_decompress_ptr cinfo)
{
}
static void ycc_rgb_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION input_row, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   register int y, cb, cr;
   register JSAMPROW outptr;
   register JSAMPROW inptr0, inptr1, inptr2;
   register JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->output_width;
   /* copy these pointers into registers if possible */
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   register JSAMPLE *range_limit = cinfo->sample_range_limit;
//             <    is read   >: cconvert cconvert[0].Cr_r_tab
//             <    is written>: Crrtab
   register int *Crrtab = cconvert->Cr_r_tab;
//             <    is read   >: cconvert cconvert[0].Cb_b_tab
//             <    is written>: Cbbtab
   register int *Cbbtab = cconvert->Cb_b_tab;
//             <    is read   >: cconvert cconvert[0].Cr_g_tab
//             <    is written>: Crgtab
   register INT32 *Crgtab = cconvert->Cr_g_tab;
//             <    is read   >: cconvert cconvert[0].Cb_g_tab
//             <    is written>: Cbgtab
   register INT32 *Cbgtab = cconvert->Cb_g_tab;
//             <    is read   >: num_rows
//             <    is written>: num_rows
   
   
   while (--num_rows>=0) {
//             <    is read   >: input_buf input_buf[0] 
//                               input_buf[0][input_row] input_row
//             <    is written>: inptr0
      inptr0 = input_buf[0][input_row];
//             <    is read   >: input_buf input_buf[1] 
//                               input_buf[1][input_row] input_row
//             <    is written>: inptr1
      inptr1 = input_buf[1][input_row];
//             <    is read   >: input_buf input_buf[2] 
//                               input_buf[2][input_row] input_row
//             <    is written>: inptr2
      inptr2 = input_buf[2][input_row];
//             <    is read   >: input_row
//             <    is written>: input_row
      input_row++;
//             <    is read   >: output_buf output_buf[0]
//             <    is written>: outptr output_buf
      outptr = *output_buf++;
//             <    is read   >: num_cols
//             <    is written>: col
      for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: col inptr0 inptr0[col] num_cols
//             <    is written>: y
         y = (int) inptr0[col];
//             <    is read   >: col inptr1 inptr1[col] num_cols
//             <    is written>: cb
         cb = (int) inptr1[col];
//             <    is read   >: col inptr2 inptr2[col] num_cols
//             <    is written>: cr
         cr = (int) inptr2[col];
//             <    is read   >: Crrtab Crrtab[cr] cr num_cols outptr 
//                               range_limit range_limit[y+Crrtab[cr]]
//                               y
//             <    is written>: outptr[0]
         /* Range-limiting is essential due to noise introduced by DCT losses. */
         outptr[0] = range_limit[y+Crrtab[cr]];
//             <    is read   >: Cbgtab Cbgtab[cb] Crgtab Crgtab[cr] 
//                               cb cr num_cols outptr range_limit 
//                               range_limit[y+(int)
//                               (Cbgtab[cb]+Crgtab[cr]>>16)] y
//             <    is written>: outptr[1]
         outptr[1] = range_limit[y+(int) (Cbgtab[cb]+Crgtab[cr]>>16)];
//             <    is read   >: Cbbtab Cbbtab[cb] cb num_cols outptr 
//                               range_limit range_limit[y+Cbbtab[cb]]
//                               y
//             <    is written>: outptr[2]
         outptr[2] = range_limit[y+Cbbtab[cb]];
//             <    is read   >: num_cols outptr
//             <    is written>: outptr
         outptr += 3;
      }
   }
}
static void ycck_cmyk_convert(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION input_row, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cconvert
//             <    is written>: cconvert
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   register int y, cb, cr;
   register JSAMPROW outptr;
   register JSAMPROW inptr0, inptr1, inptr2, inptr3;
   register JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: num_cols
   JDIMENSION num_cols = cinfo->output_width;
   /* copy these pointers into registers if possible */
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   register JSAMPLE *range_limit = cinfo->sample_range_limit;
//             <    is read   >: cconvert cconvert[0].Cr_r_tab
//             <    is written>: Crrtab
   register int *Crrtab = cconvert->Cr_r_tab;
//             <    is read   >: cconvert cconvert[0].Cb_b_tab
//             <    is written>: Cbbtab
   register int *Cbbtab = cconvert->Cb_b_tab;
//             <    is read   >: cconvert cconvert[0].Cr_g_tab
//             <    is written>: Crgtab
   register INT32 *Crgtab = cconvert->Cr_g_tab;
//             <    is read   >: cconvert cconvert[0].Cb_g_tab
//             <    is written>: Cbgtab
   register INT32 *Cbgtab = cconvert->Cb_g_tab;
//             <    is read   >: num_rows
//             <    is written>: num_rows
   
   
   while (--num_rows>=0) {
//             <    is read   >: input_buf input_buf[0] 
//                               input_buf[0][input_row] input_row
//             <    is written>: inptr0
      inptr0 = input_buf[0][input_row];
//             <    is read   >: input_buf input_buf[1] 
//                               input_buf[1][input_row] input_row
//             <    is written>: inptr1
      inptr1 = input_buf[1][input_row];
//             <    is read   >: input_buf input_buf[2] 
//                               input_buf[2][input_row] input_row
//             <    is written>: inptr2
      inptr2 = input_buf[2][input_row];
//             <    is read   >: input_buf input_buf[3] 
//                               input_buf[3][input_row] input_row
//             <    is written>: inptr3
      inptr3 = input_buf[3][input_row];
//             <    is read   >: input_row
//             <    is written>: input_row
      input_row++;
//             <    is read   >: output_buf output_buf[0]
//             <    is written>: outptr output_buf
      outptr = *output_buf++;
//             <    is read   >: num_cols
//             <    is written>: col
      for(col = 0; col <= num_cols-1; col += 1) {
//             <    is read   >: col inptr0 inptr0[col] num_cols
//             <    is written>: y
         y = (int) inptr0[col];
//             <    is read   >: col inptr1 inptr1[col] num_cols
//             <    is written>: cb
         cb = (int) inptr1[col];
//             <    is read   >: col inptr2 inptr2[col] num_cols
//             <    is written>: cr
         cr = (int) inptr2[col];
//             <    is read   >: Crrtab Crrtab[cr] cr num_cols outptr 
//                               range_limit 
//                               range_limit[255-(y+Crrtab[cr])] y
//             <    is written>: outptr[0]
         /* Range-limiting is essential due to noise introduced by DCT losses. */
         outptr[0] = range_limit[255-(y+Crrtab[cr])];
//             <    is read   >: Cbgtab Cbgtab[cb] Crgtab Crgtab[cr] 
//                               cb cr num_cols outptr range_limit 
//                               range_limit[255-(y+(int)
//                               (Cbgtab[cb]+Crgtab[cr]>>16))] y
//             <    is written>: outptr[1]
         /* red */
         /* green */
         outptr[1] = range_limit[255-(y+(int) (Cbgtab[cb]+Crgtab[cr]>>16))];
//             <    is read   >: Cbbtab Cbbtab[cb] cb num_cols outptr 
//                               range_limit 
//                               range_limit[255-(y+Cbbtab[cb])] y
//             <    is written>: outptr[2]
         outptr[2] = range_limit[255-(y+Cbbtab[cb])];
//             <    is read   >: col inptr3 inptr3[col] num_cols 
//                               outptr
//             <    is written>: outptr[3]
         /* blue */
         /* K passes through unchanged */
         outptr[3] = inptr3[col];
//             <    is read   >: num_cols outptr
//             <    is written>: outptr
         /* don't need GETJSAMPLE here */
         outptr += 4;
      }
   }
}
static void start_pass(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].idct
//             <    is written>: idct
   my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
   int ci, i;
   jpeg_component_info *compptr;
//             <    is written>: method
   int method = 0;
//             <    is written>: method_ptr
   inverse_DCT_method_ptr method_ptr = (void *) 0;
   JQUANT_TBL *qtbl;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].DCT_scaled_size
      /* Select the proper IDCT routine for this component's scaling */
      if (compptr->DCT_scaled_size==1) {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_2_case_1:         ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method_ptr
         method_ptr = jpeg_idct_1x1;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method
         method = JDCT_ISLOW;
         /* jidctred uses islow-style table */
         ;
      }
      else if (compptr->DCT_scaled_size==2) {
//             <    is read   >: cinfo cinfo[0].num_components
_switch_2_case_2:         ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method_ptr
         method_ptr = jpeg_idct_2x2;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method
         method = JDCT_ISLOW;
         /* jidctred uses islow-style table */
         ;
      }
      else if (compptr->DCT_scaled_size==4) {
//             <    is read   >: cinfo cinfo[0].num_components
_switch_2_case_4:         ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method_ptr
         method_ptr = jpeg_idct_4x4;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method
         method = JDCT_ISLOW;
         /* jidctred uses islow-style table */
         ;
      }
      else if (compptr->DCT_scaled_size==8) {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_2_case_8:         ;
//             <    is read   >: cinfo cinfo[0].dct_method 
//                               cinfo[0].num_components
         if (cinfo->dct_method==JDCT_ISLOW) {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_3_case_JDCT_ISLOW:            ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method_ptr
            method_ptr = jpeg_idct_islow;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method
            method = JDCT_ISLOW;
         }
         else if (cinfo->dct_method==JDCT_IFAST) {
//             <    is read   >: cinfo cinfo[0].num_components
            
            
_switch_3_case_JDCT_IFAST:            ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method_ptr
            method_ptr = jpeg_idct_ifast;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method
            method = JDCT_IFAST;
         }
         else if (cinfo->dct_method==JDCT_FLOAT) {
//             <    is read   >: cinfo cinfo[0].num_components
            
            
_switch_3_case_JDCT_FLOAT:            ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method_ptr
            method_ptr = jpeg_idct_float;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: method
            method = JDCT_FLOAT;
         }
         else {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_3_default:            ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_NOT_COMPILED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
         }
//             <    is read   >: cinfo cinfo[0].num_components
_break_3:         ;
      }
      else {
//             <    is read   >: cinfo cinfo[0].num_components
_switch_2_default:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_DCTSIZE, (cinfo->err->msg_parm.i)[0] = compptr->DCT_scaled_size, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
//             <    is read   >: cinfo cinfo[0].num_components
_break_2:      ;
//             <    is read   >: ci cinfo cinfo[0].num_components idct
//                               method_ptr
//             <    is written>: idct[0].pub.inverse_DCT[ci]
      (idct->pub.inverse_DCT)[ci] = method_ptr;
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               compptr compptr[0].component_needed 
//                               idct idct[0].cur_method[ci] method
      /* Create multiplier table from quant table.
           * However, we can skip this if the component is uninteresting
           * or if we already built the table.  Also, if no quant table
           * has yet been saved for the component, we leave the
           * multiplier table all-zero; we'll be reading zeroes from the
           * coefficient controller's buffer anyway.
           */
      if (!compptr->component_needed||(idct->cur_method)[ci]==method)
         ;
      else {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].quant_table
//             <    is written>: qtbl
         qtbl = compptr->quant_table;
//             <    is read   >: cinfo cinfo[0].num_components qtbl
         if (qtbl==(void *) 0)
            /* happens if no data yet for component */
            ;
         else {
//             <    is read   >: ci cinfo cinfo[0].num_components idct
//                               method
//             <    is written>: idct[0].cur_method[ci]
            (idct->cur_method)[ci] = method;
//             <    is read   >: cinfo cinfo[0].num_components method
            if (method==JDCT_ISLOW) {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_4_case_JDCT_ISLOW:               ;
               {
                  /* For LL&M IDCT method, multipliers are equal to raw quantization
                  	 * coefficients, but are stored as ints to ensure access efficiency.
                  	 */
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: ismtbl
                  ISLOW_MULT_TYPE *ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i
                  for(i = 0; i <= 63; i += 1)
//             <    is read   >: cinfo cinfo[0].num_components i 
//                               ismtbl qtbl qtbl[0].quantval[i]
//             <    is written>: ismtbl[i]
                     ismtbl[i] = (ISLOW_MULT_TYPE) (qtbl->quantval)[i];
               }
            }
            else if (method==JDCT_IFAST) {
//             <    is read   >: cinfo cinfo[0].num_components
               
               
_switch_4_case_JDCT_IFAST:               ;
               {
                  /* For AA&N IDCT method, multipliers are equal to quantization
                  	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
                  	 *   scalefactor[0] = 1
                  	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
                  	 * For integer operation, the multiplier table is to be scaled by
                  	 * IFAST_SCALE_BITS.
                  	 */
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: ifmtbl
                  IFAST_MULT_TYPE *ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
                  
                  
                  /* precomputed values scaled up by 14 bits */
                  
                  
                  
                  
                  
                  
                  
                  
                  static const  INT16 aanscales[64] = {16384, 22725, 21407, 19266, 16384, 12873, 8867, 4520, 22725, 31521, 29692, 26722, 22725, 17855, 12299, 6270, 21407, 29692, 27969, 25172, 21407, 16819, 11585, 5906, 19266, 26722, 25172, 22654, 19266, 15137, 10426, 5315, 16384, 22725, 21407, 19266, 16384, 12873, 8867, 4520, 12873, 17855, 16819, 15137, 12873, 10114, 6967, 3552, 8867, 12299, 11585, 10426, 8867, 6967, 4799, 2446, 4520, 6270, 5906, 5315, 4520, 3552, 2446, 1247};
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i
                  
                  
                  for(i = 0; i <= 63; i += 1)
//             <    is read   >: aanscales[i] cinfo 
//                               cinfo[0].num_components i ifmtbl qtbl
//                               qtbl[0].quantval[i]
//             <    is written>: ifmtbl[i]

                     ifmtbl[i] = (IFAST_MULT_TYPE) ((INT32) (qtbl->quantval)[i]*(INT32) aanscales[i]+((INT32) 1<<14-2-1)>>14-2);
               }
            }
            else if (method==JDCT_FLOAT) {
//             <    is read   >: cinfo cinfo[0].num_components
               
               
_switch_4_case_JDCT_FLOAT:               ;
               {
                  /* For float AA&N IDCT method, multipliers are equal to quantization
                  	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
                  	 *   scalefactor[0] = 1
                  	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
                  	 */
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: fmtbl
                  FLOAT_MULT_TYPE *fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
                  int row, col;
                  
                  
                  
                  static const  double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379};
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i

                  i = 0;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: row
                  for(row = 0; row <= 7; row += 1)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: col
                     for(col = 0; col <= 7; col += 1) {
//             <    is read   >: aanscalefactor[col] 
//                               aanscalefactor[row] cinfo 
//                               cinfo[0].num_components col fmtbl i 
//                               qtbl qtbl[0].quantval[i] row
//             <    is written>: fmtbl[i]
                        fmtbl[i] = (FLOAT_MULT_TYPE) ((double) (qtbl->quantval)[i]*aanscalefactor[row]*aanscalefactor[col]);
//             <    is read   >: cinfo cinfo[0].num_components i
//             <    is written>: i
                        i++;
                     }
               }
            }
            else {
//             <    is read   >: cinfo cinfo[0].num_components

_switch_4_default:               ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               cinfo->err->msg_code = JERR_NOT_COMPILED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
            }
//             <    is read   >: cinfo cinfo[0].num_components
_break_4:            ;
         }
      }
//             <    is read   >: cinfo cinfo[0].num_components
_loop_end_1:      ;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static boolean decode_mcu(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   register int s, k, r;
   int blkn, ci;
   JBLOCKROW block;
   register bit_buf_type get_buffer;
   register int bits_left;
   bitread_working_state br_state;
   savable_state state;
   d_derived_tbl *dctbl;
   d_derived_tbl *actbl;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!process_restart(cinfo))
            return 0;
//             <    is read   >: cinfo
//             <    is written>: br_state.cinfo
   
   /* Load up working state */
   br_state.cinfo = cinfo;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].next_input_byte
//             <    is written>: br_state.next_input_byte
   br_state.next_input_byte = cinfo->src->next_input_byte;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].bytes_in_buffer
//             <    is written>: br_state.bytes_in_buffer
   br_state.bytes_in_buffer = cinfo->src->bytes_in_buffer;
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: br_state.unread_marker
   br_state.unread_marker = cinfo->unread_marker;
//             <    is read   >: entropy 
//                               entropy[0].bitstate.get_buffer
//             <    is written>: get_buffer
   get_buffer = entropy->bitstate.get_buffer;
//             <    is read   >: entropy entropy[0].bitstate.bits_left
//             <    is written>: bits_left
   bits_left = entropy->bitstate.bits_left;
//             <    is read   >: entropy
//             <    is written>: br_state.printed_eod_ptr
   br_state.printed_eod_ptr = &entropy->bitstate.printed_eod;
//             <may be read   >: entropy[0].saved.last_dc_val[*]
//             <may be written>: state.last_dc_val[*]
//             <    is read   >: entropy
   state = entropy->saved;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn
   
   /* Outer loop handles each block in the MCU */
   
   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: MCU_data MCU_data[blkn] blkn cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: block
      block = MCU_data[blkn];
//             <    is read   >: blkn cinfo 
//                               cinfo[0].MCU_membership[blkn] 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: ci
      ci = (cinfo->MCU_membership)[blkn];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU compptr 
//                               compptr[0].dc_tbl_no entropy 
//                               entropy[0].dc_derived_tbls[compptr->d
//                               c_tbl_no]
//             <    is written>: dctbl
      dctbl = (entropy->dc_derived_tbls)[compptr->dc_tbl_no];
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU compptr 
//                               compptr[0].ac_tbl_no entropy 
//                               entropy[0].ac_derived_tbls[compptr->a
//                               c_tbl_no]
//             <    is written>: actbl
      actbl = (entropy->ac_derived_tbls)[compptr->ac_tbl_no];
      {
         register int nb, look;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) goto l99999;
l99996:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer
//             <    is written>: 0`2`3`look
         look = (int) (get_buffer>>bits_left-8)&(1<<8)-1;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU dctbl 
//                               dctbl[0].look_nbits[look] 0`2`3`look
//             <    is written>: 0`2`3`nb
         if ((nb = (dctbl->look_nbits)[look])!=0) goto l99998;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: 0`2`3`nb
         nb = 8+1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
label1:         if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, dctbl, nb))<0)
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
         goto l99997;
l99998:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU 0`2`3`nb
//             <    is written>: bits_left
         bits_left -= nb;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU dctbl 
//                               dctbl[0].look_sym[look] 0`2`3`look
//             <    is written>: s
         s = (dctbl->look_sym)[look];
         goto l99997;
l99999:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) {
         }
         else {
            goto l99996;
         }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: 0`2`3`nb
         nb = 1;
         goto label1;
l99997:         ;
      }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s
      if (s) {
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU s
         if (bits_left<s) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, s))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
               return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
            get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
            bits_left = br_state.bits_left;
         }
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer s
//             <    is written>: bits_left r
         r = (int) (get_buffer>>(bits_left -= s))&(1<<s)-1;
//             <may be read   >: extend_offset[*]
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU r s 
//                               extend_test[s]
//             <    is written>: s
         s = r<extend_test[s]?r+extend_offset[s]:r;
      }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU compptr 
//                               compptr[0].component_needed

/* Shortcut if component's values are not interesting */
      if (!compptr->component_needed) goto skip_ACs;
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU s 
//                               state.last_dc_val[ci]
//             <    is written>: s
      
      /* Convert DC difference to actual value, update last_dc_val */
      s += (state.last_dc_val)[ci];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: state.last_dc_val[ci]
      (state.last_dc_val)[ci] = s;
//             <    is read   >: block cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: block[0][0]
      /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
      (*block)[0] = (JCOEF) s;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU compptr 
//                               compptr[0].DCT_scaled_size

/* Do we need to decode the AC coefficients for this component? */
      if (compptr->DCT_scaled_size>1) goto l99995;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
skip_ACs:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: k
      k = 1;
l99992:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k

/* Section F.2.2.2: decode the AC coefficients */
/* In this path we just discard the values */
      if (!(k<64)) goto _break_3;
      {
         register int nb, look;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) goto l99990;
l99987:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer
//             <    is written>: 0`2`28`29`30`look
         look = (int) (get_buffer>>bits_left-8)&(1<<8)-1;
//             <    is read   >: actbl actbl[0].look_nbits[look] cinfo
//                               cinfo[0].blocks_in_MCU 
//                               0`2`28`29`30`look
//             <    is written>: 0`2`28`29`30`nb
         if ((nb = (actbl->look_nbits)[look])!=0) goto l99989;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: 0`2`28`29`30`nb
         nb = 8+1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
label3:         if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, actbl, nb))<0)
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
         goto l99988;
l99989:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU 
//                               0`2`28`29`30`nb
//             <    is written>: bits_left
         bits_left -= nb;
//             <    is read   >: actbl actbl[0].look_sym[look] cinfo 
//                               cinfo[0].blocks_in_MCU 
//                               0`2`28`29`30`look
//             <    is written>: s
         s = (actbl->look_sym)[look];
         goto l99988;
l99990:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) {
         }
         else {
            goto l99987;
         }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: 0`2`28`29`30`nb
         nb = 1;
         goto label3;
l99988:         ;
      }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: r

      r = s>>4;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: s
      s &= 15;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s

      if (s) goto l99993;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU r
      if (r!=15) goto _break_3;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k
//             <    is written>: k
      k += 15;
l99991:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k
//             <    is written>: k
      k++;
      goto l99992;
l99993:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k r
//             <    is written>: k
      k += r;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU s
      if (bits_left<s) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, s))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
      }
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU s
//             <    is written>: bits_left
      bits_left -= s;
      goto l99991;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
_break_3:      ;
      goto l99994;
l99995:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: k
      k = 1;
l99985:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k

/* Section F.2.2.2: decode the AC coefficients */
/* Since zeroes are skipped, output area must be cleared beforehand */
      if (!(k<64)) goto _break_2;
      {
         register int nb, look;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) goto l99983;
l99980:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer
//             <    is written>: 0`2`14`15`16`look
         look = (int) (get_buffer>>bits_left-8)&(1<<8)-1;
//             <    is read   >: actbl actbl[0].look_nbits[look] cinfo
//                               cinfo[0].blocks_in_MCU 
//                               0`2`14`15`16`look
//             <    is written>: 0`2`14`15`16`nb
         if ((nb = (actbl->look_nbits)[look])!=0) goto l99982;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: 0`2`14`15`16`nb
         nb = 8+1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
label2:         if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, actbl, nb))<0)
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
         goto l99981;
l99982:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU 
//                               0`2`14`15`16`nb
//             <    is written>: bits_left
         bits_left -= nb;
//             <    is read   >: actbl actbl[0].look_sym[look] cinfo 
//                               cinfo[0].blocks_in_MCU 
//                               0`2`14`15`16`look
//             <    is written>: s
         s = (actbl->look_sym)[look];
         goto l99981;
l99983:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) {
         }
         else {
            goto l99980;
         }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: 0`2`14`15`16`nb
         nb = 1;
         goto label2;
l99981:         ;
      }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: r

      r = s>>4;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: s
      s &= 15;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s

      if (s) goto l99986;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU r
      if (r!=15) goto _break_2;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k
//             <    is written>: k
      k += 15;
l99984:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k
//             <    is written>: k
      k++;
      goto l99985;
l99986:      ;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU k r
//             <    is written>: k
      k += r;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU s
      if (bits_left<s) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, s))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
      }
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer s
//             <    is written>: bits_left r
      r = (int) (get_buffer>>(bits_left -= s))&(1<<s)-1;
//             <may be read   >: extend_offset[*]
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU r s 
//                               extend_test[s]
//             <    is written>: s
      s = r<extend_test[s]?r+extend_offset[s]:r;
//             <    is read   >: block cinfo cinfo[0].blocks_in_MCU 
//                               jpeg_natural_order[k] k s
//             <    is written>: block[0][jpeg_natural_order[k]]
      /* Output coefficient in natural (dezigzagged) order.
      	   * Note: the extra entries in jpeg_natural_order[] will save us
      	   * if k >= DCTSIZE2, which could happen if the data is corrupted.
      	   */
      (*block)[jpeg_natural_order[k]] = (JCOEF) s;
      goto l99984;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
_break_2:      ;
l99994:      ;
   }
//             <    is read   >: br_state.next_input_byte cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].next_input_byte
   
   /* Completed MCU, so update state */
   cinfo->src->next_input_byte = br_state.next_input_byte;
//             <    is read   >: br_state.bytes_in_buffer cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].bytes_in_buffer
   cinfo->src->bytes_in_buffer = br_state.bytes_in_buffer;
//             <    is read   >: br_state.unread_marker cinfo
//             <    is written>: cinfo[0].unread_marker
   cinfo->unread_marker = br_state.unread_marker;
//             <    is read   >: entropy get_buffer
//             <    is written>: entropy[0].bitstate.get_buffer
   entropy->bitstate.get_buffer = get_buffer;
//             <    is read   >: bits_left entropy
//             <    is written>: entropy[0].bitstate.bits_left
   entropy->bitstate.bits_left = bits_left;
//             <may be read   >: state.last_dc_val[*]
//             <may be written>: entropy[0].saved.last_dc_val[*]
//             <    is read   >: entropy
   entropy->saved = state;
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
   
   /* Account for restart interval (no-op if not using restarts) */
   entropy->restarts_to_go--;

   return 1;
}
static boolean process_restart(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   int ci;
//             <    is read   >: cinfo cinfo[0].marker cinfo[0].marker
//                               cinfo[0].marker[0].discarded_bytes 
//                               entropy entropy[0].bitstate.bits_left
//             <    is written>: cinfo[0].marker[0].discarded_bytes
   
   /* Throw away any unused bits remaining in bit buffer; */
   /* include any full bytes in next_marker's count of discarded bytes */
   cinfo->marker->discarded_bytes += entropy->bitstate.bits_left/8;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.bits_left
   entropy->bitstate.bits_left = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Advance past the RSTn marker */
   if (!(*cinfo->marker->read_restart_marker)(cinfo))
      return 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Re-initialize DC predictions to 0 */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
      (entropy->saved.last_dc_val)[ci] = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
   
   /* Reset restart counter */
   entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.printed_eod
   
   /* Next segment can get another out-of-data warning */
   entropy->bitstate.printed_eod = 0;

   return 1;
}
static void start_pass_huff_decoder(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   int ci, dctbl, actbl;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].Ah cinfo[0].Al 
//                               cinfo[0].Se cinfo[0].Ss
   
   /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
      * This ought to be an error condition, but we make it a warning because
      * there are some baseline files out there with all zeroes in these bytes.
      */
   
   if (cinfo->Ss!=0||cinfo->Se!=64-1||cinfo->Ah!=0||cinfo->Al!=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_NOT_SEQUENTIAL, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: dctbl
      dctbl = compptr->dc_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no
//             <    is written>: actbl
      actbl = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].dc_huff_tbl_ptrs[dctbl] 
//                               dctbl
      /* Make sure requested tables are present */
      
      if (dctbl<0||dctbl>=4||(cinfo->dc_huff_tbl_ptrs)[dctbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = dctbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: actbl cinfo 
//                               cinfo[0].ac_huff_tbl_ptrs[actbl] 
//                               cinfo[0].comps_in_scan
      if (actbl<0||actbl>=4||(cinfo->ac_huff_tbl_ptrs)[actbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = actbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      
      jpeg_make_d_derived_tbl(cinfo, (cinfo->dc_huff_tbl_ptrs)[dctbl], &(entropy->dc_derived_tbls)[dctbl]);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      jpeg_make_d_derived_tbl(cinfo, (cinfo->ac_huff_tbl_ptrs)[actbl], &(entropy->ac_derived_tbls)[actbl]);
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
      /* Initialize DC predictions to 0 */
      (entropy->saved.last_dc_val)[ci] = 0;
   }
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.bits_left
   
   /* Initialize bitread state variables */
   entropy->bitstate.bits_left = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.get_buffer
   entropy->bitstate.get_buffer = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.printed_eod
   /* unnecessary, but keeps Purify quiet */
   entropy->bitstate.printed_eod = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
   
   /* Initialize restart counter */
   entropy->restarts_to_go = cinfo->restart_interval;
}
static int consume_markers(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].inputctl
//             <    is written>: inputctl
   my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
   int val;
//             <    is read   >: inputctl inputctl[0].pub.eoi_reached

   if (inputctl->pub.eoi_reached)
      /* After hitting EOI, read no further */
      return 2;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   val = (*cinfo->marker->read_markers)(cinfo);
//             <    is read   >: val

   if (val==1) {
_switch_1_case_1:      ;
//             <    is read   >: inputctl inputctl[0].inheaders
      /* Found SOS */
      if (inputctl->inheaders) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* 1st SOS */
         initial_setup(cinfo);
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].inheaders
         inputctl->inheaders = 0;
      }
      else {
//             <    is read   >: inputctl 
//                               inputctl[0].pub.has_multiple_scans
         /* 2nd or later SOS marker */
         if (!inputctl->pub.has_multiple_scans)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_EOI_EXPECTED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Oops, I wasn't expecting this! */
         start_input_pass(cinfo);
      }
   }
   else if (val==2) {
_switch_1_case_2:      ;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.eoi_reached
      /* Found EOI */
      inputctl->pub.eoi_reached = 1;
//             <    is read   >: inputctl inputctl[0].inheaders
      if (inputctl->inheaders) {
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].saw_SOF
         /* Tables-only datastream, apparently */
         if (cinfo->marker->saw_SOF)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_SOF_NO_SOS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
      else
//             <    is read   >: cinfo cinfo[0].input_scan_number 
//                               cinfo[0].output_scan_number
         /* Prevent infinite loop in coef ctlr's decompress_data routine
                * if user set output_scan_number larger than number of scans.
                */
         if (cinfo->output_scan_number>cinfo->input_scan_number)
//             <    is read   >: cinfo cinfo[0].input_scan_number
//             <    is written>: cinfo[0].output_scan_number
            cinfo->output_scan_number = cinfo->input_scan_number;
   }
   else if (val==0)
_switch_1_case_0:      ;
_break_1:   ;
//             <    is read   >: val

   return val;
}
static void finish_input_pass(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].inputctl
//             <    is written>: cinfo[0].inputctl[0].consume_input
   cinfo->inputctl->consume_input = consume_markers;
}
static void initial_setup(j_decompress_ptr cinfo)
{
   int ci;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].image_width
   
   /* Make sure image isn't bigger than I can handle */
   
   if ((long int) cinfo->image_height>(long int) 65500L||(long int) cinfo->image_width>(long int) 65500L)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_IMAGE_TOO_BIG, (cinfo->err->msg_parm.i)[0] = (unsigned int) 65500L, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].data_precision
   
   /* For now, precision must match compiled-in value... */
   if (cinfo->data_precision!=8)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_PRECISION, (cinfo->err->msg_parm.i)[0] = cinfo->data_precision, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components
   
   /* Check that number of components won't exceed internal array sizes */
   if (cinfo->num_components>10)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = cinfo->num_components, (cinfo->err->msg_parm.i)[1] = 10, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].max_h_samp_factor
   
   /* Compute maximum sampling factors; check factor validity */
   cinfo->max_h_samp_factor = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].max_v_samp_factor
   cinfo->max_v_samp_factor = 1;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].h_samp_factor 
//                               compptr[0].h_samp_factor 
//                               compptr[0].v_samp_factor 
//                               compptr[0].v_samp_factor

      if (compptr->h_samp_factor<=0||compptr->h_samp_factor>4||compptr->v_samp_factor<=0||compptr->v_samp_factor>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_SAMPLING, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: cinfo[0].max_h_samp_factor
      cinfo->max_h_samp_factor = cinfo->max_h_samp_factor>compptr->h_samp_factor?cinfo->max_h_samp_factor:compptr->h_samp_factor;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: cinfo[0].max_v_samp_factor
      cinfo->max_v_samp_factor = cinfo->max_v_samp_factor>compptr->v_samp_factor?cinfo->max_v_samp_factor:compptr->v_samp_factor;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].min_DCT_scaled_size
   
   /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
      * In the full decompressor, this will be overridden by jdmaster.c;
      * but in the transcoder, jdmaster.c is not used, so we must do it here.
      */
   cinfo->min_DCT_scaled_size = 8;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* Compute dimensions of components */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr[0].DCT_scaled_size
      compptr->DCT_scaled_size = 8;
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].width_in_blocks
      /* Size in DCT blocks */
      
      
      compptr->width_in_blocks = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width*(long int) compptr->h_samp_factor, (long int) (cinfo->max_h_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].height_in_blocks
      compptr->height_in_blocks = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height*(long int) compptr->v_samp_factor, (long int) (cinfo->max_v_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].downsampled_width
      /* downsampled_width and downsampled_height will also be overridden by
           * jdmaster.c if we are doing full decompression.  The transcoder library
           * doesn't use these values, but the calling application might.
           */
      /* Size in samples */
      
      
      compptr->downsampled_width = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width*(long int) compptr->h_samp_factor, (long int) cinfo->max_h_samp_factor);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].downsampled_height
      
      
      compptr->downsampled_height = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height*(long int) compptr->v_samp_factor, (long int) cinfo->max_v_samp_factor);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr[0].component_needed
      /* Mark component needed, until color conversion says otherwise */
      compptr->component_needed = 1;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr[0].quant_table
      /* Mark no quantization table yet saved for component */
      compptr->quant_table = (void *) 0;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor
//             <    is written>: cinfo[0].total_iMCU_rows
   
   /* Compute number of fully interleaved MCU rows. */
   
   
   cinfo->total_iMCU_rows = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, (long int) (cinfo->max_v_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].num_components 
//                               cinfo[0].progressive_mode
   
   /* Decide whether file contains multiple scans */
   if (cinfo->comps_in_scan<cinfo->num_components||cinfo->progressive_mode)
//             <    is read   >: cinfo cinfo[0].inputctl
//             <    is written>: 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns
      cinfo->inputctl->has_multiple_scans = 1;
   else
//             <    is read   >: cinfo cinfo[0].inputctl
//             <    is written>: 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns
      cinfo->inputctl->has_multiple_scans = 0;
}
static void latch_quant_tables(j_decompress_ptr cinfo)
{
   int ci, qtblno;
   jpeg_component_info *compptr;
   JQUANT_TBL *qtbl;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].quant_table
      /* No work if we already saved Q-table for this component */
      if (compptr->quant_table!=(void *) 0)
         ;
      else {
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].quant_tbl_no
//             <    is written>: qtblno
         /* Make sure specified quantization table is present */
         qtblno = compptr->quant_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].quant_tbl_ptrs[qtblno] 
//                               qtblno
         if (qtblno<0||qtblno>=4||(cinfo->quant_tbl_ptrs)[qtblno]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_NO_QUANT_TABLE, (cinfo->err->msg_parm.i)[0] = qtblno, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* OK, save away the quantization table */
         
         qtbl = (JQUANT_TBL *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(JQUANT_TBL));
//             <may be read   >: 
//                               cinfo[0].quant_tbl_ptrs[qtblno][*].qu
//                               antval[*] 
//                               cinfo[0].quant_tbl_ptrs[qtblno][*].se
//                               nt_table
//             <may be written>: qtbl[*].quantval[*] 
//                               qtbl[*].sent_table
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].quant_tbl_ptrs[qtblno] qtbl 
//                               qtblno
         memcpy((void *) qtbl, (void *) (cinfo->quant_tbl_ptrs)[qtblno], (size_t) (size_t) sizeof(JQUANT_TBL));
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               qtbl
//             <    is written>: compptr[0].quant_table
         compptr->quant_table = qtbl;
      }
//             <    is read   >: cinfo cinfo[0].comps_in_scan
_loop_end_1:      ;
   }
}
static void per_scan_setup(j_decompress_ptr cinfo)
{
   int ci, mcublks, tmp;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comps_in_scan

   if (cinfo->comps_in_scan==1) {
//             <    is read   >: cinfo cinfo[0].cur_comp_info[0]
//             <    is written>: compptr
      
      /* Noninterleaved (single-component) scan */
      compptr = (cinfo->cur_comp_info)[0];
//             <    is read   >: cinfo compptr 
//                               compptr[0].width_in_blocks
//             <    is written>: cinfo[0].MCUs_per_row
      
      /* Overall image size in MCUs */
      cinfo->MCUs_per_row = compptr->width_in_blocks;
//             <    is read   >: cinfo compptr 
//                               compptr[0].height_in_blocks
//             <    is written>: cinfo[0].MCU_rows_in_scan
      cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_width
      
      /* For noninterleaved scan, always one block per MCU */
      compptr->MCU_width = 1;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_height
      compptr->MCU_height = 1;
//             <    is read   >: compptr
//             <    is written>: compptr[0].MCU_blocks
      compptr->MCU_blocks = 1;
//             <    is read   >: compptr compptr[0].DCT_scaled_size
//             <    is written>: compptr[0].MCU_sample_width
      compptr->MCU_sample_width = compptr->DCT_scaled_size;
//             <    is read   >: compptr
//             <    is written>: compptr[0].last_col_width
      compptr->last_col_width = 1;
//             <    is read   >: compptr compptr[0].height_in_blocks 
//                               compptr[0].v_samp_factor
//             <    is written>: tmp
      /* For noninterleaved scans, it is convenient to define last_row_height
           * as the number of block rows present in the last iMCU row.
           */
      tmp = (int) (compptr->height_in_blocks%compptr->v_samp_factor);
//             <    is read   >: tmp
      if (tmp==0)
//             <    is read   >: compptr compptr[0].v_samp_factor
//             <    is written>: tmp
         tmp = compptr->v_samp_factor;
//             <    is read   >: compptr tmp
//             <    is written>: compptr[0].last_row_height
      compptr->last_row_height = tmp;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].blocks_in_MCU
      
      /* Prepare array describing MCU composition */
      cinfo->blocks_in_MCU = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].MCU_membership[0]
      (cinfo->MCU_membership)[0] = 0;
   }
   else {
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].comps_in_scan
      
      /* Interleaved (multi-component) scan */
      if (cinfo->comps_in_scan<=0||cinfo->comps_in_scan>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = cinfo->comps_in_scan, (cinfo->err->msg_parm.i)[1] = 4, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor
//             <    is written>: cinfo[0].MCUs_per_row
      
      /* Overall image size in MCUs */
      
      
      cinfo->MCUs_per_row = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width, (long int) (cinfo->max_h_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor
//             <    is written>: cinfo[0].MCU_rows_in_scan
      cinfo->MCU_rows_in_scan = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, (long int) (cinfo->max_v_samp_factor*8));
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].blocks_in_MCU

      cinfo->blocks_in_MCU = 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

      for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
         compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].MCU_width
         /* Sampling factors give # of blocks of component in each MCU */
         compptr->MCU_width = compptr->h_samp_factor;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].MCU_height
         compptr->MCU_height = compptr->v_samp_factor;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].MCU_width
//             <    is written>: compptr[0].MCU_blocks
         compptr->MCU_blocks = compptr->MCU_width*compptr->MCU_height;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].MCU_width
//             <    is written>: compptr[0].MCU_sample_width
         compptr->MCU_sample_width = compptr->MCU_width*compptr->DCT_scaled_size;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_width 
//                               compptr[0].width_in_blocks
//             <    is written>: tmp
         /* Figure number of non-dummy blocks in last MCU column & row */
         tmp = (int) (compptr->width_in_blocks%compptr->MCU_width);
//             <    is read   >: cinfo cinfo[0].comps_in_scan tmp
         if (tmp==0)
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_width
//             <    is written>: tmp
            tmp = compptr->MCU_width;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               tmp
//             <    is written>: compptr[0].last_col_width
         compptr->last_col_width = tmp;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_height 
//                               compptr[0].height_in_blocks
//             <    is written>: tmp
         tmp = (int) (compptr->height_in_blocks%compptr->MCU_height);
//             <    is read   >: cinfo cinfo[0].comps_in_scan tmp
         if (tmp==0)
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_height
//             <    is written>: tmp
            tmp = compptr->MCU_height;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               tmp
//             <    is written>: compptr[0].last_row_height
         compptr->last_row_height = tmp;
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].MCU_blocks
//             <    is written>: mcublks
         /* Prepare array describing MCU composition */
         mcublks = compptr->MCU_blocks;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].comps_in_scan mcublks
         if (cinfo->blocks_in_MCU+mcublks>10)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_BAD_MCU_SIZE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: mcublks
//             <    is written>: mcublks
         while (mcublks-->0)
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].comps_in_scan
//             <    is written>: 
//                               cinfo[0].MCU_membership[cinfo->blocks
//                               _in_MCU++] cinfo[0].blocks_in_MCU
            (cinfo->MCU_membership)[cinfo->blocks_in_MCU++] = ci;
      }
   }
}
static void reset_input_controller(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].inputctl
//             <    is written>: inputctl
   my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.consume_input

   inputctl->pub.consume_input = consume_markers;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.has_multiple_scans
   inputctl->pub.has_multiple_scans = 0;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.eoi_reached
   /* "unknown" would be better */
   inputctl->pub.eoi_reached = 0;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].inheaders
   inputctl->inheaders = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Reset other modules */
   (*cinfo->err->reset_error_mgr)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->marker->reset_marker_reader)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].coef_bits
   /* Reset progression state -- would be cleaner if entropy decoder did this */
   cinfo->coef_bits = (void *) 0;
}
static void start_input_pass(j_decompress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   per_scan_setup(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   latch_quant_tables(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->entropy->start_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->coef->start_input_pass)(cinfo);
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].coef[0].consume_data 
//                               cinfo[0].inputctl
//             <    is written>: cinfo[0].inputctl[0].consume_input
   cinfo->inputctl->consume_input = cinfo->coef->consume_data;
}
long int jdiv_round_up(long int a, long int b)
{
//             <    is read   >: a b
   return (a+b-1L)/b;
}
static void alloc_funny_pointers(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
   int ci, rgroup;
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: M
   int M = cinfo->min_DCT_scaled_size;
   jpeg_component_info *compptr;
   JSAMPARRAY xbuf;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Get top-level space for component array pointers.
      * We alloc both arrays with one call to save a few cycles.
      */
   
   (main->xbuffer)[0] = (JSAMPIMAGE) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,cinfo->num_components*2*(size_t) sizeof(JSAMPARRAY));
//             <    is read   >: cinfo cinfo[0].num_components main 
//                               main[0].xbuffer[0]
//             <    is written>: main[0].xbuffer[1]
   (main->xbuffer)[1] = (main->xbuffer)[0]+cinfo->num_components;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: rgroup
      rgroup = compptr->v_samp_factor*compptr->DCT_scaled_size/(cinfo->min_DCT_scaled_size);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* height of a row group of component */
      /* Get space for pointer lists --- M+4 row groups in each list.
           * We alloc both pointer lists with one call to save a few cycles.
           */
      
      xbuf = (JSAMPARRAY) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,2*rgroup*(M+4)*(size_t) sizeof(JSAMPROW));
//             <    is read   >: cinfo cinfo[0].num_components rgroup 
//                               xbuf
//             <    is written>: xbuf
      xbuf += rgroup;
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].xbuffer[0] xbuf
//             <    is written>: main[0].xbuffer[0][ci]
      /* want one row group at negative offsets */
      ((main->xbuffer)[0])[ci] = xbuf;
//             <    is read   >: M cinfo cinfo[0].num_components 
//                               rgroup xbuf
//             <    is written>: xbuf
      xbuf += rgroup*(M+4);
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].xbuffer[1] xbuf
//             <    is written>: main[0].xbuffer[1][ci]
      ((main->xbuffer)[1])[ci] = xbuf;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void make_funny_pointers(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
   int ci, i, rgroup;
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: M
   int M = cinfo->min_DCT_scaled_size;
   jpeg_component_info *compptr;
   JSAMPARRAY buf, xbuf0, xbuf1;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: rgroup
      rgroup = compptr->v_samp_factor*compptr->DCT_scaled_size/(cinfo->min_DCT_scaled_size);
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].xbuffer[0] 
//                               main[0].xbuffer[0][ci]
//             <    is written>: xbuf0
      /* height of a row group of component */
      xbuf0 = ((main->xbuffer)[0])[ci];
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].xbuffer[1] 
//                               main[0].xbuffer[1][ci]
//             <    is written>: xbuf1
      xbuf1 = ((main->xbuffer)[1])[ci];
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].buffer[ci]
//             <    is written>: buf
      /* First copy the workspace pointers as-is */
      buf = (main->buffer)[ci];
//             <    is read   >: M cinfo cinfo[0].num_components 
//                               rgroup
//             <    is written>: i
      for(i = 0; i <= rgroup*(M+2)-1; i += 1)
//             <    is read   >: M buf buf[i] cinfo 
//                               cinfo[0].num_components i rgroup 
//                               xbuf0 xbuf1
//             <    is written>: xbuf0[i] xbuf1[i]
         xbuf0[i] = xbuf1[i] = buf[i];
//             <    is read   >: cinfo cinfo[0].num_components rgroup
//             <    is written>: i
      /* In the second list, put the last four row groups in swapped order */
      for(i = 0; i <= rgroup*2-1; i += 1) {
//             <    is read   >: M buf buf[rgroup*M+i] cinfo 
//                               cinfo[0].num_components i rgroup 
//                               xbuf1
//             <    is written>: xbuf1[rgroup*(M-2)+i]
         xbuf1[rgroup*(M-2)+i] = buf[rgroup*M+i];
//             <    is read   >: M buf buf[rgroup*(M-2)
//                               +i] cinfo cinfo[0].num_components i 
//                               rgroup xbuf1
//             <    is written>: xbuf1[rgroup*M+i]
         xbuf1[rgroup*M+i] = buf[rgroup*(M-2)+i];
      }
//             <    is read   >: cinfo cinfo[0].num_components rgroup
//             <    is written>: i
      /* The wraparound pointers at top and bottom will be filled later
           * (see set_wraparound_pointers, below).  Initially we want the "above"
           * pointers to duplicate the first actual data line.  This only needs
           * to happen in xbuffer[0].
           */
      for(i = 0; i <= rgroup-1; i += 1)
//             <    is read   >: cinfo cinfo[0].num_components i 
//                               rgroup xbuf0 xbuf0[0]
//             <    is written>: xbuf0[i-rgroup]
         xbuf0[i-rgroup] = xbuf0[0];
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void process_data_context_main(j_decompress_ptr cinfo, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
//             <    is read   >: main main[0].buffer_full
   
   /* Read input data if we haven't filled the main buffer yet */
   if (!main->buffer_full) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*cinfo->coef->decompress_data)(cinfo,(main->xbuffer)[main->whichptr]))
         return;
//             <    is read   >: main
//             <    is written>: main[0].buffer_full
      /* suspension forced, can do nothing more */
      main->buffer_full = 1;
//             <    is read   >: main main[0].iMCU_row_ctr
//             <    is written>: main[0].iMCU_row_ctr
      /* OK, we have an iMCU row to work with */
      main->iMCU_row_ctr++;
   }
//             <    is read   >: main main[0].context_state

/* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
   if (main->context_state==2) goto _switch_1_case_2;
//             <    is read   >: main main[0].context_state
   if (main->context_state==0) goto _switch_1_case_0;
//             <    is read   >: main main[0].context_state
   if (main->context_state==1) {
   }
   else {
      goto _break_1;
   }
   /*FALLTHROUGH*/
_switch_1_case_1:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Call postprocessor using previously set pointers */
   (*cinfo->post->post_process_data)(cinfo,(main->xbuffer)[main->whichptr],&main->rowgroup_ctr,main->rowgroups_avail,output_buf,out_row_ctr,out_rows_avail);
//             <    is read   >: main main[0].rowgroup_ctr 
//                               main[0].rowgroups_avail
   if (main->rowgroup_ctr<main->rowgroups_avail)
      return;
//             <    is read   >: main main[0].iMCU_row_ctr
   /* Need to suspend */
   /* After the first iMCU, change wraparound pointers to normal state */
   if (main->iMCU_row_ctr==1)
//             <may be read   >: cinfo[0].main[0].xbuffer[0] 
//                               cinfo[0].main[0].xbuffer[0][*] 
//                               cinfo[0].main[0].xbuffer[1] 
//                               cinfo[0].main[0].xbuffer[1][*]
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].main 
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components
      set_wraparound_pointers(cinfo);
//             <    is read   >: main main[0].whichptr
//             <    is written>: main[0].whichptr
   /* Prepare to load new iMCU row using other xbuffer list */
   main->whichptr ^= 1;
//             <    is read   >: main
//             <    is written>: main[0].buffer_full
   /* 0=>1 or 1=>0 */
   main->buffer_full = 0;
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               main
//             <    is written>: main[0].rowgroup_ctr
   /* Still need to process last row group of this iMCU row, */
   /* which is saved at index M+1 of the other xbuffer */
   main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size+1);
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               main
//             <    is written>: main[0].rowgroups_avail
   main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size+2);
//             <    is read   >: main
//             <    is written>: main[0].context_state
   main->context_state = 2;
   goto _break_1;
   /* Postprocessor exactly filled output buf */
   /*FALLTHROUGH*/
_switch_1_case_0:   ;
//             <    is read   >: main
//             <    is written>: main[0].rowgroup_ctr
   /* Prepare to process first M-1 row groups of this iMCU row */
   main->rowgroup_ctr = 0;
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               main
//             <    is written>: main[0].rowgroups_avail
   main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size-1);
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows main 
//                               main[0].iMCU_row_ctr
   /* Check for bottom of image: if so, tweak pointers to "duplicate"
        * the last sample row, and adjust rowgroups_avail to ignore padding rows.
        */
   if (main->iMCU_row_ctr==cinfo->total_iMCU_rows)
//             <may be read   >: cinfo[0].main[0].whichptr 
//                               cinfo[0].main[0].xbuffer[*] 
//                               cinfo[0].main[0].xbuffer[*][*] 
//                               cinfo[0].min_DCT_scaled_size
//             <may be written>: cinfo[0].main[0].rowgroups_avail
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].main cinfo[0].num_components
      set_bottom_pointers(cinfo);
//             <    is read   >: main
//             <    is written>: main[0].context_state
   main->context_state = 1;
   goto _switch_1_case_1;
_switch_1_case_2:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Call postprocessor using previously set pointers for postponed row */
   (*cinfo->post->post_process_data)(cinfo,(main->xbuffer)[main->whichptr],&main->rowgroup_ctr,main->rowgroups_avail,output_buf,out_row_ctr,out_rows_avail);
//             <    is read   >: main main[0].rowgroup_ctr 
//                               main[0].rowgroups_avail
   if (main->rowgroup_ctr<main->rowgroups_avail)
      return;
//             <    is read   >: main
//             <    is written>: main[0].context_state
   /* Need to suspend */
   main->context_state = 0;
//             <    is read   >: out_row_ctr out_row_ctr[0] 
//                               out_rows_avail
   if (*out_row_ctr>=out_rows_avail)
      return;
   goto _switch_1_case_0;
_break_1:   ;
}
static void process_data_crank_post(j_decompress_ptr cinfo, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->post->post_process_data)(cinfo,(JSAMPIMAGE) (void *) 0,(JDIMENSION *) (void *) 0,(JDIMENSION) 0,output_buf,out_row_ctr,out_rows_avail);
}
static void process_data_simple_main(j_decompress_ptr cinfo, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
   JDIMENSION rowgroups_avail;
//             <    is read   >: main main[0].buffer_full
   
   /* Read input data if we haven't filled the main buffer yet */
   if (!main->buffer_full) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*cinfo->coef->decompress_data)(cinfo,main->buffer))
         return;
//             <    is read   >: main
//             <    is written>: main[0].buffer_full
      /* suspension forced, can do nothing more */
      main->buffer_full = 1;
   }
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: rowgroups_avail
   
   /* There are always min_DCT_scaled_size row groups in an iMCU row. */
   rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Note: at the bottom of the image, we may pass extra garbage row groups
      * to the postprocessor.  The postprocessor has to check for bottom
      * of image anyway (at row resolution), so no point in us doing it too.
      */
   
   /* Feed the postprocessor */
   (*cinfo->post->post_process_data)(cinfo,main->buffer,&main->rowgroup_ctr,rowgroups_avail,output_buf,out_row_ctr,out_rows_avail);
//             <    is read   >: main main[0].rowgroup_ctr 
//                               rowgroups_avail
   
   /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
   if (main->rowgroup_ctr>=rowgroups_avail) {
//             <    is read   >: main
//             <    is written>: main[0].buffer_full
      main->buffer_full = 0;
//             <    is read   >: main
//             <    is written>: main[0].rowgroup_ctr
      main->rowgroup_ctr = 0;
   }
}
static void set_bottom_pointers(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
   int ci, i, rgroup, iMCUheight, rows_left;
   jpeg_component_info *compptr;
   JSAMPARRAY xbuf;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: iMCUheight
      /* Count sample rows in one iMCU row and in one row group */
      iMCUheight = compptr->v_samp_factor*compptr->DCT_scaled_size;
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components iMCUheight
//             <    is written>: rgroup
      rgroup = iMCUheight/(cinfo->min_DCT_scaled_size);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].downsampled_height 
//                               iMCUheight
//             <    is written>: rows_left
      /* Count nondummy sample rows remaining for this component */
      rows_left = (int) (compptr->downsampled_height%(JDIMENSION) iMCUheight);
//             <    is read   >: cinfo cinfo[0].num_components 
//                               rows_left
      if (rows_left==0)
//             <    is read   >: cinfo cinfo[0].num_components 
//                               iMCUheight
//             <    is written>: rows_left
         rows_left = iMCUheight;
//             <    is read   >: ci cinfo cinfo[0].num_components
      /* Count nondummy row groups.  Should get same answer for each component,
           * so we need only do it once.
           */
      if (ci==0)
//             <    is read   >: cinfo cinfo[0].num_components main 
//                               rgroup rows_left
//             <    is written>: main[0].rowgroups_avail
         main->rowgroups_avail = (JDIMENSION) ((rows_left-1)/rgroup+1);
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].whichptr 
//                               main[0].xbuffer[main->whichptr] 
//                               main[0].xbuffer[main->whichptr][ci]
//             <    is written>: xbuf
      /* Duplicate the last real sample row rgroup*2 times; this pads out the
           * last partial rowgroup and ensures at least one full rowgroup of context.
           */
      xbuf = ((main->xbuffer)[main->whichptr])[ci];
//             <    is read   >: cinfo cinfo[0].num_components rgroup
//             <    is written>: i
      for(i = 0; i <= rgroup*2-1; i += 1)
//             <    is read   >: cinfo cinfo[0].num_components i 
//                               rgroup rows_left xbuf 
//                               xbuf[rows_left-1]
//             <    is written>: xbuf[rows_left+i]
         xbuf[rows_left+i] = xbuf[rows_left-1];
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void set_wraparound_pointers(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
   int ci, i, rgroup;
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: M
   int M = cinfo->min_DCT_scaled_size;
   jpeg_component_info *compptr;
   JSAMPARRAY xbuf0, xbuf1;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: rgroup
      rgroup = compptr->v_samp_factor*compptr->DCT_scaled_size/(cinfo->min_DCT_scaled_size);
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].xbuffer[0] 
//                               main[0].xbuffer[0][ci]
//             <    is written>: xbuf0
      /* height of a row group of component */
      xbuf0 = ((main->xbuffer)[0])[ci];
//             <    is read   >: ci cinfo cinfo[0].num_components main
//                               main[0].xbuffer[1] 
//                               main[0].xbuffer[1][ci]
//             <    is written>: xbuf1
      xbuf1 = ((main->xbuffer)[1])[ci];
//             <    is read   >: cinfo cinfo[0].num_components rgroup
//             <    is written>: i
      for(i = 0; i <= rgroup-1; i += 1) {
//             <    is read   >: M cinfo cinfo[0].num_components i 
//                               rgroup xbuf0 xbuf0[rgroup*(M+1)+i]
//             <    is written>: xbuf0[i-rgroup]
         xbuf0[i-rgroup] = xbuf0[rgroup*(M+1)+i];
//             <    is read   >: M cinfo cinfo[0].num_components i 
//                               rgroup xbuf1 xbuf1[rgroup*(M+1)+i]
//             <    is written>: xbuf1[i-rgroup]
         xbuf1[i-rgroup] = xbuf1[rgroup*(M+1)+i];
//             <    is read   >: M cinfo cinfo[0].num_components i 
//                               rgroup xbuf0 xbuf0[i]
//             <    is written>: xbuf0[rgroup*(M+2)+i]
         xbuf0[rgroup*(M+2)+i] = xbuf0[i];
//             <    is read   >: M cinfo cinfo[0].num_components i 
//                               rgroup xbuf1 xbuf1[i]
//             <    is written>: xbuf1[rgroup*(M+2)+i]
         xbuf1[rgroup*(M+2)+i] = xbuf1[i];
      }
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static void start_pass_main(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
//             <    is read   >: cinfo cinfo[0].main
//             <    is written>: main
   my_main_ptr main = (my_main_ptr) cinfo->main;
//             <    is read   >: pass_mode

   if (pass_mode==JBUF_PASS_THRU) {
_switch_1_case_JBUF_PASS_THRU:      ;
//             <    is read   >: cinfo cinfo[0].upsample 
//                               cinfo[0].upsample[0].need_context_row
//                               s
      if (cinfo->upsample->need_context_rows) {
//             <    is read   >: main
//             <    is written>: main[0].pub.process_data
         main->pub.process_data = process_data_context_main;
//             <may be read   >: cinfo[0].main[0].buffer[*] 
//                               cinfo[0].main[0].xbuffer[0] 
//                               cinfo[0].main[0].xbuffer[0][*] 
//                               cinfo[0].main[0].xbuffer[1] 
//                               cinfo[0].main[0].xbuffer[1][*]
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].main 
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components
         make_funny_pointers(cinfo);
//             <    is read   >: main
//             <    is written>: main[0].whichptr
         /* Create the xbuffer[] lists */
         main->whichptr = 0;
//             <    is read   >: main
//             <    is written>: main[0].context_state
         /* Read first iMCU row into xbuffer[0] */
         main->context_state = 0;
//             <    is read   >: main
//             <    is written>: main[0].iMCU_row_ctr
         main->iMCU_row_ctr = 0;
      }
      else
//             <    is read   >: main
//             <    is written>: main[0].pub.process_data
         /* Simple case with no context needed */
         main->pub.process_data = process_data_simple_main;
//             <    is read   >: main
//             <    is written>: main[0].buffer_full
      main->buffer_full = 0;
//             <    is read   >: main
//             <    is written>: main[0].rowgroup_ctr
      /* Mark buffer empty */
      main->rowgroup_ctr = 0;
   }
   else if (pass_mode==JBUF_CRANK_DEST) {

_switch_1_case_JBUF_CRANK_DEST:      ;
//             <    is read   >: main
//             <    is written>: main[0].pub.process_data
      /* For last pass of 2-pass quantization, just crank the postprocessor */
      main->pub.process_data = process_data_crank_post;
   }
   else {

_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
}
static boolean first_marker(j_decompress_ptr cinfo)
{
   int c, c2;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
      c = *next_input_byte++;
   }
   while (0);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c2 next_input_byte
      c2 = *next_input_byte++;
   }
   while (0);
//             <    is read   >: c c2
   if (c!=0xFF||c2!=(int) M_SOI)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_NO_SOI, (cinfo->err->msg_parm.i)[0] = c, (cinfo->err->msg_parm.i)[1] = c2, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: c2 cinfo
//             <    is written>: cinfo[0].unread_marker

   cinfo->unread_marker = c2;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean get_app0(j_decompress_ptr cinfo)
{

   INT32 length;
   UINT8 b[14];
   int buffp;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <    is read   >: length
//             <    is written>: length
   length -= 2;
//             <    is read   >: length
   
   /* See if a JFIF APP0 marker is present */
   
   if (length>=14) {
//             <    is written>: buffp
      for(buffp = 0; buffp <= 13; buffp += 1)
         do {
//             <    is read   >: bytes_in_buffer
            if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               if (!(*datasrc->fill_input_buffer)(cinfo))
                  return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
               next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
            }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
            bytes_in_buffer--;
//             <    is read   >: buffp next_input_byte 
//                               next_input_byte[0]
//             <    is written>: b[buffp] next_input_byte
            b[buffp] = *next_input_byte++;
         }
         while (0);
//             <    is read   >: length
//             <    is written>: length
      length -= 14;
//             <    is read   >: b[0] b[1] b[2] b[3] b[4]

      if (b[0]==0x4A&&b[1]==0x46&&b[2]==0x49&&b[3]==0x46&&b[4]==0) {
//             <    is read   >: b[5]
         /* Found JFIF APP0 marker: check version */
         /* Major version must be 1, anything else signals an incompatible change.
                * We used to treat this as an error, but now it's a nonfatal warning,
                * because some bozo at Hijaak couldn't read the spec.
                * Minor version should be 0..2, but process anyway if newer.
                */
         if (b[5]!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JWRN_JFIF_MAJOR, (cinfo->err->msg_parm.i)[0] = b[5], (cinfo->err->msg_parm.i)[1] = b[6], (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
         else if (b[6]>2)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JTRC_JFIF_MINOR, (cinfo->err->msg_parm.i)[0] = b[5], (cinfo->err->msg_parm.i)[1] = b[6], (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].saw_JFIF_marker
         /* Save info */
         cinfo->saw_JFIF_marker = 1;
//             <    is read   >: b[7] cinfo
//             <    is written>: cinfo[0].density_unit
         cinfo->density_unit = b[7];
//             <    is read   >: b[8] b[9] cinfo
//             <    is written>: cinfo[0].X_density
         cinfo->X_density = (b[8]<<8)+b[9];
//             <    is read   >: b[10] b[11] cinfo
//             <    is written>: cinfo[0].Y_density
         cinfo->Y_density = (b[10]<<8)+b[11];
         do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: _mp
            int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: _mp cinfo cinfo[0].X_density
//             <    is written>: _mp[0]
            _mp[0] = cinfo->X_density;
//             <    is read   >: _mp cinfo cinfo[0].Y_density
//             <    is written>: _mp[1]
            _mp[1] = cinfo->Y_density;
//             <    is read   >: _mp cinfo cinfo[0].density_unit
//             <    is written>: _mp[2]
            _mp[2] = cinfo->density_unit;
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
            cinfo->err->msg_code = JTRC_JFIF;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
         }
         while (0);
//             <    is read   >: b[12] b[13]

         if (b[12]|b[13])
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JTRC_JFIF_THUMBNAIL, (cinfo->err->msg_parm.i)[0] = b[12], (cinfo->err->msg_parm.i)[1] = b[13], (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: b[12] b[13] length
         if (length!=(INT32) b[12]*(INT32) b[13]*(INT32) 3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JTRC_JFIF_BADTHUMBNAILSIZE, (cinfo->err->msg_parm.i)[0] = (int) length, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
      }
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Start of APP0 does not match "JFIF" */
         cinfo->err->msg_code = JTRC_APP0, (cinfo->err->msg_parm.i)[0] = (int) length+14, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
   }
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Too short to be JFIF marker */
      cinfo->err->msg_code = JTRC_APP0, (cinfo->err->msg_parm.i)[0] = (int) length, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
//             <    is read   >: length
   if (length>0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* skip any remaining data -- could be lots */
      (*cinfo->src->skip_input_data)(cinfo,(long int) length);

   return 1;
}
static boolean get_app14(j_decompress_ptr cinfo)
{

   INT32 length;
   UINT8 b[12];
   int buffp;
   unsigned int version, flags0, flags1, transform;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <    is read   >: length
//             <    is written>: length
   length -= 2;
//             <    is read   >: length
   
   /* See if an Adobe APP14 marker is present */
   
   if (length>=12) {
//             <    is written>: buffp
      for(buffp = 0; buffp <= 11; buffp += 1)
         do {
//             <    is read   >: bytes_in_buffer
            if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               if (!(*datasrc->fill_input_buffer)(cinfo))
                  return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
               next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
            }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
            bytes_in_buffer--;
//             <    is read   >: buffp next_input_byte 
//                               next_input_byte[0]
//             <    is written>: b[buffp] next_input_byte
            b[buffp] = *next_input_byte++;
         }
         while (0);
//             <    is read   >: length
//             <    is written>: length
      length -= 12;
//             <    is read   >: b[0] b[1] b[2] b[3] b[4]

      if (b[0]==0x41&&b[1]==0x64&&b[2]==0x6F&&b[3]==0x62&&b[4]==0x65) {
//             <    is read   >: b[5] b[6]
//             <    is written>: version
         /* Found Adobe APP14 marker */
         version = (b[5]<<8)+b[6];
//             <    is read   >: b[7] b[8]
//             <    is written>: flags0
         flags0 = (b[7]<<8)+b[8];
//             <    is read   >: b[9] b[10]
//             <    is written>: flags1
         flags1 = (b[9]<<8)+b[10];
//             <    is read   >: b[11]
//             <    is written>: transform
         transform = b[11];
         do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: _mp
            int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: _mp version
//             <    is written>: _mp[0]
            _mp[0] = version;
//             <    is read   >: _mp flags0
//             <    is written>: _mp[1]
            _mp[1] = flags0;
//             <    is read   >: _mp flags1
//             <    is written>: _mp[2]
            _mp[2] = flags1;
//             <    is read   >: _mp transform
//             <    is written>: _mp[3]
            _mp[3] = transform;
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
            cinfo->err->msg_code = JTRC_ADOBE;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
         }
         while (0);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].saw_Adobe_marker
         cinfo->saw_Adobe_marker = 1;
//             <    is read   >: cinfo transform
//             <    is written>: cinfo[0].Adobe_transform
         cinfo->Adobe_transform = (UINT8) transform;
      }
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Start of APP14 does not match "Adobe" */
         cinfo->err->msg_code = JTRC_APP14, (cinfo->err->msg_parm.i)[0] = (int) length+12, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
   }
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Too short to be Adobe marker */
      cinfo->err->msg_code = JTRC_APP14, (cinfo->err->msg_parm.i)[0] = (int) length, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
//             <    is read   >: length
   if (length>0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* skip any remaining data -- could be lots */
      (*cinfo->src->skip_input_data)(cinfo,(long int) length);

   return 1;
}
static boolean get_dac(j_decompress_ptr cinfo)
{
   INT32 length;
   int index, val;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <    is read   >: length
//             <    is written>: length
   length -= 2;
//             <    is read   >: length

   while (length>0) {
      do {
//             <    is read   >: bytes_in_buffer
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: 0`index next_input_byte
         index = *next_input_byte++;
      }
      while (0);
      do {
//             <    is read   >: bytes_in_buffer
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: next_input_byte val
         val = *next_input_byte++;
      }
      while (0);
//             <    is read   >: length
//             <    is written>: length

      length -= 2;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_DAC, (cinfo->err->msg_parm.i)[0] = index, (cinfo->err->msg_parm.i)[1] = val, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: 0`index
      if (index<0||index>=2*16)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_DAC_INDEX, (cinfo->err->msg_parm.i)[0] = index, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: 0`index

      if (index>=16)
//             <    is read   >: cinfo 0`index val
//             <    is written>: cinfo[0].arith_ac_K[index-16]
         /* define AC table */
         (cinfo->arith_ac_K)[index-16] = (UINT8) val;
      else {
//             <    is read   >: cinfo 0`index val
//             <    is written>: cinfo[0].arith_dc_L[index]
         /* define DC table */
         (cinfo->arith_dc_L)[index] = (UINT8) (val&0x0F);
//             <    is read   >: cinfo 0`index val
//             <    is written>: cinfo[0].arith_dc_U[index]
         (cinfo->arith_dc_U)[index] = (UINT8) (val>>4);
//             <    is read   >: cinfo cinfo[0].arith_dc_L[index] 
//                               cinfo[0].arith_dc_U[index] 0`index
         if ((cinfo->arith_dc_L)[index]>(cinfo->arith_dc_U)[index])
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_DAC_VALUE, (cinfo->err->msg_parm.i)[0] = val, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
   }
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean get_dht(j_decompress_ptr cinfo)
{
   INT32 length;
   UINT8 bits[17];
   UINT8 huffval[256];
   int i, index, count;
   JHUFF_TBL **htblptr;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <    is read   >: length
//             <    is written>: length
   length -= 2;
//             <    is read   >: length

   while (length>0) {
      do {
//             <    is read   >: bytes_in_buffer
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: 0`index next_input_byte
         index = *next_input_byte++;
      }
      while (0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_DHT, (cinfo->err->msg_parm.i)[0] = index, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is written>: bits[0]

      bits[0] = 0;
//             <    is written>: count
      count = 0;
//             <    is written>: i
      for(i = 1; i <= 16; i += 1) {
         do {
//             <    is read   >: bytes_in_buffer
            if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               if (!(*datasrc->fill_input_buffer)(cinfo))
                  return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
               next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
            }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
            bytes_in_buffer--;
//             <    is read   >: i next_input_byte next_input_byte[0]
//             <    is written>: bits[i] next_input_byte
            bits[i] = *next_input_byte++;
         }
         while (0);
//             <    is read   >: bits[i] count i
//             <    is written>: count
         count += bits[i];
      }
//             <    is read   >: length
//             <    is written>: length

      length -= 1+16;
      do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: 0`6`14`_mp
         int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: 0`6`14`_mp bits[1]
//             <    is written>: 0`6`14`_mp[0]
         _mp[0] = bits[1];
//             <    is read   >: 0`6`14`_mp bits[2]
//             <    is written>: 0`6`14`_mp[1]
         _mp[1] = bits[2];
//             <    is read   >: 0`6`14`_mp bits[3]
//             <    is written>: 0`6`14`_mp[2]
         _mp[2] = bits[3];
//             <    is read   >: 0`6`14`_mp bits[4]
//             <    is written>: 0`6`14`_mp[3]
         _mp[3] = bits[4];
//             <    is read   >: 0`6`14`_mp bits[5]
//             <    is written>: 0`6`14`_mp[4]
         _mp[4] = bits[5];
//             <    is read   >: 0`6`14`_mp bits[6]
//             <    is written>: 0`6`14`_mp[5]
         _mp[5] = bits[6];
//             <    is read   >: 0`6`14`_mp bits[7]
//             <    is written>: 0`6`14`_mp[6]
         _mp[6] = bits[7];
//             <    is read   >: 0`6`14`_mp bits[8]
//             <    is written>: 0`6`14`_mp[7]
         _mp[7] = bits[8];
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
         cinfo->err->msg_code = JTRC_HUFFBITS;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->err->emit_message)((j_common_ptr) cinfo,2);
      }
      while (0);
      do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: 0`6`15`_mp
         int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: 0`6`15`_mp bits[9]
//             <    is written>: 0`6`15`_mp[0]
         _mp[0] = bits[9];
//             <    is read   >: 0`6`15`_mp bits[10]
//             <    is written>: 0`6`15`_mp[1]
         _mp[1] = bits[10];
//             <    is read   >: 0`6`15`_mp bits[11]
//             <    is written>: 0`6`15`_mp[2]
         _mp[2] = bits[11];
//             <    is read   >: 0`6`15`_mp bits[12]
//             <    is written>: 0`6`15`_mp[3]
         _mp[3] = bits[12];
//             <    is read   >: 0`6`15`_mp bits[13]
//             <    is written>: 0`6`15`_mp[4]
         _mp[4] = bits[13];
//             <    is read   >: 0`6`15`_mp bits[14]
//             <    is written>: 0`6`15`_mp[5]
         _mp[5] = bits[14];
//             <    is read   >: 0`6`15`_mp bits[15]
//             <    is written>: 0`6`15`_mp[6]
         _mp[6] = bits[15];
//             <    is read   >: 0`6`15`_mp bits[16]
//             <    is written>: 0`6`15`_mp[7]
         _mp[7] = bits[16];
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
         cinfo->err->msg_code = JTRC_HUFFBITS;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->err->emit_message)((j_common_ptr) cinfo,2);
      }
      while (0);
//             <    is read   >: count length
      if (count>256||(INT32) count>length)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_DHT_COUNTS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: count
//             <    is written>: i

      for(i = 0; i <= count-1; i += 1)
         do {
//             <    is read   >: bytes_in_buffer count
            if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               if (!(*datasrc->fill_input_buffer)(cinfo))
//             <    is read   >: count
                  return 0;
//             <    is read   >: count datasrc 
//                               datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
               next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
            }
//             <    is read   >: bytes_in_buffer count
//             <    is written>: bytes_in_buffer
            bytes_in_buffer--;
//             <    is read   >: count i next_input_byte 
//                               next_input_byte[0]
//             <    is written>: huffval[i] next_input_byte
            huffval[i] = *next_input_byte++;
         }
         while (0);
//             <    is read   >: count length
//             <    is written>: length

      length -= count;
//             <    is read   >: 0`index

      if (index&0x10) {
//             <    is read   >: 0`index
//             <    is written>: 0`index
         /* AC table definition */
         index -= 0x10;
//             <    is read   >: cinfo 0`index
//             <    is written>: htblptr
         htblptr = &(cinfo->ac_huff_tbl_ptrs)[index];
      }
      else
//             <    is read   >: cinfo 0`index
//             <    is written>: htblptr
         /* DC table definition */
         htblptr = &(cinfo->dc_huff_tbl_ptrs)[index];
//             <    is read   >: 0`index

      if (index<0||index>=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_DHT_INDEX, (cinfo->err->msg_parm.i)[0] = index, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: htblptr htblptr[0]
      if (*htblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
//             <may be read   >: bits[*]
//             <may be written>: htblptr[0][0].bits[*]
//             <    is read   >: htblptr htblptr[0]
      memcpy((void *) (*htblptr)->bits, (void *) bits, (size_t) (size_t) sizeof((*htblptr)->bits));
//             <may be read   >: huffval[*]
//             <may be written>: htblptr[0][0].huffval[*]
//             <    is read   >: htblptr htblptr[0]
      memcpy((void *) (*htblptr)->huffval, (void *) huffval, (size_t) (size_t) sizeof((*htblptr)->huffval));
   }
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean get_dqt(j_decompress_ptr cinfo)
{
   INT32 length;
   int n, i, prec;
   unsigned int tmp;
   JQUANT_TBL *quant_ptr;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <    is read   >: length
//             <    is written>: length
   length -= 2;
//             <    is read   >: length

   while (length>0) {
      do {
//             <    is read   >: bytes_in_buffer
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: n next_input_byte
         n = *next_input_byte++;
      }
      while (0);
//             <    is read   >: n
//             <    is written>: prec
      prec = n>>4;
//             <    is read   >: n
//             <    is written>: n
      n &= 0x0F;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_DQT, (cinfo->err->msg_parm.i)[0] = n, (cinfo->err->msg_parm.i)[1] = prec, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: n

      if (n>=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_DQT_INDEX, (cinfo->err->msg_parm.i)[0] = n, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].quant_tbl_ptrs[n] n
      if ((cinfo->quant_tbl_ptrs)[n]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (cinfo->quant_tbl_ptrs)[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].quant_tbl_ptrs[n] n
//             <    is written>: quant_ptr
      quant_ptr = (cinfo->quant_tbl_ptrs)[n];
//             <    is written>: i

      for(i = 0; i <= 63; i += 1) {
//             <    is read   >: prec
         if (prec)
            do {
//             <    is read   >: bytes_in_buffer
               if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
                  if (!(*datasrc->fill_input_buffer)(cinfo))
                     return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
                  next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
               }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
               bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: next_input_byte tmp
               tmp = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
               if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
                  if (!(*datasrc->fill_input_buffer)(cinfo))
                     return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
                  next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
               }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
               bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0] 
//                               tmp
//             <    is written>: next_input_byte tmp
               tmp += *next_input_byte++;
            }
            while (0);
         else
            do {
//             <    is read   >: bytes_in_buffer
               if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
                  if (!(*datasrc->fill_input_buffer)(cinfo))
                     return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
                  next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
               }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
               bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: next_input_byte tmp
               tmp = *next_input_byte++;
            }
            while (0);
//             <    is read   >: i jpeg_natural_order[i] quant_ptr tmp
//             <    is written>: 
//                               quant_ptr[0].quantval[jpeg_natural_or
//                               der[i]]
         /* We convert the zigzag-order table to natural array order. */
         (quant_ptr->quantval)[jpeg_natural_order[i]] = (UINT16) tmp;
      }
//             <    is read   >: cinfo cinfo[0].err 
//                               cinfo[0].err[0].trace_level

      if (cinfo->err->trace_level>=2)
//             <    is written>: i
         for(i = 0; i <= 63; i += 8)
            do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: _mp
               int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i]
//             <    is written>: _mp[0]
               _mp[0] = (quant_ptr->quantval)[i];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+1]
//             <    is written>: _mp[1]
               _mp[1] = (quant_ptr->quantval)[i+1];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+2]
//             <    is written>: _mp[2]
               _mp[2] = (quant_ptr->quantval)[i+2];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+3]
//             <    is written>: _mp[3]
               _mp[3] = (quant_ptr->quantval)[i+3];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+4]
//             <    is written>: _mp[4]
               _mp[4] = (quant_ptr->quantval)[i+4];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+5]
//             <    is written>: _mp[5]
               _mp[5] = (quant_ptr->quantval)[i+5];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+6]
//             <    is written>: _mp[6]
               _mp[6] = (quant_ptr->quantval)[i+6];
//             <    is read   >: _mp i quant_ptr 
//                               quant_ptr[0].quantval[i+7]
//             <    is written>: _mp[7]
               _mp[7] = (quant_ptr->quantval)[i+7];
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
               cinfo->err->msg_code = JTRC_QUANTVALS;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               (*cinfo->err->emit_message)((j_common_ptr) cinfo,2);
            }
            while (0);
//             <    is read   >: length
//             <    is written>: length

      length -= 64+1;
//             <    is read   >: prec
      if (prec)
//             <    is read   >: length
//             <    is written>: length
         length -= 64;
   }
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean get_dri(j_decompress_ptr cinfo)
{
   INT32 length;
   unsigned int tmp;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <    is read   >: length

   if (length!=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_LENGTH, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: next_input_byte tmp
      tmp = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0] 
//                               tmp
//             <    is written>: next_input_byte tmp
      tmp += *next_input_byte++;
   }
   while (0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JTRC_DRI, (cinfo->err->msg_parm.i)[0] = tmp, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: cinfo tmp
//             <    is written>: cinfo[0].restart_interval

   cinfo->restart_interval = tmp;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean get_sof(j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
{
   INT32 length;
   int c, ci;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
//             <    is read   >: cinfo is_prog
//             <    is written>: cinfo[0].progressive_mode

   cinfo->progressive_mode = is_prog;
//             <    is read   >: cinfo is_arith
//             <    is written>: cinfo[0].arith_code
   cinfo->arith_code = is_arith;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: cinfo next_input_byte 
//                               next_input_byte[0]
//             <    is written>: cinfo[0].data_precision 
//                               next_input_byte
      cinfo->data_precision = *next_input_byte++;
   }
   while (0);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: cinfo next_input_byte 
//                               next_input_byte[0]
//             <    is written>: cinfo[0].image_height next_input_byte
      cinfo->image_height = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: cinfo cinfo[0].image_height 
//                               next_input_byte next_input_byte[0]
//             <    is written>: cinfo[0].image_height next_input_byte
      cinfo->image_height += *next_input_byte++;
   }
   while (0);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: cinfo next_input_byte 
//                               next_input_byte[0]
//             <    is written>: cinfo[0].image_width next_input_byte
      cinfo->image_width = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: cinfo cinfo[0].image_width 
//                               next_input_byte next_input_byte[0]
//             <    is written>: cinfo[0].image_width next_input_byte
      cinfo->image_width += *next_input_byte++;
   }
   while (0);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: cinfo next_input_byte 
//                               next_input_byte[0]
//             <    is written>: cinfo[0].num_components 
//                               next_input_byte
      cinfo->num_components = *next_input_byte++;
   }
   while (0);
//             <    is read   >: length
//             <    is written>: length

   length -= 8;
   do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: 0`22`_mp
      int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: 0`22`_mp cinfo cinfo[0].unread_marker
//             <    is written>: 0`22`_mp[0]
      _mp[0] = cinfo->unread_marker;
//             <    is read   >: 0`22`_mp cinfo cinfo[0].image_width
//             <    is written>: 0`22`_mp[1]
      _mp[1] = (int) cinfo->image_width;
//             <    is read   >: 0`22`_mp cinfo cinfo[0].image_height
//             <    is written>: 0`22`_mp[2]
      _mp[2] = (int) cinfo->image_height;
//             <    is read   >: 0`22`_mp cinfo 
//                               cinfo[0].num_components
//             <    is written>: 0`22`_mp[3]
      _mp[3] = cinfo->num_components;
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
      cinfo->err->msg_code = JTRC_SOF;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
   }
   while (0);
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].saw_SOF
   
   
   
   if (cinfo->marker->saw_SOF)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_SOF_DUPLICATE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].image_width 
//                               cinfo[0].num_components
   
   /* We don't support files in which the image height is initially specified */
   /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
   /* might as well have a general sanity check. */
   
   if (cinfo->image_height<=0||cinfo->image_width<=0||cinfo->num_components<=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_EMPTY_IMAGE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components length
   if (length!=cinfo->num_components*3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_LENGTH, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].comp_info
   if (cinfo->comp_info==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* do only once, even if suspend */
      cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,cinfo->num_components*(size_t) sizeof(jpeg_component_info));
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               compptr
//             <    is written>: compptr[0].component_index
      compptr->component_index = ci;
      do {
//             <    is read   >: bytes_in_buffer cinfo 
//                               cinfo[0].num_components
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
//             <    is read   >: cinfo cinfo[0].num_components
               return 0;
//             <    is read   >: cinfo cinfo[0].num_components datasrc
//                               datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer cinfo 
//                               cinfo[0].num_components
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               next_input_byte next_input_byte[0]
//             <    is written>: compptr[0].component_id 
//                               next_input_byte
         compptr->component_id = *next_input_byte++;
      }
      while (0);
      do {
//             <    is read   >: bytes_in_buffer cinfo 
//                               cinfo[0].num_components
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
//             <    is read   >: cinfo cinfo[0].num_components
               return 0;
//             <    is read   >: cinfo cinfo[0].num_components datasrc
//                               datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer cinfo 
//                               cinfo[0].num_components
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
         c = *next_input_byte++;
      }
      while (0);
//             <    is read   >: c cinfo cinfo[0].num_components 
//                               compptr
//             <    is written>: compptr[0].h_samp_factor
      compptr->h_samp_factor = c>>4&15;
//             <    is read   >: c cinfo cinfo[0].num_components 
//                               compptr
//             <    is written>: compptr[0].v_samp_factor
      compptr->v_samp_factor = c&15;
      do {
//             <    is read   >: bytes_in_buffer cinfo 
//                               cinfo[0].num_components
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
//             <    is read   >: cinfo cinfo[0].num_components
               return 0;
//             <    is read   >: cinfo cinfo[0].num_components datasrc
//                               datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer cinfo 
//                               cinfo[0].num_components
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               next_input_byte next_input_byte[0]
//             <    is written>: compptr[0].quant_tbl_no 
//                               next_input_byte
         compptr->quant_tbl_no = *next_input_byte++;
      }
      while (0);
      do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: 0`23`33`_mp
         int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: 0`23`33`_mp cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].component_id
//             <    is written>: 0`23`33`_mp[0]
         _mp[0] = compptr->component_id;
//             <    is read   >: 0`23`33`_mp cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor
//             <    is written>: 0`23`33`_mp[1]
         _mp[1] = compptr->h_samp_factor;
//             <    is read   >: 0`23`33`_mp cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].v_samp_factor
//             <    is written>: 0`23`33`_mp[2]
         _mp[2] = compptr->v_samp_factor;
//             <    is read   >: 0`23`33`_mp cinfo 
//                               cinfo[0].num_components compptr 
//                               compptr[0].quant_tbl_no
//             <    is written>: 0`23`33`_mp[3]
         _mp[3] = compptr->quant_tbl_no;
//             <    is read   >: cinfo cinfo[0].err 
//                               cinfo[0].num_components
//             <    is written>: cinfo[0].err[0].msg_code
         cinfo->err->msg_code = JTRC_SOF_COMPONENT;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
      }
      while (0);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].saw_SOF

   cinfo->marker->saw_SOF = 1;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean get_soi(j_decompress_ptr cinfo)
{
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JTRC_SOI, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].saw_SOI

   if (cinfo->marker->saw_SOI)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_SOI_DUPLICATE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is written>: i
   
   /* Reset all parameters that are defined to be reset by SOI */
   
   for(i = 0; i <= 15; i += 1) {
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].arith_dc_L[i]
      (cinfo->arith_dc_L)[i] = 0;
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].arith_dc_U[i]
      (cinfo->arith_dc_U)[i] = 1;
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].arith_ac_K[i]
      (cinfo->arith_ac_K)[i] = 5;
   }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].restart_interval
   cinfo->restart_interval = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].jpeg_color_space
   
   /* Set initial assumptions for colorspace etc */
   
   cinfo->jpeg_color_space = JCS_UNKNOWN;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].CCIR601_sampling
   cinfo->CCIR601_sampling = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].saw_JFIF_marker
   /* Assume non-CCIR sampling??? */
   
   cinfo->saw_JFIF_marker = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].density_unit
   cinfo->density_unit = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].X_density
   /* set default JFIF APP0 values */
   cinfo->X_density = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Y_density
   cinfo->Y_density = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].saw_Adobe_marker
   cinfo->saw_Adobe_marker = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Adobe_transform
   cinfo->Adobe_transform = 0;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].saw_SOI

   cinfo->marker->saw_SOI = 1;

   return 1;
}
static boolean get_sos(j_decompress_ptr cinfo)
{
   INT32 length;
   int i, ci, n, c, cc;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].saw_SOF

   if (!cinfo->marker->saw_SOF)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_SOS_NO_SOF, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: n next_input_byte
      n = *next_input_byte++;
   }
   while (0);
//             <    is read   >: length n
   /* Number of components */
   
   if (length!=n*2+6||n<1||n>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_LENGTH, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JTRC_SOS, (cinfo->err->msg_parm.i)[0] = n, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: cinfo n
//             <    is written>: cinfo[0].comps_in_scan

   cinfo->comps_in_scan = n;
//             <    is read   >: n
//             <    is written>: i
   
   /* Collect the component-spec parameters */
   
   for(i = 0; i <= n-1; i += 1) {
      do {
//             <    is read   >: bytes_in_buffer n
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
//             <    is read   >: n
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte n
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer n
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: n next_input_byte next_input_byte[0]
//             <    is written>: cc next_input_byte
         cc = *next_input_byte++;
      }
      while (0);
      do {
//             <    is read   >: bytes_in_buffer n
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
//             <    is read   >: n
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte n
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer n
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: n next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
         c = *next_input_byte++;
      }
      while (0);
//             <    is read   >: cinfo cinfo[0].comp_info n
//             <    is written>: ci compptr
      ci = 0, compptr = cinfo->comp_info;
l99998:      ;
//             <    is read   >: ci cinfo cinfo[0].num_components n

      if (!(ci<cinfo->num_components)) goto l99999;
//             <    is read   >: cc compptr compptr[0].component_id n
      if (cc==compptr->component_id) goto id_found;
//             <    is read   >: ci compptr n
//             <    is written>: ci compptr
      ci++, compptr++;
      goto l99998;
l99999:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_COMPONENT_ID, (cinfo->err->msg_parm.i)[0] = cc, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: n
      
      
id_found:      ;
//             <    is read   >: cinfo compptr i n
//             <    is written>: cinfo[0].cur_comp_info[i]
      (cinfo->cur_comp_info)[i] = compptr;
//             <    is read   >: c compptr n
//             <    is written>: compptr[0].dc_tbl_no
      compptr->dc_tbl_no = c>>4&15;
//             <    is read   >: c compptr n
//             <    is written>: compptr[0].ac_tbl_no
      compptr->ac_tbl_no = c&15;
      do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: 0`9`17`_mp
         int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: 0`9`17`_mp cc n
//             <    is written>: 0`9`17`_mp[0]
         _mp[0] = cc;
//             <    is read   >: 0`9`17`_mp compptr 
//                               compptr[0].dc_tbl_no n
//             <    is written>: 0`9`17`_mp[1]
         _mp[1] = compptr->dc_tbl_no;
//             <    is read   >: 0`9`17`_mp compptr 
//                               compptr[0].ac_tbl_no n
//             <    is written>: 0`9`17`_mp[2]
         _mp[2] = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].err n
//             <    is written>: cinfo[0].err[0].msg_code
         cinfo->err->msg_code = JTRC_SOS_COMPONENT;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
      }
      while (0);
   }
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
      c = *next_input_byte++;
   }
   while (0);
//             <    is read   >: c cinfo
//             <    is written>: cinfo[0].Ss
   cinfo->Ss = c;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
      c = *next_input_byte++;
   }
   while (0);
//             <    is read   >: c cinfo
//             <    is written>: cinfo[0].Se
   cinfo->Se = c;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
      c = *next_input_byte++;
   }
   while (0);
//             <    is read   >: c cinfo
//             <    is written>: cinfo[0].Ah
   cinfo->Ah = c>>4&15;
//             <    is read   >: c cinfo
//             <    is written>: cinfo[0].Al
   cinfo->Al = c&15;
   do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: 0`27`_mp
      int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: 0`27`_mp cinfo cinfo[0].Ss
//             <    is written>: 0`27`_mp[0]
      _mp[0] = cinfo->Ss;
//             <    is read   >: 0`27`_mp cinfo cinfo[0].Se
//             <    is written>: 0`27`_mp[1]
      _mp[1] = cinfo->Se;
//             <    is read   >: 0`27`_mp cinfo cinfo[0].Ah
//             <    is written>: 0`27`_mp[2]
      _mp[2] = cinfo->Ah;
//             <    is read   >: 0`27`_mp cinfo cinfo[0].Al
//             <    is written>: 0`27`_mp[3]
      _mp[3] = cinfo->Al;
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
      cinfo->err->msg_code = JTRC_SOS_PARAMS;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
   }
   while (0);
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].next_restart_num
   
   
   /* Prepare to scan data & restart markers */
   cinfo->marker->next_restart_num = 0;
//             <    is read   >: cinfo cinfo[0].input_scan_number
//             <    is written>: cinfo[0].input_scan_number
   
   /* Count another SOS marker */
   cinfo->input_scan_number++;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static boolean next_marker(j_decompress_ptr cinfo)
{
   int c;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
l99999:   ;

   if (!1) goto _break_1;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
      c = *next_input_byte++;
   }
   while (0);
//             <    is read   >: c
   /* Skip any non-FF bytes.
        * This may look a bit inefficient, but it will not occur in a valid file.
        * We sync after each discarded byte so that a suspending data source
        * can discard the byte from its buffer.
        */
   while (c!=0xFF) {
//             <    is read   >: cinfo cinfo[0].marker cinfo[0].marker
//                               cinfo[0].marker[0].discarded_bytes
//             <    is written>: cinfo[0].marker[0].discarded_bytes
      cinfo->marker->discarded_bytes++;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
      datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
      do {
//             <    is read   >: bytes_in_buffer
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
         c = *next_input_byte++;
      }
      while (0);
   }
//             <    is read   >: c
   do {
      do {
//             <    is read   >: bytes_in_buffer
         if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!(*datasrc->fill_input_buffer)(cinfo))
               return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
            next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
         }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
         c = *next_input_byte++;
      }
      while (0);
   }
   while (c==0xFF);
//             <    is read   >: c
   if (c!=0) goto _break_1;
//             <    is read   >: cinfo cinfo[0].marker cinfo[0].marker
//                               cinfo[0].marker[0].discarded_bytes
//             <    is written>: cinfo[0].marker[0].discarded_bytes
   /* found a valid marker, exit loop */
   /* Reach here if we found a stuffed-zero data sequence (FF/00).
        * Discard it and loop back to try again.
        */
   cinfo->marker->discarded_bytes += 2;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   goto l99999;
_break_1:   ;
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].discarded_bytes

   if (cinfo->marker->discarded_bytes!=0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_EXTRANEOUS_DATA, (cinfo->err->msg_parm.i)[0] = cinfo->marker->discarded_bytes, (cinfo->err->msg_parm.i)[1] = c, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].discarded_bytes
      cinfo->marker->discarded_bytes = 0;
   }
//             <    is read   >: c cinfo
//             <    is written>: cinfo[0].unread_marker

   cinfo->unread_marker = c;
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
   return 1;
}
static int read_markers(j_decompress_ptr cinfo)
{
   /* Outer loop repeats once for each marker. */
   while (1) {
//             <    is read   >: cinfo cinfo[0].unread_marker
      /* Collect the marker proper, unless we already did. */
      /* NB: first_marker() enforces the requirement that SOI appear first. */
      if (cinfo->unread_marker==0)
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].saw_SOI
         if (!cinfo->marker->saw_SOI)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!first_marker(cinfo))
               return 0;
         else if (!next_marker(cinfo))
            return 0;
//             <    is read   >: cinfo cinfo[0].unread_marker
/* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
      if (cinfo->unread_marker==M_SOI) goto _switch_2_case_M_SOI;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF0) goto _switch_2_case_M_SOF0;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF1) goto _switch_2_case_M_SOF1;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF2) goto _switch_2_case_M_SOF2;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF9) goto _switch_2_case_M_SOF9;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF10) goto _switch_2_case_M_SOF10;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF3) goto _switch_2_case_M_SOF3;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF5) goto _switch_2_case_M_SOF5;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF6) goto _switch_2_case_M_SOF6;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF7) goto _switch_2_case_M_SOF7;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_JPG) goto _switch_2_case_M_JPG;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF11) goto _switch_2_case_M_SOF11;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF13) goto _switch_2_case_M_SOF13;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF14) goto _switch_2_case_M_SOF14;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOF15) goto _switch_2_case_M_SOF15;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_SOS) goto _switch_2_case_M_SOS;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_EOI) goto _switch_2_case_M_EOI;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_DAC) goto _switch_2_case_M_DAC;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_DHT) goto _switch_2_case_M_DHT;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_DQT) goto _switch_2_case_M_DQT;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_DRI) goto _switch_2_case_M_DRI;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP0) goto _switch_2_case_M_APP0;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP1) goto _switch_2_case_M_APP1;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP2) goto _switch_2_case_M_APP2;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP3) goto _switch_2_case_M_APP3;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP4) goto _switch_2_case_M_APP4;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP5) goto _switch_2_case_M_APP5;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP6) goto _switch_2_case_M_APP6;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP7) goto _switch_2_case_M_APP7;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP8) goto _switch_2_case_M_APP8;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP9) goto _switch_2_case_M_APP9;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP10) goto _switch_2_case_M_APP10;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP11) goto _switch_2_case_M_APP11;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP12) goto _switch_2_case_M_APP12;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP13) goto _switch_2_case_M_APP13;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP14) goto _switch_2_case_M_APP14;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_APP15) goto _switch_2_case_M_APP15;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_COM) goto _switch_2_case_M_COM;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST0) goto _switch_2_case_M_RST0;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST1) goto _switch_2_case_M_RST1;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST2) goto _switch_2_case_M_RST2;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST3) goto _switch_2_case_M_RST3;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST4) goto _switch_2_case_M_RST4;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST5) goto _switch_2_case_M_RST5;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST6) goto _switch_2_case_M_RST6;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_RST7) goto _switch_2_case_M_RST7;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_TEM) goto _switch_2_case_M_TEM;
//             <    is read   >: cinfo cinfo[0].unread_marker
      if (cinfo->unread_marker==M_DNL) {

_switch_2_case_M_DNL:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Ignore DNL ... perhaps the wrong thing */
         if (!skip_variable(cinfo))
            return 0;
      }
      else {

_switch_2_default:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* must be DHP, EXP, JPGn, or RESn */
         /* For now, we treat the reserved markers as fatal errors since they are
                * likely to be used to signal incompatible JPEG Part 3 extensions.
                * Once the JPEG 3 version-number marker is well defined, this code
                * ought to change!
                */
         cinfo->err->msg_code = JERR_UNKNOWN_MARKER, (cinfo->err->msg_parm.i)[0] = cinfo->unread_marker, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
      goto _break_2;
_switch_2_case_M_TEM:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_PARMLESS_MARKER, (cinfo->err->msg_parm.i)[0] = cinfo->unread_marker, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
      goto _break_2;
_switch_2_case_M_RST7:      ;
      goto _switch_2_case_M_TEM;
_switch_2_case_M_RST6:      ;
      goto _switch_2_case_M_RST7;
_switch_2_case_M_RST5:      ;
      goto _switch_2_case_M_RST6;
_switch_2_case_M_RST4:      ;
      goto _switch_2_case_M_RST5;
_switch_2_case_M_RST3:      ;
      goto _switch_2_case_M_RST4;
_switch_2_case_M_RST2:      ;
      goto _switch_2_case_M_RST3;
      /* these are all parameterless */
_switch_2_case_M_RST1:      ;
      goto _switch_2_case_M_RST2;

_switch_2_case_M_RST0:      ;
      goto _switch_2_case_M_RST1;

_switch_2_case_M_COM:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*cinfo->marker->process_COM)(cinfo))
         return 0;
      goto _break_2;
_switch_2_case_M_APP15:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*(cinfo->marker->process_APPn)[cinfo->unread_marker-((int) M_APP0)])(cinfo))
         return 0;
      goto _break_2;
_switch_2_case_M_APP14:      ;
      goto _switch_2_case_M_APP15;
_switch_2_case_M_APP13:      ;
      goto _switch_2_case_M_APP14;
_switch_2_case_M_APP12:      ;
      goto _switch_2_case_M_APP13;
_switch_2_case_M_APP11:      ;
      goto _switch_2_case_M_APP12;
_switch_2_case_M_APP10:      ;
      goto _switch_2_case_M_APP11;
_switch_2_case_M_APP9:      ;
      goto _switch_2_case_M_APP10;
_switch_2_case_M_APP8:      ;
      goto _switch_2_case_M_APP9;
_switch_2_case_M_APP7:      ;
      goto _switch_2_case_M_APP8;
_switch_2_case_M_APP6:      ;
      goto _switch_2_case_M_APP7;
_switch_2_case_M_APP5:      ;
      goto _switch_2_case_M_APP6;
_switch_2_case_M_APP4:      ;
      goto _switch_2_case_M_APP5;
_switch_2_case_M_APP3:      ;
      goto _switch_2_case_M_APP4;
_switch_2_case_M_APP2:      ;
      goto _switch_2_case_M_APP3;
_switch_2_case_M_APP1:      ;
      goto _switch_2_case_M_APP2;

_switch_2_case_M_APP0:      ;
      goto _switch_2_case_M_APP1;

_switch_2_case_M_DRI:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!get_dri(cinfo))
         return 0;
      goto _break_2;

_switch_2_case_M_DQT:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!get_dqt(cinfo))
         return 0;
      goto _break_2;

_switch_2_case_M_DHT:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!get_dht(cinfo))
         return 0;
      goto _break_2;

_switch_2_case_M_DAC:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!get_dac(cinfo))
         return 0;
      goto _break_2;

_switch_2_case_M_EOI:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_EOI, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].unread_marker
      cinfo->unread_marker = 0;
      /* processed the marker */
      return 2;

_switch_2_case_M_SOS:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!get_sos(cinfo))
         return 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].unread_marker
      cinfo->unread_marker = 0;
      /* processed the marker */
      return 1;
      /* Differential progressive, arithmetic */
_switch_2_case_M_SOF15:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Differential lossless, arithmetic */
      cinfo->err->msg_code = JERR_SOF_UNSUPPORTED, (cinfo->err->msg_parm.i)[0] = cinfo->unread_marker, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      goto _break_2;
      /* Differential sequential, arithmetic */
_switch_2_case_M_SOF14:      ;
      goto _switch_2_case_M_SOF15;
      /* Lossless, arithmetic */
_switch_2_case_M_SOF13:      ;
      goto _switch_2_case_M_SOF14;
      /* Reserved for JPEG extensions */
_switch_2_case_M_SOF11:      ;
      goto _switch_2_case_M_SOF13;
      /* Differential lossless, Huffman */
_switch_2_case_M_JPG:      ;
      goto _switch_2_case_M_SOF11;
      /* Differential progressive, Huffman */
_switch_2_case_M_SOF7:      ;
      goto _switch_2_case_M_JPG;
      /* Differential sequential, Huffman */
_switch_2_case_M_SOF6:      ;
      goto _switch_2_case_M_SOF7;
      /* Lossless, Huffman */
_switch_2_case_M_SOF5:      ;
      goto _switch_2_case_M_SOF6;
      
      /* Currently unsupported SOFn types */
_switch_2_case_M_SOF3:      ;
      goto _switch_2_case_M_SOF5;

_switch_2_case_M_SOF10:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Progressive, arithmetic */
      if (!get_sof(cinfo, 1, 1))
         return 0;
      goto _break_2;

_switch_2_case_M_SOF9:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Extended sequential, arithmetic */
      if (!get_sof(cinfo, 0, 1))
         return 0;
      goto _break_2;

_switch_2_case_M_SOF2:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Progressive, Huffman */
      if (!get_sof(cinfo, 1, 0))
         return 0;
      goto _break_2;
      /* Baseline */
_switch_2_case_M_SOF1:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Extended sequential, Huffman */
      if (!get_sof(cinfo, 0, 0))
         return 0;
      goto _break_2;

_switch_2_case_M_SOF0:      ;
      goto _switch_2_case_M_SOF1;
_switch_2_case_M_SOI:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!get_soi(cinfo))
         return 0;
_break_2:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].unread_marker
      /* Successfully processed marker, so reset state variable */
      cinfo->unread_marker = 0;
   }
}
static boolean read_restart_marker(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].unread_marker
   /* Obtain a marker unless we already did. */
   /* Note that next_marker will complain if it skips any data. */
   if (cinfo->unread_marker==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!next_marker(cinfo))
         return 0;
//             <    is read   >: cinfo cinfo[0].marker 
//                               cinfo[0].marker[0].next_restart_num 
//                               cinfo[0].unread_marker
   if (cinfo->unread_marker==(int) M_RST0+cinfo->marker->next_restart_num) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Normal case --- swallow the marker and let entropy decoder continue */
      cinfo->err->msg_code = JTRC_RST, (cinfo->err->msg_parm.i)[0] = cinfo->marker->next_restart_num, (*cinfo->err->emit_message)((j_common_ptr) cinfo,3);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].unread_marker
      cinfo->unread_marker = 0;
   }
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Uh-oh, the restart markers have been messed up. */
      /* Let the data source manager determine how to resync. */
      if (!(*cinfo->src->resync_to_restart)(cinfo,cinfo->marker->next_restart_num))
         return 0;
//             <    is read   >: cinfo cinfo[0].marker cinfo[0].marker
//                               cinfo[0].marker[0].next_restart_num
//             <    is written>: cinfo[0].marker[0].next_restart_num
   
   /* Update next-restart state */
   cinfo->marker->next_restart_num = cinfo->marker->next_restart_num+1&7;

   return 1;
}
static void reset_marker_reader(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].comp_info
   cinfo->comp_info = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].input_scan_number
   /* until allocated by get_sof */
   cinfo->input_scan_number = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].unread_marker
   /* no SOS seen yet */
   cinfo->unread_marker = 0;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].saw_SOI
   /* no pending marker */
   cinfo->marker->saw_SOI = 0;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].saw_SOF
   /* set internal state too */
   cinfo->marker->saw_SOF = 0;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].discarded_bytes
   cinfo->marker->discarded_bytes = 0;
}
static boolean skip_variable(j_decompress_ptr cinfo)
{
   INT32 length;
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: datasrc
   struct jpeg_source_mgr *datasrc = cinfo->src;
//             <    is read   >: datasrc datasrc[0].next_input_byte
//             <    is written>: next_input_byte
   const JOCTET *next_input_byte = datasrc->next_input_byte;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   size_t bytes_in_buffer = datasrc->bytes_in_buffer;
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: length next_input_byte
      length = (unsigned int) *next_input_byte++<<8;
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*datasrc->fill_input_buffer)(cinfo))
            return 0;
//             <    is read   >: datasrc datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
//             <    is written>: bytes_in_buffer next_input_byte
         next_input_byte = datasrc->next_input_byte, bytes_in_buffer = datasrc->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: length next_input_byte 
//                               next_input_byte[0]
//             <    is written>: length next_input_byte
      length += *next_input_byte++;
   }
   while (0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JTRC_MISC_MARKER, (cinfo->err->msg_parm.i)[0] = cinfo->unread_marker, (cinfo->err->msg_parm.i)[1] = (int) length, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <    is read   >: bytes_in_buffer datasrc 
//                               next_input_byte
//             <    is written>: datasrc[0].bytes_in_buffer 
//                               datasrc[0].next_input_byte
   datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer = bytes_in_buffer;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* do before skip_input_data */
   (*cinfo->src->skip_input_data)(cinfo,(long int) length-2L);

   return 1;
}
static void finish_output_pass(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
   my_master_ptr master = (my_master_ptr) cinfo->master;
//             <    is read   >: cinfo cinfo[0].quantize_colors

   if (cinfo->quantize_colors)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->cquantize->finish_pass)(cinfo);
//             <    is read   >: master master[0].pass_number
//             <    is written>: master[0].pass_number
   master->pass_number++;
}
static void master_selection(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
   my_master_ptr master = (my_master_ptr) cinfo->master;
   boolean use_c_buffer;
   long int samplesperrow;
   JDIMENSION jd_samplesperrow;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Initialize dimensions and other stuff */
   jpeg_calc_output_dimensions(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   prepare_range_limit_table(cinfo);
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cinfo[0].output_width
//             <    is written>: samplesperrow
   
   /* Width of an output scanline must be representable as JDIMENSION. */
   samplesperrow = (long int) cinfo->output_width*(long int) cinfo->out_color_components;
//             <    is read   >: samplesperrow
//             <    is written>: jd_samplesperrow
   jd_samplesperrow = (JDIMENSION) samplesperrow;
//             <    is read   >: jd_samplesperrow samplesperrow
   if ((long int) jd_samplesperrow!=samplesperrow)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_WIDTH_OVERFLOW, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: master
//             <    is written>: master[0].pass_number
   
   /* Initialize my private state */
   master->pass_number = 0;
//             <    is read   >: cinfo cinfo[0].CCIR601_sampling 
//                               cinfo[0].comp_info 
//                               cinfo[0].comp_info[0].DCT_scaled_size
//                               cinfo[0].comp_info[0].h_samp_factor 
//                               cinfo[0].comp_info[0].v_samp_factor 
//                               cinfo[0].comp_info[1].DCT_scaled_size
//                               cinfo[0].comp_info[1].h_samp_factor 
//                               cinfo[0].comp_info[1].v_samp_factor 
//                               cinfo[0].comp_info[2].DCT_scaled_size
//                               cinfo[0].comp_info[2].h_samp_factor 
//                               cinfo[0].comp_info[2].v_samp_factor 
//                               cinfo[0].do_fancy_upsampling 
//                               cinfo[0].jpeg_color_space 
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components 
//                               cinfo[0].out_color_components 
//                               cinfo[0].out_color_space master
//             <    is written>: master[0].using_merged_upsample
   master->using_merged_upsample = use_merged_upsample(cinfo);
//             <    is read   >: master
//             <    is written>: master[0].quantizer_1pass
   
   /* Color quantizer selection */
   master->quantizer_1pass = (void *) 0;
//             <    is read   >: master
//             <    is written>: master[0].quantizer_2pass
   master->quantizer_2pass = (void *) 0;
//             <    is read   >: cinfo cinfo[0].buffered_image 
//                               cinfo[0].quantize_colors
   /* No mode changes if not using buffered-image mode. */
   if (!cinfo->quantize_colors||!cinfo->buffered_image) {
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_1pass_quant
      cinfo->enable_1pass_quant = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_external_quant
      cinfo->enable_external_quant = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_2pass_quant
      cinfo->enable_2pass_quant = 0;
   }
//             <    is read   >: cinfo cinfo[0].quantize_colors
   if (cinfo->quantize_colors) {
//             <    is read   >: cinfo cinfo[0].raw_data_out
      if (cinfo->raw_data_out)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].out_color_components
      /* 2-pass quantizer only works in 3-component color space. */
      if (cinfo->out_color_components!=3) {
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_1pass_quant
         cinfo->enable_1pass_quant = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_external_quant
         cinfo->enable_external_quant = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_2pass_quant
         cinfo->enable_2pass_quant = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].colormap
         cinfo->colormap = (void *) 0;
      }
      else if (cinfo->colormap!=(void *) 0)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_external_quant
         cinfo->enable_external_quant = 1;
      else if (cinfo->two_pass_quantize)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_2pass_quant
         cinfo->enable_2pass_quant = 1;
      else
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].enable_1pass_quant
         cinfo->enable_1pass_quant = 1;
//             <    is read   >: cinfo cinfo[0].enable_1pass_quant

      if (cinfo->enable_1pass_quant) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

         jinit_1pass_quantizer(cinfo);
//             <    is read   >: cinfo cinfo[0].cquantize master
//             <    is written>: master[0].quantizer_1pass
         master->quantizer_1pass = cinfo->cquantize;
      }
//             <    is read   >: cinfo cinfo[0].enable_2pass_quant 
//                               cinfo[0].enable_external_quant
      
      /* We use the 2-pass code to map to external colormaps. */
      if (cinfo->enable_2pass_quant||cinfo->enable_external_quant) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

         jinit_2pass_quantizer(cinfo);
//             <    is read   >: cinfo cinfo[0].cquantize master
//             <    is written>: master[0].quantizer_2pass
         master->quantizer_2pass = cinfo->cquantize;
      }
   }
//             <    is read   >: cinfo cinfo[0].raw_data_out
   
   /* Post-processing: in particular, color conversion first */
   if (!cinfo->raw_data_out) {
//             <    is read   >: master 
//                               master[0].using_merged_upsample
      if (master->using_merged_upsample)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

         jinit_merged_upsampler(cinfo);
      else {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         jinit_color_deconverter(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         jinit_upsampler(cinfo);
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Inverse DCT */
   jinit_inverse_dct(cinfo);
//             <    is read   >: cinfo cinfo[0].arith_code
   /* Entropy decoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_ARITH_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   else if (cinfo->progressive_mode)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      jinit_phuff_decoder(cinfo);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_huff_decoder(cinfo);
//             <    is read   >: cinfo cinfo[0].buffered_image 
//                               cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns
//             <    is written>: use_c_buffer
   
   /* Initialize principal buffer controllers. */
   use_c_buffer = cinfo->inputctl->has_multiple_scans||cinfo->buffered_image;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   jinit_d_coef_controller(cinfo, use_c_buffer);
//             <    is read   >: cinfo cinfo[0].raw_data_out

   if (!cinfo->raw_data_out)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* never need full buffer here */
      jinit_d_main_controller(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* We can now tell the memory manager to allocate virtual arrays. */
   (*cinfo->mem->realize_virt_arrays)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Initialize input side of decompressor to consume first scan. */
   (*cinfo->inputctl->start_input_pass)(cinfo);
//             <    is read   >: cinfo cinfo[0].buffered_image 
//                               cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns cinfo[0].progress
   if (cinfo->progress!=(void *) 0&&!cinfo->buffered_image&&cinfo->inputctl->has_multiple_scans) {
      int nscans;
//             <    is read   >: cinfo cinfo[0].progressive_mode
      /* Estimate number of scans to set pass_limit. */
      
      
      /* If jpeg_start_decompress will read the whole file, initialize
         * progress monitoring appropriately.  The input step is counted
         * as one pass.
         */
      if (cinfo->progressive_mode)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: nscans
         /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
         nscans = 2+3*cinfo->num_components;
      else
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: nscans
         /* For a nonprogressive multiscan file, estimate 1 scan per component. */
         nscans = cinfo->num_components;
//             <    is read   >: cinfo cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
      cinfo->progress->pass_counter = 0L;
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].total_iMCU_rows nscans
//             <    is written>: cinfo[0].progress[0].pass_limit
      cinfo->progress->pass_limit = (long int) cinfo->total_iMCU_rows*nscans;
//             <    is read   >: cinfo cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].completed_passes
      cinfo->progress->completed_passes = 0;
//             <    is read   >: cinfo cinfo[0].enable_2pass_quant 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].total_passes
      cinfo->progress->total_passes = cinfo->enable_2pass_quant?3:2;
//             <    is read   >: master master[0].pass_number
//             <    is written>: master[0].pass_number
      /* Count the input pass as done */
      master->pass_number++;
   }
}
static void prepare_for_output_pass(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
   my_master_ptr master = (my_master_ptr) cinfo->master;
//             <    is read   >: master master[0].pub.is_dummy_pass

   if (master->pub.is_dummy_pass) {
//             <    is read   >: master
//             <    is written>: master[0].pub.is_dummy_pass
      
      /* Final pass of 2-pass quantization */
      master->pub.is_dummy_pass = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->cquantize->start_pass)(cinfo,0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->post->start_pass)(cinfo,JBUF_CRANK_DEST);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->main->start_pass)(cinfo,JBUF_CRANK_DEST);
   }
   else {
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].quantize_colors
      if (cinfo->quantize_colors&&cinfo->colormap==(void *) 0)
//             <    is read   >: cinfo cinfo[0].enable_2pass_quant 
//                               cinfo[0].two_pass_quantize
         /* Select new quantization method */
         if (cinfo->two_pass_quantize&&cinfo->enable_2pass_quant) {
//             <    is read   >: cinfo master 
//                               master[0].quantizer_2pass
//             <    is written>: cinfo[0].cquantize
            cinfo->cquantize = master->quantizer_2pass;
//             <    is read   >: master
//             <    is written>: master[0].pub.is_dummy_pass
            master->pub.is_dummy_pass = 1;
         }
         else if (cinfo->enable_1pass_quant)
//             <    is read   >: cinfo master 
//                               master[0].quantizer_1pass
//             <    is written>: cinfo[0].cquantize
            cinfo->cquantize = master->quantizer_1pass;
         else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_MODE_CHANGE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->idct->start_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->coef->start_output_pass)(cinfo);
//             <    is read   >: cinfo cinfo[0].raw_data_out
      if (!cinfo->raw_data_out) {
//             <    is read   >: master 
//                               master[0].using_merged_upsample
         if (!master->using_merged_upsample)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->cconvert->start_pass)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->upsample->start_pass)(cinfo);
//             <    is read   >: cinfo cinfo[0].quantize_colors
         if (cinfo->quantize_colors)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->cquantize->start_pass)(cinfo,master->pub.is_dummy_pass);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->post->start_pass)(cinfo,master->pub.is_dummy_pass?JBUF_SAVE_AND_PASS:JBUF_PASS_THRU);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->main->start_pass)(cinfo,JBUF_PASS_THRU);
      }
   }
//             <    is read   >: cinfo cinfo[0].progress
   if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].progress master 
//                               master[0].pass_number
//             <    is written>: cinfo[0].progress[0].completed_passes
      cinfo->progress->completed_passes = master->pass_number;
//             <    is read   >: cinfo cinfo[0].progress master 
//                               master[0].pass_number 
//                               master[0].pub.is_dummy_pass
//             <    is written>: cinfo[0].progress[0].total_passes
      cinfo->progress->total_passes = master->pass_number+(master->pub.is_dummy_pass?2:1);
//             <    is read   >: cinfo cinfo[0].buffered_image 
//                               cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].eoi_reached
      /* In buffered-image mode, we assume one more output pass if EOI not
           * yet reached, but no more passes if EOI has been reached.
           */
      
      /* Set up progress monitor's pass info if present */
      if (cinfo->buffered_image&&!cinfo->inputctl->eoi_reached)
//             <    is read   >: cinfo cinfo[0].enable_2pass_quant 
//                               cinfo[0].progress cinfo[0].progress 
//                               cinfo[0].progress[0].total_passes
//             <    is written>: cinfo[0].progress[0].total_passes
         cinfo->progress->total_passes += cinfo->enable_2pass_quant?2:1;
   }
}
static void prepare_range_limit_table(j_decompress_ptr cinfo)
{
   JSAMPLE *table;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   table = (JSAMPLE *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(5*(255+1)+128)*(size_t) sizeof(JSAMPLE));
//             <    is read   >: table
//             <    is written>: table
   table += 255+1;
//             <    is read   >: cinfo table
//             <    is written>: cinfo[0].sample_range_limit
   /* allow negative subscripts of simple table */
   cinfo->sample_range_limit = table;
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: table
   /* First segment of "simple" table: limit[x] = 0 for x < 0 */
   memset((void *) (table-(255+1)), 0, (size_t) ((255+1)*(size_t) sizeof(JSAMPLE)));
//             <    is written>: i
   /* Main part of "simple" table: limit[x] = x */
   for(i = 0; i <= 255; i += 1)
//             <    is read   >: i table
//             <    is written>: table[i]
      table[i] = (JSAMPLE) i;
//             <    is read   >: table
//             <    is written>: table
   table += 128;
//             <    is written>: i
   /* Point to where post-IDCT table starts */
   /* End of simple table, rest of first half of post-IDCT table */
   for(i = 128; i <= 511; i += 1)
//             <    is read   >: i table
//             <    is written>: table[i]
      table[i] = 255;
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: table
   /* Second half of post-IDCT table */
   memset((void *) (table+2*(255+1)), 0, (size_t) ((2*(255+1)-128)*(size_t) sizeof(JSAMPLE)));
//             <may be read   >: cinfo[0].sample_range_limit[*]
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: cinfo cinfo[0].sample_range_limit 
//                               table
   memcpy((void *) (table+(4*(255+1)-128)), (void *) cinfo->sample_range_limit, (size_t) (128*(size_t) sizeof(JSAMPLE)));
}
static boolean use_merged_upsample(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].CCIR601_sampling 
//                               cinfo[0].do_fancy_upsampling
   
   /* Merging is the equivalent of plain box-filter upsampling */
   if (cinfo->do_fancy_upsampling||cinfo->CCIR601_sampling)
      return 0;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space 
//                               cinfo[0].num_components 
//                               cinfo[0].out_color_components 
//                               cinfo[0].out_color_space
   /* jdmerge.c only supports YCC=>RGB color conversion */
   
   
   if (cinfo->jpeg_color_space!=JCS_YCbCr||cinfo->num_components!=3||cinfo->out_color_space!=JCS_RGB||cinfo->out_color_components!=3)
      return 0;
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].comp_info cinfo[0].comp_info
//                               cinfo[0].comp_info cinfo[0].comp_info
//                               cinfo[0].comp_info 
//                               cinfo[0].comp_info[0].h_samp_factor 
//                               cinfo[0].comp_info[0].v_samp_factor 
//                               cinfo[0].comp_info[1].h_samp_factor 
//                               cinfo[0].comp_info[1].v_samp_factor 
//                               cinfo[0].comp_info[2].h_samp_factor 
//                               cinfo[0].comp_info[2].v_samp_factor
   /* and it only handles 2h1v or 2h2v sampling ratios */
   
   
   
   
   
   if ((cinfo->comp_info)[0].h_samp_factor!=2||(cinfo->comp_info)[1].h_samp_factor!=1||(cinfo->comp_info)[2].h_samp_factor!=1||(cinfo->comp_info)[0].v_samp_factor>2||(cinfo->comp_info)[1].v_samp_factor!=1||(cinfo->comp_info)[2].v_samp_factor!=1)
      return 0;
//             <    is read   >: cinfo cinfo[0].comp_info 
//                               cinfo[0].comp_info cinfo[0].comp_info
//                               cinfo[0].comp_info[0].DCT_scaled_size
//                               cinfo[0].comp_info[1].DCT_scaled_size
//                               cinfo[0].comp_info[2].DCT_scaled_size
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].min_DCT_scaled_size
   /* furthermore, it doesn't work if we've scaled the IDCTs differently */
   
   
   if ((cinfo->comp_info)[0].DCT_scaled_size!=cinfo->min_DCT_scaled_size||(cinfo->comp_info)[1].DCT_scaled_size!=cinfo->min_DCT_scaled_size||(cinfo->comp_info)[2].DCT_scaled_size!=cinfo->min_DCT_scaled_size)
      return 0;
   /* ??? also need to test for upsample-time rescaling, when & if supported */
   return 1;
}
static void build_ycc_rgb_table(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   int i;
   INT32 x;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   upsample->Cr_r_tab = (int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(int));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   upsample->Cb_b_tab = (int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(int));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   upsample->Cr_g_tab = (INT32 *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(INT32));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   upsample->Cb_g_tab = (INT32 *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255+1)*(size_t) sizeof(INT32));
//             <    is written>: x
   x = -128;
//             <    is written>: i

   for(i = 0; i <= 255; i += 1) {
//             <    is read   >: i upsample upsample[0].Cr_r_tab x
//             <    is written>: upsample[0].Cr_r_tab[i]
      /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
      /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
      /* Cr=>R value is nearest int to 1.40200 * x */
      
      (upsample->Cr_r_tab)[i] = (int) ((INT32) (1.40200*(1L<<16)+0.5)*x+((INT32) 1<<16-1)>>16);
//             <    is read   >: i upsample upsample[0].Cb_b_tab x
//             <    is written>: upsample[0].Cb_b_tab[i]
      /* Cb=>B value is nearest int to 1.77200 * x */
      
      (upsample->Cb_b_tab)[i] = (int) ((INT32) (1.77200*(1L<<16)+0.5)*x+((INT32) 1<<16-1)>>16);
//             <    is read   >: i upsample upsample[0].Cr_g_tab x
//             <    is written>: upsample[0].Cr_g_tab[i]
      /* Cr=>G value is scaled-up -0.71414 * x */
      (upsample->Cr_g_tab)[i] = -((INT32) (0.71414*(1L<<16)+0.5))*x;
//             <    is read   >: i upsample upsample[0].Cb_g_tab x
//             <    is written>: upsample[0].Cb_g_tab[i]
      /* Cb=>G value is scaled-up -0.34414 * x */
      /* We also add in ONE_HALF so that need not do it in inner loop */
      (upsample->Cb_g_tab)[i] = -((INT32) (0.34414*(1L<<16)+0.5))*x+((INT32) 1<<16-1);
//             <    is read   >: x
//             <    is written>: x
      x++;
   }
}
static void h2v1_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr;
   JSAMPROW inptr0, inptr1, inptr2;
   JDIMENSION col;
   /* copy these pointers into registers if possible */
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   register JSAMPLE *range_limit = cinfo->sample_range_limit;
//             <    is read   >: upsample upsample[0].Cr_r_tab
//             <    is written>: Crrtab
   int *Crrtab = upsample->Cr_r_tab;
//             <    is read   >: upsample upsample[0].Cb_b_tab
//             <    is written>: Cbbtab
   int *Cbbtab = upsample->Cb_b_tab;
//             <    is read   >: upsample upsample[0].Cr_g_tab
//             <    is written>: Crgtab
   INT32 *Crgtab = upsample->Cr_g_tab;
//             <    is read   >: upsample upsample[0].Cb_g_tab
//             <    is written>: Cbgtab
   INT32 *Cbgtab = upsample->Cb_g_tab;
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[0] 
//                               input_buf[0][in_row_group_ctr]
//             <    is written>: inptr0
   
   
   inptr0 = input_buf[0][in_row_group_ctr];
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[1] 
//                               input_buf[1][in_row_group_ctr]
//             <    is written>: inptr1
   inptr1 = input_buf[1][in_row_group_ctr];
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[2] 
//                               input_buf[2][in_row_group_ctr]
//             <    is written>: inptr2
   inptr2 = input_buf[2][in_row_group_ctr];
//             <    is read   >: output_buf output_buf[0]
//             <    is written>: outptr
   outptr = output_buf[0];
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: col
   /* Loop for each pair of output pixels */
   for(col = cinfo->output_width>>1; col >= 1; col += -1) {
//             <    is read   >: cinfo cinfo[0].output_width inptr1 
//                               inptr1[0]
//             <    is written>: cb inptr1
      /* Do the chroma part of the calculation */
      cb = (int) *inptr1++;
//             <    is read   >: cinfo cinfo[0].output_width inptr2 
//                               inptr2[0]
//             <    is written>: cr inptr2
      cr = (int) *inptr2++;
//             <    is read   >: Crrtab Crrtab[cr] cinfo 
//                               cinfo[0].output_width cr
//             <    is written>: cred
      cred = Crrtab[cr];
//             <    is read   >: Cbgtab Cbgtab[cb] Crgtab Crgtab[cr] 
//                               cb cinfo cinfo[0].output_width cr
//             <    is written>: cgreen
      cgreen = (int) (Cbgtab[cb]+Crgtab[cr]>>16);
//             <    is read   >: Cbbtab Cbbtab[cb] cb cinfo 
//                               cinfo[0].output_width
//             <    is written>: cblue
      cblue = Cbbtab[cb];
//             <    is read   >: cinfo cinfo[0].output_width inptr0 
//                               inptr0[0]
//             <    is written>: inptr0 y
      /* Fetch 2 Y values and emit 2 pixels */
      y = (int) *inptr0++;
//             <    is read   >: cinfo cinfo[0].output_width cred 
//                               outptr range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr[0]
      outptr[0] = range_limit[y+cred];
//             <    is read   >: cgreen cinfo cinfo[0].output_width 
//                               outptr range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr[1]
      outptr[1] = range_limit[y+cgreen];
//             <    is read   >: cblue cinfo cinfo[0].output_width 
//                               outptr range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr[2]
      outptr[2] = range_limit[y+cblue];
//             <    is read   >: cinfo cinfo[0].output_width outptr
//             <    is written>: outptr
      outptr += 3;
//             <    is read   >: cinfo cinfo[0].output_width inptr0 
//                               inptr0[0]
//             <    is written>: inptr0 y
      y = (int) *inptr0++;
//             <    is read   >: cinfo cinfo[0].output_width cred 
//                               outptr range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr[0]
      outptr[0] = range_limit[y+cred];
//             <    is read   >: cgreen cinfo cinfo[0].output_width 
//                               outptr range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr[1]
      outptr[1] = range_limit[y+cgreen];
//             <    is read   >: cblue cinfo cinfo[0].output_width 
//                               outptr range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr[2]
      outptr[2] = range_limit[y+cblue];
//             <    is read   >: cinfo cinfo[0].output_width outptr
//             <    is written>: outptr
      outptr += 3;
   }
//             <    is read   >: cinfo cinfo[0].output_width
   /* If image width is odd, do the last output column separately */
   if (cinfo->output_width&1) {
//             <    is read   >: inptr1 inptr1[0]
//             <    is written>: cb
      cb = (int) *inptr1;
//             <    is read   >: inptr2 inptr2[0]
//             <    is written>: cr
      cr = (int) *inptr2;
//             <    is read   >: Crrtab Crrtab[cr] cr
//             <    is written>: cred
      cred = Crrtab[cr];
//             <    is read   >: Cbgtab Cbgtab[cb] Crgtab Crgtab[cr] 
//                               cb cr
//             <    is written>: cgreen
      cgreen = (int) (Cbgtab[cb]+Crgtab[cr]>>16);
//             <    is read   >: Cbbtab Cbbtab[cb] cb
//             <    is written>: cblue
      cblue = Cbbtab[cb];
//             <    is read   >: inptr0 inptr0[0]
//             <    is written>: y
      y = (int) *inptr0;
//             <    is read   >: cred outptr range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr[0]
      outptr[0] = range_limit[y+cred];
//             <    is read   >: cgreen outptr range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr[1]
      outptr[1] = range_limit[y+cgreen];
//             <    is read   >: cblue outptr range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr[2]
      outptr[2] = range_limit[y+cblue];
   }
}
static void h2v2_merged_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr0, outptr1;
   JSAMPROW inptr00, inptr01, inptr1, inptr2;
   JDIMENSION col;
   /* copy these pointers into registers if possible */
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   register JSAMPLE *range_limit = cinfo->sample_range_limit;
//             <    is read   >: upsample upsample[0].Cr_r_tab
//             <    is written>: Crrtab
   int *Crrtab = upsample->Cr_r_tab;
//             <    is read   >: upsample upsample[0].Cb_b_tab
//             <    is written>: Cbbtab
   int *Cbbtab = upsample->Cb_b_tab;
//             <    is read   >: upsample upsample[0].Cr_g_tab
//             <    is written>: Crgtab
   INT32 *Crgtab = upsample->Cr_g_tab;
//             <    is read   >: upsample upsample[0].Cb_g_tab
//             <    is written>: Cbgtab
   INT32 *Cbgtab = upsample->Cb_g_tab;
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[0] 
//                               input_buf[0][in_row_group_ctr*2]
//             <    is written>: inptr00
   
   
   inptr00 = input_buf[0][in_row_group_ctr*2];
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[0] 
//                               input_buf[0][in_row_group_ctr*2+1]
//             <    is written>: inptr01
   inptr01 = input_buf[0][in_row_group_ctr*2+1];
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[1] 
//                               input_buf[1][in_row_group_ctr]
//             <    is written>: inptr1
   inptr1 = input_buf[1][in_row_group_ctr];
//             <    is read   >: in_row_group_ctr input_buf 
//                               input_buf[2] 
//                               input_buf[2][in_row_group_ctr]
//             <    is written>: inptr2
   inptr2 = input_buf[2][in_row_group_ctr];
//             <    is read   >: output_buf output_buf[0]
//             <    is written>: outptr0
   outptr0 = output_buf[0];
//             <    is read   >: output_buf output_buf[1]
//             <    is written>: outptr1
   outptr1 = output_buf[1];
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: col
   /* Loop for each group of output pixels */
   for(col = cinfo->output_width>>1; col >= 1; col += -1) {
//             <    is read   >: cinfo cinfo[0].output_width inptr1 
//                               inptr1[0]
//             <    is written>: cb inptr1
      /* Do the chroma part of the calculation */
      cb = (int) *inptr1++;
//             <    is read   >: cinfo cinfo[0].output_width inptr2 
//                               inptr2[0]
//             <    is written>: cr inptr2
      cr = (int) *inptr2++;
//             <    is read   >: Crrtab Crrtab[cr] cinfo 
//                               cinfo[0].output_width cr
//             <    is written>: cred
      cred = Crrtab[cr];
//             <    is read   >: Cbgtab Cbgtab[cb] Crgtab Crgtab[cr] 
//                               cb cinfo cinfo[0].output_width cr
//             <    is written>: cgreen
      cgreen = (int) (Cbgtab[cb]+Crgtab[cr]>>16);
//             <    is read   >: Cbbtab Cbbtab[cb] cb cinfo 
//                               cinfo[0].output_width
//             <    is written>: cblue
      cblue = Cbbtab[cb];
//             <    is read   >: cinfo cinfo[0].output_width inptr00 
//                               inptr00[0]
//             <    is written>: inptr00 y
      /* Fetch 4 Y values and emit 4 pixels */
      y = (int) *inptr00++;
//             <    is read   >: cinfo cinfo[0].output_width cred 
//                               outptr0 range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr0[0]
      outptr0[0] = range_limit[y+cred];
//             <    is read   >: cgreen cinfo cinfo[0].output_width 
//                               outptr0 range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr0[1]
      outptr0[1] = range_limit[y+cgreen];
//             <    is read   >: cblue cinfo cinfo[0].output_width 
//                               outptr0 range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr0[2]
      outptr0[2] = range_limit[y+cblue];
//             <    is read   >: cinfo cinfo[0].output_width outptr0
//             <    is written>: outptr0
      outptr0 += 3;
//             <    is read   >: cinfo cinfo[0].output_width inptr00 
//                               inptr00[0]
//             <    is written>: inptr00 y
      y = (int) *inptr00++;
//             <    is read   >: cinfo cinfo[0].output_width cred 
//                               outptr0 range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr0[0]
      outptr0[0] = range_limit[y+cred];
//             <    is read   >: cgreen cinfo cinfo[0].output_width 
//                               outptr0 range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr0[1]
      outptr0[1] = range_limit[y+cgreen];
//             <    is read   >: cblue cinfo cinfo[0].output_width 
//                               outptr0 range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr0[2]
      outptr0[2] = range_limit[y+cblue];
//             <    is read   >: cinfo cinfo[0].output_width outptr0
//             <    is written>: outptr0
      outptr0 += 3;
//             <    is read   >: cinfo cinfo[0].output_width inptr01 
//                               inptr01[0]
//             <    is written>: inptr01 y
      y = (int) *inptr01++;
//             <    is read   >: cinfo cinfo[0].output_width cred 
//                               outptr1 range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr1[0]
      outptr1[0] = range_limit[y+cred];
//             <    is read   >: cgreen cinfo cinfo[0].output_width 
//                               outptr1 range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr1[1]
      outptr1[1] = range_limit[y+cgreen];
//             <    is read   >: cblue cinfo cinfo[0].output_width 
//                               outptr1 range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr1[2]
      outptr1[2] = range_limit[y+cblue];
//             <    is read   >: cinfo cinfo[0].output_width outptr1
//             <    is written>: outptr1
      outptr1 += 3;
//             <    is read   >: cinfo cinfo[0].output_width inptr01 
//                               inptr01[0]
//             <    is written>: inptr01 y
      y = (int) *inptr01++;
//             <    is read   >: cinfo cinfo[0].output_width cred 
//                               outptr1 range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr1[0]
      outptr1[0] = range_limit[y+cred];
//             <    is read   >: cgreen cinfo cinfo[0].output_width 
//                               outptr1 range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr1[1]
      outptr1[1] = range_limit[y+cgreen];
//             <    is read   >: cblue cinfo cinfo[0].output_width 
//                               outptr1 range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr1[2]
      outptr1[2] = range_limit[y+cblue];
//             <    is read   >: cinfo cinfo[0].output_width outptr1
//             <    is written>: outptr1
      outptr1 += 3;
   }
//             <    is read   >: cinfo cinfo[0].output_width
   /* If image width is odd, do the last output column separately */
   if (cinfo->output_width&1) {
//             <    is read   >: inptr1 inptr1[0]
//             <    is written>: cb
      cb = (int) *inptr1;
//             <    is read   >: inptr2 inptr2[0]
//             <    is written>: cr
      cr = (int) *inptr2;
//             <    is read   >: Crrtab Crrtab[cr] cr
//             <    is written>: cred
      cred = Crrtab[cr];
//             <    is read   >: Cbgtab Cbgtab[cb] Crgtab Crgtab[cr] 
//                               cb cr
//             <    is written>: cgreen
      cgreen = (int) (Cbgtab[cb]+Crgtab[cr]>>16);
//             <    is read   >: Cbbtab Cbbtab[cb] cb
//             <    is written>: cblue
      cblue = Cbbtab[cb];
//             <    is read   >: inptr00 inptr00[0]
//             <    is written>: y
      y = (int) *inptr00;
//             <    is read   >: cred outptr0 range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr0[0]
      outptr0[0] = range_limit[y+cred];
//             <    is read   >: cgreen outptr0 range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr0[1]
      outptr0[1] = range_limit[y+cgreen];
//             <    is read   >: cblue outptr0 range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr0[2]
      outptr0[2] = range_limit[y+cblue];
//             <    is read   >: inptr01 inptr01[0]
//             <    is written>: y
      y = (int) *inptr01;
//             <    is read   >: cred outptr1 range_limit 
//                               range_limit[y+cred] y
//             <    is written>: outptr1[0]
      outptr1[0] = range_limit[y+cred];
//             <    is read   >: cgreen outptr1 range_limit 
//                               range_limit[y+cgreen] y
//             <    is written>: outptr1[1]
      outptr1[1] = range_limit[y+cgreen];
//             <    is read   >: cblue outptr1 range_limit 
//                               range_limit[y+cblue] y
//             <    is written>: outptr1[2]
      outptr1[2] = range_limit[y+cblue];
   }
}
static void merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Just do the upsampling. */
   (*upsample->upmethod)(cinfo,input_buf,*in_row_group_ctr,output_buf+*out_row_ctr);
//             <    is read   >: out_row_ctr out_row_ctr[0]
//             <    is written>: out_row_ctr[0]
   /* Adjust counts */
   (*out_row_ctr)++;
//             <    is read   >: in_row_group_ctr in_row_group_ctr[0]
//             <    is written>: in_row_group_ctr[0]
   (*in_row_group_ctr)++;
}
static void merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   JSAMPROW work_ptrs[2];
   JDIMENSION num_rows;
//             <    is read   >: upsample upsample[0].spare_full
   /* number of rows returned to caller */
   
   if (upsample->spare_full) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* If we have a spare row saved from a previous cycle, just return it. */
      
      jcopy_sample_rows(&upsample->spare_row, 0, output_buf+*out_row_ctr, 0, 1, upsample->out_row_width);
//             <    is written>: num_rows
      num_rows = 1;
//             <    is read   >: upsample
//             <    is written>: upsample[0].spare_full
      upsample->spare_full = 0;
   }
   else {
//             <    is written>: num_rows
      /* Figure number of rows to return to caller. */
      num_rows = 2;
//             <    is read   >: num_rows upsample 
//                               upsample[0].rows_to_go
      /* Not more than the distance to the end of the image. */
      if (num_rows>upsample->rows_to_go)
//             <    is read   >: upsample upsample[0].rows_to_go
//             <    is written>: num_rows
         num_rows = upsample->rows_to_go;
//             <    is read   >: out_row_ctr out_row_ctr[0] 
//                               out_rows_avail
//             <    is written>: out_rows_avail
      /* And not more than what the client can accept: */
      out_rows_avail -= *out_row_ctr;
//             <    is read   >: num_rows out_rows_avail
      if (num_rows>out_rows_avail)
//             <    is read   >: out_rows_avail
//             <    is written>: num_rows
         num_rows = out_rows_avail;
//             <    is read   >: out_row_ctr out_row_ctr[0] output_buf
//                               output_buf[*out_row_ctr]
//             <    is written>: work_ptrs[0]
      /* Create output pointer array for upsampler. */
      work_ptrs[0] = output_buf[*out_row_ctr];
//             <    is read   >: num_rows
      if (num_rows>1)
//             <    is read   >: out_row_ctr out_row_ctr[0] output_buf
//                               output_buf[*out_row_ctr+1]
//             <    is written>: work_ptrs[1]
         work_ptrs[1] = output_buf[*out_row_ctr+1];
      else {
//             <    is read   >: upsample upsample[0].spare_row
//             <    is written>: work_ptrs[1]
         work_ptrs[1] = upsample->spare_row;
//             <    is read   >: upsample
//             <    is written>: upsample[0].spare_full
         upsample->spare_full = 1;
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Now do the upsampling. */
      (*upsample->upmethod)(cinfo,input_buf,*in_row_group_ctr,work_ptrs);
   }
//             <    is read   >: num_rows out_row_ctr out_row_ctr[0]
//             <    is written>: out_row_ctr[0]
   
   /* Adjust counts */
   *out_row_ctr += num_rows;
//             <    is read   >: num_rows upsample 
//                               upsample[0].rows_to_go
//             <    is written>: upsample[0].rows_to_go
   upsample->rows_to_go -= num_rows;
//             <    is read   >: upsample upsample[0].spare_full
   /* When the buffer is emptied, declare this input row group consumed */
   if (!upsample->spare_full)
//             <    is read   >: in_row_group_ctr in_row_group_ctr[0]
//             <    is written>: in_row_group_ctr[0]
      (*in_row_group_ctr)++;
}
static void start_pass_merged_upsample(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].spare_full
   
   /* Mark the spare buffer empty */
   upsample->spare_full = 0;
//             <    is read   >: cinfo cinfo[0].output_height upsample
//             <    is written>: upsample[0].rows_to_go
   /* Initialize total-height counter for detecting bottom of image */
   upsample->rows_to_go = cinfo->output_height;
}
static boolean decode_mcu_AC_first(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
//             <    is read   >: cinfo cinfo[0].Se
//             <    is written>: Se
   int Se = cinfo->Se;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: Al
   int Al = cinfo->Al;
   register int s, k, r;
   unsigned int EOBRUN;
   JBLOCKROW block;
   register bit_buf_type get_buffer;
   register int bits_left;
   bitread_working_state br_state;
   d_derived_tbl *tbl;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!process_restart(cinfo))
            return 0;
//             <    is read   >: entropy entropy[0].saved.EOBRUN
//             <    is written>: EOBRUN
   
   /* Load up working state.
      * We can avoid loading/saving bitread state if in an EOB run.
      */
   EOBRUN = entropy->saved.EOBRUN;
//             <    is read   >: EOBRUN
   /* only part of saved state we care about */
   
   /* There is always only one block per MCU */
   
   if (EOBRUN>0)
//             <    is read   >: EOBRUN
//             <    is written>: EOBRUN
      /* if it's a band of zeroes... */
      EOBRUN--;
   else {
//             <    is read   >: cinfo
//             <    is written>: br_state.cinfo
      br_state.cinfo = cinfo;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].next_input_byte
//             <    is written>: br_state.next_input_byte
      br_state.next_input_byte = cinfo->src->next_input_byte;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].bytes_in_buffer
//             <    is written>: br_state.bytes_in_buffer
      br_state.bytes_in_buffer = cinfo->src->bytes_in_buffer;
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: br_state.unread_marker
      br_state.unread_marker = cinfo->unread_marker;
//             <    is read   >: entropy 
//                               entropy[0].bitstate.get_buffer
//             <    is written>: get_buffer
      get_buffer = entropy->bitstate.get_buffer;
//             <    is read   >: entropy entropy[0].bitstate.bits_left
//             <    is written>: bits_left
      bits_left = entropy->bitstate.bits_left;
//             <    is read   >: entropy
//             <    is written>: br_state.printed_eod_ptr
      br_state.printed_eod_ptr = &entropy->bitstate.printed_eod;
//             <    is read   >: MCU_data MCU_data[0]
//             <    is written>: block
      block = MCU_data[0];
//             <    is read   >: entropy entropy[0].ac_derived_tbl
//             <    is written>: tbl
      tbl = entropy->ac_derived_tbl;
//             <    is read   >: cinfo cinfo[0].Ss
//             <    is written>: k
      k = cinfo->Ss;
l99997:      ;
//             <    is read   >: Se k

      if (!(k<=Se)) goto _break_1;
      {
         register int nb, look;
//             <    is read   >: bits_left
         if (bits_left<8) goto l99995;
l99992:         ;
//             <    is read   >: bits_left get_buffer
//             <    is written>: look
         look = (int) (get_buffer>>bits_left-8)&(1<<8)-1;
//             <    is read   >: look tbl tbl[0].look_nbits[look]
//             <    is written>: nb
         if ((nb = (tbl->look_nbits)[look])!=0) goto l99994;
//             <    is written>: nb
         nb = 8+1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
label2:         if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, tbl, nb))<0)
            return 0;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
         goto l99993;
l99994:         ;
//             <    is read   >: bits_left nb
//             <    is written>: bits_left
         bits_left -= nb;
//             <    is read   >: look tbl tbl[0].look_sym[look]
//             <    is written>: s
         s = (tbl->look_sym)[look];
         goto l99993;
l99995:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0))
            return 0;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
//             <    is read   >: bits_left
         if (bits_left<8) {
         }
         else {
            goto l99992;
         }
//             <    is written>: nb
         nb = 1;
         goto label2;
l99993:         ;
      }
//             <    is read   >: s
//             <    is written>: r
      r = s>>4;
//             <    is read   >: s
//             <    is written>: s
      s &= 15;
//             <    is read   >: s
      if (s) goto l99999;
//             <    is read   >: r
      if (r==15) goto l99998;
//             <    is read   >: r
//             <    is written>: EOBRUN
      /* EOBr, run length is 2^r + appended bits */
      EOBRUN = 1<<r;
//             <    is read   >: r
      if (r) {
//             <    is read   >: bits_left r
         if (bits_left<r) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, r))
               return 0;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
            get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
            bits_left = br_state.bits_left;
         }
//             <    is read   >: bits_left get_buffer r
//             <    is written>: bits_left r
         r = (int) (get_buffer>>(bits_left -= r))&(1<<r)-1;
//             <    is read   >: EOBRUN r
//             <    is written>: EOBRUN
         EOBRUN += r;
      }
//             <    is read   >: EOBRUN
//             <    is written>: EOBRUN
      EOBRUN--;
      /* this band is processed at this moment */
      ;
      goto _break_1;
l99998:      ;
//             <    is read   >: k
//             <    is written>: k
      /* ZRL */
      k += 15;
l99996:      ;
//             <    is read   >: k
//             <    is written>: k
      k++;
      goto l99997;
l99999:      ;
//             <    is read   >: k r
//             <    is written>: k
      k += r;
//             <    is read   >: bits_left s
      if (bits_left<s) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, s))
            return 0;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
      }
//             <    is read   >: bits_left get_buffer s
//             <    is written>: bits_left r
      r = (int) (get_buffer>>(bits_left -= s))&(1<<s)-1;
//             <may be read   >: extend_offset[*]
//             <    is read   >: r s extend_test[s]
//             <    is written>: s
      s = r<extend_test[s]?r+extend_offset[s]:r;
//             <    is read   >: Al block jpeg_natural_order[k] k s
//             <    is written>: block[0][jpeg_natural_order[k]]
      /* Scale and output coefficient in natural (dezigzagged) order */
      (*block)[jpeg_natural_order[k]] = (JCOEF) (s<<Al);
      goto l99996;
_break_1:      ;
//             <    is read   >: br_state.next_input_byte cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].next_input_byte

      cinfo->src->next_input_byte = br_state.next_input_byte;
//             <    is read   >: br_state.bytes_in_buffer cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].bytes_in_buffer
      cinfo->src->bytes_in_buffer = br_state.bytes_in_buffer;
//             <    is read   >: br_state.unread_marker cinfo
//             <    is written>: cinfo[0].unread_marker
      cinfo->unread_marker = br_state.unread_marker;
//             <    is read   >: entropy get_buffer
//             <    is written>: entropy[0].bitstate.get_buffer
      entropy->bitstate.get_buffer = get_buffer;
//             <    is read   >: bits_left entropy
//             <    is written>: entropy[0].bitstate.bits_left
      entropy->bitstate.bits_left = bits_left;
   }
//             <    is read   >: EOBRUN entropy
//             <    is written>: entropy[0].saved.EOBRUN
   
   /* Completed MCU, so update state */
   entropy->saved.EOBRUN = EOBRUN;
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
   /* only part of saved state we care about */
   
   /* Account for restart interval (no-op if not using restarts) */
   entropy->restarts_to_go--;

   return 1;
}
static boolean decode_mcu_AC_refine(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
//             <    is read   >: cinfo cinfo[0].Se
//             <    is written>: Se
   int Se = cinfo->Se;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: p1
   int p1 = 1<<cinfo->Al;
   /* 1 in the bit position being coded */
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: m1
   int m1 = -1<<cinfo->Al;
   /* -1 in the bit position being coded */
   register int s, k, r;
   unsigned int EOBRUN;
   JBLOCKROW block;
   JCOEFPTR thiscoef;
   register bit_buf_type get_buffer;
   register int bits_left;
   bitread_working_state br_state;
   d_derived_tbl *tbl;
   int num_newnz;
   int newnz_pos[64];
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!process_restart(cinfo))
            return 0;
//             <    is read   >: cinfo
//             <    is written>: br_state.cinfo
   
   /* Load up working state */
   br_state.cinfo = cinfo;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].next_input_byte
//             <    is written>: br_state.next_input_byte
   br_state.next_input_byte = cinfo->src->next_input_byte;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].bytes_in_buffer
//             <    is written>: br_state.bytes_in_buffer
   br_state.bytes_in_buffer = cinfo->src->bytes_in_buffer;
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: br_state.unread_marker
   br_state.unread_marker = cinfo->unread_marker;
//             <    is read   >: entropy 
//                               entropy[0].bitstate.get_buffer
//             <    is written>: get_buffer
   get_buffer = entropy->bitstate.get_buffer;
//             <    is read   >: entropy entropy[0].bitstate.bits_left
//             <    is written>: bits_left
   bits_left = entropy->bitstate.bits_left;
//             <    is read   >: entropy
//             <    is written>: br_state.printed_eod_ptr
   br_state.printed_eod_ptr = &entropy->bitstate.printed_eod;
//             <    is read   >: entropy entropy[0].saved.EOBRUN
//             <    is written>: EOBRUN
   EOBRUN = entropy->saved.EOBRUN;
//             <    is read   >: MCU_data MCU_data[0]
//             <    is written>: block
   /* only part of saved state we care about */
   
   /* There is always only one block per MCU */
   block = MCU_data[0];
//             <    is read   >: entropy entropy[0].ac_derived_tbl
//             <    is written>: tbl
   tbl = entropy->ac_derived_tbl;
//             <    is written>: num_newnz
   
   /* If we are forced to suspend, we must undo the assignments to any newly
      * nonzero coefficients in the block, because otherwise we'd get confused
      * next time about which coefficients were already nonzero.
      * But we need not undo addition of bits to already-nonzero coefficients;
      * instead, we can test the current bit position to see if we already did it.
      */
   num_newnz = 0;
//             <    is read   >: cinfo cinfo[0].Ss
//             <    is written>: k
   
   /* initialize coefficient loop counter to start of band */
   k = cinfo->Ss;
//             <    is read   >: EOBRUN

   if (EOBRUN==0) goto l99999;
l99988:   ;
//             <    is read   >: EOBRUN

   if (EOBRUN>0) goto l99981;
l99974:   ;
//             <    is read   >: br_state.next_input_byte cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].next_input_byte
   
   /* Completed MCU, so update state */
   cinfo->src->next_input_byte = br_state.next_input_byte;
//             <    is read   >: br_state.bytes_in_buffer cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].bytes_in_buffer
   cinfo->src->bytes_in_buffer = br_state.bytes_in_buffer;
//             <    is read   >: br_state.unread_marker cinfo
//             <    is written>: cinfo[0].unread_marker
   cinfo->unread_marker = br_state.unread_marker;
//             <    is read   >: entropy get_buffer
//             <    is written>: entropy[0].bitstate.get_buffer
   entropy->bitstate.get_buffer = get_buffer;
//             <    is read   >: bits_left entropy
//             <    is written>: entropy[0].bitstate.bits_left
   entropy->bitstate.bits_left = bits_left;
//             <    is read   >: EOBRUN entropy
//             <    is written>: entropy[0].saved.EOBRUN
   entropy->saved.EOBRUN = EOBRUN;
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
   /* only part of saved state we care about */
   
   /* Account for restart interval (no-op if not using restarts) */
   entropy->restarts_to_go--;

   return 1;
l99981:   ;
//             <    is read   >: Se k
/* Scan any remaining coefficient positions after the end-of-band
     * (the last newly nonzero coefficient, if any).  Append a correction
     * bit to each already-nonzero coefficient.  A correction bit is 1
     * if the absolute value of the coefficient must be increased.
     */
   if (!(k<=Se)) goto l99980;
//             <    is read   >: block jpeg_natural_order[k] k
//             <    is written>: thiscoef
   thiscoef = *block+jpeg_natural_order[k];
//             <    is read   >: thiscoef thiscoef[0]
   if (*thiscoef!=0) goto l99979;
l99977:   ;
//             <    is read   >: k
//             <    is written>: k
   k++;
   goto l99981;
l99979:   ;
//             <    is read   >: bits_left
   if (bits_left<1) goto l99978;
l99975:   ;
//             <    is read   >: bits_left get_buffer
//             <    is written>: bits_left
   if ((int) (get_buffer>>(bits_left -= 1))&(1<<1)-1)
//             <    is read   >: p1 thiscoef thiscoef[0]
      if ((*thiscoef&p1)==0)
//             <    is read   >: thiscoef thiscoef[0]
         /* do nothing if already changed it */
         if (*thiscoef>=0)
//             <    is read   >: p1 thiscoef thiscoef[0]
//             <    is written>: thiscoef[0]
            *thiscoef += p1;
         else
//             <    is read   >: m1 thiscoef thiscoef[0]
//             <    is written>: thiscoef[0]
            *thiscoef += m1;
   goto l99977;
l99978:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 1)) goto l99976;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
   get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
   bits_left = br_state.bits_left;
   goto l99975;
l99980:   ;
//             <    is read   >: EOBRUN
//             <    is written>: EOBRUN
   /* Count one block completed in EOB run */
   EOBRUN--;
   goto l99974;
l99976:   ;
   goto undoit;
l99999:   ;
//             <    is read   >: Se k
   if (!(k<=Se)) goto _break_1;
   register int nb, look;
//             <    is read   >: bits_left
   if (bits_left<8) goto l99998;
l99982:   ;
//             <    is read   >: bits_left get_buffer
//             <    is written>: look
   look = (int) (get_buffer>>bits_left-8)&(1<<8)-1;
//             <    is read   >: look tbl tbl[0].look_nbits[look]
//             <    is written>: nb
   if ((nb = (tbl->look_nbits)[look])!=0) goto l99997;
//             <    is written>: nb
   nb = 8+1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
label3:   if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, tbl, nb))<0) goto undoit;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
   get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
   bits_left = br_state.bits_left;
l99983:   ;
//             <    is read   >: s
//             <    is written>: r
   r = s>>4;
//             <    is read   >: s
//             <    is written>: s
   s &= 15;
//             <    is read   >: s
   if (s) goto l99996;
//             <    is read   >: r
   if (r!=15) goto l99995;
l99993:   ;
//             <    is read   >: Se k
   if (!(k<=Se)) goto _break_2;
//             <    is read   >: block jpeg_natural_order[k] k
//             <    is written>: thiscoef
   thiscoef = *block+jpeg_natural_order[k];
//             <    is read   >: thiscoef thiscoef[0]
   if (*thiscoef!=0) goto l99994;
//             <    is read   >: r
//             <    is written>: r
   if (--r<0) goto _break_2;
l99991:   ;
//             <    is read   >: k
//             <    is written>: k
   k++;
   goto l99993;
_break_2:   ;
//             <    is read   >: s
   if (s) {
//             <    is read   >: jpeg_natural_order[k] k
//             <    is written>: pos
      int pos = jpeg_natural_order[k];
//             <    is read   >: block pos s
//             <    is written>: block[0][pos]
      /* Output newly nonzero coefficient */
      (*block)[pos] = (JCOEF) s;
//             <    is read   >: num_newnz pos
//             <    is written>: newnz_pos[num_newnz++] num_newnz
      /* Remember its position in case we have to suspend */
      newnz_pos[num_newnz++] = pos;
   }
//             <    is read   >: k
//             <    is written>: k
   k++;
   goto l99999;
l99994:   ;
//             <    is read   >: bits_left
   if (bits_left<1) goto l99992;
l99990:   ;
//             <    is read   >: bits_left get_buffer
//             <    is written>: bits_left
   if ((int) (get_buffer>>(bits_left -= 1))&(1<<1)-1)
//             <    is read   >: p1 thiscoef thiscoef[0]
      if ((*thiscoef&p1)==0)
//             <    is read   >: thiscoef thiscoef[0]
         /* do nothing if already changed it */
         if (*thiscoef>=0)
//             <    is read   >: p1 thiscoef thiscoef[0]
//             <    is written>: thiscoef[0]
            *thiscoef += p1;
         else
//             <    is read   >: m1 thiscoef thiscoef[0]
//             <    is written>: thiscoef[0]
            *thiscoef += m1;
   goto l99991;
l99992:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 1)) goto undoit;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
   get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
   bits_left = br_state.bits_left;
   goto l99990;
l99995:   ;
//             <    is read   >: r
//             <    is written>: EOBRUN
   EOBRUN = 1<<r;
//             <    is read   >: r
/* EOBr, run length is 2^r + appended bits */
   if (r) goto l99989;
_break_1:   ;
   goto l99988;
l99989:   ;
//             <    is read   >: bits_left r
   if (bits_left<r) goto l99987;
l99986:   ;
//             <    is read   >: bits_left get_buffer r
//             <    is written>: bits_left r
   r = (int) (get_buffer>>(bits_left -= r))&(1<<r)-1;
//             <    is read   >: EOBRUN r
//             <    is written>: EOBRUN
   EOBRUN += r;
   goto _break_1;
l99987:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, r)) goto undoit;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
   get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
   bits_left = br_state.bits_left;
   goto l99986;
l99996:   ;
//             <    is read   >: s
   if (s!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* size of new coef should always be 1 */
      cinfo->err->msg_code = JWRN_HUFF_BAD_CODE, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: bits_left
   if (bits_left<1) goto l99985;
l99984:   ;
//             <    is read   >: bits_left get_buffer
//             <    is written>: bits_left
   if ((int) (get_buffer>>(bits_left -= 1))&(1<<1)-1)
//             <    is read   >: p1
//             <    is written>: s
      s = p1;
   else
//             <    is read   >: m1
//             <    is written>: s
      s = m1;
   goto l99993;
l99985:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 1)) goto undoit;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
   get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
   bits_left = br_state.bits_left;
   goto l99984;
l99997:   ;
//             <    is read   >: bits_left nb
//             <    is written>: bits_left
   bits_left -= nb;
//             <    is read   >: look tbl tbl[0].look_sym[look]
//             <    is written>: s
   s = (tbl->look_sym)[look];
   goto l99983;
l99998:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0)) goto undoit;
//             <    is read   >: br_state.get_buffer
//             <    is written>: get_buffer
   get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left
//             <    is written>: bits_left
   bits_left = br_state.bits_left;
//             <    is read   >: bits_left
   if (bits_left<8) {
   }
   else {
      goto l99982;
   }
//             <    is written>: nb
   nb = 1;
   goto label3;
   
   /* Re-zero any output coefficients that we made newly nonzero */
undoit:   ;
//             <    is read   >: num_newnz
   while (num_newnz>0)
//             <    is read   >: block newnz_pos[--num_newnz] 
//                               num_newnz
//             <    is written>: block[0][newnz_pos[--num_newnz]] 
//                               num_newnz
      (*block)[newnz_pos[--num_newnz]] = 0;

   return 0;
}
static boolean decode_mcu_DC_first(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: Al
   int Al = cinfo->Al;
   register int s, r;
   int blkn, ci;
   JBLOCKROW block;
   register bit_buf_type get_buffer;
   register int bits_left;
   bitread_working_state br_state;
   savable_state state;
   d_derived_tbl *tbl;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!process_restart(cinfo))
            return 0;
//             <    is read   >: cinfo
//             <    is written>: br_state.cinfo
   
   /* Load up working state */
   br_state.cinfo = cinfo;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].next_input_byte
//             <    is written>: br_state.next_input_byte
   br_state.next_input_byte = cinfo->src->next_input_byte;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].bytes_in_buffer
//             <    is written>: br_state.bytes_in_buffer
   br_state.bytes_in_buffer = cinfo->src->bytes_in_buffer;
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: br_state.unread_marker
   br_state.unread_marker = cinfo->unread_marker;
//             <    is read   >: entropy 
//                               entropy[0].bitstate.get_buffer
//             <    is written>: get_buffer
   get_buffer = entropy->bitstate.get_buffer;
//             <    is read   >: entropy entropy[0].bitstate.bits_left
//             <    is written>: bits_left
   bits_left = entropy->bitstate.bits_left;
//             <    is read   >: entropy
//             <    is written>: br_state.printed_eod_ptr
   br_state.printed_eod_ptr = &entropy->bitstate.printed_eod;
//             <may be read   >: entropy[0].saved.last_dc_val[*]
//             <may be written>: state.last_dc_val[*]
//             <    is read   >: entropy entropy[0].saved.EOBRUN
//             <    is written>: state.EOBRUN
   state = entropy->saved;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn
   
   /* Outer loop handles each block in the MCU */
   
   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: MCU_data MCU_data[blkn] blkn cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: block
      block = MCU_data[blkn];
//             <    is read   >: blkn cinfo 
//                               cinfo[0].MCU_membership[blkn] 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: ci
      ci = (cinfo->MCU_membership)[blkn];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU compptr 
//                               compptr[0].dc_tbl_no entropy 
//                               entropy[0].derived_tbls[compptr->dc_t
//                               bl_no]
//             <    is written>: tbl
      tbl = (entropy->derived_tbls)[compptr->dc_tbl_no];
      {
         register int nb, look;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) goto l99999;
l99996:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer
//             <    is written>: look
         look = (int) (get_buffer>>bits_left-8)&(1<<8)-1;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU look tbl
//                               tbl[0].look_nbits[look]
//             <    is written>: nb
         if ((nb = (tbl->look_nbits)[look])!=0) goto l99998;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: nb
         nb = 8+1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
label1:         if ((s = jpeg_huff_decode(&br_state, get_buffer, bits_left, tbl, nb))<0)
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
         goto l99997;
l99998:         ;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU nb
//             <    is written>: bits_left
         bits_left -= nb;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU look tbl
//                               tbl[0].look_sym[look]
//             <    is written>: s
         s = (tbl->look_sym)[look];
         goto l99997;
l99999:         ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 0))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
         if (bits_left<8) {
         }
         else {
            goto l99996;
         }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: nb
         nb = 1;
         goto label1;
l99997:         ;
      }
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU s
      if (s) {
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU s
         if (bits_left<s) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, s))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
               return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
            get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
            bits_left = br_state.bits_left;
         }
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer s
//             <    is written>: bits_left r
         r = (int) (get_buffer>>(bits_left -= s))&(1<<s)-1;
//             <may be read   >: extend_offset[*]
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU r s 
//                               extend_test[s]
//             <    is written>: s
         s = r<extend_test[s]?r+extend_offset[s]:r;
      }
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU s 
//                               state.last_dc_val[ci]
//             <    is written>: s
      
      /* Convert DC difference to actual value, update last_dc_val */
      s += (state.last_dc_val)[ci];
//             <    is read   >: ci cinfo cinfo[0].blocks_in_MCU s
//             <    is written>: state.last_dc_val[ci]
      (state.last_dc_val)[ci] = s;
//             <    is read   >: Al block cinfo cinfo[0].blocks_in_MCU
//                               s
//             <    is written>: block[0][0]
      /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s<<Al);
   }
//             <    is read   >: br_state.next_input_byte cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].next_input_byte
   
   /* Completed MCU, so update state */
   cinfo->src->next_input_byte = br_state.next_input_byte;
//             <    is read   >: br_state.bytes_in_buffer cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].bytes_in_buffer
   cinfo->src->bytes_in_buffer = br_state.bytes_in_buffer;
//             <    is read   >: br_state.unread_marker cinfo
//             <    is written>: cinfo[0].unread_marker
   cinfo->unread_marker = br_state.unread_marker;
//             <    is read   >: entropy get_buffer
//             <    is written>: entropy[0].bitstate.get_buffer
   entropy->bitstate.get_buffer = get_buffer;
//             <    is read   >: bits_left entropy
//             <    is written>: entropy[0].bitstate.bits_left
   entropy->bitstate.bits_left = bits_left;
//             <may be read   >: state.last_dc_val[*]
//             <may be written>: entropy[0].saved.last_dc_val[*]
//             <    is read   >: entropy state.EOBRUN
//             <    is written>: entropy[0].saved.EOBRUN
   entropy->saved = state;
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
   
   /* Account for restart interval (no-op if not using restarts) */
   entropy->restarts_to_go--;

   return 1;
}
static boolean decode_mcu_DC_refine(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
//             <    is read   >: cinfo cinfo[0].Al
//             <    is written>: p1
   int p1 = 1<<cinfo->Al;
   /* 1 in the bit position being coded */
   int blkn;
   JBLOCKROW block;
   register bit_buf_type get_buffer;
   register int bits_left;
   bitread_working_state br_state;
//             <    is read   >: cinfo cinfo[0].restart_interval
   
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval)
//             <    is read   >: entropy entropy[0].restarts_to_go
      if (entropy->restarts_to_go==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!process_restart(cinfo))
            return 0;
//             <    is read   >: cinfo
//             <    is written>: br_state.cinfo
   
   /* Load up working state */
   br_state.cinfo = cinfo;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].next_input_byte
//             <    is written>: br_state.next_input_byte
   br_state.next_input_byte = cinfo->src->next_input_byte;
//             <    is read   >: cinfo cinfo[0].src 
//                               cinfo[0].src[0].bytes_in_buffer
//             <    is written>: br_state.bytes_in_buffer
   br_state.bytes_in_buffer = cinfo->src->bytes_in_buffer;
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: br_state.unread_marker
   br_state.unread_marker = cinfo->unread_marker;
//             <    is read   >: entropy 
//                               entropy[0].bitstate.get_buffer
//             <    is written>: get_buffer
   get_buffer = entropy->bitstate.get_buffer;
//             <    is read   >: entropy entropy[0].bitstate.bits_left
//             <    is written>: bits_left
   bits_left = entropy->bitstate.bits_left;
//             <    is read   >: entropy
//             <    is written>: br_state.printed_eod_ptr
   br_state.printed_eod_ptr = &entropy->bitstate.printed_eod;
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
//             <    is written>: blkn
   
   /* Outer loop handles each block in the MCU */
   
   for(blkn = 0; blkn <= cinfo->blocks_in_MCU-1; blkn += 1) {
//             <    is read   >: MCU_data MCU_data[blkn] blkn cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: block
      block = MCU_data[blkn];
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
      if (bits_left<1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&br_state, get_buffer, bits_left, 1))
//             <    is read   >: cinfo cinfo[0].blocks_in_MCU
            return 0;
//             <    is read   >: br_state.get_buffer cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: get_buffer
         get_buffer = br_state.get_buffer;
//             <    is read   >: br_state.bits_left cinfo 
//                               cinfo[0].blocks_in_MCU
//             <    is written>: bits_left
         bits_left = br_state.bits_left;
      }
//             <    is read   >: bits_left cinfo 
//                               cinfo[0].blocks_in_MCU get_buffer
//             <    is written>: bits_left
      if ((int) (get_buffer>>(bits_left -= 1))&(1<<1)-1)
//             <    is read   >: block block[0][0] cinfo 
//                               cinfo[0].blocks_in_MCU p1
//             <    is written>: block[0][0]
         (*block)[0] |= p1;
   }
//             <    is read   >: br_state.next_input_byte cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].next_input_byte
   
   /* Completed MCU, so update state */
   cinfo->src->next_input_byte = br_state.next_input_byte;
//             <    is read   >: br_state.bytes_in_buffer cinfo 
//                               cinfo[0].src
//             <    is written>: cinfo[0].src[0].bytes_in_buffer
   cinfo->src->bytes_in_buffer = br_state.bytes_in_buffer;
//             <    is read   >: br_state.unread_marker cinfo
//             <    is written>: cinfo[0].unread_marker
   cinfo->unread_marker = br_state.unread_marker;
//             <    is read   >: entropy get_buffer
//             <    is written>: entropy[0].bitstate.get_buffer
   entropy->bitstate.get_buffer = get_buffer;
//             <    is read   >: bits_left entropy
//             <    is written>: entropy[0].bitstate.bits_left
   entropy->bitstate.bits_left = bits_left;
//             <    is read   >: entropy entropy[0].restarts_to_go
//             <    is written>: entropy[0].restarts_to_go
   
   /* Account for restart interval (no-op if not using restarts) */
   entropy->restarts_to_go--;

   return 1;
}
static boolean process_restart(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   int ci;
//             <    is read   >: cinfo cinfo[0].marker cinfo[0].marker
//                               cinfo[0].marker[0].discarded_bytes 
//                               entropy entropy[0].bitstate.bits_left
//             <    is written>: cinfo[0].marker[0].discarded_bytes
   
   /* Throw away any unused bits remaining in bit buffer; */
   /* include any full bytes in next_marker's count of discarded bytes */
   cinfo->marker->discarded_bytes += entropy->bitstate.bits_left/8;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.bits_left
   entropy->bitstate.bits_left = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Advance past the RSTn marker */
   if (!(*cinfo->marker->read_restart_marker)(cinfo))
      return 0;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   
   /* Re-initialize DC predictions to 0 */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
      (entropy->saved.last_dc_val)[ci] = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].saved.EOBRUN
   /* Re-init EOB run count, too */
   entropy->saved.EOBRUN = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
   
   /* Reset restart counter */
   entropy->restarts_to_go = cinfo->restart_interval;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.printed_eod
   
   /* Next segment can get another out-of-data warning */
   entropy->bitstate.printed_eod = 0;

   return 1;
}
static void start_pass_phuff_decoder(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].entropy
//             <    is written>: entropy
   phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
   boolean is_DC_band, bad;
   int ci, coefi, tbl;
   int *coef_bit_ptr;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].Ss
//             <    is written>: is_DC_band
   is_DC_band = cinfo->Ss==0;
//             <    is written>: bad
   
   /* Validate scan parameters */
   bad = 0;
//             <    is read   >: is_DC_band
   if (is_DC_band) {
//             <    is read   >: cinfo cinfo[0].Se
      if (cinfo->Se!=0)
//             <    is written>: bad
         bad = 1;
   }
   else {
//             <    is read   >: cinfo cinfo[0].Se cinfo[0].Se 
//                               cinfo[0].Ss
      /* need not check Ss/Se < 0 since they came from unsigned bytes */
      if (cinfo->Ss>cinfo->Se||cinfo->Se>=64)
//             <    is written>: bad
         bad = 1;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
      /* AC scans may have only one component */
      if (cinfo->comps_in_scan!=1)
//             <    is written>: bad
         bad = 1;
   }
//             <    is read   >: cinfo cinfo[0].Ah
   if (cinfo->Ah!=0)
//             <    is read   >: cinfo cinfo[0].Ah cinfo[0].Al
      /* Successive approximation refinement scan: must have Al = Ah-1. */
      if (cinfo->Al!=cinfo->Ah-1)
//             <    is written>: bad
         bad = 1;
//             <    is read   >: cinfo cinfo[0].Al
   if (cinfo->Al>13)
//             <    is written>: bad
      /* need not check for < 0 */
      bad = 1;
//             <    is read   >: bad
   if (bad)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_PROGRESSION, (cinfo->err->msg_parm.i)[0] = cinfo->Ss, (cinfo->err->msg_parm.i)[1] = cinfo->Se, (cinfo->err->msg_parm.i)[2] = cinfo->Ah, (cinfo->err->msg_parm.i)[3] = cinfo->Al, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci
   /* Update progression status, and verify that scan order is legal.
      * Note that inter-scan inconsistencies are treated as warnings
      * not fatal errors ... not clear if this is right way to behave.
      */
   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].cur_comp_info[ci] 
//                               cinfo[0].cur_comp_info[ci][0].compone
//                               nt_index
//             <    is written>: cindex
      int cindex = (cinfo->cur_comp_info)[ci]->component_index;
//             <    is read   >: cindex cinfo cinfo[0].coef_bits 
//                               cinfo[0].comps_in_scan
//             <    is written>: coef_bit_ptr
      coef_bit_ptr = &((cinfo->coef_bits)[cindex])[0];
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               coef_bit_ptr coef_bit_ptr[0] 
//                               is_DC_band
      if (!is_DC_band&&coef_bit_ptr[0]<0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* AC without prior DC scan */
         cinfo->err->msg_code = JWRN_BOGUS_PROGRESSION, (cinfo->err->msg_parm.i)[0] = cindex, (cinfo->err->msg_parm.i)[1] = 0, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo cinfo[0].Se cinfo[0].Ss 
//                               cinfo[0].comps_in_scan
//             <    is written>: coefi
      for(coefi = cinfo->Ss; coefi <= cinfo->Se; coefi += 1) {
//             <may be read   >: coef_bit_ptr[*]
//             <    is read   >: coef_bit_ptr coef_bit_ptr[coefi] 
//                               coefi
//             <    is written>: expected
         int expected = coef_bit_ptr[coefi]<0?0:coef_bit_ptr[coefi];
//             <    is read   >: cinfo cinfo[0].Ah cinfo[0].Se 
//                               cinfo[0].Ss cinfo[0].comps_in_scan 
//                               expected
         if (cinfo->Ah!=expected)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JWRN_BOGUS_PROGRESSION, (cinfo->err->msg_parm.i)[0] = cindex, (cinfo->err->msg_parm.i)[1] = coefi, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo cinfo[0].Al cinfo[0].Se 
//                               cinfo[0].Ss cinfo[0].comps_in_scan 
//                               coef_bit_ptr coefi
//             <    is written>: coef_bit_ptr[coefi]
         coef_bit_ptr[coefi] = cinfo->Al;
      }
   }
//             <    is read   >: cinfo cinfo[0].Ah
   
   /* Select MCU decoding routine */
   if (cinfo->Ah==0)
//             <    is read   >: is_DC_band
      if (is_DC_band)
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.decode_mcu
         entropy->pub.decode_mcu = decode_mcu_DC_first;
      else
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.decode_mcu
         entropy->pub.decode_mcu = decode_mcu_AC_first;
   else if (is_DC_band)
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.decode_mcu
      entropy->pub.decode_mcu = decode_mcu_DC_refine;
   else
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.decode_mcu
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
//             <    is read   >: cinfo cinfo[0].comps_in_scan
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->comps_in_scan-1; ci += 1) {
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].cur_comp_info[ci]
//             <    is written>: compptr
      compptr = (cinfo->cur_comp_info)[ci];
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               is_DC_band
      /* Make sure requested tables are present, and compute derived tables.
           * We may build same derived table more than once, but it's not expensive.
           */
      if (is_DC_band) {
//             <    is read   >: cinfo cinfo[0].Ah 
//                               cinfo[0].comps_in_scan
         if (cinfo->Ah==0) {
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].dc_tbl_no
//             <    is written>: tbl
            /* DC refinement needs no table */
            tbl = compptr->dc_tbl_no;
//             <    is read   >: cinfo cinfo[0].comps_in_scan 
//                               cinfo[0].dc_huff_tbl_ptrs[tbl] tbl
            if (tbl<0||tbl>=4||(cinfo->dc_huff_tbl_ptrs)[tbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = tbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

            jpeg_make_d_derived_tbl(cinfo, (cinfo->dc_huff_tbl_ptrs)[tbl], &(entropy->derived_tbls)[tbl]);
         }
      }
      else {
//             <    is read   >: cinfo cinfo[0].comps_in_scan compptr 
//                               compptr[0].ac_tbl_no
//             <    is written>: tbl
         tbl = compptr->ac_tbl_no;
//             <    is read   >: cinfo cinfo[0].ac_huff_tbl_ptrs[tbl] 
//                               cinfo[0].comps_in_scan tbl
         if (tbl<0||tbl>=4||(cinfo->ac_huff_tbl_ptrs)[tbl]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_NO_HUFF_TABLE, (cinfo->err->msg_parm.i)[0] = tbl, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

         jpeg_make_d_derived_tbl(cinfo, (cinfo->ac_huff_tbl_ptrs)[tbl], &(entropy->derived_tbls)[tbl]);
//             <    is read   >: cinfo cinfo[0].comps_in_scan entropy 
//                               entropy[0].derived_tbls[tbl] tbl
//             <    is written>: entropy[0].ac_derived_tbl
         /* remember the single active table */
         entropy->ac_derived_tbl = (entropy->derived_tbls)[tbl];
      }
//             <    is read   >: ci cinfo cinfo[0].comps_in_scan 
//                               entropy
//             <    is written>: entropy[0].saved.last_dc_val[ci]
      /* Initialize DC predictions to 0 */
      (entropy->saved.last_dc_val)[ci] = 0;
   }
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.bits_left
   
   /* Initialize bitread state variables */
   entropy->bitstate.bits_left = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.get_buffer
   entropy->bitstate.get_buffer = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].bitstate.printed_eod
   /* unnecessary, but keeps Purify quiet */
   entropy->bitstate.printed_eod = 0;
//             <    is read   >: entropy
//             <    is written>: entropy[0].saved.EOBRUN
   
   /* Initialize private state variables */
   entropy->saved.EOBRUN = 0;
//             <    is read   >: cinfo cinfo[0].restart_interval 
//                               entropy
//             <    is written>: entropy[0].restarts_to_go
   
   /* Initialize restart counter */
   entropy->restarts_to_go = cinfo->restart_interval;
}
static void post_process_1pass(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].post
//             <    is written>: post
   my_post_ptr post = (my_post_ptr) cinfo->post;
   JDIMENSION num_rows, max_rows;
//             <    is read   >: out_row_ctr out_row_ctr[0] 
//                               out_rows_avail
//             <    is written>: max_rows
   
   /* Fill the buffer, but not more than what we can dump out in one go. */
   /* Note we rely on the upsampler to detect bottom of image. */
   max_rows = out_rows_avail-*out_row_ctr;
//             <    is read   >: max_rows post post[0].strip_height
   if (max_rows>post->strip_height)
//             <    is read   >: post post[0].strip_height
//             <    is written>: max_rows
      max_rows = post->strip_height;
//             <    is written>: num_rows
   num_rows = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   (*cinfo->upsample->upsample)(cinfo,input_buf,in_row_group_ctr,in_row_groups_avail,post->buffer,&num_rows,max_rows);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Quantize and emit data. */
   (*cinfo->cquantize->color_quantize)(cinfo,post->buffer,output_buf+*out_row_ctr,(int) num_rows);
//             <    is read   >: num_rows out_row_ctr out_row_ctr[0]
//             <    is written>: out_row_ctr[0]
   *out_row_ctr += num_rows;
}
static void post_process_2pass(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].post
//             <    is written>: post
   my_post_ptr post = (my_post_ptr) cinfo->post;
   JDIMENSION num_rows, max_rows;
//             <    is read   >: post post[0].next_row
   
   /* Reposition virtual buffer if at start of strip. */
   if (post->next_row==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      post->buffer = (*cinfo->mem->access_virt_sarray)((j_common_ptr) cinfo,post->whole_image,post->starting_row,post->strip_height,0);
//             <    is read   >: post post[0].next_row 
//                               post[0].strip_height
//             <    is written>: num_rows
   
   /* Determine number of rows to emit. */
   num_rows = post->strip_height-post->next_row;
//             <    is read   >: out_row_ctr out_row_ctr[0] 
//                               out_rows_avail
//             <    is written>: max_rows
   /* available in strip */
   max_rows = out_rows_avail-*out_row_ctr;
//             <    is read   >: max_rows num_rows
   /* available in output area */
   if (num_rows>max_rows)
//             <    is read   >: max_rows
//             <    is written>: num_rows
      num_rows = max_rows;
//             <    is read   >: cinfo cinfo[0].output_height post 
//                               post[0].starting_row
//             <    is written>: max_rows
   /* We have to check bottom of image here, can't depend on upsampler. */
   max_rows = cinfo->output_height-post->starting_row;
//             <    is read   >: max_rows num_rows
   if (num_rows>max_rows)
//             <    is read   >: max_rows
//             <    is written>: num_rows
      num_rows = max_rows;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   
   /* Quantize and emit data. */
   (*cinfo->cquantize->color_quantize)(cinfo,post->buffer+post->next_row,output_buf+*out_row_ctr,(int) num_rows);
//             <    is read   >: num_rows out_row_ctr out_row_ctr[0]
//             <    is written>: out_row_ctr[0]
   *out_row_ctr += num_rows;
//             <    is read   >: num_rows post post[0].next_row
//             <    is written>: post[0].next_row
   
   /* Advance if we filled the strip. */
   post->next_row += num_rows;
//             <    is read   >: post post[0].next_row 
//                               post[0].strip_height
   if (post->next_row>=post->strip_height) {
//             <    is read   >: post post[0].starting_row 
//                               post[0].strip_height
//             <    is written>: post[0].starting_row
      post->starting_row += post->strip_height;
//             <    is read   >: post
//             <    is written>: post[0].next_row
      post->next_row = 0;
   }
}
static void post_process_prepass(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].post
//             <    is written>: post
   my_post_ptr post = (my_post_ptr) cinfo->post;
   JDIMENSION old_next_row, num_rows;
//             <    is read   >: post post[0].next_row
   
   /* Reposition virtual buffer if at start of strip. */
   if (post->next_row==0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      post->buffer = (*cinfo->mem->access_virt_sarray)((j_common_ptr) cinfo,post->whole_image,post->starting_row,post->strip_height,1);
//             <    is read   >: post post[0].next_row
//             <    is written>: old_next_row
   
   /* Upsample some data (up to a strip height's worth). */
   old_next_row = post->next_row;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   (*cinfo->upsample->upsample)(cinfo,input_buf,in_row_group_ctr,in_row_groups_avail,post->buffer,&post->next_row,post->strip_height);
//             <    is read   >: old_next_row post post[0].next_row
   
   /* Allow quantizer to scan new data.  No data is emitted, */
   /* but we advance out_row_ctr so outer loop can tell when we're done. */
   if (post->next_row>old_next_row) {
//             <    is read   >: old_next_row post post[0].next_row
//             <    is written>: num_rows
      num_rows = post->next_row-old_next_row;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->cquantize->color_quantize)(cinfo,post->buffer+old_next_row,(JSAMPARRAY) (void *) 0,(int) num_rows);
//             <    is read   >: num_rows out_row_ctr out_row_ctr[0]
//             <    is written>: out_row_ctr[0]
      *out_row_ctr += num_rows;
   }
//             <    is read   >: post post[0].next_row 
//                               post[0].strip_height
   
   /* Advance if we filled the strip. */
   if (post->next_row>=post->strip_height) {
//             <    is read   >: post post[0].starting_row 
//                               post[0].strip_height
//             <    is written>: post[0].starting_row
      post->starting_row += post->strip_height;
//             <    is read   >: post
//             <    is written>: post[0].next_row
      post->next_row = 0;
   }
}
static void start_pass_dpost(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
//             <    is read   >: cinfo cinfo[0].post
//             <    is written>: post
   my_post_ptr post = (my_post_ptr) cinfo->post;
//             <    is read   >: pass_mode

   if (pass_mode==JBUF_PASS_THRU) {
_switch_1_case_JBUF_PASS_THRU:      ;
//             <    is read   >: cinfo cinfo[0].quantize_colors
      if (cinfo->quantize_colors) {
//             <    is read   >: post
//             <    is written>: post[0].pub.post_process_data
         /* Single-pass processing with color quantization. */
         post->pub.post_process_data = post_process_1pass;
//             <    is read   >: post post[0].buffer
         /* We could be doing buffered-image output before starting a 2-pass
                * color quantization; in that case, jinit_d_post_controller did not
                * allocate a strip buffer.  Use the virtual-array buffer as workspace.
                */
         if (post->buffer==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

            post->buffer = (*cinfo->mem->access_virt_sarray)((j_common_ptr) cinfo,post->whole_image,(JDIMENSION) 0,post->strip_height,1);
      }
      else
//             <    is read   >: cinfo cinfo[0].upsample 
//                               cinfo[0].upsample[0].upsample post
//             <    is written>: post[0].pub.post_process_data
         /* For single-pass processing without color quantization,
                * I have no work to do; just call the upsampler directly.
                */
         post->pub.post_process_data = cinfo->upsample->upsample;
   }
   else if (pass_mode==JBUF_SAVE_AND_PASS) {

_switch_1_case_JBUF_SAVE_AND_PASS:      ;
//             <    is read   >: post post[0].whole_image
      /* First pass of 2-pass quantization */
      if (post->whole_image==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: post
//             <    is written>: post[0].pub.post_process_data
      post->pub.post_process_data = post_process_prepass;
   }
   else if (pass_mode==JBUF_CRANK_DEST) {
_switch_1_case_JBUF_CRANK_DEST:      ;
//             <    is read   >: post post[0].whole_image
      /* Second pass of 2-pass quantization */
      if (post->whole_image==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: post
//             <    is written>: post[0].pub.post_process_data
      post->pub.post_process_data = post_process_2pass;
   }
   else {

_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
//             <    is read   >: post
//             <    is written>: post[0].next_row post[0].starting_row
   post->starting_row = post->next_row = 0;
}
static void fullsize_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: input_data output_data_ptr
//             <    is written>: output_data_ptr[0]
   *output_data_ptr = input_data;
}
static void h2v1_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: output_data_ptr output_data_ptr[0]
//             <    is written>: output_data
   JSAMPARRAY output_data = *output_data_ptr;
   register JSAMPROW inptr, outptr;
   register int invalue;
   register JDIMENSION colctr;
   int inrow;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor
//             <    is written>: inrow

   for(inrow = 0; inrow <= cinfo->max_v_samp_factor-1; inrow += 1) {
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               input_data input_data[inrow] inrow
//             <    is written>: inptr
      inptr = input_data[inrow];
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inrow output_data output_data[inrow]
//             <    is written>: outptr
      outptr = output_data[inrow];
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inptr inptr[0]
//             <    is written>: inptr invalue
      /* Special case for first column */
      invalue = (int) *inptr++;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               invalue outptr
//             <    is written>: outptr outptr[0]
      *outptr++ = (JSAMPLE) invalue;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inptr inptr[0] invalue outptr
//             <    is written>: outptr outptr[0]
      *outptr++ = (JSAMPLE) (invalue*3+(int) *inptr+2>>2);
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               compptr compptr[0].downsampled_width
//             <    is written>: colctr

      for(colctr = compptr->downsampled_width-2; colctr >= 1; colctr += -1) {
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               compptr compptr[0].downsampled_width 
//                               inptr inptr[0]
//             <    is written>: inptr invalue
         /* General case: 3/4 * nearer pixel + 1/4 * further pixel */
         invalue = (int) *inptr++*3;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               compptr compptr[0].downsampled_width 
//                               inptr inptr[-2] invalue outptr
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) (invalue+(int) inptr[-2]+1>>2);
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               compptr compptr[0].downsampled_width 
//                               inptr inptr[0] invalue outptr
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) (invalue+(int) *inptr+2>>2);
      }
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inptr inptr[0]
//             <    is written>: invalue
      
      /* Special case for last column */
      invalue = (int) *inptr;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inptr inptr[-1] invalue outptr
//             <    is written>: outptr outptr[0]
      *outptr++ = (JSAMPLE) (invalue*3+(int) inptr[-1]+1>>2);
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               invalue outptr
//             <    is written>: outptr outptr[0]
      *outptr++ = (JSAMPLE) invalue;
   }
}
static void h2v1_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: output_data_ptr output_data_ptr[0]
//             <    is written>: output_data
   JSAMPARRAY output_data = *output_data_ptr;
   register JSAMPROW inptr, outptr;
   register JSAMPLE invalue;
   JSAMPROW outend;
   int inrow;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor
//             <    is written>: inrow

   for(inrow = 0; inrow <= cinfo->max_v_samp_factor-1; inrow += 1) {
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               input_data input_data[inrow] inrow
//             <    is written>: inptr
      inptr = input_data[inrow];
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inrow output_data output_data[inrow]
//             <    is written>: outptr
      outptr = output_data[inrow];
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               cinfo[0].output_width outptr
//             <    is written>: outend
      outend = outptr+cinfo->output_width;
//             <    is read   >: outend outptr
      while (outptr<outend) {
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               inptr inptr[0]
//             <    is written>: inptr invalue
         invalue = *inptr++;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               invalue outptr
//             <    is written>: outptr outptr[0]
         /* don't need GETJSAMPLE() here */
         *outptr++ = invalue;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               invalue outptr
//             <    is written>: outptr outptr[0]
         *outptr++ = invalue;
      }
   }
}
static void h2v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: output_data_ptr output_data_ptr[0]
//             <    is written>: output_data
   JSAMPARRAY output_data = *output_data_ptr;
   register JSAMPROW inptr0, inptr1, outptr;

   register int thiscolsum, lastcolsum, nextcolsum;
   
   
   
   register JDIMENSION colctr;
   int inrow, outrow, v;
//             <    is written>: inrow outrow

   inrow = outrow = 0;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               outrow
   while (outrow<cinfo->max_v_samp_factor) {
//             <    is written>: v
      for(v = 0; v <= 1; v += 1) {
//             <    is read   >: input_data input_data[inrow] inrow
//             <    is written>: inptr0
         /* inptr0 points to nearest input row, inptr1 points to next nearest */
         inptr0 = input_data[inrow];
//             <    is read   >: v
         if (v==0)
//             <    is read   >: input_data input_data[inrow-1] inrow
//             <    is written>: inptr1
            /* next nearest is row above */
            inptr1 = input_data[inrow-1];
         else
//             <    is read   >: input_data input_data[inrow+1] inrow
//             <    is written>: inptr1
            /* next nearest is row below */
            inptr1 = input_data[inrow+1];
//             <    is read   >: output_data output_data[outrow++] 
//                               outrow
//             <    is written>: outptr outrow
         outptr = output_data[outrow++];
//             <    is read   >: inptr0 inptr0[0] inptr1 inptr1[0]
//             <    is written>: inptr0 inptr1 thiscolsum
         
         /* Special case for first column */
         thiscolsum = (int) *inptr0++*3+(int) *inptr1++;
//             <    is read   >: inptr0 inptr0[0] inptr1 inptr1[0]
//             <    is written>: inptr0 inptr1 nextcolsum
         nextcolsum = (int) *inptr0++*3+(int) *inptr1++;
//             <    is read   >: outptr thiscolsum
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) (thiscolsum*4+8>>4);
//             <    is read   >: nextcolsum outptr thiscolsum
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) (thiscolsum*3+nextcolsum+7>>4);
//             <    is read   >: thiscolsum
//             <    is written>: lastcolsum
         lastcolsum = thiscolsum;
//             <    is read   >: nextcolsum
//             <    is written>: thiscolsum
         thiscolsum = nextcolsum;
//             <    is read   >: compptr compptr[0].downsampled_width
//             <    is written>: colctr

         for(colctr = compptr->downsampled_width-2; colctr >= 1; colctr += -1) {
//             <    is read   >: compptr compptr[0].downsampled_width 
//                               inptr0 inptr0[0] inptr1 inptr1[0]
//             <    is written>: inptr0 inptr1 nextcolsum
            /* General case: 3/4 * nearer pixel + 1/4 * further pixel in each */
            /* dimension, thus 9/16, 3/16, 3/16, 1/16 overall */
            nextcolsum = (int) *inptr0++*3+(int) *inptr1++;
//             <    is read   >: compptr compptr[0].downsampled_width 
//                               lastcolsum outptr thiscolsum
//             <    is written>: outptr outptr[0]
            *outptr++ = (JSAMPLE) (thiscolsum*3+lastcolsum+8>>4);
//             <    is read   >: compptr compptr[0].downsampled_width 
//                               nextcolsum outptr thiscolsum
//             <    is written>: outptr outptr[0]
            *outptr++ = (JSAMPLE) (thiscolsum*3+nextcolsum+7>>4);
//             <    is read   >: compptr compptr[0].downsampled_width 
//                               thiscolsum
//             <    is written>: lastcolsum
            lastcolsum = thiscolsum;
//             <    is read   >: compptr compptr[0].downsampled_width 
//                               nextcolsum
//             <    is written>: thiscolsum
            thiscolsum = nextcolsum;
         }
//             <    is read   >: lastcolsum outptr thiscolsum
//             <    is written>: outptr outptr[0]
         
         /* Special case for last column */
         *outptr++ = (JSAMPLE) (thiscolsum*3+lastcolsum+8>>4);
//             <    is read   >: outptr thiscolsum
//             <    is written>: outptr outptr[0]
         *outptr++ = (JSAMPLE) (thiscolsum*4+7>>4);
      }
//             <    is read   >: inrow
//             <    is written>: inrow
      inrow++;
   }
}
static void h2v2_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: output_data_ptr output_data_ptr[0]
//             <    is written>: output_data
   JSAMPARRAY output_data = *output_data_ptr;
   register JSAMPROW inptr, outptr;
   register JSAMPLE invalue;
   JSAMPROW outend;
   int inrow, outrow;
//             <    is written>: inrow outrow

   inrow = outrow = 0;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               outrow
   while (outrow<cinfo->max_v_samp_factor) {
//             <    is read   >: input_data input_data[inrow] inrow
//             <    is written>: inptr
      inptr = input_data[inrow];
//             <    is read   >: output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: cinfo cinfo[0].output_width outptr
//             <    is written>: outend
      outend = outptr+cinfo->output_width;
//             <    is read   >: outend outptr
      while (outptr<outend) {
//             <    is read   >: inptr inptr[0]
//             <    is written>: inptr invalue
         invalue = *inptr++;
//             <    is read   >: invalue outptr
//             <    is written>: outptr outptr[0]
         /* don't need GETJSAMPLE() here */
         *outptr++ = invalue;
//             <    is read   >: invalue outptr
//             <    is written>: outptr outptr[0]
         *outptr++ = invalue;
      }
//             <may be read   >: output_data[0] output_data[0]
//             <    is read   >: cinfo cinfo[0].output_width 
//                               output_data outrow

      jcopy_sample_rows(output_data, outrow, output_data, outrow+1, 1, cinfo->output_width);
//             <    is read   >: inrow
//             <    is written>: inrow
      inrow++;
//             <    is read   >: outrow
//             <    is written>: outrow
      outrow += 2;
   }
}
static void int_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
//             <    is read   >: output_data_ptr output_data_ptr[0]
//             <    is written>: output_data
   JSAMPARRAY output_data = *output_data_ptr;
   register JSAMPROW inptr, outptr;
   register JSAMPLE invalue;
   register int h;
   JSAMPROW outend;
   int h_expand, v_expand;
   int inrow, outrow;
//             <    is read   >: compptr compptr[0].component_index 
//                               upsample 
//                               upsample[0].h_expand[compptr->compone
//                               nt_index]
//             <    is written>: h_expand

   h_expand = (upsample->h_expand)[compptr->component_index];
//             <    is read   >: compptr compptr[0].component_index 
//                               upsample 
//                               upsample[0].v_expand[compptr->compone
//                               nt_index]
//             <    is written>: v_expand
   v_expand = (upsample->v_expand)[compptr->component_index];
//             <    is written>: inrow outrow

   inrow = outrow = 0;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               outrow
   while (outrow<cinfo->max_v_samp_factor) {
//             <    is read   >: input_data input_data[inrow] inrow
//             <    is written>: inptr
      /* Generate one output row with proper horizontal expansion */
      inptr = input_data[inrow];
//             <    is read   >: output_data output_data[outrow] 
//                               outrow
//             <    is written>: outptr
      outptr = output_data[outrow];
//             <    is read   >: cinfo cinfo[0].output_width outptr
//             <    is written>: outend
      outend = outptr+cinfo->output_width;
//             <    is read   >: outend outptr
      while (outptr<outend) {
//             <    is read   >: inptr inptr[0]
//             <    is written>: inptr invalue
         invalue = *inptr++;
//             <    is read   >: h_expand
//             <    is written>: h
         /* don't need GETJSAMPLE() here */
         for(h = h_expand; h >= 1; h += -1)
//             <    is read   >: h_expand invalue outptr
//             <    is written>: outptr outptr[0]
            *outptr++ = invalue;
      }
//             <    is read   >: v_expand
      /* Generate any additional output rows by duplicating the first one */
      if (v_expand>1)
//             <may be read   >: output_data[0] output_data[0]
//             <    is read   >: cinfo cinfo[0].output_width 
//                               output_data outrow v_expand

         jcopy_sample_rows(output_data, outrow, output_data, outrow+1, v_expand-1, cinfo->output_width);
//             <    is read   >: inrow
//             <    is written>: inrow
      inrow++;
//             <    is read   >: outrow v_expand
//             <    is written>: outrow
      outrow += v_expand;
   }
}
static void noop_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr, JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr)
{
//             <    is read   >: output_data_ptr
//             <    is written>: output_data_ptr[0]
   *output_data_ptr = (void *) 0;
}
static void sep_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf, JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   int ci;
   jpeg_component_info *compptr;
   JDIMENSION num_rows;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               upsample upsample[0].next_row_out
   
   /* Fill the conversion buffer, if it's empty */
   if (upsample->next_row_out>=cinfo->max_v_samp_factor) {
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
      compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Invoke per-component upsample method.  Notice we pass a POINTER
                * to color_buf[ci], so that fullsize_upsample can change it.
                */
         (*(upsample->methods)[ci])(cinfo,compptr,input_buf[ci]+*in_row_group_ctr*(upsample->rowgroup_height)[ci],upsample->color_buf+ci);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
         compptr++;
      }
//             <    is read   >: upsample
//             <    is written>: upsample[0].next_row_out
      upsample->next_row_out = 0;
   }
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               upsample upsample[0].next_row_out
//             <    is written>: num_rows
   
   /* Color-convert and emit rows */
   
   /* How many we have in the buffer: */
   num_rows = (JDIMENSION) (cinfo->max_v_samp_factor-upsample->next_row_out);
//             <    is read   >: num_rows upsample 
//                               upsample[0].rows_to_go
   /* Not more than the distance to the end of the image.  Need this test
      * in case the image height is not a multiple of max_v_samp_factor:
      */
   if (num_rows>upsample->rows_to_go)
//             <    is read   >: upsample upsample[0].rows_to_go
//             <    is written>: num_rows
      num_rows = upsample->rows_to_go;
//             <    is read   >: out_row_ctr out_row_ctr[0] 
//                               out_rows_avail
//             <    is written>: out_rows_avail
   /* And not more than what the client can accept: */
   out_rows_avail -= *out_row_ctr;
//             <    is read   >: num_rows out_rows_avail
   if (num_rows>out_rows_avail)
//             <    is read   >: out_rows_avail
//             <    is written>: num_rows
      num_rows = out_rows_avail;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   
   (*cinfo->cconvert->color_convert)(cinfo,upsample->color_buf,(JDIMENSION) upsample->next_row_out,output_buf+*out_row_ctr,(int) num_rows);
//             <    is read   >: num_rows out_row_ctr out_row_ctr[0]
//             <    is written>: out_row_ctr[0]
   
   /* Adjust counts */
   *out_row_ctr += num_rows;
//             <    is read   >: num_rows upsample 
//                               upsample[0].rows_to_go
//             <    is written>: upsample[0].rows_to_go
   upsample->rows_to_go -= num_rows;
//             <    is read   >: num_rows upsample 
//                               upsample[0].next_row_out
//             <    is written>: upsample[0].next_row_out
   upsample->next_row_out += num_rows;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               upsample upsample[0].next_row_out
   /* When the buffer is emptied, declare this input row group consumed */
   if (upsample->next_row_out>=cinfo->max_v_samp_factor)
//             <    is read   >: in_row_group_ctr in_row_group_ctr[0]
//             <    is written>: in_row_group_ctr[0]
      (*in_row_group_ctr)++;
}
static void start_pass_upsample(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].upsample
//             <    is written>: upsample
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               upsample
//             <    is written>: upsample[0].next_row_out
   
   /* Mark the conversion buffer empty */
   upsample->next_row_out = cinfo->max_v_samp_factor;
//             <    is read   >: cinfo cinfo[0].output_height upsample
//             <    is written>: upsample[0].rows_to_go
   /* Initialize total-height counter for detecting bottom of image */
   upsample->rows_to_go = cinfo->output_height;
}
static void transdecode_master_selection(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].arith_code
   /* Entropy decoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_ARITH_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   else if (cinfo->progressive_mode)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      jinit_phuff_decoder(cinfo);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_huff_decoder(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Always get a full-image coefficient buffer. */
   jinit_d_coef_controller(cinfo, 1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* We can now tell the memory manager to allocate virtual arrays. */
   (*cinfo->mem->realize_virt_arrays)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Initialize input side of decompressor to consume first scan. */
   (*cinfo->inputctl->start_input_pass)(cinfo);
//             <    is read   >: cinfo cinfo[0].progress
   if (cinfo->progress!=(void *) 0) {
      int nscans;
//             <    is read   >: cinfo cinfo[0].progressive_mode
      /* Estimate number of scans to set pass_limit. */
      if (cinfo->progressive_mode)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: nscans
         /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
         nscans = 2+3*cinfo->num_components;
      else
//             <    is read   >: cinfo cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns
         
         /* Initialize progress monitoring. */
         if (cinfo->inputctl->has_multiple_scans)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: nscans
            /* For a nonprogressive multiscan file, estimate 1 scan per component. */
            nscans = cinfo->num_components;
         else
//             <    is written>: nscans
            nscans = 1;
//             <    is read   >: cinfo cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
      cinfo->progress->pass_counter = 0L;
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].total_iMCU_rows nscans
//             <    is written>: cinfo[0].progress[0].pass_limit
      cinfo->progress->pass_limit = (long int) cinfo->total_iMCU_rows*nscans;
//             <    is read   >: cinfo cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].completed_passes
      cinfo->progress->completed_passes = 0;
//             <    is read   >: cinfo cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].total_passes
      cinfo->progress->total_passes = 1;
   }
}
static void emit_message(j_common_ptr cinfo, int msg_level)
{
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: err
   struct jpeg_error_mgr *err = cinfo->err;
//             <    is read   >: msg_level

   if (msg_level<0) {
//             <    is read   >: err err[0].num_warnings 
//                               err[0].trace_level
      /* It's a warning message.  Since corrupt files may generate many warnings,
           * the policy implemented here is to show only the first warning,
           * unless trace_level >= 3.
           */
      if (err->num_warnings==0||err->trace_level>=3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*err->output_message)(cinfo);
//             <    is read   >: err err[0].num_warnings
//             <    is written>: err[0].num_warnings
      /* Always count warnings in num_warnings. */
      err->num_warnings++;
   }
   else
//             <    is read   >: err err[0].trace_level msg_level
      /* It's a trace message.  Show it if trace_level >= msg_level. */
      if (err->trace_level>=msg_level)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*err->output_message)(cinfo);
}
static void error_exit(j_common_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Always display the message */
   (*cinfo->err->output_message)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Let the memory manager delete any temp files before we die */
   jpeg_destroy(cinfo);

   exit(1);
}
static void format_message(j_common_ptr cinfo, char *buffer)
{
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: err
   struct jpeg_error_mgr *err = cinfo->err;
//             <    is read   >: err err[0].msg_code
//             <    is written>: msg_code
   int msg_code = err->msg_code;
//             <    is written>: msgtext
   const char *msgtext = (void *) 0;
   const char *msgptr;
   char ch;
   boolean isstring;
//             <    is read   >: err err[0].last_jpeg_message msg_code
   
   /* Look up message string in proper table */
   if (msg_code>0&&msg_code<=err->last_jpeg_message)
//             <    is read   >: err err[0].jpeg_message_table 
//                               err[0].jpeg_message_table[msg_code] 
//                               msg_code
//             <    is written>: msgtext
      msgtext = (err->jpeg_message_table)[msg_code];
   else
//             <    is read   >: err err[0].addon_message_table 
//                               err[0].first_addon_message 
//                               err[0].last_addon_message msg_code

      if (err->addon_message_table!=(void *) 0&&msg_code>=err->first_addon_message&&msg_code<=err->last_addon_message)
//             <    is read   >: err err[0].addon_message_table 
//                               err[0].addon_message_table[msg_code-e
//                               rr->first_addon_message] 
//                               err[0].first_addon_message msg_code
//             <    is written>: msgtext
         msgtext = (err->addon_message_table)[msg_code-err->first_addon_message];
//             <    is read   >: msgtext
   
   /* Defend against bogus message number */
   if (msgtext==(void *) 0) {
//             <    is read   >: err msg_code
//             <    is written>: err[0].msg_parm.i[0]
      (err->msg_parm.i)[0] = msg_code;
//             <    is read   >: err err[0].jpeg_message_table 
//                               err[0].jpeg_message_table[0]
//             <    is written>: msgtext
      msgtext = (err->jpeg_message_table)[0];
   }
//             <    is written>: isstring
   
   /* Check for string parameter, as indicated by %s in the message text */
   isstring = 0;
//             <    is read   >: msgtext
//             <    is written>: msgptr
   msgptr = msgtext;
l99999:   ;
//             <    is read   >: msgptr msgptr[0]
//             <    is written>: ch msgptr
   if (!((ch = *msgptr++)!='\0')) goto _break_1;
//             <    is read   >: ch
   if (ch=='%') {
   }
   else {
      goto l99999;
   }
//             <    is read   >: msgptr msgptr[0]
   if (*msgptr=='s')
//             <    is written>: isstring
      isstring = 1;
_break_1:   ;
//             <    is read   >: isstring
   
   /* Format the message into the passed buffer */
   if (isstring)
//             <may be read   >: err[0].msg_parm.s[*] msgtext[*]
//             <may be written>: buffer[*]
//             <    is read   >: buffer err msgtext
      sprintf(buffer, msgtext, err->msg_parm.s);
   else
//             <may be read   >: msgtext[*]
//             <may be written>: buffer[*]
//             <    is read   >: buffer err err[0].msg_parm.i[0] 
//                               err[0].msg_parm.i[1] 
//                               err[0].msg_parm.i[2] 
//                               err[0].msg_parm.i[3] 
//                               err[0].msg_parm.i[4] 
//                               err[0].msg_parm.i[5] 
//                               err[0].msg_parm.i[6] 
//                               err[0].msg_parm.i[7] msgtext
      
      
      
      
      sprintf(buffer, msgtext, (err->msg_parm.i)[0], (err->msg_parm.i)[1], (err->msg_parm.i)[2], (err->msg_parm.i)[3], (err->msg_parm.i)[4], (err->msg_parm.i)[5], (err->msg_parm.i)[6], (err->msg_parm.i)[7]);
}
static void output_message(j_common_ptr cinfo)
{
   char buffer[200];
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Create the message */
   (*cinfo->err->format_message)(cinfo,buffer);
//             <may be read   >: buffer[*] stderr[0]
//             <may be written>: stderr[0]
//             <    is read   >: stderr __IO_EFFECTS:LUNS[2]
//             <    is written>: __IO_EFFECTS:LUNS[2]
   
   /* Send it to stderr, adding a newline */
   fprintf(stderr, "%s\n", buffer);
}
static void reset_error_mgr(j_common_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].num_warnings
   cinfo->err->num_warnings = 0;
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
   /* trace_level is not reset since it is an application-supplied parameter */
   cinfo->err->msg_code = 0;
}
void jinit_1pass_quantizer(j_decompress_ptr cinfo)
{
   my_cquantize_ptr cquantize;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cquantize = (my_cquantize_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_cquantizer));
//             <    is read   >: cinfo cquantize
//             <    is written>: cinfo[0].cquantize
   cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.start_pass
   cquantize->pub.start_pass = start_pass_1_quant;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.finish_pass
   cquantize->pub.finish_pass = finish_pass_1_quant;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.new_color_map
   cquantize->pub.new_color_map = new_color_map_1_quant;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].fserrors[0]
   (cquantize->fserrors)[0] = (void *) 0;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].odither[0]
   /* Flag FS workspace not allocated */
   (cquantize->odither)[0] = (void *) 0;
//             <    is read   >: cinfo cinfo[0].out_color_components
   /* Also flag odither arrays not allocated */
   
   /* Make sure my internal arrays won't overflow */
   if (cinfo->out_color_components>4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_QUANT_COMPONENTS, (cinfo->err->msg_parm.i)[0] = 4, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo 
//                               cinfo[0].desired_number_of_colors
   /* Make sure colormap indexes can be represented by JSAMPLEs */
   if (cinfo->desired_number_of_colors>255+1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_QUANT_MANY_COLORS, (cinfo->err->msg_parm.i)[0] = 255+1, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Create the colormap and color index table. */
   create_colormap(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   create_colorindex(cinfo);
//             <    is read   >: cinfo cinfo[0].dither_mode
   
   /* Allocate Floyd-Steinberg workspace now if requested.
      * We do this now since it is FAR storage and may affect the memory
      * manager's space calculations.  If the user changes to FS dither
      * mode in a later pass, we will allocate the space then, and will
      * possibly overrun the max_memory_to_use setting.
      */
   if (cinfo->dither_mode==JDITHER_FS)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      alloc_fs_workspace(cinfo);
}
void jinit_2pass_quantizer(j_decompress_ptr cinfo)
{
   my_cquantize_ptr cquantize;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cquantize = (my_cquantize_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_cquantizer));
//             <    is read   >: cinfo cquantize
//             <    is written>: cinfo[0].cquantize
   cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.start_pass
   cquantize->pub.start_pass = start_pass_2_quant;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.new_color_map
   cquantize->pub.new_color_map = new_color_map_2_quant;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].fserrors
   cquantize->fserrors = (void *) 0;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].error_limiter
   /* flag optional arrays not allocated */
   cquantize->error_limiter = (void *) 0;
//             <    is read   >: cinfo cinfo[0].out_color_components
   
   /* Make sure jdmaster didn't give me a case I can't handle */
   if (cinfo->out_color_components!=3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Allocate the histogram/inverse colormap storage */
   cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(1<<5)*(size_t) sizeof(hist2d));
//             <    is written>: i
   for(i = 0; i <= 31; i += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (cquantize->histogram)[i] = (hist2d) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,(1<<6)*(1<<5)*(size_t) sizeof(histcell));
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].needs_zeroed
   cquantize->needs_zeroed = 1;
//             <    is read   >: cinfo cinfo[0].enable_2pass_quant
   /* histogram is garbage now */
   
   /* Allocate storage for the completed colormap, if required.
      * We do this now since it is FAR storage and may affect
      * the memory manager's space calculations.
      */
   if (cinfo->enable_2pass_quant) {
      /* Make sure color count is acceptable */
//             <    is read   >: cinfo 
//                               cinfo[0].desired_number_of_colors
//             <    is written>: desired
      int desired = cinfo->desired_number_of_colors;
//             <    is read   >: desired
      /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
      if (desired<8)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_QUANT_FEW_COLORS, (cinfo->err->msg_parm.i)[0] = 8, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: desired
      /* Make sure colormap indexes can be represented by JSAMPLEs */
      if (desired>255+1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_QUANT_MANY_COLORS, (cinfo->err->msg_parm.i)[0] = 255+1, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,(JDIMENSION) desired,(JDIMENSION) 3);
//             <    is read   >: cquantize desired
//             <    is written>: cquantize[0].desired
      cquantize->desired = desired;
   }
   else
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].sv_colormap
      cquantize->sv_colormap = (void *) 0;
//             <    is read   >: cinfo cinfo[0].dither_mode
   
   /* Only F-S dithering or no dithering is supported. */
   /* If user asks for ordered dither, give him F-S. */
   if (cinfo->dither_mode!=JDITHER_NONE)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].dither_mode
      cinfo->dither_mode = JDITHER_FS;
//             <    is read   >: cinfo cinfo[0].dither_mode
   
   /* Allocate Floyd-Steinberg workspace if necessary.
      * This isn't really needed until pass 2, but again it is FAR storage.
      * Although we will cope with a later change in dither_mode,
      * we do not promise to honor max_memory_to_use if dither_mode changes.
      */
   if (cinfo->dither_mode==JDITHER_FS) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,(size_t) ((cinfo->output_width+2)*3*(size_t) sizeof(FSERROR)));
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Might as well create the error-limiting table too. */
      init_error_limit(cinfo);
   }
}
void jinit_c_coef_controller(j_compress_ptr cinfo, boolean need_full_buffer)
{
   my_coef_ptr coef;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   coef = (my_coef_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_coef_controller));
//             <    is read   >: cinfo coef
//             <    is written>: cinfo[0].coef
   cinfo->coef = (struct jpeg_c_coef_controller *) coef;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.start_pass
   coef->pub.start_pass = start_pass_coef;
//             <    is read   >: need_full_buffer
   
   /* Create the coefficient buffer. */
   if (need_full_buffer) {
      
      /* Allocate a full-image virtual array for each component, */
      /* padded to a multiple of samp_factor DCT blocks in each direction. */
      int ci;
      jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
      compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         
         
         
         (coef->whole_image)[ci] = (*cinfo->mem->request_virt_barray)((j_common_ptr) cinfo,1,0,(JDIMENSION) jround_up((long int) compptr->width_in_blocks, (long int) compptr->h_samp_factor),(JDIMENSION) jround_up((long int) compptr->height_in_blocks, (long int) compptr->v_samp_factor),(JDIMENSION) compptr->v_samp_factor);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
         compptr++;
      }
   }
   else {
      /* We only need a single-MCU buffer. */
      JBLOCKROW buffer;
      int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      buffer = (JBLOCKROW) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,10*(size_t) sizeof(JBLOCK));
//             <    is written>: i
      for(i = 0; i <= 9; i += 1)
//             <    is read   >: buffer coef i
//             <    is written>: coef[0].MCU_buffer[i]
         (coef->MCU_buffer)[i] = buffer+i;
//             <    is read   >: coef
//             <    is written>: coef[0].whole_image[0]
      (coef->whole_image)[0] = (void *) 0;
   }
}
void jinit_c_main_controller(j_compress_ptr cinfo, boolean need_full_buffer)
{
   my_main_ptr main;
   int ci;
   jpeg_component_info *compptr;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   main = (my_main_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_main_controller));
//             <    is read   >: cinfo main
//             <    is written>: cinfo[0].main
   cinfo->main = (struct jpeg_c_main_controller *) main;
//             <    is read   >: main
//             <    is written>: main[0].pub.start_pass
   main->pub.start_pass = start_pass_main;
//             <    is read   >: cinfo cinfo[0].raw_data_in
   
   /* We don't need to create a buffer in raw-data mode. */
   if (cinfo->raw_data_in)
      return;
//             <    is read   >: need_full_buffer
   
   /* Create the buffer.  It holds downsampled data, so each component
      * may be of a different size.
      */
   if (need_full_buffer)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   else {
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
      compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      
      
      
      /* Allocate a strip buffer for each component */
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (main->buffer)[ci] = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,compptr->width_in_blocks*8,(JDIMENSION) (compptr->v_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
         compptr++;
      }
   }
}
void jinit_c_master_control(j_compress_ptr cinfo, boolean transcode_only)
{
   my_master_ptr master;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   master = (my_master_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_comp_master));
//             <    is read   >: cinfo master
//             <    is written>: cinfo[0].master
   cinfo->master = (struct jpeg_comp_master *) master;
//             <    is read   >: master
//             <    is written>: master[0].pub.prepare_for_pass
   master->pub.prepare_for_pass = prepare_for_pass;
//             <    is read   >: master
//             <    is written>: master[0].pub.pass_startup
   master->pub.pass_startup = pass_startup;
//             <    is read   >: master
//             <    is written>: master[0].pub.finish_pass
   master->pub.finish_pass = finish_pass_master;
//             <    is read   >: master
//             <    is written>: master[0].pub.is_last_pass
   master->pub.is_last_pass = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Validate parameters, determine derived values */
   initial_setup(cinfo);
//             <    is read   >: cinfo cinfo[0].scan_info
   if (cinfo->scan_info!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      validate_script(cinfo);
   else {
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].progressive_mode
      cinfo->progressive_mode = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_scans
      cinfo->num_scans = 1;
   }
//             <    is read   >: cinfo cinfo[0].progressive_mode

   if (cinfo->progressive_mode)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].optimize_coding
      /*  TEMPORARY HACK ??? */
      cinfo->optimize_coding = 1;
//             <    is read   >: transcode_only
   /* assume default tables no good for progressive mode */
   
   /* Initialize my private state */
   if (transcode_only)
//             <    is read   >: cinfo cinfo[0].optimize_coding
      /* no main pass in transcoding */
      if (cinfo->optimize_coding)
//             <    is read   >: master
//             <    is written>: master[0].pass_type
         master->pass_type = huff_opt_pass;
      else
//             <    is read   >: master
//             <    is written>: master[0].pass_type
         master->pass_type = output_pass;
   else
//             <    is read   >: master
//             <    is written>: master[0].pass_type
      /* for normal compression, first pass is always this type: */
      master->pass_type = main_pass;
//             <    is read   >: master
//             <    is written>: master[0].scan_number
   master->scan_number = 0;
//             <    is read   >: master
//             <    is written>: master[0].pass_number
   master->pass_number = 0;
//             <    is read   >: cinfo cinfo[0].optimize_coding
   if (cinfo->optimize_coding)
//             <    is read   >: cinfo cinfo[0].num_scans master
//             <    is written>: master[0].total_passes
      master->total_passes = cinfo->num_scans*2;
   else
//             <    is read   >: cinfo cinfo[0].num_scans master
//             <    is written>: master[0].total_passes
      master->total_passes = cinfo->num_scans;
}
void jinit_c_prep_controller(j_compress_ptr cinfo, boolean need_full_buffer)
{
   my_prep_ptr prep;
   int ci;
   jpeg_component_info *compptr;
//             <    is read   >: need_full_buffer

   if (need_full_buffer)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* safety check */
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   prep = (my_prep_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_prep_controller));
//             <    is read   >: cinfo prep
//             <    is written>: cinfo[0].prep
   cinfo->prep = (struct jpeg_c_prep_controller *) prep;
//             <    is read   >: prep
//             <    is written>: prep[0].pub.start_pass
   prep->pub.start_pass = start_pass_prep;
//             <    is read   >: cinfo cinfo[0].downsample 
//                               cinfo[0].downsample[0].need_context_r
//                               ows
   
   /* Allocate the color conversion buffer.
      * We make the buffer wide enough to allow the downsampler to edge-expand
      * horizontally within the buffer, if it so chooses.
      */
   if (cinfo->downsample->need_context_rows) {
//             <    is read   >: prep
//             <    is written>: prep[0].pub.pre_process_data
      /* Set up to provide context rows */
      
      prep->pub.pre_process_data = pre_process_context;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      create_context_buffer(cinfo);
   }
   else {
//             <    is read   >: prep
//             <    is written>: prep[0].pub.pre_process_data
      /* No context, just make it tall enough for one row group */
      prep->pub.pre_process_data = pre_process_data;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
      compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (prep->color_buf)[ci] = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,(JDIMENSION) ((long int) compptr->width_in_blocks*8*cinfo->max_h_samp_factor/(compptr->h_samp_factor)),(JDIMENSION) cinfo->max_v_samp_factor);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
         compptr++;
      }
   }
}
void jinit_color_converter(j_compress_ptr cinfo)
{
   my_cconvert_ptr cconvert;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cconvert = (my_cconvert_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_color_converter));
//             <    is read   >: cconvert cinfo
//             <    is written>: cinfo[0].cconvert
   cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.start_pass
   /* set start_pass to null method until we find out differently */
   cconvert->pub.start_pass = null_method;
//             <    is read   >: cinfo cinfo[0].in_color_space

/* Make sure input_components agrees with in_color_space */
   if (cinfo->in_color_space==JCS_GRAYSCALE) goto _switch_1_case_JCS_GRAYSCALE;
//             <    is read   >: cinfo cinfo[0].in_color_space
   if (cinfo->in_color_space==JCS_RGB) goto _switch_1_case_JCS_RGB;
//             <    is read   >: cinfo cinfo[0].in_color_space
   if (cinfo->in_color_space==JCS_YCbCr) goto _switch_1_case_JCS_YCbCr;
//             <    is read   >: cinfo cinfo[0].in_color_space
   if (cinfo->in_color_space==JCS_CMYK) goto _switch_1_case_JCS_CMYK;
//             <    is read   >: cinfo cinfo[0].in_color_space
   if (cinfo->in_color_space==JCS_YCCK) goto _switch_1_case_JCS_YCCK;

_switch_1_default:   ;
//             <    is read   >: cinfo cinfo[0].input_components
   /* JCS_UNKNOWN can be anything */
   if (cinfo->input_components<1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_IN_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;
_switch_1_case_JCS_YCCK:   ;
//             <    is read   >: cinfo cinfo[0].input_components
   if (cinfo->input_components!=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_IN_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;

_switch_1_case_JCS_CMYK:   ;
   goto _switch_1_case_JCS_YCCK;
   
   
   
   
   
   
_switch_1_case_JCS_YCbCr:   ;
//             <    is read   >: cinfo cinfo[0].input_components
   if (cinfo->input_components!=3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_IN_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;

_switch_1_case_JCS_RGB:   ;
   goto _switch_1_case_JCS_YCbCr;
_switch_1_case_JCS_GRAYSCALE:   ;
//             <    is read   >: cinfo cinfo[0].input_components
   if (cinfo->input_components!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_IN_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
_break_1:   ;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
   
   /* Check num_components, set conversion method based on requested space */
   if (cinfo->jpeg_color_space==JCS_GRAYSCALE) {
_switch_2_case_JCS_GRAYSCALE:      ;
//             <    is read   >: cinfo cinfo[0].num_components
      if (cinfo->num_components!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].in_color_space
      if (cinfo->in_color_space==JCS_GRAYSCALE)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = grayscale_convert;
      else if (cinfo->in_color_space==JCS_RGB) {
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.start_pass
         cconvert->pub.start_pass = rgb_ycc_start;
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = rgb_gray_convert;
      }
      else if (cinfo->in_color_space==JCS_YCbCr)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = grayscale_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else if (cinfo->jpeg_color_space==JCS_RGB) {

_switch_2_case_JCS_RGB:      ;
//             <    is read   >: cinfo cinfo[0].num_components
      if (cinfo->num_components!=3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].in_color_space
      if (cinfo->in_color_space==JCS_RGB&&3==3)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else if (cinfo->jpeg_color_space==JCS_YCbCr) {

_switch_2_case_JCS_YCbCr:      ;
//             <    is read   >: cinfo cinfo[0].num_components
      if (cinfo->num_components!=3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].in_color_space
      if (cinfo->in_color_space==JCS_RGB) {
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.start_pass
         cconvert->pub.start_pass = rgb_ycc_start;
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = rgb_ycc_convert;
      }
      else if (cinfo->in_color_space==JCS_YCbCr)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else if (cinfo->jpeg_color_space==JCS_CMYK) {

_switch_2_case_JCS_CMYK:      ;
//             <    is read   >: cinfo cinfo[0].num_components
      if (cinfo->num_components!=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].in_color_space
      if (cinfo->in_color_space==JCS_CMYK)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else if (cinfo->jpeg_color_space==JCS_YCCK) {

_switch_2_case_JCS_YCCK:      ;
//             <    is read   >: cinfo cinfo[0].num_components
      if (cinfo->num_components!=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].in_color_space
      if (cinfo->in_color_space==JCS_CMYK) {
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.start_pass
         cconvert->pub.start_pass = rgb_ycc_start;
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = cmyk_ycck_convert;
      }
      else if (cinfo->in_color_space==JCS_YCCK)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else {

_switch_2_default:      ;
//             <    is read   >: cinfo cinfo[0].in_color_space 
//                               cinfo[0].input_components 
//                               cinfo[0].jpeg_color_space 
//                               cinfo[0].num_components
      /* allow null conversion of JCS_UNKNOWN */
      
      if (cinfo->jpeg_color_space!=cinfo->in_color_space||cinfo->num_components!=cinfo->input_components)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
      cconvert->pub.color_convert = null_convert;
   }
_break_2:   ;
}
void jinit_color_deconverter(j_decompress_ptr cinfo)
{
   my_cconvert_ptr cconvert;
   int ci;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cconvert = (my_cconvert_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_color_deconverter));
//             <    is read   >: cconvert cinfo
//             <    is written>: cinfo[0].cconvert
   cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.start_pass
   cconvert->pub.start_pass = start_pass_dcolor;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space

/* Make sure num_components agrees with jpeg_color_space */
   if (cinfo->jpeg_color_space==JCS_GRAYSCALE) goto _switch_1_case_JCS_GRAYSCALE;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
   if (cinfo->jpeg_color_space==JCS_RGB) goto _switch_1_case_JCS_RGB;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
   if (cinfo->jpeg_color_space==JCS_YCbCr) goto _switch_1_case_JCS_YCbCr;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
   if (cinfo->jpeg_color_space==JCS_CMYK) goto _switch_1_case_JCS_CMYK;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
   if (cinfo->jpeg_color_space==JCS_YCCK) goto _switch_1_case_JCS_YCCK;

_switch_1_default:   ;
//             <    is read   >: cinfo cinfo[0].num_components
   /* JCS_UNKNOWN can be anything */
   if (cinfo->num_components<1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;
_switch_1_case_JCS_YCCK:   ;
//             <    is read   >: cinfo cinfo[0].num_components
   if (cinfo->num_components!=4)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;

_switch_1_case_JCS_CMYK:   ;
   goto _switch_1_case_JCS_YCCK;
_switch_1_case_JCS_YCbCr:   ;
//             <    is read   >: cinfo cinfo[0].num_components
   if (cinfo->num_components!=3)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;

_switch_1_case_JCS_RGB:   ;
   goto _switch_1_case_JCS_YCbCr;
_switch_1_case_JCS_GRAYSCALE:   ;
//             <    is read   >: cinfo cinfo[0].num_components
   if (cinfo->num_components!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
_break_1:   ;
//             <    is read   >: cinfo cinfo[0].out_color_space
   
   /* Set out_color_components and conversion method based on requested space.
      * Also clear the component_needed flags for any unused components,
      * so that earlier pipeline stages can avoid useless computation.
      */
   
   if (cinfo->out_color_space==JCS_GRAYSCALE) {
_switch_2_case_JCS_GRAYSCALE:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_components
      cinfo->out_color_components = 1;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space 
//                               cinfo[0].jpeg_color_space

      if (cinfo->jpeg_color_space==JCS_GRAYSCALE||cinfo->jpeg_color_space==JCS_YCbCr) {
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = grayscale_convert;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
         /* For color->grayscale conversion, only the Y (0) component is needed */
         for(ci = 1; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comp_info 
//                               cinfo[0].num_components
//             <    is written>: 
//                               cinfo[0].comp_info[ci].component_need
//                               ed
            (cinfo->comp_info)[ci].component_needed = 0;
      }
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else if (cinfo->out_color_space==JCS_RGB) {

_switch_2_case_JCS_RGB:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_components
      cinfo->out_color_components = 3;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
      if (cinfo->jpeg_color_space==JCS_YCbCr) {
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = ycc_rgb_convert;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         build_ycc_rgb_table(cinfo);
      }
      else if (cinfo->jpeg_color_space==JCS_RGB&&3==3)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else if (cinfo->out_color_space==JCS_CMYK) {

_switch_2_case_JCS_CMYK:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_components
      cinfo->out_color_components = 4;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space
      if (cinfo->jpeg_color_space==JCS_YCCK) {
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = ycck_cmyk_convert;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         build_ycc_rgb_table(cinfo);
      }
      else if (cinfo->jpeg_color_space==JCS_CMYK)
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
   else {

_switch_2_default:      ;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space 
//                               cinfo[0].out_color_space
      /* Permit null conversion to same output space */
      if (cinfo->out_color_space==cinfo->jpeg_color_space) {
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: cinfo[0].out_color_components
         cinfo->out_color_components = cinfo->num_components;
//             <    is read   >: cconvert
//             <    is written>: cconvert[0].pub.color_convert
         cconvert->pub.color_convert = null_convert;
      }
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* unsupported non-null conversion */
         cinfo->err->msg_code = JERR_CONVERSION_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_2:   ;
//             <    is read   >: cinfo cinfo[0].quantize_colors

   if (cinfo->quantize_colors)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].output_components
      cinfo->output_components = 1;
   else
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: cinfo[0].output_components
      cinfo->output_components = cinfo->out_color_components;
}
void jinit_compress_master(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Initialize master control (includes parameter checking/processing) */
   /* full compression */
   jinit_c_master_control(cinfo, 0);
//             <    is read   >: cinfo cinfo[0].raw_data_in
   
   /* Preprocessing */
   if (!cinfo->raw_data_in) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_color_converter(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_downsampler(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* never need full buffer here */
      jinit_c_prep_controller(cinfo, 0);
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Forward DCT */
   jinit_forward_dct(cinfo);
//             <    is read   >: cinfo cinfo[0].arith_code
   /* Entropy encoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_ARITH_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   else if (cinfo->progressive_mode)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      jinit_phuff_encoder(cinfo);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jinit_huff_encoder(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Need a full-image coefficient buffer in any multi-pass mode. */
   
   jinit_c_coef_controller(cinfo, cinfo->num_scans>1||cinfo->optimize_coding);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* never need full buffer here */
   jinit_c_main_controller(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   jinit_marker_writer(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* We can now tell the memory manager to allocate virtual arrays. */
   (*cinfo->mem->realize_virt_arrays)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Write the datastream header (SOI) immediately.
      * Frame and scan headers are postponed till later.
      * This lets application insert special markers after the SOI.
      */
   (*cinfo->marker->write_file_header)(cinfo);
}
void jinit_d_coef_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
{
   my_coef_ptr coef;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   coef = (my_coef_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_coef_controller));
//             <    is read   >: cinfo coef
//             <    is written>: cinfo[0].coef
   cinfo->coef = (struct jpeg_d_coef_controller *) coef;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.start_input_pass
   coef->pub.start_input_pass = start_input_pass;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.start_output_pass
   coef->pub.start_output_pass = start_output_pass;
//             <    is read   >: coef
//             <    is written>: coef[0].coef_bits_latch
   coef->coef_bits_latch = (void *) 0;
//             <    is read   >: need_full_buffer
   
   
   /* Create the coefficient buffer. */
   if (need_full_buffer) {
      
      /* Allocate a full-image virtual array for each component, */
      /* padded to a multiple of samp_factor DCT blocks in each direction. */
      /* Note we ask for a pre-zeroed array. */
      int ci, access_rows;
      jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
      compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

      for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].v_samp_factor
//             <    is written>: access_rows
         access_rows = compptr->v_samp_factor;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].progressive_mode
         
         /* If block smoothing could be used, need a bigger window */
         if (cinfo->progressive_mode)
//             <    is read   >: access_rows cinfo 
//                               cinfo[0].num_components
//             <    is written>: access_rows
            access_rows *= 3;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         
         
         
         (coef->whole_image)[ci] = (*cinfo->mem->request_virt_barray)((j_common_ptr) cinfo,1,1,(JDIMENSION) jround_up((long int) compptr->width_in_blocks, (long int) compptr->h_samp_factor),(JDIMENSION) jround_up((long int) compptr->height_in_blocks, (long int) compptr->v_samp_factor),(JDIMENSION) access_rows);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
         compptr++;
      }
//             <    is read   >: coef
//             <    is written>: coef[0].pub.consume_data
      coef->pub.consume_data = consume_data;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.decompress_data
      coef->pub.decompress_data = decompress_data;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.coef_arrays
      coef->pub.coef_arrays = coef->whole_image;
   }
   else {
      /* We only need a single-MCU buffer. */
      JBLOCKROW buffer;
      int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      buffer = (JBLOCKROW) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,10*(size_t) sizeof(JBLOCK));
//             <    is written>: i
      for(i = 0; i <= 9; i += 1)
//             <    is read   >: buffer coef i
//             <    is written>: coef[0].MCU_buffer[i]
         (coef->MCU_buffer)[i] = buffer+i;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.consume_data
      coef->pub.consume_data = dummy_consume_data;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.decompress_data
      coef->pub.decompress_data = decompress_onepass;
//             <    is read   >: coef
//             <    is written>: coef[0].pub.coef_arrays
      coef->pub.coef_arrays = (void *) 0;
   }
}
void jinit_d_main_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
{
   my_main_ptr main;
   int ci, rgroup, ngroups;
   jpeg_component_info *compptr;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   main = (my_main_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_main_controller));
//             <    is read   >: cinfo main
//             <    is written>: cinfo[0].main
   cinfo->main = (struct jpeg_d_main_controller *) main;
//             <    is read   >: main
//             <    is written>: main[0].pub.start_pass
   main->pub.start_pass = start_pass_main;
//             <    is read   >: need_full_buffer

   if (need_full_buffer)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* shouldn't happen */
      cinfo->err->msg_code = JERR_BAD_BUFFER_MODE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].upsample 
//                               cinfo[0].upsample[0].need_context_row
//                               s
   
   /* Allocate the workspace.
      * ngroups is the number of row groups we need.
      */
   if (cinfo->upsample->need_context_rows) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
      if (cinfo->min_DCT_scaled_size<2)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* unsupported, see comments above */
         cinfo->err->msg_code = JERR_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      alloc_funny_pointers(cinfo);
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: ngroups
      /* Alloc space for xbuffer[] lists */
      ngroups = cinfo->min_DCT_scaled_size+2;
   }
   else
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: ngroups
      ngroups = cinfo->min_DCT_scaled_size;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: rgroup
      rgroup = compptr->v_samp_factor*compptr->DCT_scaled_size/(cinfo->min_DCT_scaled_size);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* height of a row group of component */
      (main->buffer)[ci] = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,compptr->width_in_blocks*compptr->DCT_scaled_size,(JDIMENSION) (rgroup*ngroups));
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
void jinit_d_post_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
{
   my_post_ptr post;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   post = (my_post_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_post_controller));
//             <    is read   >: cinfo post
//             <    is written>: cinfo[0].post
   cinfo->post = (struct jpeg_d_post_controller *) post;
//             <    is read   >: post
//             <    is written>: post[0].pub.start_pass
   post->pub.start_pass = start_pass_dpost;
//             <    is read   >: post
//             <    is written>: post[0].whole_image
   post->whole_image = (void *) 0;
//             <    is read   >: post
//             <    is written>: post[0].buffer
   /* flag for no virtual arrays */
   post->buffer = (void *) 0;
//             <    is read   >: cinfo cinfo[0].quantize_colors
   /* flag for no strip buffer */
   
   /* Create the quantization buffer, if needed */
   if (cinfo->quantize_colors) {
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor post
//             <    is written>: post[0].strip_height
      /* The buffer strip height is max_v_samp_factor, which is typically
           * an efficient number of rows for upsampling to return.
           * (In the presence of output rescaling, we might want to be smarter?)
           */
      post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
//             <    is read   >: need_full_buffer
      if (need_full_buffer)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         
         
         /* Two-pass color quantization: need full-image storage. */
         /* We round up the number of rows to a multiple of the strip height. */
         
         post->whole_image = (*cinfo->mem->request_virt_sarray)((j_common_ptr) cinfo,1,0,cinfo->output_width*cinfo->out_color_components,(JDIMENSION) jround_up((long int) cinfo->output_height, (long int) post->strip_height),post->strip_height);
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         /* One-pass color quantization: just make a strip buffer. */
         post->buffer = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,cinfo->output_width*cinfo->out_color_components,post->strip_height);
   }
}
void jinit_downsampler(j_compress_ptr cinfo)
{
   my_downsample_ptr downsample;
   int ci;
   jpeg_component_info *compptr;
//             <    is written>: smoothok
   boolean smoothok = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   downsample = (my_downsample_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_downsampler));
//             <    is read   >: cinfo downsample
//             <    is written>: cinfo[0].downsample
   cinfo->downsample = (struct jpeg_downsampler *) downsample;
//             <    is read   >: downsample
//             <    is written>: downsample[0].pub.start_pass
   downsample->pub.start_pass = start_pass_downsample;
//             <    is read   >: downsample
//             <    is written>: downsample[0].pub.downsample
   downsample->pub.downsample = sep_downsample;
//             <    is read   >: downsample
//             <    is written>: downsample[0].pub.need_context_rows
   downsample->pub.need_context_rows = 0;
//             <    is read   >: cinfo cinfo[0].CCIR601_sampling

   if (cinfo->CCIR601_sampling)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_CCIR601_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* Verify we can handle the sampling factors, and set up method pointers */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].max_h_samp_factor 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].h_samp_factor 
//                               compptr[0].v_samp_factor

      if (compptr->h_samp_factor==cinfo->max_h_samp_factor&&compptr->v_samp_factor==cinfo->max_v_samp_factor)
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].smoothing_factor

         if (cinfo->smoothing_factor) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].methods[ci]
            (downsample->methods)[ci] = fullsize_smooth_downsample;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].pub.need_context_rows
            downsample->pub.need_context_rows = 1;
         }
         else
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].methods[ci]

            (downsample->methods)[ci] = fullsize_downsample;
      else if (compptr->h_samp_factor*2==cinfo->max_h_samp_factor&&compptr->v_samp_factor==cinfo->max_v_samp_factor) {
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: smoothok
         smoothok = 0;
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].methods[ci]
         (downsample->methods)[ci] = h2v1_downsample;
      }
      else if (compptr->h_samp_factor*2==cinfo->max_h_samp_factor&&compptr->v_samp_factor*2==cinfo->max_v_samp_factor)
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].smoothing_factor

         if (cinfo->smoothing_factor) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].methods[ci]
            (downsample->methods)[ci] = h2v2_smooth_downsample;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].pub.need_context_rows
            downsample->pub.need_context_rows = 1;
         }
         else
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].methods[ci]

            (downsample->methods)[ci] = h2v2_downsample;
      else if (cinfo->max_h_samp_factor%compptr->h_samp_factor==0&&cinfo->max_v_samp_factor%compptr->v_samp_factor==0) {
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: smoothok
         smoothok = 0;
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               downsample
//             <    is written>: downsample[0].methods[ci]
         (downsample->methods)[ci] = int_downsample;
      }
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_FRACT_SAMPLE_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].smoothing_factor 
//                               smoothok
   
   
   if (cinfo->smoothing_factor&&!smoothok)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_SMOOTH_NOTIMPL, (*cinfo->err->emit_message)((j_common_ptr) cinfo,0);
}
void jinit_forward_dct(j_compress_ptr cinfo)
{
   my_fdct_ptr fdct;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   fdct = (my_fdct_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_fdct_controller));
//             <    is read   >: cinfo fdct
//             <    is written>: cinfo[0].fdct
   cinfo->fdct = (struct jpeg_forward_dct *) fdct;
//             <    is read   >: fdct
//             <    is written>: fdct[0].pub.start_pass
   fdct->pub.start_pass = start_pass_fdctmgr;
//             <    is read   >: cinfo cinfo[0].dct_method

   if (cinfo->dct_method==JDCT_ISLOW) {

_switch_1_case_JDCT_ISLOW:      ;
//             <    is read   >: fdct
//             <    is written>: fdct[0].pub.forward_DCT
      fdct->pub.forward_DCT = forward_DCT;
//             <    is read   >: fdct
//             <    is written>: fdct[0].do_dct
      fdct->do_dct = jpeg_fdct_islow;
   }
   else if (cinfo->dct_method==JDCT_IFAST) {
      
      
_switch_1_case_JDCT_IFAST:      ;
//             <    is read   >: fdct
//             <    is written>: fdct[0].pub.forward_DCT
      fdct->pub.forward_DCT = forward_DCT;
//             <    is read   >: fdct
//             <    is written>: fdct[0].do_dct
      fdct->do_dct = jpeg_fdct_ifast;
   }
   else if (cinfo->dct_method==JDCT_FLOAT) {
      
      
_switch_1_case_JDCT_FLOAT:      ;
//             <    is read   >: fdct
//             <    is written>: fdct[0].pub.forward_DCT
      fdct->pub.forward_DCT = forward_DCT_float;
//             <    is read   >: fdct
//             <    is written>: fdct[0].do_float_dct
      fdct->do_float_dct = jpeg_fdct_float;
   }
   else {

_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_NOT_COMPILED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
//             <    is written>: i
   
   /* Mark divisor tables unallocated */
   for(i = 0; i <= 3; i += 1) {
//             <    is read   >: fdct i
//             <    is written>: fdct[0].divisors[i]
      (fdct->divisors)[i] = (void *) 0;
//             <    is read   >: fdct i
//             <    is written>: fdct[0].float_divisors[i]
      (fdct->float_divisors)[i] = (void *) 0;
   }
}
void jinit_huff_decoder(j_decompress_ptr cinfo)
{
   huff_entropy_ptr entropy;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   entropy = (huff_entropy_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(huff_entropy_decoder));
//             <    is read   >: cinfo entropy
//             <    is written>: cinfo[0].entropy
   cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.start_pass
   entropy->pub.start_pass = start_pass_huff_decoder;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.decode_mcu
   entropy->pub.decode_mcu = decode_mcu;
//             <    is written>: i
   
   /* Mark tables unallocated */
   for(i = 0; i <= 3; i += 1)
//             <    is read   >: entropy i
//             <    is written>: entropy[0].ac_derived_tbls[i] 
//                               entropy[0].dc_derived_tbls[i]
      (entropy->dc_derived_tbls)[i] = (entropy->ac_derived_tbls)[i] = (void *) 0;
}
void jinit_huff_encoder(j_compress_ptr cinfo)
{
   huff_entropy_ptr entropy;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   entropy = (huff_entropy_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(huff_entropy_encoder));
//             <    is read   >: cinfo entropy
//             <    is written>: cinfo[0].entropy
   cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.start_pass
   entropy->pub.start_pass = start_pass_huff;
//             <    is written>: i
   
   /* Mark tables unallocated */
   for(i = 0; i <= 3; i += 1) {
//             <    is read   >: entropy i
//             <    is written>: entropy[0].ac_derived_tbls[i] 
//                               entropy[0].dc_derived_tbls[i]
      (entropy->dc_derived_tbls)[i] = (entropy->ac_derived_tbls)[i] = (void *) 0;
//             <    is read   >: entropy i
//             <    is written>: entropy[0].ac_count_ptrs[i] 
//                               entropy[0].dc_count_ptrs[i]
      (entropy->dc_count_ptrs)[i] = (entropy->ac_count_ptrs)[i] = (void *) 0;
   }
}
void jinit_input_controller(j_decompress_ptr cinfo)
{
   my_inputctl_ptr inputctl;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Create subobject in permanent pool */
   
   inputctl = (my_inputctl_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,(size_t) sizeof(my_input_controller));
//             <    is read   >: cinfo inputctl
//             <    is written>: cinfo[0].inputctl
   cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.consume_input
   /* Initialize method pointers */
   inputctl->pub.consume_input = consume_markers;
//             <    is read   >: inputctl
//             <    is written>: 
//                               inputctl[0].pub.reset_input_controlle
//                               r
   inputctl->pub.reset_input_controller = reset_input_controller;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.start_input_pass
   inputctl->pub.start_input_pass = start_input_pass;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.finish_input_pass
   inputctl->pub.finish_input_pass = finish_input_pass;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.has_multiple_scans
   /* Initialize state: can't use reset_input_controller since we don't
      * want to try to reset other modules yet.
      */
   inputctl->pub.has_multiple_scans = 0;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].pub.eoi_reached
   /* "unknown" would be better */
   inputctl->pub.eoi_reached = 0;
//             <    is read   >: inputctl
//             <    is written>: inputctl[0].inheaders
   inputctl->inheaders = 1;
}
void jinit_inverse_dct(j_decompress_ptr cinfo)
{
   my_idct_ptr idct;
   int ci;
   jpeg_component_info *compptr;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   idct = (my_idct_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_idct_controller));
//             <    is read   >: cinfo idct
//             <    is written>: cinfo[0].idct
   cinfo->idct = (struct jpeg_inverse_dct *) idct;
//             <    is read   >: idct
//             <    is written>: idct[0].pub.start_pass
   idct->pub.start_pass = start_pass;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci

   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Allocate and pre-zero a multiplier table for each component */
      
      compptr->dct_table = (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(multiplier_table));
//             <may be written>: compptr[0].dct_table[*]
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].dct_table
      memset((void *) compptr->dct_table, 0, (size_t) (size_t) sizeof(multiplier_table));
//             <    is read   >: ci cinfo cinfo[0].num_components idct
//             <    is written>: idct[0].cur_method[ci]
      /* Mark multiplier table not yet set up for any method */
      (idct->cur_method)[ci] = -1;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
void jinit_marker_reader(j_decompress_ptr cinfo)
{
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Create subobject in permanent pool */
   
   cinfo->marker = (struct jpeg_marker_reader *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,(size_t) sizeof(struct jpeg_marker_reader ));
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: 
//                               cinfo[0].marker[0].reset_marker_reade
//                               r
   /* Initialize method pointers */
   cinfo->marker->reset_marker_reader = reset_marker_reader;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].read_markers
   cinfo->marker->read_markers = read_markers;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: 
//                               cinfo[0].marker[0].read_restart_marke
//                               r
   cinfo->marker->read_restart_marker = read_restart_marker;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].process_COM
   cinfo->marker->process_COM = skip_variable;
//             <    is written>: i
   for(i = 0; i <= 15; i += 1)
//             <    is read   >: cinfo cinfo[0].marker i
//             <    is written>: cinfo[0].marker[0].process_APPn[i]
      (cinfo->marker->process_APPn)[i] = skip_variable;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].process_APPn[0]
   (cinfo->marker->process_APPn)[0] = get_app0;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].process_APPn[14]
   (cinfo->marker->process_APPn)[14] = get_app14;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].comp_info 
//                               cinfo[0].input_scan_number 
//                               cinfo[0].marker[0].discarded_bytes 
//                               cinfo[0].marker[0].saw_SOF 
//                               cinfo[0].marker[0].saw_SOI 
//                               cinfo[0].unread_marker
   /* Reset marker processing state */
   reset_marker_reader(cinfo);
}
void jinit_marker_writer(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Create the subobject */
   
   cinfo->marker = (struct jpeg_marker_writer *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(struct jpeg_marker_writer ));
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].write_any_marker
   /* Initialize method pointers */
   cinfo->marker->write_any_marker = write_any_marker;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].write_file_header
   cinfo->marker->write_file_header = write_file_header;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].write_frame_header
   cinfo->marker->write_frame_header = write_frame_header;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].write_scan_header
   cinfo->marker->write_scan_header = write_scan_header;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].write_file_trailer
   cinfo->marker->write_file_trailer = write_file_trailer;
//             <    is read   >: cinfo cinfo[0].marker
//             <    is written>: cinfo[0].marker[0].write_tables_only
   cinfo->marker->write_tables_only = write_tables_only;
}
void jinit_master_decompress(j_decompress_ptr cinfo)
{
   my_master_ptr master;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   master = (my_master_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_decomp_master));
//             <    is read   >: cinfo master
//             <    is written>: cinfo[0].master
   cinfo->master = (struct jpeg_decomp_master *) master;
//             <    is read   >: master
//             <    is written>: master[0].pub.prepare_for_output_pass
   master->pub.prepare_for_output_pass = prepare_for_output_pass;
//             <    is read   >: master
//             <    is written>: master[0].pub.finish_output_pass
   master->pub.finish_output_pass = finish_output_pass;
//             <    is read   >: master
//             <    is written>: master[0].pub.is_dummy_pass

   master->pub.is_dummy_pass = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   master_selection(cinfo);
}
void jinit_memory_mgr(j_common_ptr cinfo)
{
   my_mem_ptr mem;
   long int max_to_use;
   int pool;
   size_t test_mac;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].mem
   cinfo->mem = (void *) 0;
   /* for safety if init fails */
   
   /* Check for configuration errors.
      * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
      * doesn't reflect any real hardware alignment requirement.
      * The test is a little tricky: for X>0, X and X-1 have no one-bits
      * in common if and only if X is a power of 2, ie has only one one-bit.
      * Some compilers may give an "unreachable code" warning here; ignore it.
      */
   if (((size_t) sizeof(double)&(size_t) sizeof(double)-1)!=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_ALIGN_TYPE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is written>: test_mac
   /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
      * a multiple of SIZEOF(ALIGN_TYPE).
      * Again, an "unreachable code" warning may be ignored here.
      * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
      */
   test_mac = (size_t) 1000000000L;
//             <    is read   >: test_mac
   if ((long int) test_mac!=1000000000L||1000000000L%(size_t) sizeof(double)!=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_ALLOC_CHUNK, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo
//             <    is written>: max_to_use

   max_to_use = jpeg_mem_init(cinfo);
//             <    is read   >: cinfo _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: mem _MALLOC_EFFECTS:_MALLOC_
   /* system-dependent initialization */
   
   /* Attempt to allocate memory manager's control block */
   mem = (my_mem_ptr) jpeg_get_small(cinfo, (size_t) sizeof(my_memory_mgr));
//             <    is read   >: mem
   if (mem==(void *) 0) {
//             <    is read   >: cinfo
      jpeg_mem_term(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* system-dependent cleanup */
      cinfo->err->msg_code = JERR_OUT_OF_MEMORY, (cinfo->err->msg_parm.i)[0] = 0, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
//             <    is read   >: mem
//             <    is written>: mem[0].pub.alloc_small
   
   /* OK, fill in the method pointers */
   mem->pub.alloc_small = alloc_small;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.alloc_large
   mem->pub.alloc_large = alloc_large;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.alloc_sarray
   mem->pub.alloc_sarray = alloc_sarray;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.alloc_barray
   mem->pub.alloc_barray = alloc_barray;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.request_virt_sarray
   mem->pub.request_virt_sarray = request_virt_sarray;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.request_virt_barray
   mem->pub.request_virt_barray = request_virt_barray;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.realize_virt_arrays
   mem->pub.realize_virt_arrays = realize_virt_arrays;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.access_virt_sarray
   mem->pub.access_virt_sarray = access_virt_sarray;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.access_virt_barray
   mem->pub.access_virt_barray = access_virt_barray;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.free_pool
   mem->pub.free_pool = free_pool;
//             <    is read   >: mem
//             <    is written>: mem[0].pub.self_destruct
   mem->pub.self_destruct = self_destruct;
//             <    is read   >: max_to_use mem
//             <    is written>: mem[0].pub.max_memory_to_use
   
   /* Initialize working state */
   mem->pub.max_memory_to_use = max_to_use;
//             <    is written>: pool

   for(pool = 2-1; pool >= 0; pool += -1) {
//             <    is read   >: mem pool
//             <    is written>: mem[0].small_list[pool]
      (mem->small_list)[pool] = (void *) 0;
//             <    is read   >: mem pool
//             <    is written>: mem[0].large_list[pool]
      (mem->large_list)[pool] = (void *) 0;
   }
//             <    is read   >: mem
//             <    is written>: mem[0].virt_sarray_list
   mem->virt_sarray_list = (void *) 0;
//             <    is read   >: mem
//             <    is written>: mem[0].virt_barray_list
   mem->virt_barray_list = (void *) 0;
//             <    is read   >: mem
//             <    is written>: mem[0].total_space_allocated
   mem->total_space_allocated = (size_t) sizeof(my_memory_mgr);
//             <    is read   >: cinfo mem
//             <    is written>: cinfo[0].mem
   
   /* Declare ourselves open for business */
   cinfo->mem = &mem->pub;
   {
      char *memenv;
//             <    is written>: memenv
      if ((memenv = getenv("JPEGMEM"))!=(void *) 0) {
//             <    is written>: ch
         char ch = 'x';
//             <may be read   >: memenv[*]
//             <may be written>: ch max_to_use
//             <    is read   >: memenv

         if (sscanf(memenv, "%ld%c", &max_to_use, &ch)>0) {
//             <    is read   >: ch
            if (ch=='m'||ch=='M')
//             <    is read   >: max_to_use
//             <    is written>: max_to_use
               max_to_use *= 1000L;
//             <    is read   >: max_to_use mem
//             <    is written>: mem[0].pub.max_memory_to_use
            mem->pub.max_memory_to_use = max_to_use*1000L;
         }
      }
   }
}
void jinit_merged_upsampler(j_decompress_ptr cinfo)
{
   my_upsample_ptr upsample;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   upsample = (my_upsample_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_upsampler));
//             <    is read   >: cinfo upsample
//             <    is written>: cinfo[0].upsample
   cinfo->upsample = (struct jpeg_upsampler *) upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.start_pass
   upsample->pub.start_pass = start_pass_merged_upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.need_context_rows
   upsample->pub.need_context_rows = 0;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cinfo[0].output_width upsample
//             <    is written>: upsample[0].out_row_width

   upsample->out_row_width = cinfo->output_width*cinfo->out_color_components;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor

   if (cinfo->max_v_samp_factor==2) {
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.upsample
      upsample->pub.upsample = merged_2v_upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].upmethod
      upsample->upmethod = h2v2_merged_upsample;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Allocate a spare row buffer */
      
      upsample->spare_row = (JSAMPROW) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,(size_t) (upsample->out_row_width*(size_t) sizeof(JSAMPLE)));
   }
   else {
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.upsample
      upsample->pub.upsample = merged_1v_upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].upmethod
      upsample->upmethod = h2v1_merged_upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].spare_row
      /* No spare row needed */
      upsample->spare_row = (void *) 0;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   build_ycc_rgb_table(cinfo);
}
void jinit_phuff_decoder(j_decompress_ptr cinfo)
{
   phuff_entropy_ptr entropy;
   int *coef_bit_ptr;
   int ci, i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   entropy = (phuff_entropy_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(phuff_entropy_decoder));
//             <    is read   >: cinfo entropy
//             <    is written>: cinfo[0].entropy
   cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.start_pass
   entropy->pub.start_pass = start_pass_phuff_decoder;
//             <    is written>: i
   
   /* Mark derived tables unallocated */
   for(i = 0; i <= 3; i += 1)
//             <    is read   >: entropy i
//             <    is written>: entropy[0].derived_tbls[i]
      (entropy->derived_tbls)[i] = (void *) 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Create progression status table */
   
   cinfo->coef_bits = (int (*)[64]) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,cinfo->num_components*64*(size_t) sizeof(int));
//             <    is read   >: cinfo cinfo[0].coef_bits
//             <    is written>: coef_bit_ptr
   coef_bit_ptr = &((cinfo->coef_bits)[0])[0];
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: i
      for(i = 0; i <= 63; i += 1)
//             <    is read   >: cinfo cinfo[0].num_components 
//                               coef_bit_ptr
//             <    is written>: coef_bit_ptr coef_bit_ptr[0]
         *coef_bit_ptr++ = -1;
}
void jinit_phuff_encoder(j_compress_ptr cinfo)
{
   phuff_entropy_ptr entropy;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   entropy = (phuff_entropy_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(phuff_entropy_encoder));
//             <    is read   >: cinfo entropy
//             <    is written>: cinfo[0].entropy
   cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
//             <    is read   >: entropy
//             <    is written>: entropy[0].pub.start_pass
   entropy->pub.start_pass = start_pass_phuff;
//             <    is written>: i
   
   /* Mark tables unallocated */
   for(i = 0; i <= 3; i += 1) {
//             <    is read   >: entropy i
//             <    is written>: entropy[0].derived_tbls[i]
      (entropy->derived_tbls)[i] = (void *) 0;
//             <    is read   >: entropy i
//             <    is written>: entropy[0].count_ptrs[i]
      (entropy->count_ptrs)[i] = (void *) 0;
   }
//             <    is read   >: entropy
//             <    is written>: entropy[0].bit_buffer
   entropy->bit_buffer = (void *) 0;
}
void jinit_upsampler(j_decompress_ptr cinfo)
{
   my_upsample_ptr upsample;
   int ci;
   jpeg_component_info *compptr;
   boolean need_buffer, do_fancy;
   int h_in_group, v_in_group, h_out_group, v_out_group;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   upsample = (my_upsample_ptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(my_upsampler));
//             <    is read   >: cinfo upsample
//             <    is written>: cinfo[0].upsample
   cinfo->upsample = (struct jpeg_upsampler *) upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.start_pass
   upsample->pub.start_pass = start_pass_upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.upsample
   upsample->pub.upsample = sep_upsample;
//             <    is read   >: upsample
//             <    is written>: upsample[0].pub.need_context_rows
   upsample->pub.need_context_rows = 0;
//             <    is read   >: cinfo cinfo[0].CCIR601_sampling
   /* until we find out differently */
   
   if (cinfo->CCIR601_sampling)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* this isn't supported */
      cinfo->err->msg_code = JERR_CCIR601_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].do_fancy_upsampling 
//                               cinfo[0].min_DCT_scaled_size
//             <    is written>: do_fancy
   
   /* jdmainct.c doesn't support context rows when min_DCT_scaled_size = 1,
      * so don't ask for it.
      */
   do_fancy = cinfo->do_fancy_upsampling&&cinfo->min_DCT_scaled_size>1;
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* Verify we can handle the sampling factors, select per-component methods,
      * and create storage as needed.
      */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].h_samp_factor
//             <    is written>: h_in_group
      /* Compute size of an "input group" after IDCT scaling.  This many samples
           * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
           */
      h_in_group = compptr->h_samp_factor*compptr->DCT_scaled_size/(cinfo->min_DCT_scaled_size);
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: v_in_group
      v_in_group = compptr->v_samp_factor*compptr->DCT_scaled_size/(cinfo->min_DCT_scaled_size);
//             <    is read   >: cinfo cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components
//             <    is written>: h_out_group
      h_out_group = cinfo->max_h_samp_factor;
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components
//             <    is written>: v_out_group
      v_out_group = cinfo->max_v_samp_factor;
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample v_in_group
//             <    is written>: upsample[0].rowgroup_height[ci]
      (upsample->rowgroup_height)[ci] = v_in_group;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: need_buffer
      /* save for use later */
      need_buffer = 1;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].component_needed
      if (!compptr->component_needed) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
         /* Don't bother to upsample an uninteresting component. */
         (upsample->methods)[ci] = noop_upsample;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: need_buffer
         need_buffer = 0;
      }
      else if (h_in_group==h_out_group&&v_in_group==v_out_group) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
         /* Fullsize components can be processed without any work. */
         (upsample->methods)[ci] = fullsize_upsample;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: need_buffer
         need_buffer = 0;
      }
      else if (h_in_group*2==h_out_group&&v_in_group==v_out_group)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].downsampled_width do_fancy
         /* Special cases for 2h1v upsampling */
         if (do_fancy&&compptr->downsampled_width>2)
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
            (upsample->methods)[ci] = h2v1_fancy_upsample;
         else
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
            (upsample->methods)[ci] = h2v1_upsample;
      else if (h_in_group*2==h_out_group&&v_in_group*2==v_out_group)
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               compptr[0].downsampled_width do_fancy
         /* Special cases for 2h2v upsampling */
         if (do_fancy&&compptr->downsampled_width>2) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
            (upsample->methods)[ci] = h2v2_fancy_upsample;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].pub.need_context_rows
            upsample->pub.need_context_rows = 1;
         }
         else
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
            (upsample->methods)[ci] = h2v2_upsample;
      else if (h_out_group%h_in_group==0&&v_out_group%v_in_group==0) {
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample
//             <    is written>: upsample[0].methods[ci]
         /* Generic integral-factors upsampling method */
         (upsample->methods)[ci] = int_upsample;
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               h_in_group h_out_group upsample
//             <    is written>: upsample[0].h_expand[ci]
         (upsample->h_expand)[ci] = (UINT8) (h_out_group/h_in_group);
//             <    is read   >: ci cinfo cinfo[0].num_components 
//                               upsample v_in_group v_out_group
//             <    is written>: upsample[0].v_expand[ci]
         (upsample->v_expand)[ci] = (UINT8) (v_out_group/v_in_group);
      }
      else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_FRACT_SAMPLE_NOTIMPL, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components 
//                               need_buffer
      if (need_buffer)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         
         
         
         (upsample->color_buf)[ci] = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,(JDIMENSION) jround_up((long int) cinfo->output_width, (long int) cinfo->max_h_samp_factor),(JDIMENSION) cinfo->max_v_samp_factor);
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
}
static JBLOCKARRAY access_virt_barray(j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable)
{
//             <    is read   >: num_rows start_row
//             <    is written>: end_row
   JDIMENSION end_row = start_row+num_rows;
   JDIMENSION undef_row;
//             <    is read   >: end_row num_rows ptr ptr[0].maxaccess
//                               ptr[0].mem_buffer 
//                               ptr[0].rows_in_array
   
   /* debugging check */
   
   if (end_row>ptr->rows_in_array||num_rows>ptr->maxaccess||ptr->mem_buffer==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: end_row ptr ptr[0].cur_start_row 
//                               ptr[0].cur_start_row 
//                               ptr[0].rows_in_mem start_row
   
   /* Make the desired part of the virtual array accessible */
   
   if (start_row<ptr->cur_start_row||end_row>ptr->cur_start_row+ptr->rows_in_mem) {
//             <    is read   >: ptr ptr[0].b_s_open
      if (!ptr->b_s_open)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_VIRTUAL_BUG, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: ptr ptr[0].dirty
      /* Flush old buffer contents if necessary */
      if (ptr->dirty) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         do_barray_io(cinfo, ptr, 1);
//             <    is read   >: ptr
//             <    is written>: ptr[0].dirty
         ptr->dirty = 0;
      }
//             <    is read   >: ptr ptr[0].cur_start_row start_row
      /* Decide what part of virtual array to access.
           * Algorithm: if target address > current window, assume forward scan,
           * load starting at target address.  If target address < current window,
           * assume backward scan, load so that target area is top of window.
           * Note that when switching from forward write to forward read, will have
           * start_row = 0, so the limiting case applies and we load from 0 anyway.
           */
      if (start_row>ptr->cur_start_row)
//             <    is read   >: ptr start_row
//             <    is written>: ptr[0].cur_start_row
         ptr->cur_start_row = start_row;
      else {
         /* use long arithmetic here to avoid overflow & unsigned problems */
         long int ltemp;
//             <    is read   >: end_row ptr ptr[0].rows_in_mem
//             <    is written>: ltemp

         ltemp = (long int) end_row-((long int) ptr->rows_in_mem);
//             <    is read   >: ltemp
         if (ltemp<0)
//             <    is written>: ltemp
            ltemp = 0;
//             <    is read   >: ltemp ptr
//             <    is written>: ptr[0].cur_start_row
         /* don't fall off front end of file */
         ptr->cur_start_row = (JDIMENSION) ltemp;
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Read in the selected part of the array.
           * During the initial write pass, we will do no actual read
           * because the selected part is all undefined.
           */
      do_barray_io(cinfo, ptr, 0);
   }
//             <    is read   >: end_row ptr ptr[0].first_undef_row
   /* Ensure the accessed part of the array is defined; prezero if needed.
      * To improve locality of access, we only prezero the part of the array
      * that the caller is about to access, not the entire in-memory array.
      */
   if (ptr->first_undef_row<end_row) {
//             <    is read   >: ptr ptr[0].first_undef_row start_row
      if (ptr->first_undef_row<start_row) {
//             <    is read   >: writable
         if (writable)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* writer skipped over a section of array */
            cinfo->err->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: start_row
//             <    is written>: undef_row
         undef_row = start_row;
      }
      else
//             <    is read   >: ptr ptr[0].first_undef_row
//             <    is written>: undef_row
         undef_row = ptr->first_undef_row;
//             <    is read   >: writable
      if (writable)
//             <    is read   >: end_row ptr
//             <    is written>: ptr[0].first_undef_row
         ptr->first_undef_row = end_row;
//             <    is read   >: ptr ptr[0].pre_zero
      if (ptr->pre_zero) {
//             <    is read   >: ptr ptr[0].blocksperrow
//             <    is written>: bytesperrow
         size_t bytesperrow = (size_t) ptr->blocksperrow*(size_t) sizeof(JBLOCK);
//             <    is read   >: ptr ptr[0].cur_start_row undef_row
//             <    is written>: undef_row
         undef_row -= ptr->cur_start_row;
//             <    is read   >: end_row ptr ptr[0].cur_start_row
//             <    is written>: end_row
         /* make indexes relative to buffer */
         end_row -= ptr->cur_start_row;
//             <    is read   >: end_row undef_row
         while (undef_row<end_row) {
//             <may be written>: ptr[0].mem_buffer[undef_row][*][*]
//             <    is read   >: bytesperrow ptr ptr[0].mem_buffer 
//                               ptr[0].mem_buffer[undef_row] 
//                               undef_row
            jzero_far((void *) (ptr->mem_buffer)[undef_row], bytesperrow);
//             <    is read   >: undef_row
//             <    is written>: undef_row
            undef_row++;
         }
      }
      else if (!writable)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* reader looking at undefined data */
         cinfo->err->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
//             <    is read   >: writable
   /* Flag the buffer dirty if caller will write in it */
   if (writable)
//             <    is read   >: ptr
//             <    is written>: ptr[0].dirty
      ptr->dirty = 1;
//             <    is read   >: ptr ptr[0].cur_start_row 
//                               ptr[0].mem_buffer start_row
   /* Return address of proper part of the buffer */
   return ptr->mem_buffer+(start_row-ptr->cur_start_row);
}
static JSAMPARRAY access_virt_sarray(j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable)
{
//             <    is read   >: num_rows start_row
//             <    is written>: end_row
   JDIMENSION end_row = start_row+num_rows;
   JDIMENSION undef_row;
//             <    is read   >: end_row num_rows ptr ptr[0].maxaccess
//                               ptr[0].mem_buffer 
//                               ptr[0].rows_in_array
   
   /* debugging check */
   
   if (end_row>ptr->rows_in_array||num_rows>ptr->maxaccess||ptr->mem_buffer==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: end_row ptr ptr[0].cur_start_row 
//                               ptr[0].cur_start_row 
//                               ptr[0].rows_in_mem start_row
   
   /* Make the desired part of the virtual array accessible */
   
   if (start_row<ptr->cur_start_row||end_row>ptr->cur_start_row+ptr->rows_in_mem) {
//             <    is read   >: ptr ptr[0].b_s_open
      if (!ptr->b_s_open)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_VIRTUAL_BUG, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: ptr ptr[0].dirty
      /* Flush old buffer contents if necessary */
      if (ptr->dirty) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         do_sarray_io(cinfo, ptr, 1);
//             <    is read   >: ptr
//             <    is written>: ptr[0].dirty
         ptr->dirty = 0;
      }
//             <    is read   >: ptr ptr[0].cur_start_row start_row
      /* Decide what part of virtual array to access.
           * Algorithm: if target address > current window, assume forward scan,
           * load starting at target address.  If target address < current window,
           * assume backward scan, load so that target area is top of window.
           * Note that when switching from forward write to forward read, will have
           * start_row = 0, so the limiting case applies and we load from 0 anyway.
           */
      if (start_row>ptr->cur_start_row)
//             <    is read   >: ptr start_row
//             <    is written>: ptr[0].cur_start_row
         ptr->cur_start_row = start_row;
      else {
         /* use long arithmetic here to avoid overflow & unsigned problems */
         long int ltemp;
//             <    is read   >: end_row ptr ptr[0].rows_in_mem
//             <    is written>: ltemp

         ltemp = (long int) end_row-((long int) ptr->rows_in_mem);
//             <    is read   >: ltemp
         if (ltemp<0)
//             <    is written>: ltemp
            ltemp = 0;
//             <    is read   >: ltemp ptr
//             <    is written>: ptr[0].cur_start_row
         /* don't fall off front end of file */
         ptr->cur_start_row = (JDIMENSION) ltemp;
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Read in the selected part of the array.
           * During the initial write pass, we will do no actual read
           * because the selected part is all undefined.
           */
      do_sarray_io(cinfo, ptr, 0);
   }
//             <    is read   >: end_row ptr ptr[0].first_undef_row
   /* Ensure the accessed part of the array is defined; prezero if needed.
      * To improve locality of access, we only prezero the part of the array
      * that the caller is about to access, not the entire in-memory array.
      */
   if (ptr->first_undef_row<end_row) {
//             <    is read   >: ptr ptr[0].first_undef_row start_row
      if (ptr->first_undef_row<start_row) {
//             <    is read   >: writable
         if (writable)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* writer skipped over a section of array */
            cinfo->err->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: start_row
//             <    is written>: undef_row
         undef_row = start_row;
      }
      else
//             <    is read   >: ptr ptr[0].first_undef_row
//             <    is written>: undef_row
         undef_row = ptr->first_undef_row;
//             <    is read   >: writable
      if (writable)
//             <    is read   >: end_row ptr
//             <    is written>: ptr[0].first_undef_row
         ptr->first_undef_row = end_row;
//             <    is read   >: ptr ptr[0].pre_zero
      if (ptr->pre_zero) {
//             <    is read   >: ptr ptr[0].samplesperrow
//             <    is written>: bytesperrow
         size_t bytesperrow = (size_t) ptr->samplesperrow*(size_t) sizeof(JSAMPLE);
//             <    is read   >: ptr ptr[0].cur_start_row undef_row
//             <    is written>: undef_row
         undef_row -= ptr->cur_start_row;
//             <    is read   >: end_row ptr ptr[0].cur_start_row
//             <    is written>: end_row
         /* make indexes relative to buffer */
         end_row -= ptr->cur_start_row;
//             <    is read   >: end_row undef_row
         while (undef_row<end_row) {
//             <may be written>: ptr[0].mem_buffer[undef_row][*]
//             <    is read   >: bytesperrow ptr ptr[0].mem_buffer 
//                               ptr[0].mem_buffer[undef_row] 
//                               undef_row
            jzero_far((void *) (ptr->mem_buffer)[undef_row], bytesperrow);
//             <    is read   >: undef_row
//             <    is written>: undef_row
            undef_row++;
         }
      }
      else if (!writable)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* reader looking at undefined data */
         cinfo->err->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
//             <    is read   >: writable
   /* Flag the buffer dirty if caller will write in it */
   if (writable)
//             <    is read   >: ptr
//             <    is written>: ptr[0].dirty
      ptr->dirty = 1;
//             <    is read   >: ptr ptr[0].cur_start_row 
//                               ptr[0].mem_buffer start_row
   /* Return address of proper part of the buffer */
   return ptr->mem_buffer+(start_row-ptr->cur_start_row);
}
static JBLOCKARRAY alloc_barray(j_common_ptr cinfo, int pool_id, JDIMENSION blocksperrow, JDIMENSION numrows)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   JBLOCKARRAY result;
   JBLOCKROW workspace;
   JDIMENSION rowsperchunk, currow, i;
   long int ltemp;
//             <    is read   >: blocksperrow
//             <    is written>: ltemp
   
   /* Calculate max # of rows allowed in one allocation chunk */
   ltemp = (1000000000L-((size_t) sizeof(large_pool_hdr)))/((long int) blocksperrow*(size_t) sizeof(JBLOCK));
//             <    is read   >: ltemp
   if (ltemp<=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_WIDTH_OVERFLOW, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: ltemp numrows
   if (ltemp<(long int) numrows)
//             <    is read   >: ltemp
//             <    is written>: rowsperchunk
      rowsperchunk = (JDIMENSION) ltemp;
   else
//             <    is read   >: numrows
//             <    is written>: rowsperchunk
      rowsperchunk = numrows;
//             <    is read   >: mem rowsperchunk
//             <    is written>: mem[0].last_rowsperchunk
   mem->last_rowsperchunk = rowsperchunk;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
   
   /* Get space for row pointers (small object) */
   
   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id, (size_t) (numrows*(size_t) sizeof(JBLOCKROW)));
//             <    is written>: currow
   
   /* Get the rows themselves (large objects) */
   currow = 0;
//             <    is read   >: currow numrows
   while (currow<numrows) {
//             <    is read   >: currow numrows rowsperchunk
//             <    is written>: rowsperchunk
      rowsperchunk = rowsperchunk<numrows-currow?rowsperchunk:numrows-currow;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
      workspace = (JBLOCKROW) alloc_large(cinfo, pool_id, (size_t) ((size_t) rowsperchunk*(size_t) blocksperrow*(size_t) sizeof(JBLOCK)));
//             <    is read   >: rowsperchunk
//             <    is written>: i
      for(i = rowsperchunk; i >= 1; i += -1) {
//             <    is read   >: currow result rowsperchunk workspace
//             <    is written>: currow result[currow++]
         result[currow++] = workspace;
//             <    is read   >: blocksperrow rowsperchunk workspace
//             <    is written>: workspace
         workspace += blocksperrow;
      }
   }
//             <    is read   >: result

   return result;
}
static void * alloc_large(j_common_ptr cinfo, int pool_id, size_t sizeofobject)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   large_pool_ptr hdr_ptr;
   size_t odd_bytes;
//             <    is read   >: sizeofobject
   
   /* Check for unsatisfiable request (do now to ensure no overflow below) */
   if (sizeofobject>(size_t) (1000000000L-((size_t) sizeof(large_pool_hdr))))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      out_of_memory(cinfo, 3);
//             <    is read   >: sizeofobject
//             <    is written>: odd_bytes
   /* request exceeds malloc's ability */
   
   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
   odd_bytes = sizeofobject%(size_t) sizeof(double);
//             <    is read   >: odd_bytes
   if (odd_bytes>0)
//             <    is read   >: odd_bytes sizeofobject
//             <    is written>: sizeofobject
      sizeofobject += (size_t) sizeof(double)-odd_bytes;
//             <    is read   >: pool_id
   
   /* Always make a new pool */
   if (pool_id<0||pool_id>=2)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_POOL_ID, (cinfo->err->msg_parm.i)[0] = pool_id, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo sizeofobject 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: hdr_ptr _MALLOC_EFFECTS:_MALLOC_
   /* safety check */
   
   
   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject+(size_t) sizeof(large_pool_hdr));
//             <    is read   >: hdr_ptr
   if (hdr_ptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      out_of_memory(cinfo, 4);
//             <    is read   >: mem mem[0].total_space_allocated 
//                               sizeofobject
//             <    is written>: mem[0].total_space_allocated
   /* jpeg_get_large failed */
   mem->total_space_allocated += sizeofobject+(size_t) sizeof(large_pool_hdr);
//             <    is read   >: hdr_ptr mem 
//                               mem[0].large_list[pool_id] pool_id
//             <    is written>: hdr_ptr[0].hdr.next
   
   /* Success, initialize the new pool header and add to list */
   hdr_ptr->hdr.next = (mem->large_list)[pool_id];
//             <    is read   >: hdr_ptr sizeofobject
//             <    is written>: hdr_ptr[0].hdr.bytes_used
   /* We maintain space counts in each pool header for statistical purposes,
      * even though they are not needed for allocation.
      */
   hdr_ptr->hdr.bytes_used = sizeofobject;
//             <    is read   >: hdr_ptr
//             <    is written>: hdr_ptr[0].hdr.bytes_left
   hdr_ptr->hdr.bytes_left = 0;
//             <    is read   >: hdr_ptr mem pool_id
//             <    is written>: mem[0].large_list[pool_id]
   (mem->large_list)[pool_id] = hdr_ptr;
//             <    is read   >: hdr_ptr
   return (void *) (hdr_ptr+1);
}
static JSAMPARRAY alloc_sarray(j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   JSAMPARRAY result;
   JSAMPROW workspace;
   JDIMENSION rowsperchunk, currow, i;
   long int ltemp;
//             <    is read   >: samplesperrow
//             <    is written>: ltemp
   
   /* Calculate max # of rows allowed in one allocation chunk */
   ltemp = (1000000000L-((size_t) sizeof(large_pool_hdr)))/((long int) samplesperrow*(size_t) sizeof(JSAMPLE));
//             <    is read   >: ltemp
   if (ltemp<=0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_WIDTH_OVERFLOW, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: ltemp numrows
   if (ltemp<(long int) numrows)
//             <    is read   >: ltemp
//             <    is written>: rowsperchunk
      rowsperchunk = (JDIMENSION) ltemp;
   else
//             <    is read   >: numrows
//             <    is written>: rowsperchunk
      rowsperchunk = numrows;
//             <    is read   >: mem rowsperchunk
//             <    is written>: mem[0].last_rowsperchunk
   mem->last_rowsperchunk = rowsperchunk;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
   
   /* Get space for row pointers (small object) */
   
   result = (JSAMPARRAY) alloc_small(cinfo, pool_id, (size_t) (numrows*(size_t) sizeof(JSAMPROW)));
//             <    is written>: currow
   
   /* Get the rows themselves (large objects) */
   currow = 0;
//             <    is read   >: currow numrows
   while (currow<numrows) {
//             <    is read   >: currow numrows rowsperchunk
//             <    is written>: rowsperchunk
      rowsperchunk = rowsperchunk<numrows-currow?rowsperchunk:numrows-currow;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
      workspace = (JSAMPROW) alloc_large(cinfo, pool_id, (size_t) ((size_t) rowsperchunk*(size_t) samplesperrow*(size_t) sizeof(JSAMPLE)));
//             <    is read   >: rowsperchunk
//             <    is written>: i
      for(i = rowsperchunk; i >= 1; i += -1) {
//             <    is read   >: currow result rowsperchunk workspace
//             <    is written>: currow result[currow++]
         result[currow++] = workspace;
//             <    is read   >: rowsperchunk samplesperrow workspace
//             <    is written>: workspace
         workspace += samplesperrow;
      }
   }
//             <    is read   >: result

   return result;
}
static void * alloc_small(j_common_ptr cinfo, int pool_id, size_t sizeofobject)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   small_pool_ptr hdr_ptr, prev_hdr_ptr;
   char *data_ptr;
   size_t odd_bytes, min_request, slop;
//             <    is read   >: sizeofobject
   
   /* Check for unsatisfiable request (do now to ensure no overflow below) */
   if (sizeofobject>(size_t) (1000000000L-((size_t) sizeof(small_pool_hdr))))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      out_of_memory(cinfo, 1);
//             <    is read   >: sizeofobject
//             <    is written>: odd_bytes
   /* request exceeds malloc's ability */
   
   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
   odd_bytes = sizeofobject%(size_t) sizeof(double);
//             <    is read   >: odd_bytes
   if (odd_bytes>0)
//             <    is read   >: odd_bytes sizeofobject
//             <    is written>: sizeofobject
      sizeofobject += (size_t) sizeof(double)-odd_bytes;
//             <    is read   >: pool_id
   
   /* See if space is available in any existing pool */
   if (pool_id<0||pool_id>=2)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_POOL_ID, (cinfo->err->msg_parm.i)[0] = pool_id, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is written>: prev_hdr_ptr
   /* safety check */
   prev_hdr_ptr = (void *) 0;
//             <    is read   >: mem mem[0].small_list[pool_id] 
//                               pool_id
//             <    is written>: hdr_ptr
   hdr_ptr = (mem->small_list)[pool_id];
l99999:   ;
//             <    is read   >: hdr_ptr
   if (!(hdr_ptr!=(void *) 0)) goto _break_1;
//             <    is read   >: hdr_ptr hdr_ptr[0].hdr.bytes_left 
//                               sizeofobject
   if (hdr_ptr->hdr.bytes_left>=sizeofobject) goto _break_1;
//             <    is read   >: hdr_ptr
//             <    is written>: prev_hdr_ptr
   /* found pool with enough space */
   prev_hdr_ptr = hdr_ptr;
//             <    is read   >: hdr_ptr hdr_ptr[0].hdr.next
//             <    is written>: hdr_ptr
   hdr_ptr = hdr_ptr->hdr.next;
   goto l99999;
_break_1:   ;
//             <    is read   >: hdr_ptr
   if (hdr_ptr==(void *) 0) {
//             <    is read   >: sizeofobject
//             <    is written>: min_request
      /* min_request is what we need now, slop is what will be leftover */
      min_request = sizeofobject+(size_t) sizeof(small_pool_hdr);
//             <    is read   >: prev_hdr_ptr
      
      /* Time to make a new pool? */
      if (prev_hdr_ptr==(void *) 0)
//             <    is read   >: pool_id first_pool_slop[pool_id]
//             <    is written>: slop
         /* first pool in class? */
         slop = first_pool_slop[pool_id];
      else
//             <    is read   >: pool_id extra_pool_slop[pool_id]
//             <    is written>: slop
         slop = extra_pool_slop[pool_id];
//             <    is read   >: min_request slop
      /* Don't ask for more than MAX_ALLOC_CHUNK */
      if (slop>(size_t) (1000000000L-min_request))
//             <    is read   >: min_request
//             <    is written>: slop
         slop = (size_t) (1000000000L-min_request);
l99998:      ;
/* Try to get space, if fail reduce slop and try again */
      if (!1) goto _break_2;
//             <    is read   >: cinfo min_request slop 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: hdr_ptr _MALLOC_EFFECTS:_MALLOC_
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request+slop);
//             <    is read   >: hdr_ptr
      if (hdr_ptr!=(void *) 0) goto _break_2;
//             <    is read   >: slop
//             <    is written>: slop
      slop /= 2;
//             <    is read   >: slop
      if (slop<50)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* give up when it gets real small */
         out_of_memory(cinfo, 2);
      goto l99998;
_break_2:      ;
//             <    is read   >: mem mem[0].total_space_allocated 
//                               min_request slop
//             <    is written>: mem[0].total_space_allocated
      mem->total_space_allocated += min_request+slop;
//             <    is read   >: hdr_ptr
//             <    is written>: hdr_ptr[0].hdr.next
      /* Success, initialize the new pool header and add to end of list */
      hdr_ptr->hdr.next = (void *) 0;
//             <    is read   >: hdr_ptr
//             <    is written>: hdr_ptr[0].hdr.bytes_used
      hdr_ptr->hdr.bytes_used = 0;
//             <    is read   >: hdr_ptr sizeofobject slop
//             <    is written>: hdr_ptr[0].hdr.bytes_left
      hdr_ptr->hdr.bytes_left = sizeofobject+slop;
//             <    is read   >: prev_hdr_ptr
      if (prev_hdr_ptr==(void *) 0)
//             <    is read   >: hdr_ptr mem pool_id
//             <    is written>: mem[0].small_list[pool_id]
         /* first pool in class? */
         (mem->small_list)[pool_id] = hdr_ptr;
      else
//             <    is read   >: hdr_ptr prev_hdr_ptr
//             <    is written>: prev_hdr_ptr[0].hdr.next
         prev_hdr_ptr->hdr.next = hdr_ptr;
   }
//             <    is read   >: hdr_ptr
//             <    is written>: data_ptr
   
   /* OK, allocate the object from the current pool */
   data_ptr = (char *) (hdr_ptr+1);
//             <    is read   >: data_ptr hdr_ptr 
//                               hdr_ptr[0].hdr.bytes_used
//             <    is written>: data_ptr
   /* point to first data byte in pool */
   data_ptr += hdr_ptr->hdr.bytes_used;
//             <    is read   >: hdr_ptr hdr_ptr[0].hdr.bytes_used 
//                               sizeofobject
//             <    is written>: hdr_ptr[0].hdr.bytes_used
   /* point to place for object */
   hdr_ptr->hdr.bytes_used += sizeofobject;
//             <    is read   >: hdr_ptr hdr_ptr[0].hdr.bytes_left 
//                               sizeofobject
//             <    is written>: hdr_ptr[0].hdr.bytes_left
   hdr_ptr->hdr.bytes_left -= sizeofobject;
//             <    is read   >: data_ptr

   return (void *) data_ptr;
}
static void do_barray_io(j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
{
   long int bytesperrow, file_offset, byte_count, rows, thisrow, i;
//             <    is read   >: ptr ptr[0].blocksperrow
//             <    is written>: bytesperrow
   bytesperrow = (long int) ptr->blocksperrow*(size_t) sizeof(JBLOCK);
//             <    is read   >: bytesperrow ptr ptr[0].cur_start_row
//             <    is written>: file_offset
   file_offset = ptr->cur_start_row*bytesperrow;
//             <    is written>: i
   i = 0;
l99998:   ;
//             <    is read   >: i ptr ptr[0].rows_in_mem
/* Loop to read or write each allocation chunk in mem_buffer */
   if (!(i<(long int) ptr->rows_in_mem)) goto _break_1;
//             <    is read   >: i ptr ptr[0].rows_in_mem 
//                               ptr[0].rowsperchunk
//             <    is written>: rows
   /* One chunk, but check for short chunk at end of buffer */
   rows = (long int) ptr->rowsperchunk<(long int) ptr->rows_in_mem-i?(long int) ptr->rowsperchunk:(long int) ptr->rows_in_mem-i;
//             <    is read   >: i ptr ptr[0].cur_start_row
//             <    is written>: thisrow
   /* Transfer no more than is currently defined */
   thisrow = (long int) ptr->cur_start_row+i;
//             <    is read   >: ptr ptr[0].first_undef_row rows 
//                               thisrow
//             <    is written>: rows
   rows = rows<(long int) ptr->first_undef_row-thisrow?rows:(long int) ptr->first_undef_row-thisrow;
//             <    is read   >: ptr ptr[0].rows_in_array rows thisrow
//             <    is written>: rows
   /* Transfer no more than fits in file */
   rows = rows<(long int) ptr->rows_in_array-thisrow?rows:(long int) ptr->rows_in_array-thisrow;
//             <    is read   >: rows
   if (rows<=0) goto l99999;
//             <    is read   >: bytesperrow rows
//             <    is written>: byte_count
   byte_count = rows*bytesperrow;
//             <    is read   >: writing
   if (writing)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      (*ptr->b_s_info.write_backing_store)(cinfo,&ptr->b_s_info,(void *) (ptr->mem_buffer)[i],file_offset,byte_count);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      (*ptr->b_s_info.read_backing_store)(cinfo,&ptr->b_s_info,(void *) (ptr->mem_buffer)[i],file_offset,byte_count);
//             <    is read   >: byte_count file_offset
//             <    is written>: file_offset
   file_offset += byte_count;
//             <    is read   >: i ptr ptr[0].rowsperchunk
//             <    is written>: i
   i += ptr->rowsperchunk;
   goto l99998;
l99999:   ;
   /* this chunk might be past end of file! */
   ;
_break_1:   ;
}
static void do_sarray_io(j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
{
   long int bytesperrow, file_offset, byte_count, rows, thisrow, i;
//             <    is read   >: ptr ptr[0].samplesperrow
//             <    is written>: bytesperrow
   bytesperrow = (long int) ptr->samplesperrow*(size_t) sizeof(JSAMPLE);
//             <    is read   >: bytesperrow ptr ptr[0].cur_start_row
//             <    is written>: file_offset
   file_offset = ptr->cur_start_row*bytesperrow;
//             <    is written>: i
   i = 0;
l99998:   ;
//             <    is read   >: i ptr ptr[0].rows_in_mem
/* Loop to read or write each allocation chunk in mem_buffer */
   if (!(i<(long int) ptr->rows_in_mem)) goto _break_1;
//             <    is read   >: i ptr ptr[0].rows_in_mem 
//                               ptr[0].rowsperchunk
//             <    is written>: rows
   /* One chunk, but check for short chunk at end of buffer */
   rows = (long int) ptr->rowsperchunk<(long int) ptr->rows_in_mem-i?(long int) ptr->rowsperchunk:(long int) ptr->rows_in_mem-i;
//             <    is read   >: i ptr ptr[0].cur_start_row
//             <    is written>: thisrow
   /* Transfer no more than is currently defined */
   thisrow = (long int) ptr->cur_start_row+i;
//             <    is read   >: ptr ptr[0].first_undef_row rows 
//                               thisrow
//             <    is written>: rows
   rows = rows<(long int) ptr->first_undef_row-thisrow?rows:(long int) ptr->first_undef_row-thisrow;
//             <    is read   >: ptr ptr[0].rows_in_array rows thisrow
//             <    is written>: rows
   /* Transfer no more than fits in file */
   rows = rows<(long int) ptr->rows_in_array-thisrow?rows:(long int) ptr->rows_in_array-thisrow;
//             <    is read   >: rows
   if (rows<=0) goto l99999;
//             <    is read   >: bytesperrow rows
//             <    is written>: byte_count
   byte_count = rows*bytesperrow;
//             <    is read   >: writing
   if (writing)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      (*ptr->b_s_info.write_backing_store)(cinfo,&ptr->b_s_info,(void *) (ptr->mem_buffer)[i],file_offset,byte_count);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

      (*ptr->b_s_info.read_backing_store)(cinfo,&ptr->b_s_info,(void *) (ptr->mem_buffer)[i],file_offset,byte_count);
//             <    is read   >: byte_count file_offset
//             <    is written>: file_offset
   file_offset += byte_count;
//             <    is read   >: i ptr ptr[0].rowsperchunk
//             <    is written>: i
   i += ptr->rowsperchunk;
   goto l99998;
l99999:   ;
   /* this chunk might be past end of file! */
   ;
_break_1:   ;
}
static void free_pool(j_common_ptr cinfo, int pool_id)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   small_pool_ptr shdr_ptr;
   large_pool_ptr lhdr_ptr;
   size_t space_freed;
//             <    is read   >: pool_id

   if (pool_id<0||pool_id>=2)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_POOL_ID, (cinfo->err->msg_parm.i)[0] = pool_id, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: pool_id
   /* safety check */
   
   
   
   
   
   
   /* If freeing IMAGE pool, close any virtual arrays first */
   if (pool_id==1) {
      jvirt_sarray_ptr sptr;
      jvirt_barray_ptr bptr;
//             <    is read   >: mem mem[0].virt_sarray_list
//             <    is written>: sptr

      sptr = mem->virt_sarray_list;
//             <    is read   >: sptr
      while (sptr!=(void *) 0) {
//             <    is read   >: sptr sptr[0].b_s_open
         if (sptr->b_s_open) {
//             <    is read   >: sptr
//             <    is written>: sptr[0].b_s_open
            /* there may be no backing store */
            sptr->b_s_open = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* prevent recursive close if error */
            (*sptr->b_s_info.close_backing_store)(cinfo,&sptr->b_s_info);
         }
//             <    is read   >: sptr sptr[0].next
//             <    is written>: sptr
         sptr = sptr->next;
      }
//             <    is read   >: mem
//             <    is written>: mem[0].virt_sarray_list
      mem->virt_sarray_list = (void *) 0;
//             <    is read   >: mem mem[0].virt_barray_list
//             <    is written>: bptr
      bptr = mem->virt_barray_list;
//             <    is read   >: bptr
      while (bptr!=(void *) 0) {
//             <    is read   >: bptr bptr[0].b_s_open
         if (bptr->b_s_open) {
//             <    is read   >: bptr
//             <    is written>: bptr[0].b_s_open
            /* there may be no backing store */
            bptr->b_s_open = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            /* prevent recursive close if error */
            (*bptr->b_s_info.close_backing_store)(cinfo,&bptr->b_s_info);
         }
//             <    is read   >: bptr bptr[0].next
//             <    is written>: bptr
         bptr = bptr->next;
      }
//             <    is read   >: mem
//             <    is written>: mem[0].virt_barray_list
      mem->virt_barray_list = (void *) 0;
   }
//             <    is read   >: mem mem[0].large_list[pool_id] 
//                               pool_id
//             <    is written>: lhdr_ptr
   
   /* Release large objects */
   lhdr_ptr = (mem->large_list)[pool_id];
//             <    is read   >: mem pool_id
//             <    is written>: mem[0].large_list[pool_id]
   (mem->large_list)[pool_id] = (void *) 0;
//             <    is read   >: lhdr_ptr
   while (lhdr_ptr!=(void *) 0) {
//             <    is read   >: lhdr_ptr lhdr_ptr[0].hdr.next
//             <    is written>: next_lhdr_ptr
      large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
//             <    is read   >: lhdr_ptr lhdr_ptr[0].hdr.bytes_left 
//                               lhdr_ptr[0].hdr.bytes_used
//             <    is written>: space_freed
      space_freed = lhdr_ptr->hdr.bytes_used+lhdr_ptr->hdr.bytes_left+(size_t) sizeof(large_pool_hdr);
//             <    is read   >: cinfo lhdr_ptr space_freed 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
      jpeg_free_large(cinfo, (void *) lhdr_ptr, space_freed);
//             <    is read   >: mem mem[0].total_space_allocated 
//                               space_freed
//             <    is written>: mem[0].total_space_allocated
      mem->total_space_allocated -= space_freed;
//             <    is read   >: next_lhdr_ptr
//             <    is written>: lhdr_ptr
      lhdr_ptr = next_lhdr_ptr;
   }
//             <    is read   >: mem mem[0].small_list[pool_id] 
//                               pool_id
//             <    is written>: shdr_ptr
   
   /* Release small objects */
   shdr_ptr = (mem->small_list)[pool_id];
//             <    is read   >: mem pool_id
//             <    is written>: mem[0].small_list[pool_id]
   (mem->small_list)[pool_id] = (void *) 0;
//             <    is read   >: shdr_ptr
   while (shdr_ptr!=(void *) 0) {
//             <    is read   >: shdr_ptr shdr_ptr[0].hdr.next
//             <    is written>: next_shdr_ptr
      small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
//             <    is read   >: shdr_ptr shdr_ptr[0].hdr.bytes_left 
//                               shdr_ptr[0].hdr.bytes_used
//             <    is written>: space_freed
      space_freed = shdr_ptr->hdr.bytes_used+shdr_ptr->hdr.bytes_left+(size_t) sizeof(small_pool_hdr);
//             <    is read   >: cinfo shdr_ptr space_freed 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
      jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
//             <    is read   >: mem mem[0].total_space_allocated 
//                               space_freed
//             <    is written>: mem[0].total_space_allocated
      mem->total_space_allocated -= space_freed;
//             <    is read   >: next_shdr_ptr
//             <    is written>: shdr_ptr
      shdr_ptr = next_shdr_ptr;
   }
}
static void out_of_memory(j_common_ptr cinfo, int which)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JERR_OUT_OF_MEMORY, (cinfo->err->msg_parm.i)[0] = which, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
static void realize_virt_arrays(j_common_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   long int space_per_minheight, maximum_space, avail_mem;
   long int minheights, max_minheights;
   jvirt_sarray_ptr sptr;
   jvirt_barray_ptr bptr;
//             <    is written>: space_per_minheight
   
   /* Compute the minimum space needed (maxaccess rows in each buffer)
      * and the maximum space needed (full image height in each buffer).
      * These may be of use to the system-dependent jpeg_mem_available routine.
      */
   space_per_minheight = 0;
//             <    is written>: maximum_space
   maximum_space = 0;
//             <    is read   >: mem mem[0].virt_sarray_list
//             <    is written>: sptr
   sptr = mem->virt_sarray_list;
//             <    is read   >: sptr
   while (sptr!=(void *) 0) {
//             <    is read   >: sptr sptr[0].mem_buffer
      if (sptr->mem_buffer==(void *) 0) {
//             <    is read   >: space_per_minheight sptr 
//                               sptr[0].maxaccess 
//                               sptr[0].samplesperrow
//             <    is written>: space_per_minheight
         /* if not realized yet */
         
         space_per_minheight += (long int) sptr->maxaccess*(long int) sptr->samplesperrow*(size_t) sizeof(JSAMPLE);
//             <    is read   >: maximum_space sptr 
//                               sptr[0].rows_in_array 
//                               sptr[0].samplesperrow
//             <    is written>: maximum_space
         maximum_space += (long int) sptr->rows_in_array*(long int) sptr->samplesperrow*(size_t) sizeof(JSAMPLE);
      }
//             <    is read   >: sptr sptr[0].next
//             <    is written>: sptr
      sptr = sptr->next;
   }
//             <    is read   >: mem mem[0].virt_barray_list
//             <    is written>: bptr
   bptr = mem->virt_barray_list;
//             <    is read   >: bptr
   while (bptr!=(void *) 0) {
//             <    is read   >: bptr bptr[0].mem_buffer
      if (bptr->mem_buffer==(void *) 0) {
//             <    is read   >: bptr bptr[0].blocksperrow 
//                               bptr[0].maxaccess space_per_minheight
//             <    is written>: space_per_minheight
         /* if not realized yet */
         
         space_per_minheight += (long int) bptr->maxaccess*(long int) bptr->blocksperrow*(size_t) sizeof(JBLOCK);
//             <    is read   >: bptr bptr[0].blocksperrow 
//                               bptr[0].rows_in_array maximum_space
//             <    is written>: maximum_space
         maximum_space += (long int) bptr->rows_in_array*(long int) bptr->blocksperrow*(size_t) sizeof(JBLOCK);
      }
//             <    is read   >: bptr bptr[0].next
//             <    is written>: bptr
      bptr = bptr->next;
   }
//             <    is read   >: space_per_minheight

   if (space_per_minheight<=0)
      return;
//             <    is read   >: cinfo maximum_space mem 
//                               mem[0].total_space_allocated 
//                               space_per_minheight
//             <    is written>: avail_mem
   /* no unrealized arrays, no work */
   
   /* Determine amount of memory to actually use; this is system-dependent. */
   
   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space, mem->total_space_allocated);
//             <    is read   >: avail_mem maximum_space
   
   /* If the maximum space needed is available, make all the buffers full
      * height; otherwise parcel it out with the same number of minheights
      * in each buffer.
      */
   if (avail_mem>=maximum_space)
//             <    is written>: max_minheights
      max_minheights = 1000000000L;
   else {
//             <    is read   >: avail_mem space_per_minheight
//             <    is written>: max_minheights
      max_minheights = avail_mem/space_per_minheight;
//             <    is read   >: max_minheights
      /* If there doesn't seem to be enough space, try to get the minimum
           * anyway.  This allows a "stub" implementation of jpeg_mem_available().
           */
      if (max_minheights<=0)
//             <    is written>: max_minheights
         max_minheights = 1;
   }
//             <    is read   >: mem mem[0].virt_sarray_list
//             <    is written>: sptr
   
   /* Allocate the in-memory buffers and initialize backing store as needed. */
   
   sptr = mem->virt_sarray_list;
//             <    is read   >: sptr
   while (sptr!=(void *) 0) {
//             <    is read   >: sptr sptr[0].mem_buffer
      if (sptr->mem_buffer==(void *) 0) {
//             <    is read   >: sptr sptr[0].maxaccess 
//                               sptr[0].rows_in_array
//             <    is written>: minheights
         /* if not realized yet */
         minheights = ((long int) sptr->rows_in_array-1L)/(sptr->maxaccess)+1L;
//             <    is read   >: max_minheights minheights
         if (minheights<=max_minheights)
//             <    is read   >: sptr sptr[0].rows_in_array
//             <    is written>: sptr[0].rows_in_mem
            /* This buffer fits in memory */
            sptr->rows_in_mem = sptr->rows_in_array;
         else {
//             <    is read   >: max_minheights sptr sptr[0].maxaccess
//             <    is written>: sptr[0].rows_in_mem
            /* It doesn't fit in memory, create backing store. */
            sptr->rows_in_mem = (JDIMENSION) (max_minheights*sptr->maxaccess);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            jpeg_open_backing_store(cinfo, &sptr->b_s_info, (long int) sptr->rows_in_array*(long int) sptr->samplesperrow*(long int) (size_t) sizeof(JSAMPLE));
//             <    is read   >: sptr
//             <    is written>: sptr[0].b_s_open
            sptr->b_s_open = 1;
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_

         sptr->mem_buffer = alloc_sarray(cinfo, 1, sptr->samplesperrow, sptr->rows_in_mem);
//             <    is read   >: mem mem[0].last_rowsperchunk sptr
//             <    is written>: sptr[0].rowsperchunk
         sptr->rowsperchunk = mem->last_rowsperchunk;
//             <    is read   >: sptr
//             <    is written>: sptr[0].cur_start_row
         sptr->cur_start_row = 0;
//             <    is read   >: sptr
//             <    is written>: sptr[0].first_undef_row
         sptr->first_undef_row = 0;
//             <    is read   >: sptr
//             <    is written>: sptr[0].dirty
         sptr->dirty = 0;
      }
//             <    is read   >: sptr sptr[0].next
//             <    is written>: sptr
      sptr = sptr->next;
   }
//             <    is read   >: mem mem[0].virt_barray_list
//             <    is written>: bptr

   bptr = mem->virt_barray_list;
//             <    is read   >: bptr
   while (bptr!=(void *) 0) {
//             <    is read   >: bptr bptr[0].mem_buffer
      if (bptr->mem_buffer==(void *) 0) {
//             <    is read   >: bptr bptr[0].maxaccess 
//                               bptr[0].rows_in_array
//             <    is written>: minheights
         /* if not realized yet */
         minheights = ((long int) bptr->rows_in_array-1L)/(bptr->maxaccess)+1L;
//             <    is read   >: max_minheights minheights
         if (minheights<=max_minheights)
//             <    is read   >: bptr bptr[0].rows_in_array
//             <    is written>: bptr[0].rows_in_mem
            /* This buffer fits in memory */
            bptr->rows_in_mem = bptr->rows_in_array;
         else {
//             <    is read   >: bptr bptr[0].maxaccess max_minheights
//             <    is written>: bptr[0].rows_in_mem
            /* It doesn't fit in memory, create backing store. */
            bptr->rows_in_mem = (JDIMENSION) (max_minheights*bptr->maxaccess);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            jpeg_open_backing_store(cinfo, &bptr->b_s_info, (long int) bptr->rows_in_array*(long int) bptr->blocksperrow*(long int) (size_t) sizeof(JBLOCK));
//             <    is read   >: bptr
//             <    is written>: bptr[0].b_s_open
            bptr->b_s_open = 1;
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_

         bptr->mem_buffer = alloc_barray(cinfo, 1, bptr->blocksperrow, bptr->rows_in_mem);
//             <    is read   >: bptr mem mem[0].last_rowsperchunk
//             <    is written>: bptr[0].rowsperchunk
         bptr->rowsperchunk = mem->last_rowsperchunk;
//             <    is read   >: bptr
//             <    is written>: bptr[0].cur_start_row
         bptr->cur_start_row = 0;
//             <    is read   >: bptr
//             <    is written>: bptr[0].first_undef_row
         bptr->first_undef_row = 0;
//             <    is read   >: bptr
//             <    is written>: bptr[0].dirty
         bptr->dirty = 0;
      }
//             <    is read   >: bptr bptr[0].next
//             <    is written>: bptr
      bptr = bptr->next;
   }
}
static jvirt_barray_ptr request_virt_barray(j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   jvirt_barray_ptr result;
//             <    is read   >: pool_id
   
   /* Only IMAGE-lifetime virtual arrays are currently supported */
   if (pool_id!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_POOL_ID, (cinfo->err->msg_parm.i)[0] = pool_id, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
   /* safety check */
   
   /* get control block */
   
   result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id, (size_t) sizeof(struct jvirt_barray_control ));
//             <    is read   >: result
//             <    is written>: result[0].mem_buffer
   result->mem_buffer = (void *) 0;
//             <    is read   >: numrows result
//             <    is written>: result[0].rows_in_array
   /* marks array not yet realized */
   result->rows_in_array = numrows;
//             <    is read   >: blocksperrow result
//             <    is written>: result[0].blocksperrow
   result->blocksperrow = blocksperrow;
//             <    is read   >: maxaccess result
//             <    is written>: result[0].maxaccess
   result->maxaccess = maxaccess;
//             <    is read   >: pre_zero result
//             <    is written>: result[0].pre_zero
   result->pre_zero = pre_zero;
//             <    is read   >: result
//             <    is written>: result[0].b_s_open
   result->b_s_open = 0;
//             <    is read   >: mem mem[0].virt_barray_list result
//             <    is written>: result[0].next
   /* no associated backing-store object */
   result->next = mem->virt_barray_list;
//             <    is read   >: mem result
//             <    is written>: mem[0].virt_barray_list
   /* add to list of virtual arrays */
   mem->virt_barray_list = result;
//             <    is read   >: result

   return result;
}
static jvirt_sarray_ptr request_virt_sarray(j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess)
{
//             <    is read   >: cinfo cinfo[0].mem
//             <    is written>: mem
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   jvirt_sarray_ptr result;
//             <    is read   >: pool_id
   
   /* Only IMAGE-lifetime virtual arrays are currently supported */
   if (pool_id!=1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_POOL_ID, (cinfo->err->msg_parm.i)[0] = pool_id, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
   /* safety check */
   
   /* get control block */
   
   result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id, (size_t) sizeof(struct jvirt_sarray_control ));
//             <    is read   >: result
//             <    is written>: result[0].mem_buffer
   result->mem_buffer = (void *) 0;
//             <    is read   >: numrows result
//             <    is written>: result[0].rows_in_array
   /* marks array not yet realized */
   result->rows_in_array = numrows;
//             <    is read   >: result samplesperrow
//             <    is written>: result[0].samplesperrow
   result->samplesperrow = samplesperrow;
//             <    is read   >: maxaccess result
//             <    is written>: result[0].maxaccess
   result->maxaccess = maxaccess;
//             <    is read   >: pre_zero result
//             <    is written>: result[0].pre_zero
   result->pre_zero = pre_zero;
//             <    is read   >: result
//             <    is written>: result[0].b_s_open
   result->b_s_open = 0;
//             <    is read   >: mem mem[0].virt_sarray_list result
//             <    is written>: result[0].next
   /* no associated backing-store object */
   result->next = mem->virt_sarray_list;
//             <    is read   >: mem result
//             <    is written>: mem[0].virt_sarray_list
   /* add to list of virtual arrays */
   mem->virt_sarray_list = result;
//             <    is read   >: result

   return result;
}
static void self_destruct(j_common_ptr cinfo)
{
   int pool;
//             <    is written>: pool
   
   /* Close all backing store, release all memory.
      * Releasing pools in reverse order might help avoid fragmentation
      * with some (brain-damaged) malloc libraries.
      */
   for(pool = 2-1; pool >= 0; pool += -1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <may be written>: *ANY_MODULE*:*ANYWHERE* 
//                               _MALLOC_EFFECTS:_MALLOC_
      free_pool(cinfo, pool);
//             <    is read   >: cinfo cinfo[0].mem 
//                               _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   
   /* Release the memory manager control block too. */
   jpeg_free_small(cinfo, (void *) cinfo->mem, (size_t) sizeof(my_memory_mgr));
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].mem
   cinfo->mem = (void *) 0;
//             <    is read   >: cinfo
   /* ensures I will be called only once */
   
   jpeg_mem_term(cinfo);
}
void jpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)
{
   int i;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].mem
   
   /* Guard against version mismatches between library and caller. */
   cinfo->mem = (void *) 0;
//             <    is read   >: version
   /* so jpeg_destroy knows mem mgr not called */
   if (version!=61)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_LIB_VERSION, (cinfo->err->msg_parm.i)[0] = 61, (cinfo->err->msg_parm.i)[1] = version, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: structsize
   if (structsize!=(size_t) sizeof(struct jpeg_compress_struct ))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STRUCT_SIZE, (cinfo->err->msg_parm.i)[0] = (int) (size_t) sizeof(struct jpeg_compress_struct ), (cinfo->err->msg_parm.i)[1] = (int) structsize, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: err
      struct jpeg_error_mgr *err = cinfo->err;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      memset((void *) cinfo, 0, (size_t) (size_t) sizeof(struct jpeg_compress_struct ));
//             <    is read   >: cinfo err
//             <    is written>: cinfo[0].err
      cinfo->err = err;
   }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].is_decompressor
   cinfo->is_decompressor = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   
   /* Initialize a memory manager instance for this object */
   jinit_memory_mgr((j_common_ptr) cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].progress
   
   /* Zero out pointers to permanent structures. */
   cinfo->progress = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].dest
   cinfo->dest = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].comp_info
   cinfo->comp_info = (void *) 0;
//             <    is written>: i

   for(i = 0; i <= 3; i += 1)
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].quant_tbl_ptrs[i]
      (cinfo->quant_tbl_ptrs)[i] = (void *) 0;
//             <    is written>: i

   for(i = 0; i <= 3; i += 1) {
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].dc_huff_tbl_ptrs[i]
      (cinfo->dc_huff_tbl_ptrs)[i] = (void *) 0;
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].ac_huff_tbl_ptrs[i]
      (cinfo->ac_huff_tbl_ptrs)[i] = (void *) 0;
   }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].input_gamma

   cinfo->input_gamma = 1.0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   /* in case application forgets */
   
   /* OK, I'm ready */
   cinfo->global_state = 100;
}
void jpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)
{
   int i;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].mem
   
   /* Guard against version mismatches between library and caller. */
   cinfo->mem = (void *) 0;
//             <    is read   >: version
   /* so jpeg_destroy knows mem mgr not called */
   if (version!=61)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_LIB_VERSION, (cinfo->err->msg_parm.i)[0] = 61, (cinfo->err->msg_parm.i)[1] = version, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: structsize
   if (structsize!=(size_t) sizeof(struct jpeg_decompress_struct ))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STRUCT_SIZE, (cinfo->err->msg_parm.i)[0] = (int) (size_t) sizeof(struct jpeg_decompress_struct ), (cinfo->err->msg_parm.i)[1] = (int) structsize, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: err
      struct jpeg_error_mgr *err = cinfo->err;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      memset((void *) cinfo, 0, (size_t) (size_t) sizeof(struct jpeg_decompress_struct ));
//             <    is read   >: cinfo err
//             <    is written>: cinfo[0].err
      cinfo->err = err;
   }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].is_decompressor
   cinfo->is_decompressor = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
//             <    is read   >: _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   
   /* Initialize a memory manager instance for this object */
   jinit_memory_mgr((j_common_ptr) cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].progress
   
   /* Zero out pointers to permanent structures. */
   cinfo->progress = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].src
   cinfo->src = (void *) 0;
//             <    is written>: i

   for(i = 0; i <= 3; i += 1)
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].quant_tbl_ptrs[i]
      (cinfo->quant_tbl_ptrs)[i] = (void *) 0;
//             <    is written>: i

   for(i = 0; i <= 3; i += 1) {
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].dc_huff_tbl_ptrs[i]
      (cinfo->dc_huff_tbl_ptrs)[i] = (void *) 0;
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].ac_huff_tbl_ptrs[i]
      (cinfo->ac_huff_tbl_ptrs)[i] = (void *) 0;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Initialize marker processor so application can override methods
      * for COM, APPn markers before calling jpeg_read_header.
      */
   jinit_marker_reader(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* And initialize the overall input controller. */
   jinit_input_controller(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   
   /* OK, I'm ready */
   cinfo->global_state = 200;
}
void jpeg_abort(j_common_ptr cinfo)
{
   int pool;
//             <    is written>: pool
   
   /* Releasing pools in reverse order might help avoid fragmentation
      * with some (brain-damaged) malloc libraries.
      */
   for(pool = 2-1; pool >= 1; pool += -1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->mem->free_pool)(cinfo,pool);
//             <    is read   >: cinfo cinfo[0].is_decompressor
//             <    is written>: cinfo[0].global_state
   
   /* Reset overall state for possible reuse of object */
   cinfo->global_state = cinfo->is_decompressor?200:100;
}
void jpeg_abort_compress(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   jpeg_abort((j_common_ptr) cinfo);
}
void jpeg_abort_decompress(j_decompress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   jpeg_abort((j_common_ptr) cinfo);
}
void jpeg_add_quant_table(j_compress_ptr cinfo, int which_tbl, const unsigned int *basic_table, int scale_factor, boolean force_baseline)
{
//             <    is read   >: cinfo which_tbl
//             <    is written>: qtblptr
   JQUANT_TBL **qtblptr = &(cinfo->quant_tbl_ptrs)[which_tbl];
   int i;
   long int temp;
//             <    is read   >: cinfo cinfo[0].global_state
   
   /* Safety check to ensure start_compress not called yet. */
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: qtblptr qtblptr[0]
   if (*qtblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      *qtblptr = jpeg_alloc_quant_table((j_common_ptr) cinfo);
//             <    is written>: i

   for(i = 0; i <= 63; i += 1) {
//             <    is read   >: basic_table basic_table[i] i 
//                               scale_factor
//             <    is written>: temp
      temp = ((long int) basic_table[i]*scale_factor+50L)/100L;
//             <    is read   >: temp
      /* limit the values to the valid range */
      if (temp<=0L)
//             <    is written>: temp
         temp = 1L;
//             <    is read   >: temp
      if (temp>32767L)
//             <    is written>: temp
         temp = 32767L;
//             <    is read   >: force_baseline temp
      /* max quantizer needed for 12 bits */
      if (force_baseline&&temp>255L)
//             <    is written>: temp
         temp = 255L;
//             <    is read   >: i qtblptr qtblptr[0] temp
//             <    is written>: qtblptr[0][0].quantval[i]
      /* limit to baseline range if requested */
      ((*qtblptr)->quantval)[i] = (UINT16) temp;
   }
//             <    is read   >: qtblptr qtblptr[0]
//             <    is written>: qtblptr[0][0].sent_table
   
   /* Initialize sent_table FALSE so table will be written to JPEG file. */
   (*qtblptr)->sent_table = 0;
}
JHUFF_TBL * jpeg_alloc_huff_table(j_common_ptr cinfo)
{
   JHUFF_TBL *tbl;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   tbl = (JHUFF_TBL *) (*cinfo->mem->alloc_small)(cinfo,0,(size_t) sizeof(JHUFF_TBL));
//             <    is read   >: tbl
//             <    is written>: tbl[0].sent_table
   tbl->sent_table = 0;
//             <    is read   >: tbl
   /* make sure this is false in any new table */
   return tbl;
}
JQUANT_TBL * jpeg_alloc_quant_table(j_common_ptr cinfo)
{
   JQUANT_TBL *tbl;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   tbl = (JQUANT_TBL *) (*cinfo->mem->alloc_small)(cinfo,0,(size_t) sizeof(JQUANT_TBL));
//             <    is read   >: tbl
//             <    is written>: tbl[0].sent_table
   tbl->sent_table = 0;
//             <    is read   >: tbl
   /* make sure this is false in any new table */
   return tbl;
}
void jpeg_calc_output_dimensions(j_decompress_ptr cinfo)
{
   int ci;
   jpeg_component_info *compptr;
//             <    is read   >: cinfo cinfo[0].global_state
   
   /* Prevent application from calling me at wrong times */
   if (cinfo->global_state!=202)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].scale_denom 
//                               cinfo[0].scale_num
   
   
   
   /* Compute actual output image dimensions and DCT scaling choices. */
   if (cinfo->scale_num*8<=cinfo->scale_denom) {
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: cinfo[0].output_width
      /* Provide 1/8 scaling */
      
      cinfo->output_width = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width, 8L);
//             <    is read   >: cinfo cinfo[0].image_height
//             <    is written>: cinfo[0].output_height

      cinfo->output_height = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, 8L);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].min_DCT_scaled_size
      cinfo->min_DCT_scaled_size = 1;
   }
   else if (cinfo->scale_num*4<=cinfo->scale_denom) {
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: cinfo[0].output_width
      /* Provide 1/4 scaling */
      
      cinfo->output_width = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width, 4L);
//             <    is read   >: cinfo cinfo[0].image_height
//             <    is written>: cinfo[0].output_height

      cinfo->output_height = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, 4L);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].min_DCT_scaled_size
      cinfo->min_DCT_scaled_size = 2;
   }
   else if (cinfo->scale_num*2<=cinfo->scale_denom) {
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: cinfo[0].output_width
      /* Provide 1/2 scaling */
      
      cinfo->output_width = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width, 2L);
//             <    is read   >: cinfo cinfo[0].image_height
//             <    is written>: cinfo[0].output_height

      cinfo->output_height = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height, 2L);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].min_DCT_scaled_size
      cinfo->min_DCT_scaled_size = 4;
   }
   else {
//             <    is read   >: cinfo cinfo[0].image_width
//             <    is written>: cinfo[0].output_width
      /* Provide 1/1 scaling */
      cinfo->output_width = cinfo->image_width;
//             <    is read   >: cinfo cinfo[0].image_height
//             <    is written>: cinfo[0].output_height
      cinfo->output_height = cinfo->image_height;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].min_DCT_scaled_size
      cinfo->min_DCT_scaled_size = 8;
   }
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   /* In selecting the actual DCT scaling for each component, we try to
      * scale up the chroma components via IDCT scaling rather than upsampling.
      * This saves time if the upsampler gets to use 1:1 scaling.
      * Note this code assumes that the supported DCT scalings are powers of 2.
      */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].min_DCT_scaled_size
//             <    is written>: ssize
      int ssize = cinfo->min_DCT_scaled_size;
//             <    is read   >: cinfo cinfo cinfo cinfo 
//                               cinfo[0].max_h_samp_factor 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].min_DCT_scaled_size compptr 
//                               compptr compptr[0].h_samp_factor 
//                               compptr[0].v_samp_factor ssize ssize 
//                               ssize
      while (ssize<8&&compptr->h_samp_factor*ssize*2<=cinfo->max_h_samp_factor*cinfo->min_DCT_scaled_size&&compptr->v_samp_factor*ssize*2<=cinfo->max_v_samp_factor*cinfo->min_DCT_scaled_size)
//             <    is read   >: cinfo cinfo[0].num_components ssize
//             <    is written>: ssize
         ssize = ssize*2;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//                               ssize
//             <    is written>: compptr[0].DCT_scaled_size
      compptr->DCT_scaled_size = ssize;
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].comp_info
//             <    is written>: compptr
   compptr = cinfo->comp_info;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
   
   /* Recompute downsampled dimensions of components;
      * application needs to know these if using raw downsampled data.
      */
   for(ci = 0; ci <= cinfo->num_components-1; ci += 1) {
//             <    is read   >: cinfo cinfo[0].image_width 
//                               cinfo[0].max_h_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].h_samp_factor
//             <    is written>: compptr[0].downsampled_width
      /* Size in samples, after IDCT scaling */
      
      
      compptr->downsampled_width = (JDIMENSION) jdiv_round_up((long int) cinfo->image_width*(long int) (compptr->h_samp_factor*compptr->DCT_scaled_size), (long int) (cinfo->max_h_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].max_v_samp_factor 
//                               cinfo[0].num_components compptr 
//                               compptr[0].DCT_scaled_size 
//                               compptr[0].v_samp_factor
//             <    is written>: compptr[0].downsampled_height
      compptr->downsampled_height = (JDIMENSION) jdiv_round_up((long int) cinfo->image_height*(long int) (compptr->v_samp_factor*compptr->DCT_scaled_size), (long int) (cinfo->max_v_samp_factor*8));
//             <    is read   >: cinfo cinfo[0].num_components compptr
//             <    is written>: compptr
      compptr++;
   }
//             <    is read   >: cinfo cinfo[0].out_color_space
/* Report number of components in selected colorspace. */
/* Probably this should be in the color conversion module... */
   if (cinfo->out_color_space==JCS_GRAYSCALE) goto _switch_4_case_JCS_GRAYSCALE;
//             <    is read   >: cinfo cinfo[0].out_color_space
   if (cinfo->out_color_space==JCS_RGB) goto _switch_4_case_JCS_RGB;
//             <    is read   >: cinfo cinfo[0].out_color_space
   if (cinfo->out_color_space==JCS_YCbCr) goto _switch_4_case_JCS_YCbCr;
//             <    is read   >: cinfo cinfo[0].out_color_space
   if (cinfo->out_color_space==JCS_CMYK) goto _switch_4_case_JCS_CMYK;
//             <    is read   >: cinfo cinfo[0].out_color_space
   if (cinfo->out_color_space==JCS_YCCK) goto _switch_4_case_JCS_YCCK;
_switch_4_default:   ;
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: cinfo[0].out_color_components
   /* else must be same colorspace as in file */
   cinfo->out_color_components = cinfo->num_components;
   goto _break_4;
_switch_4_case_JCS_YCCK:   ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_components
   cinfo->out_color_components = 4;
   goto _break_4;
_switch_4_case_JCS_CMYK:   ;
   goto _switch_4_case_JCS_YCCK;
   
   
   
   
_switch_4_case_JCS_YCbCr:   ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_components
   cinfo->out_color_components = 3;
   goto _break_4;
_switch_4_case_JCS_RGB:   ;
   goto _switch_4_case_JCS_YCbCr;
_switch_4_case_JCS_GRAYSCALE:   ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].out_color_components
   cinfo->out_color_components = 1;
_break_4:   ;
//             <may be read   >: cinfo[0].out_color_components
//             <    is read   >: cinfo cinfo[0].quantize_colors
//             <    is written>: cinfo[0].output_components
   cinfo->output_components = cinfo->quantize_colors?1:cinfo->out_color_components;
//             <    is read   >: cinfo cinfo[0].CCIR601_sampling 
//                               cinfo[0].comp_info 
//                               cinfo[0].comp_info[0].DCT_scaled_size
//                               cinfo[0].comp_info[0].h_samp_factor 
//                               cinfo[0].comp_info[0].v_samp_factor 
//                               cinfo[0].comp_info[1].DCT_scaled_size
//                               cinfo[0].comp_info[1].h_samp_factor 
//                               cinfo[0].comp_info[1].v_samp_factor 
//                               cinfo[0].comp_info[2].DCT_scaled_size
//                               cinfo[0].comp_info[2].h_samp_factor 
//                               cinfo[0].comp_info[2].v_samp_factor 
//                               cinfo[0].do_fancy_upsampling 
//                               cinfo[0].jpeg_color_space 
//                               cinfo[0].min_DCT_scaled_size 
//                               cinfo[0].num_components 
//                               cinfo[0].out_color_components 
//                               cinfo[0].out_color_space
   
   /* See if upsampler will want to emit more than one row at a time */
   if (use_merged_upsample(cinfo))
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor
//             <    is written>: cinfo[0].rec_outbuf_height
      cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
   else
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].rec_outbuf_height
      cinfo->rec_outbuf_height = 1;
}
int jpeg_consume_input(j_decompress_ptr cinfo)
{
//             <    is written>: retcode
   int retcode = 0;
//             <    is read   >: cinfo cinfo[0].global_state

/* NB: every possible DSTATE value should be listed in this switch */
   if (cinfo->global_state==200) goto _switch_1_case_200;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==201) goto _switch_1_case_201;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==202) goto _switch_1_case_202;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==203) goto _switch_1_case_203;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==204) goto _switch_1_case_204;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==205) goto _switch_1_case_205;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==206) goto _switch_1_case_206;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==207) goto _switch_1_case_207;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==208) goto _switch_1_case_208;
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==210) goto _switch_1_case_210;
_switch_1_default:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   goto _break_1;
_switch_1_case_210:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   retcode = (*cinfo->inputctl->consume_input)(cinfo);
   goto _break_1;
_switch_1_case_208:   ;
   goto _switch_1_case_210;
_switch_1_case_207:   ;
   goto _switch_1_case_208;
_switch_1_case_206:   ;
   goto _switch_1_case_207;
_switch_1_case_205:   ;
   goto _switch_1_case_206;
_switch_1_case_204:   ;
   goto _switch_1_case_205;
_switch_1_case_203:   ;
   goto _switch_1_case_204;
_switch_1_case_202:   ;
//             <    is written>: retcode
   /* Can't advance past first SOS until start_decompress is called */
   retcode = 1;
   goto _break_1;
   /*FALLTHROUGH*/
_switch_1_case_201:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   retcode = (*cinfo->inputctl->consume_input)(cinfo);
//             <    is read   >: retcode
   if (retcode==1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      /* Set global state: ready for start_decompress */
      cinfo->global_state = 202;
   }
   goto _break_1;
_switch_1_case_200:   ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Start-of-datastream actions: reset appropriate modules */
   (*cinfo->inputctl->reset_input_controller)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Initialize application's data source module */
   (*cinfo->src->init_source)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   cinfo->global_state = 201;
   goto _switch_1_case_201;
_break_1:   ;
//             <    is read   >: retcode
   return retcode;
}
void jpeg_copy_critical_parameters(j_decompress_ptr srcinfo, j_compress_ptr dstinfo)
{
   JQUANT_TBL **qtblptr;
   jpeg_component_info *incomp, *outcomp;
   JQUANT_TBL *c_quant, *slot_quant;
   int tblno, ci, coefi;
//             <    is read   >: dstinfo dstinfo[0].global_state
   
   /* Safety check to ensure start_compress not called yet. */
   if (dstinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      dstinfo->err->msg_code = JERR_BAD_STATE, (dstinfo->err->msg_parm.i)[0] = dstinfo->global_state, (*dstinfo->err->error_exit)((j_common_ptr) dstinfo);
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].image_width
//             <    is written>: dstinfo[0].image_width
   /* Copy fundamental image dimensions */
   dstinfo->image_width = srcinfo->image_width;
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].image_height
//             <    is written>: dstinfo[0].image_height
   dstinfo->image_height = srcinfo->image_height;
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].num_components
//             <    is written>: dstinfo[0].input_components
   dstinfo->input_components = srcinfo->num_components;
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].jpeg_color_space
//             <    is written>: dstinfo[0].in_color_space
   dstinfo->in_color_space = srcinfo->jpeg_color_space;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Initialize all parameters to default values */
   jpeg_set_defaults(dstinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* jpeg_set_defaults may choose wrong colorspace, eg YCbCr if input is RGB.
      * Fix it to get the right header markers for the image colorspace.
      */
   jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].data_precision
//             <    is written>: dstinfo[0].data_precision
   dstinfo->data_precision = srcinfo->data_precision;
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].CCIR601_sampling
//             <    is written>: dstinfo[0].CCIR601_sampling
   dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;
//             <    is written>: tblno
   /* Copy the source's quantization tables. */
   for(tblno = 0; tblno <= 3; tblno += 1)
//             <    is read   >: srcinfo 
//                               srcinfo[0].quant_tbl_ptrs[tblno] 
//                               tblno
      if ((srcinfo->quant_tbl_ptrs)[tblno]!=(void *) 0) {
//             <    is read   >: dstinfo tblno
//             <    is written>: qtblptr
         qtblptr = &(dstinfo->quant_tbl_ptrs)[tblno];
//             <    is read   >: qtblptr qtblptr[0]
         if (*qtblptr==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            *qtblptr = jpeg_alloc_quant_table((j_common_ptr) dstinfo);
//             <may be read   >: 
//                               srcinfo[0].quant_tbl_ptrs[tblno][0].q
//                               uantval[*]
//             <may be written>: qtblptr[0][0].quantval[*]
//             <    is read   >: qtblptr qtblptr[0] srcinfo 
//                               srcinfo[0].quant_tbl_ptrs[tblno] 
//                               tblno

         memcpy((void *) (*qtblptr)->quantval, (void *) (srcinfo->quant_tbl_ptrs)[tblno]->quantval, (size_t) (size_t) sizeof((*qtblptr)->quantval));
//             <    is read   >: qtblptr qtblptr[0]
//             <    is written>: qtblptr[0][0].sent_table
         (*qtblptr)->sent_table = 0;
      }
//             <    is read   >: dstinfo srcinfo 
//                               srcinfo[0].num_components
//             <    is written>: dstinfo[0].num_components
   /* Copy the source's per-component info.
      * Note we assume jpeg_set_defaults has allocated the dest comp_info array.
      */
   dstinfo->num_components = srcinfo->num_components;
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               dstinfo[0].num_components
   if (dstinfo->num_components<1||dstinfo->num_components>10)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      dstinfo->err->msg_code = JERR_COMPONENT_COUNT, (dstinfo->err->msg_parm.i)[0] = dstinfo->num_components, (dstinfo->err->msg_parm.i)[1] = 10, (*dstinfo->err->error_exit)((j_common_ptr) dstinfo);
//             <    is read   >: srcinfo srcinfo[0].comp_info
//             <    is written>: incomp
   incomp = srcinfo->comp_info;
//             <    is read   >: dstinfo dstinfo[0].num_components
//             <    is written>: ci
   for(ci = 0; ci <= dstinfo->num_components-1; ci += 1) {
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               incomp incomp[0].component_id outcomp
//             <    is written>: outcomp[0].component_id
      outcomp->component_id = incomp->component_id;
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               incomp incomp[0].h_samp_factor 
//                               outcomp
//             <    is written>: outcomp[0].h_samp_factor
      outcomp->h_samp_factor = incomp->h_samp_factor;
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               incomp incomp[0].v_samp_factor 
//                               outcomp
//             <    is written>: outcomp[0].v_samp_factor
      outcomp->v_samp_factor = incomp->v_samp_factor;
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               incomp incomp[0].quant_tbl_no outcomp
//             <    is written>: outcomp[0].quant_tbl_no
      outcomp->quant_tbl_no = incomp->quant_tbl_no;
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               outcomp outcomp[0].quant_tbl_no
//             <    is written>: tblno
      /* Make sure saved quantization table for component matches the qtable
           * slot.  If not, the input file re-used this qtable slot.
           * IJG encoder currently cannot duplicate this.
           */
      tblno = outcomp->quant_tbl_no;
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               srcinfo 
//                               srcinfo[0].quant_tbl_ptrs[tblno] 
//                               tblno
      if (tblno<0||tblno>=4||(srcinfo->quant_tbl_ptrs)[tblno]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         dstinfo->err->msg_code = JERR_NO_QUANT_TABLE, (dstinfo->err->msg_parm.i)[0] = tblno, (*dstinfo->err->error_exit)((j_common_ptr) dstinfo);
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               srcinfo 
//                               srcinfo[0].quant_tbl_ptrs[tblno] 
//                               tblno
//             <    is written>: slot_quant
      slot_quant = (srcinfo->quant_tbl_ptrs)[tblno];
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               incomp incomp[0].quant_table
//             <    is written>: c_quant
      c_quant = incomp->quant_table;
//             <    is read   >: c_quant dstinfo 
//                               dstinfo[0].num_components
      if (c_quant!=(void *) 0)
//             <    is read   >: dstinfo dstinfo[0].num_components
//             <    is written>: coefi
         for(coefi = 0; coefi <= 63; coefi += 1)
//             <    is read   >: c_quant c_quant[0].quantval[coefi] 
//                               coefi dstinfo 
//                               dstinfo[0].num_components slot_quant 
//                               slot_quant[0].quantval[coefi]
            if ((c_quant->quantval)[coefi]!=(slot_quant->quantval)[coefi])
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
               dstinfo->err->msg_code = JERR_MISMATCHED_QUANT_TABLE, (dstinfo->err->msg_parm.i)[0] = tblno, (*dstinfo->err->error_exit)((j_common_ptr) dstinfo);
//             <    is read   >: dstinfo dstinfo[0].num_components 
//                               incomp
//             <    is written>: incomp
      incomp++;
   }
}
void jpeg_default_colorspace(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].in_color_space
   if (cinfo->in_color_space==JCS_GRAYSCALE) {
_switch_1_case_JCS_GRAYSCALE:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
   }
   else if (cinfo->in_color_space==JCS_RGB) {
_switch_1_case_JCS_RGB:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jpeg_set_colorspace(cinfo, JCS_YCbCr);
   }
   else if (cinfo->in_color_space==JCS_YCbCr) {
_switch_1_case_JCS_YCbCr:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jpeg_set_colorspace(cinfo, JCS_YCbCr);
   }
   else if (cinfo->in_color_space==JCS_CMYK) {
_switch_1_case_JCS_CMYK:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jpeg_set_colorspace(cinfo, JCS_CMYK);
      /* By default, no translation */
      ;
   }
   else if (cinfo->in_color_space==JCS_YCCK) {
_switch_1_case_JCS_YCCK:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jpeg_set_colorspace(cinfo, JCS_YCCK);
   }
   else if (cinfo->in_color_space==JCS_UNKNOWN) {
_switch_1_case_JCS_UNKNOWN:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
   }
   else {
_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_IN_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
}
void jpeg_destroy(j_common_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].mem
   /* We need only tell the memory manager to release everything. */
   /* NB: mem pointer is NULL if memory mgr failed to initialize. */
   if (cinfo->mem!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->mem->self_destruct)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].mem
   cinfo->mem = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   /* be safe if jpeg_destroy is called twice */
   cinfo->global_state = 0;
}
void jpeg_destroy_compress(j_compress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   jpeg_destroy((j_common_ptr) cinfo);
}
void jpeg_destroy_decompress(j_decompress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   jpeg_destroy((j_common_ptr) cinfo);
}
void jpeg_fdct_float(float *data)
{
   float tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   float tmp10, tmp11, tmp12, tmp13;
   float z1, z2, z3, z4, z5, z11, z13;
   float *dataptr;
   int ctr;
//             <    is read   >: data
//             <    is written>: dataptr
   
   /* Pass 1: process rows. */
   
   dataptr = data;
//             <    is written>: ctr
   for(ctr = 8-1; ctr >= 0; ctr += -1) {
//             <    is read   >: dataptr dataptr[0] dataptr[7]
//             <    is written>: tmp0
      tmp0 = dataptr[0]+dataptr[7];
//             <    is read   >: dataptr dataptr[0] dataptr[7]
//             <    is written>: tmp7
      tmp7 = dataptr[0]-dataptr[7];
//             <    is read   >: dataptr dataptr[1] dataptr[6]
//             <    is written>: tmp1
      tmp1 = dataptr[1]+dataptr[6];
//             <    is read   >: dataptr dataptr[1] dataptr[6]
//             <    is written>: tmp6
      tmp6 = dataptr[1]-dataptr[6];
//             <    is read   >: dataptr dataptr[2] dataptr[5]
//             <    is written>: tmp2
      tmp2 = dataptr[2]+dataptr[5];
//             <    is read   >: dataptr dataptr[2] dataptr[5]
//             <    is written>: tmp5
      tmp5 = dataptr[2]-dataptr[5];
//             <    is read   >: dataptr dataptr[3] dataptr[4]
//             <    is written>: tmp3
      tmp3 = dataptr[3]+dataptr[4];
//             <    is read   >: dataptr dataptr[3] dataptr[4]
//             <    is written>: tmp4
      tmp4 = dataptr[3]-dataptr[4];
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10
      
      /* Even part */
      
      tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
      /* phase 2 */
      tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
      tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
      tmp12 = tmp1-tmp2;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[0]

      dataptr[0] = tmp10+tmp11;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[4]
      /* phase 3 */
      dataptr[4] = tmp10-tmp11;
//             <    is read   >: tmp12 tmp13
//             <    is written>: z1
      z1 = (tmp12+tmp13)*(float) 0.707106781;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[2]
      /* c4 */
      dataptr[2] = tmp13+z1;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[6]
      /* phase 5 */
      dataptr[6] = tmp13-z1;
//             <    is read   >: tmp4 tmp5
//             <    is written>: tmp10
      
      /* Odd part */
      
      tmp10 = tmp4+tmp5;
//             <    is read   >: tmp5 tmp6
//             <    is written>: tmp11
      /* phase 2 */
      tmp11 = tmp5+tmp6;
//             <    is read   >: tmp6 tmp7
//             <    is written>: tmp12
      tmp12 = tmp6+tmp7;
//             <    is read   >: tmp10 tmp12
//             <    is written>: z5
      
      /* The rotator is modified from fig 4-8 to avoid extra negations. */
      z5 = (tmp10-tmp12)*(float) 0.382683433;
//             <    is read   >: tmp10 z5
//             <    is written>: z2
      /* c6 */
      z2 = (float) 0.541196100*tmp10+z5;
//             <    is read   >: tmp12 z5
//             <    is written>: z4
      /* c2-c6 */
      z4 = (float) 1.306562965*tmp12+z5;
//             <    is read   >: tmp11
//             <    is written>: z3
      /* c2+c6 */
      z3 = tmp11*(float) 0.707106781;
//             <    is read   >: tmp7 z3
//             <    is written>: z11
      /* c4 */
      
      z11 = tmp7+z3;
//             <    is read   >: tmp7 z3
//             <    is written>: z13
      /* phase 5 */
      z13 = tmp7-z3;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[5]

      dataptr[5] = z13+z2;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[3]
      /* phase 6 */
      dataptr[3] = z13-z2;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[1]
      dataptr[1] = z11+z4;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[7]
      dataptr[7] = z11-z4;
//             <    is read   >: dataptr
//             <    is written>: dataptr

      dataptr += 8;
   }
//             <    is read   >: data
//             <    is written>: dataptr
   
   /* Pass 2: process columns. */
   
   dataptr = data;
//             <    is written>: ctr
   for(ctr = 8-1; ctr >= 0; ctr += -1) {
//             <    is read   >: dataptr dataptr[8*0] dataptr[8*7]
//             <    is written>: tmp0
      tmp0 = dataptr[8*0]+dataptr[8*7];
//             <    is read   >: dataptr dataptr[8*0] dataptr[8*7]
//             <    is written>: tmp7
      tmp7 = dataptr[8*0]-dataptr[8*7];
//             <    is read   >: dataptr dataptr[8*1] dataptr[8*6]
//             <    is written>: tmp1
      tmp1 = dataptr[8*1]+dataptr[8*6];
//             <    is read   >: dataptr dataptr[8*1] dataptr[8*6]
//             <    is written>: tmp6
      tmp6 = dataptr[8*1]-dataptr[8*6];
//             <    is read   >: dataptr dataptr[8*2] dataptr[8*5]
//             <    is written>: tmp2
      tmp2 = dataptr[8*2]+dataptr[8*5];
//             <    is read   >: dataptr dataptr[8*2] dataptr[8*5]
//             <    is written>: tmp5
      tmp5 = dataptr[8*2]-dataptr[8*5];
//             <    is read   >: dataptr dataptr[8*3] dataptr[8*4]
//             <    is written>: tmp3
      tmp3 = dataptr[8*3]+dataptr[8*4];
//             <    is read   >: dataptr dataptr[8*3] dataptr[8*4]
//             <    is written>: tmp4
      tmp4 = dataptr[8*3]-dataptr[8*4];
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10
      
      /* Even part */
      
      tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
      /* phase 2 */
      tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
      tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
      tmp12 = tmp1-tmp2;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[8*0]

      dataptr[8*0] = tmp10+tmp11;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[8*4]
      /* phase 3 */
      dataptr[8*4] = tmp10-tmp11;
//             <    is read   >: tmp12 tmp13
//             <    is written>: z1
      z1 = (tmp12+tmp13)*(float) 0.707106781;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[8*2]
      /* c4 */
      dataptr[8*2] = tmp13+z1;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[8*6]
      /* phase 5 */
      dataptr[8*6] = tmp13-z1;
//             <    is read   >: tmp4 tmp5
//             <    is written>: tmp10
      
      /* Odd part */
      
      tmp10 = tmp4+tmp5;
//             <    is read   >: tmp5 tmp6
//             <    is written>: tmp11
      /* phase 2 */
      tmp11 = tmp5+tmp6;
//             <    is read   >: tmp6 tmp7
//             <    is written>: tmp12
      tmp12 = tmp6+tmp7;
//             <    is read   >: tmp10 tmp12
//             <    is written>: z5
      
      /* The rotator is modified from fig 4-8 to avoid extra negations. */
      z5 = (tmp10-tmp12)*(float) 0.382683433;
//             <    is read   >: tmp10 z5
//             <    is written>: z2
      /* c6 */
      z2 = (float) 0.541196100*tmp10+z5;
//             <    is read   >: tmp12 z5
//             <    is written>: z4
      /* c2-c6 */
      z4 = (float) 1.306562965*tmp12+z5;
//             <    is read   >: tmp11
//             <    is written>: z3
      /* c2+c6 */
      z3 = tmp11*(float) 0.707106781;
//             <    is read   >: tmp7 z3
//             <    is written>: z11
      /* c4 */
      
      z11 = tmp7+z3;
//             <    is read   >: tmp7 z3
//             <    is written>: z13
      /* phase 5 */
      z13 = tmp7-z3;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[8*5]

      dataptr[8*5] = z13+z2;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[8*3]
      /* phase 6 */
      dataptr[8*3] = z13-z2;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[8*1]
      dataptr[8*1] = z11+z4;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[8*7]
      dataptr[8*7] = z11-z4;
//             <    is read   >: dataptr
//             <    is written>: dataptr

      dataptr++;
   }
}
void jpeg_fdct_ifast(DCTELEM *data)
{
   DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   DCTELEM tmp10, tmp11, tmp12, tmp13;
   DCTELEM z1, z2, z3, z4, z5, z11, z13;
   DCTELEM *dataptr;
   int ctr;
//             <    is read   >: data
//             <    is written>: dataptr
   
   
   /* Pass 1: process rows. */
   
   dataptr = data;
//             <    is written>: ctr
   for(ctr = 8-1; ctr >= 0; ctr += -1) {
//             <    is read   >: dataptr dataptr[0] dataptr[7]
//             <    is written>: tmp0
      tmp0 = dataptr[0]+dataptr[7];
//             <    is read   >: dataptr dataptr[0] dataptr[7]
//             <    is written>: tmp7
      tmp7 = dataptr[0]-dataptr[7];
//             <    is read   >: dataptr dataptr[1] dataptr[6]
//             <    is written>: tmp1
      tmp1 = dataptr[1]+dataptr[6];
//             <    is read   >: dataptr dataptr[1] dataptr[6]
//             <    is written>: tmp6
      tmp6 = dataptr[1]-dataptr[6];
//             <    is read   >: dataptr dataptr[2] dataptr[5]
//             <    is written>: tmp2
      tmp2 = dataptr[2]+dataptr[5];
//             <    is read   >: dataptr dataptr[2] dataptr[5]
//             <    is written>: tmp5
      tmp5 = dataptr[2]-dataptr[5];
//             <    is read   >: dataptr dataptr[3] dataptr[4]
//             <    is written>: tmp3
      tmp3 = dataptr[3]+dataptr[4];
//             <    is read   >: dataptr dataptr[3] dataptr[4]
//             <    is written>: tmp4
      tmp4 = dataptr[3]-dataptr[4];
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10
      
      /* Even part */
      
      tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
      /* phase 2 */
      tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
      tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
      tmp12 = tmp1-tmp2;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[0]

      dataptr[0] = tmp10+tmp11;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[4]
      /* phase 3 */
      dataptr[4] = tmp10-tmp11;
//             <    is read   >: tmp12 tmp13
//             <    is written>: z1
      z1 = (DCTELEM) ((tmp12+tmp13)*(INT32) 181>>8);
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[2]
      /* c4 */
      dataptr[2] = tmp13+z1;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[6]
      /* phase 5 */
      dataptr[6] = tmp13-z1;
//             <    is read   >: tmp4 tmp5
//             <    is written>: tmp10
      
      /* Odd part */
      
      tmp10 = tmp4+tmp5;
//             <    is read   >: tmp5 tmp6
//             <    is written>: tmp11
      /* phase 2 */
      tmp11 = tmp5+tmp6;
//             <    is read   >: tmp6 tmp7
//             <    is written>: tmp12
      tmp12 = tmp6+tmp7;
//             <    is read   >: tmp10 tmp12
//             <    is written>: z5
      
      /* The rotator is modified from fig 4-8 to avoid extra negations. */
      z5 = (DCTELEM) ((tmp10-tmp12)*(INT32) 98>>8);
//             <    is read   >: tmp10 z5
//             <    is written>: z2
      /* c6 */
      z2 = (DCTELEM) (tmp10*(INT32) 139>>8)+z5;
//             <    is read   >: tmp12 z5
//             <    is written>: z4
      /* c2-c6 */
      z4 = (DCTELEM) (tmp12*(INT32) 334>>8)+z5;
//             <    is read   >: tmp11
//             <    is written>: z3
      /* c2+c6 */
      z3 = (DCTELEM) (tmp11*(INT32) 181>>8);
//             <    is read   >: tmp7 z3
//             <    is written>: z11
      /* c4 */
      
      z11 = tmp7+z3;
//             <    is read   >: tmp7 z3
//             <    is written>: z13
      /* phase 5 */
      z13 = tmp7-z3;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[5]

      dataptr[5] = z13+z2;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[3]
      /* phase 6 */
      dataptr[3] = z13-z2;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[1]
      dataptr[1] = z11+z4;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[7]
      dataptr[7] = z11-z4;
//             <    is read   >: dataptr
//             <    is written>: dataptr

      dataptr += 8;
   }
//             <    is read   >: data
//             <    is written>: dataptr
   
   /* Pass 2: process columns. */
   
   dataptr = data;
//             <    is written>: ctr
   for(ctr = 8-1; ctr >= 0; ctr += -1) {
//             <    is read   >: dataptr dataptr[8*0] dataptr[8*7]
//             <    is written>: tmp0
      tmp0 = dataptr[8*0]+dataptr[8*7];
//             <    is read   >: dataptr dataptr[8*0] dataptr[8*7]
//             <    is written>: tmp7
      tmp7 = dataptr[8*0]-dataptr[8*7];
//             <    is read   >: dataptr dataptr[8*1] dataptr[8*6]
//             <    is written>: tmp1
      tmp1 = dataptr[8*1]+dataptr[8*6];
//             <    is read   >: dataptr dataptr[8*1] dataptr[8*6]
//             <    is written>: tmp6
      tmp6 = dataptr[8*1]-dataptr[8*6];
//             <    is read   >: dataptr dataptr[8*2] dataptr[8*5]
//             <    is written>: tmp2
      tmp2 = dataptr[8*2]+dataptr[8*5];
//             <    is read   >: dataptr dataptr[8*2] dataptr[8*5]
//             <    is written>: tmp5
      tmp5 = dataptr[8*2]-dataptr[8*5];
//             <    is read   >: dataptr dataptr[8*3] dataptr[8*4]
//             <    is written>: tmp3
      tmp3 = dataptr[8*3]+dataptr[8*4];
//             <    is read   >: dataptr dataptr[8*3] dataptr[8*4]
//             <    is written>: tmp4
      tmp4 = dataptr[8*3]-dataptr[8*4];
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10
      
      /* Even part */
      
      tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
      /* phase 2 */
      tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
      tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
      tmp12 = tmp1-tmp2;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[8*0]

      dataptr[8*0] = tmp10+tmp11;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[8*4]
      /* phase 3 */
      dataptr[8*4] = tmp10-tmp11;
//             <    is read   >: tmp12 tmp13
//             <    is written>: z1
      z1 = (DCTELEM) ((tmp12+tmp13)*(INT32) 181>>8);
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[8*2]
      /* c4 */
      dataptr[8*2] = tmp13+z1;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[8*6]
      /* phase 5 */
      dataptr[8*6] = tmp13-z1;
//             <    is read   >: tmp4 tmp5
//             <    is written>: tmp10
      
      /* Odd part */
      
      tmp10 = tmp4+tmp5;
//             <    is read   >: tmp5 tmp6
//             <    is written>: tmp11
      /* phase 2 */
      tmp11 = tmp5+tmp6;
//             <    is read   >: tmp6 tmp7
//             <    is written>: tmp12
      tmp12 = tmp6+tmp7;
//             <    is read   >: tmp10 tmp12
//             <    is written>: z5
      
      /* The rotator is modified from fig 4-8 to avoid extra negations. */
      z5 = (DCTELEM) ((tmp10-tmp12)*(INT32) 98>>8);
//             <    is read   >: tmp10 z5
//             <    is written>: z2
      /* c6 */
      z2 = (DCTELEM) (tmp10*(INT32) 139>>8)+z5;
//             <    is read   >: tmp12 z5
//             <    is written>: z4
      /* c2-c6 */
      z4 = (DCTELEM) (tmp12*(INT32) 334>>8)+z5;
//             <    is read   >: tmp11
//             <    is written>: z3
      /* c2+c6 */
      z3 = (DCTELEM) (tmp11*(INT32) 181>>8);
//             <    is read   >: tmp7 z3
//             <    is written>: z11
      /* c4 */
      
      z11 = tmp7+z3;
//             <    is read   >: tmp7 z3
//             <    is written>: z13
      /* phase 5 */
      z13 = tmp7-z3;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[8*5]

      dataptr[8*5] = z13+z2;
//             <    is read   >: dataptr z13 z2
//             <    is written>: dataptr[8*3]
      /* phase 6 */
      dataptr[8*3] = z13-z2;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[8*1]
      dataptr[8*1] = z11+z4;
//             <    is read   >: dataptr z11 z4
//             <    is written>: dataptr[8*7]
      dataptr[8*7] = z11-z4;
//             <    is read   >: dataptr
//             <    is written>: dataptr

      dataptr++;
   }
}
void jpeg_fdct_islow(DCTELEM *data)
{
   INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   INT32 tmp10, tmp11, tmp12, tmp13;
   INT32 z1, z2, z3, z4, z5;
   DCTELEM *dataptr;
   int ctr;
//             <    is read   >: data
//             <    is written>: dataptr
   
   
   /* Pass 1: process rows. */
   /* Note results are scaled up by sqrt(8) compared to a true DCT; */
   /* furthermore, we scale the results by 2**PASS1_BITS. */
   
   dataptr = data;
//             <    is written>: ctr
   for(ctr = 8-1; ctr >= 0; ctr += -1) {
//             <    is read   >: dataptr dataptr[0] dataptr[7]
//             <    is written>: tmp0
      tmp0 = dataptr[0]+dataptr[7];
//             <    is read   >: dataptr dataptr[0] dataptr[7]
//             <    is written>: tmp7
      tmp7 = dataptr[0]-dataptr[7];
//             <    is read   >: dataptr dataptr[1] dataptr[6]
//             <    is written>: tmp1
      tmp1 = dataptr[1]+dataptr[6];
//             <    is read   >: dataptr dataptr[1] dataptr[6]
//             <    is written>: tmp6
      tmp6 = dataptr[1]-dataptr[6];
//             <    is read   >: dataptr dataptr[2] dataptr[5]
//             <    is written>: tmp2
      tmp2 = dataptr[2]+dataptr[5];
//             <    is read   >: dataptr dataptr[2] dataptr[5]
//             <    is written>: tmp5
      tmp5 = dataptr[2]-dataptr[5];
//             <    is read   >: dataptr dataptr[3] dataptr[4]
//             <    is written>: tmp3
      tmp3 = dataptr[3]+dataptr[4];
//             <    is read   >: dataptr dataptr[3] dataptr[4]
//             <    is written>: tmp4
      tmp4 = dataptr[3]-dataptr[4];
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10
      
      /* Even part per LL&M figure 1 --- note that published figure is faulty;
           * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
           */
      
      tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
      tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
      tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
      tmp12 = tmp1-tmp2;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[0]
      dataptr[0] = (DCTELEM) (tmp10+tmp11<<2);
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[4]
      dataptr[4] = (DCTELEM) (tmp10-tmp11<<2);
//             <    is read   >: tmp12 tmp13
//             <    is written>: z1
      z1 = (tmp12+tmp13)*(INT32) 4433;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[2]
      dataptr[2] = (DCTELEM) (z1+tmp13*(INT32) 6270+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: dataptr tmp12 z1
//             <    is written>: dataptr[6]
      dataptr[6] = (DCTELEM) (z1+tmp12*(-((INT32) 15137))+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp4 tmp7
//             <    is written>: z1
      
      /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
           * cK represents cos(K*pi/16).
           * i0..i3 in the paper are tmp4..tmp7 here.
           */
      
      z1 = tmp4+tmp7;
//             <    is read   >: tmp5 tmp6
//             <    is written>: z2
      z2 = tmp5+tmp6;
//             <    is read   >: tmp4 tmp6
//             <    is written>: z3
      z3 = tmp4+tmp6;
//             <    is read   >: tmp5 tmp7
//             <    is written>: z4
      z4 = tmp5+tmp7;
//             <    is read   >: z3 z4
//             <    is written>: z5
      z5 = (z3+z4)*(INT32) 9633;
//             <    is read   >: tmp4
//             <    is written>: tmp4
      /* sqrt(2) * c3 */
      
      tmp4 = tmp4*(INT32) 2446;
//             <    is read   >: tmp5
//             <    is written>: tmp5
      /* sqrt(2) * (-c1+c3+c5-c7) */
      tmp5 = tmp5*(INT32) 16819;
//             <    is read   >: tmp6
//             <    is written>: tmp6
      /* sqrt(2) * ( c1+c3-c5+c7) */
      tmp6 = tmp6*(INT32) 25172;
//             <    is read   >: tmp7
//             <    is written>: tmp7
      /* sqrt(2) * ( c1+c3+c5-c7) */
      tmp7 = tmp7*(INT32) 12299;
//             <    is read   >: z1
//             <    is written>: z1
      /* sqrt(2) * ( c1+c3-c5-c7) */
      z1 = z1*(-((INT32) 7373));
//             <    is read   >: z2
//             <    is written>: z2
      /* sqrt(2) * (c7-c3) */
      z2 = z2*(-((INT32) 20995));
//             <    is read   >: z3
//             <    is written>: z3
      /* sqrt(2) * (-c1-c3) */
      z3 = z3*(-((INT32) 16069));
//             <    is read   >: z4
//             <    is written>: z4
      /* sqrt(2) * (-c3-c5) */
      z4 = z4*(-((INT32) 3196));
//             <    is read   >: z3 z5
//             <    is written>: z3
      /* sqrt(2) * (c5-c3) */
      
      z3 += z5;
//             <    is read   >: z4 z5
//             <    is written>: z4
      z4 += z5;
//             <    is read   >: dataptr tmp4 z1 z3
//             <    is written>: dataptr[7]
      dataptr[7] = (DCTELEM) (tmp4+z1+z3+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: dataptr tmp5 z2 z4
//             <    is written>: dataptr[5]
      dataptr[5] = (DCTELEM) (tmp5+z2+z4+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: dataptr tmp6 z2 z3
//             <    is written>: dataptr[3]
      dataptr[3] = (DCTELEM) (tmp6+z2+z3+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: dataptr tmp7 z1 z4
//             <    is written>: dataptr[1]
      dataptr[1] = (DCTELEM) (tmp7+z1+z4+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: dataptr
//             <    is written>: dataptr

      dataptr += 8;
   }
//             <    is read   >: data
//             <    is written>: dataptr
   
   /* Pass 2: process columns.
      * We remove the PASS1_BITS scaling, but leave the results scaled up
      * by an overall factor of 8.
      */
   
   dataptr = data;
//             <    is written>: ctr
   for(ctr = 8-1; ctr >= 0; ctr += -1) {
//             <    is read   >: dataptr dataptr[8*0] dataptr[8*7]
//             <    is written>: tmp0
      tmp0 = dataptr[8*0]+dataptr[8*7];
//             <    is read   >: dataptr dataptr[8*0] dataptr[8*7]
//             <    is written>: tmp7
      tmp7 = dataptr[8*0]-dataptr[8*7];
//             <    is read   >: dataptr dataptr[8*1] dataptr[8*6]
//             <    is written>: tmp1
      tmp1 = dataptr[8*1]+dataptr[8*6];
//             <    is read   >: dataptr dataptr[8*1] dataptr[8*6]
//             <    is written>: tmp6
      tmp6 = dataptr[8*1]-dataptr[8*6];
//             <    is read   >: dataptr dataptr[8*2] dataptr[8*5]
//             <    is written>: tmp2
      tmp2 = dataptr[8*2]+dataptr[8*5];
//             <    is read   >: dataptr dataptr[8*2] dataptr[8*5]
//             <    is written>: tmp5
      tmp5 = dataptr[8*2]-dataptr[8*5];
//             <    is read   >: dataptr dataptr[8*3] dataptr[8*4]
//             <    is written>: tmp3
      tmp3 = dataptr[8*3]+dataptr[8*4];
//             <    is read   >: dataptr dataptr[8*3] dataptr[8*4]
//             <    is written>: tmp4
      tmp4 = dataptr[8*3]-dataptr[8*4];
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10
      
      /* Even part per LL&M figure 1 --- note that published figure is faulty;
           * rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
           */
      
      tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
      tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
      tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
      tmp12 = tmp1-tmp2;
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[8*0]
      dataptr[8*0] = (DCTELEM) (tmp10+tmp11+((INT32) 1<<2-1)>>2);
//             <    is read   >: dataptr tmp10 tmp11
//             <    is written>: dataptr[8*4]
      dataptr[8*4] = (DCTELEM) (tmp10-tmp11+((INT32) 1<<2-1)>>2);
//             <    is read   >: tmp12 tmp13
//             <    is written>: z1
      z1 = (tmp12+tmp13)*(INT32) 4433;
//             <    is read   >: dataptr tmp13 z1
//             <    is written>: dataptr[8*2]
      dataptr[8*2] = (DCTELEM) (z1+tmp13*(INT32) 6270+((INT32) 1<<13+2-1)>>13+2);
//             <    is read   >: dataptr tmp12 z1
//             <    is written>: dataptr[8*6]
      dataptr[8*6] = (DCTELEM) (z1+tmp12*(-((INT32) 15137))+((INT32) 1<<13+2-1)>>13+2);
//             <    is read   >: tmp4 tmp7
//             <    is written>: z1
      
      /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
           * cK represents cos(K*pi/16).
           * i0..i3 in the paper are tmp4..tmp7 here.
           */
      
      z1 = tmp4+tmp7;
//             <    is read   >: tmp5 tmp6
//             <    is written>: z2
      z2 = tmp5+tmp6;
//             <    is read   >: tmp4 tmp6
//             <    is written>: z3
      z3 = tmp4+tmp6;
//             <    is read   >: tmp5 tmp7
//             <    is written>: z4
      z4 = tmp5+tmp7;
//             <    is read   >: z3 z4
//             <    is written>: z5
      z5 = (z3+z4)*(INT32) 9633;
//             <    is read   >: tmp4
//             <    is written>: tmp4
      /* sqrt(2) * c3 */
      
      tmp4 = tmp4*(INT32) 2446;
//             <    is read   >: tmp5
//             <    is written>: tmp5
      /* sqrt(2) * (-c1+c3+c5-c7) */
      tmp5 = tmp5*(INT32) 16819;
//             <    is read   >: tmp6
//             <    is written>: tmp6
      /* sqrt(2) * ( c1+c3-c5+c7) */
      tmp6 = tmp6*(INT32) 25172;
//             <    is read   >: tmp7
//             <    is written>: tmp7
      /* sqrt(2) * ( c1+c3+c5-c7) */
      tmp7 = tmp7*(INT32) 12299;
//             <    is read   >: z1
//             <    is written>: z1
      /* sqrt(2) * ( c1+c3-c5-c7) */
      z1 = z1*(-((INT32) 7373));
//             <    is read   >: z2
//             <    is written>: z2
      /* sqrt(2) * (c7-c3) */
      z2 = z2*(-((INT32) 20995));
//             <    is read   >: z3
//             <    is written>: z3
      /* sqrt(2) * (-c1-c3) */
      z3 = z3*(-((INT32) 16069));
//             <    is read   >: z4
//             <    is written>: z4
      /* sqrt(2) * (-c3-c5) */
      z4 = z4*(-((INT32) 3196));
//             <    is read   >: z3 z5
//             <    is written>: z3
      /* sqrt(2) * (c5-c3) */
      
      z3 += z5;
//             <    is read   >: z4 z5
//             <    is written>: z4
      z4 += z5;
//             <    is read   >: dataptr tmp4 z1 z3
//             <    is written>: dataptr[8*7]
      dataptr[8*7] = (DCTELEM) (tmp4+z1+z3+((INT32) 1<<13+2-1)>>13+2);
//             <    is read   >: dataptr tmp5 z2 z4
//             <    is written>: dataptr[8*5]
      dataptr[8*5] = (DCTELEM) (tmp5+z2+z4+((INT32) 1<<13+2-1)>>13+2);
//             <    is read   >: dataptr tmp6 z2 z3
//             <    is written>: dataptr[8*3]
      dataptr[8*3] = (DCTELEM) (tmp6+z2+z3+((INT32) 1<<13+2-1)>>13+2);
//             <    is read   >: dataptr tmp7 z1 z4
//             <    is written>: dataptr[8*1]
      dataptr[8*1] = (DCTELEM) (tmp7+z1+z4+((INT32) 1<<13+2-1)>>13+2);
//             <    is read   >: dataptr
//             <    is written>: dataptr

      dataptr++;
   }
}
boolean jpeg_fill_bit_buffer(bitread_working_state *state, register bit_buf_type get_buffer, register int bits_left, int nbits)
{
   /* Copy heavily used state fields into locals (hopefully registers) */
//             <    is read   >: state state[0].next_input_byte
//             <    is written>: next_input_byte
   const register JOCTET *next_input_byte = state->next_input_byte;
//             <    is read   >: state state[0].bytes_in_buffer
//             <    is written>: bytes_in_buffer
   register size_t bytes_in_buffer = state->bytes_in_buffer;
   register int c;
l99998:   ;
//             <    is read   >: bits_left
   if (!(bits_left<32-7)) goto _break_1;
//             <    is read   >: state state[0].unread_marker
/* Attempt to read a byte */

/* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
/* (It is assumed that no request will be for more than that many bits.) */

   if (state->unread_marker!=0) goto no_more_data;
//             <    is read   >: bytes_in_buffer
   /* can't advance past a marker */
   
   if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!(*state->cinfo->src->fill_input_buffer)(state->cinfo))
         return 0;
//             <    is read   >: state state[0].cinfo 
//                               state[0].cinfo[0].src 
//                               state[0].cinfo[0].src[0].next_input_b
//                               yte
//             <    is written>: next_input_byte
      next_input_byte = state->cinfo->src->next_input_byte;
//             <    is read   >: state state[0].cinfo 
//                               state[0].cinfo[0].src 
//                               state[0].cinfo[0].src[0].bytes_in_buf
//                               fer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer = state->cinfo->src->bytes_in_buffer;
   }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
   bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
   c = *next_input_byte++;
//             <    is read   >: c

/* If it's 0xFF, check and discard stuffed zero byte */
   if (c==0xFF) goto l99999;
l99996:   ;
//             <    is read   >: c get_buffer
//             <    is written>: get_buffer
   
   /* OK, load c into get_buffer */
   get_buffer = get_buffer<<8|c;
//             <    is read   >: bits_left
//             <    is written>: bits_left
   bits_left += 8;
   goto l99998;
l99999:   ;
//             <    is read   >: c
   do {
//             <    is read   >: bytes_in_buffer
      if (bytes_in_buffer==0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!(*state->cinfo->src->fill_input_buffer)(state->cinfo))
            return 0;
//             <    is read   >: state state[0].cinfo 
//                               state[0].cinfo[0].src 
//                               state[0].cinfo[0].src[0].next_input_b
//                               yte
//             <    is written>: next_input_byte
         next_input_byte = state->cinfo->src->next_input_byte;
//             <    is read   >: state state[0].cinfo 
//                               state[0].cinfo[0].src 
//                               state[0].cinfo[0].src[0].bytes_in_buf
//                               fer
//             <    is written>: bytes_in_buffer
         bytes_in_buffer = state->cinfo->src->bytes_in_buffer;
      }
//             <    is read   >: bytes_in_buffer
//             <    is written>: bytes_in_buffer
      bytes_in_buffer--;
//             <    is read   >: next_input_byte next_input_byte[0]
//             <    is written>: c next_input_byte
      c = *next_input_byte++;
   }
   while (c==0xFF);
//             <    is read   >: c

   if (c==0) goto l99997;
//             <    is read   >: c state
//             <    is written>: state[0].unread_marker
   /* Oops, it's actually a marker indicating end of compressed data. */
   /* Better put it back for use later */
   state->unread_marker = c;
//             <    is read   >: bits_left nbits

/* There should be enough bits still left in the data segment; */
/* if so, just break out of the outer while loop. */
no_more_data:   if (bits_left>=nbits) goto _break_1;
//             <    is read   >: state state[0].printed_eod_ptr 
//                               state[0].printed_eod_ptr[0]
   /* Uh-oh.  Report corrupted data to user and stuff zeroes into
   	 * the data stream, so that we can produce some kind of image.
   	 * Note that this code will be repeated for each byte demanded
   	 * for the rest of the segment.  We use a nonvolatile flag to ensure
   	 * that only one warning message appears.
   	 */
   if (!*state->printed_eod_ptr) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      state->cinfo->err->msg_code = JWRN_HIT_MARKER, (*state->cinfo->err->emit_message)((j_common_ptr) state->cinfo,-1);
//             <    is read   >: state state[0].printed_eod_ptr
//             <    is written>: state[0].printed_eod_ptr[0]
      *state->printed_eod_ptr = 1;
   }
//             <    is written>: c
   c = 0;
   goto l99996;
l99997:   ;
//             <    is written>: c
   /* Found FF/00, which represents an FF data byte */
   c = 0xFF;
   goto l99996;
_break_1:   ;
//             <    is read   >: next_input_byte state
//             <    is written>: state[0].next_input_byte
   
   /* Unload the local registers */
   state->next_input_byte = next_input_byte;
//             <    is read   >: bytes_in_buffer state
//             <    is written>: state[0].bytes_in_buffer
   state->bytes_in_buffer = bytes_in_buffer;
//             <    is read   >: get_buffer state
//             <    is written>: state[0].get_buffer
   state->get_buffer = get_buffer;
//             <    is read   >: bits_left state
//             <    is written>: state[0].bits_left
   state->bits_left = bits_left;

   return 1;
}
void jpeg_finish_compress(j_compress_ptr cinfo)
{
   JDIMENSION iMCU_row;
//             <    is read   >: cinfo cinfo[0].global_state 
//                               cinfo[0].global_state
   
   
   if (cinfo->global_state==101||cinfo->global_state==102) {
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].next_scanline
      /* Terminate first pass */
      if (cinfo->next_scanline<cinfo->image_height)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_TOO_LITTLE_DATA, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->finish_pass)(cinfo);
   }
   else if (cinfo->global_state!=103)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].master 
//                               cinfo[0].master[0].is_last_pass
   /* Perform any remaining passes */
   while (!cinfo->master->is_last_pass) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->prepare_for_pass)(cinfo);
//             <    is read   >: cinfo cinfo[0].total_iMCU_rows
//             <    is written>: iMCU_row
      for(iMCU_row = 0; iMCU_row <= cinfo->total_iMCU_rows-1; iMCU_row += 1) {
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].total_iMCU_rows
         if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].total_iMCU_rows iMCU_row
//             <    is written>: cinfo[0].progress[0].pass_counter
            cinfo->progress->pass_counter = (long int) iMCU_row;
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].total_iMCU_rows 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].progress[0].pass_limit
            cinfo->progress->pass_limit = (long int) cinfo->total_iMCU_rows;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
         }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* We bypass the main controller and invoke coef controller directly;
                * all work is being done from the coefficient buffer.
                */
         if (!(*cinfo->coef->compress_data)(cinfo,(JSAMPIMAGE) (void *) 0))
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_CANT_SUSPEND, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
      }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->finish_pass)(cinfo);
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Write EOI, do final cleanup */
   (*cinfo->marker->write_file_trailer)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->dest->term_destination)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* We can use jpeg_abort to release memory and reset global_state */
   jpeg_abort((j_common_ptr) cinfo);
}
boolean jpeg_finish_decompress(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].buffered_image 
//                               cinfo[0].global_state 
//                               cinfo[0].global_state
   if ((cinfo->global_state==205||cinfo->global_state==206)&&!cinfo->buffered_image) {
//             <    is read   >: cinfo cinfo[0].output_height 
//                               cinfo[0].output_scanline
      /* Terminate final pass of non-buffered mode */
      if (cinfo->output_scanline<cinfo->output_height)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_TOO_LITTLE_DATA, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->finish_output_pass)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      cinfo->global_state = 210;
   }
   else if (cinfo->global_state==207)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      /* Finishing after a buffered-image operation */
      cinfo->global_state = 210;
   else if (cinfo->global_state!=210)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* STOPPING = repeat call after a suspension, anything else is error */
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].eoi_reached
   /* Read until EOI */
   while (!cinfo->inputctl->eoi_reached)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if ((*cinfo->inputctl->consume_input)(cinfo)==0)
         return 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Do final cleanup */
   (*cinfo->src->term_source)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* We can use jpeg_abort to release memory and reset global_state */
   jpeg_abort((j_common_ptr) cinfo);
   return 1;
}
boolean jpeg_finish_output(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].buffered_image 
//                               cinfo[0].global_state 
//                               cinfo[0].global_state
   if ((cinfo->global_state==205||cinfo->global_state==206)&&cinfo->buffered_image) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Terminate this pass. */
      /* We do not require the whole pass to have been completed. */
      (*cinfo->master->finish_output_pass)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      cinfo->global_state = 208;
   }
   else if (cinfo->global_state!=208)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* BUFPOST = repeat call after a suspension, anything else is error */
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo cinfo 
//                               cinfo[0].input_scan_number 
//                               cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].eoi_reached 
//                               cinfo[0].output_scan_number
   /* Read markers looking for SOS or EOI */
   
   while (cinfo->input_scan_number<=cinfo->output_scan_number&&!cinfo->inputctl->eoi_reached)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if ((*cinfo->inputctl->consume_input)(cinfo)==0)
         return 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   cinfo->global_state = 207;
   return 1;
}
void jpeg_free_large(j_common_ptr cinfo, void *object, size_t sizeofobject)
{
//             <    is read   >: object _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   free(object);
}
void jpeg_free_small(j_common_ptr cinfo, void *object, size_t sizeofobject)
{
//             <    is read   >: object _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   free(object);
}
void jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL *htbl, long int freq[])
{

   UINT8 bits[32+1];
   /* bits[k] = # of symbols with code length k */
   int codesize[257];
   /* codesize[k] = code length of symbol k */
   int others[257];
   /* next symbol in current branch of tree */
   int c1, c2;
   int p, i, j;
   long int v;
//             <may be written>: bits[*]
   
   /* This algorithm is explained in section K.2 of the JPEG standard */
   
   memset((void *) bits, 0, (size_t) (size_t) sizeof(bits));
//             <may be written>: codesize[*]
   memset((void *) codesize, 0, (size_t) (size_t) sizeof(codesize));
//             <    is written>: i
   for(i = 0; i <= 256; i += 1)
//             <    is read   >: i
//             <    is written>: others[i]
      others[i] = -1;
//             <    is written>: freq[256]
   /* init links to empty */
   
   freq[256] = 1;
l99999:   ;
/* make sure there is a nonzero count */
/* Including the pseudo-symbol 256 in the Huffman procedure guarantees
   * that no real symbol is given code-value of all ones, because 256
   * will be placed in the largest codeword category.
   */

/* Huffman's basic algorithm to assign optimal code lengths to symbols */

   if (!1) goto _break_2;
//             <    is written>: c1
   /* Find the smallest nonzero frequency, set c1 = its symbol */
   /* In case of ties, take the larger symbol number */
   c1 = -1;
//             <    is written>: v
   v = 1000000000L;
//             <    is written>: i
   for(i = 0; i <= 256; i += 1)
//             <    is read   >: freq[i] freq[i] i v
      if (freq[i]&&freq[i]<=v) {
//             <    is read   >: freq[i] i
//             <    is written>: v
         v = freq[i];
//             <    is read   >: i
//             <    is written>: c1
         c1 = i;
      }
//             <    is written>: c2
   
   /* Find the next smallest nonzero frequency, set c2 = its symbol */
   /* In case of ties, take the larger symbol number */
   c2 = -1;
//             <    is written>: v
   v = 1000000000L;
//             <    is written>: i
   for(i = 0; i <= 256; i += 1)
//             <    is read   >: c1 freq[i] freq[i] i v
      if (freq[i]&&freq[i]<=v&&i!=c1) {
//             <    is read   >: freq[i] i
//             <    is written>: v
         v = freq[i];
//             <    is read   >: i
//             <    is written>: c2
         c2 = i;
      }
//             <    is read   >: c2

/* Done if we've merged everything into one frequency */
   if (c2<0) goto _break_2;
//             <    is read   >: c1 c2 freq[c1] freq[c2]
//             <    is written>: freq[c1]
   
   /* Else merge the two counts/trees */
   freq[c1] += freq[c2];
//             <    is read   >: c2
//             <    is written>: freq[c2]
   freq[c2] = 0;
//             <    is read   >: c1 codesize[c1]
//             <    is written>: codesize[c1]
   
   /* Increment the codesize of everything in c1's tree branch */
   codesize[c1]++;
//             <    is read   >: c1 others[c1]
   while (others[c1]>=0) {
//             <    is read   >: c1 others[c1]
//             <    is written>: c1
      c1 = others[c1];
//             <    is read   >: c1 codesize[c1]
//             <    is written>: codesize[c1]
      codesize[c1]++;
   }
//             <    is read   >: c1 c2
//             <    is written>: others[c1]

   others[c1] = c2;
//             <    is read   >: c2 codesize[c2]
//             <    is written>: codesize[c2]
   /* chain c2 onto c1's tree branch */
   
   /* Increment the codesize of everything in c2's tree branch */
   codesize[c2]++;
//             <    is read   >: c2 others[c2]
   while (others[c2]>=0) {
//             <    is read   >: c2 others[c2]
//             <    is written>: c2
      c2 = others[c2];
//             <    is read   >: c2 codesize[c2]
//             <    is written>: codesize[c2]
      codesize[c2]++;
   }
   goto l99999;
_break_2:   ;
//             <    is written>: i
   
   /* Now count the number of symbols of each code length */
   for(i = 0; i <= 256; i += 1)
//             <    is read   >: codesize[i] i
      if (codesize[i]) {
//             <    is read   >: codesize[i] i
         /* The JPEG standard seems to think that this can't happen, */
         /* but I'm paranoid... */
         if (codesize[i]>32)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cinfo->err->msg_code = JERR_HUFF_CLEN_OVERFLOW, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: bits[codesize[i]] codesize[i] 
//                               codesize[i] i
//             <    is written>: bits[codesize[i]]

         bits[codesize[i]]++;
      }
//             <    is written>: i
   
   /* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure
      * Huffman procedure assigned any such lengths, we must adjust the coding.
      * Here is what the JPEG spec says about how this next bit works:
      * Since symbols are paired for the longest Huffman code, the symbols are
      * removed from this length category two at a time.  The prefix for the pair
      * (which is one bit shorter) is allocated to one of the pair; then,
      * skipping the BITS entry for that prefix length, a code word from the next
      * shortest nonzero BITS entry is converted into a prefix for two code words
      * one bit longer.
      */
   
   for(i = 32; i >= 17; i += -1)
//             <    is read   >: bits[i] i
      while (bits[i]>0) {
//             <    is read   >: i
//             <    is written>: j
         j = i-2;
//             <    is read   >: bits[j] j
         /* find length of new prefix to be used */
         while (bits[j]==0)
//             <    is read   >: j
//             <    is written>: j
            j--;
//             <    is read   >: bits[i] i
//             <    is written>: bits[i]

         bits[i] -= 2;
//             <    is read   >: bits[i-1] i
//             <    is written>: bits[i-1]
         /* remove two symbols */
         bits[i-1]++;
//             <    is read   >: bits[j+1] j
//             <    is written>: bits[j+1]
         /* one goes in this length */
         bits[j+1] += 2;
//             <    is read   >: bits[j] j
//             <    is written>: bits[j]
         /* two new symbols in this length */
         bits[j]--;
      }
//             <    is read   >: bits[i] i
   
   /* Remove the count for the pseudo-symbol 256 from the largest codelength */
   while (bits[i]==0)
//             <    is read   >: i
//             <    is written>: i
      /* find largest codelength still in use */
      i--;
//             <    is read   >: bits[i] i
//             <    is written>: bits[i]
   bits[i]--;
//             <may be read   >: bits[*]
//             <may be written>: htbl[0].bits[*]
//             <    is read   >: htbl
   
   /* Return final symbol counts (only for lengths 0..16) */
   memcpy((void *) htbl->bits, (void *) bits, (size_t) (size_t) sizeof(htbl->bits));
//             <    is written>: p
   
   /* Return a list of the symbols sorted by code length */
   /* It's not real clear to me why we don't need to consider the codelength
      * changes made above, but the JPEG spec seems to think this works.
      */
   p = 0;
//             <    is written>: i
   for(i = 1; i <= 32; i += 1)
//             <    is written>: j
      for(j = 0; j <= 255; j += 1)
//             <    is read   >: codesize[j] i j
         if (codesize[j]==i) {
//             <    is read   >: htbl j p
//             <    is written>: htbl[0].huffval[p]
            (htbl->huffval)[p] = (UINT8) j;
//             <    is read   >: p
//             <    is written>: p
            p++;
         }
//             <    is read   >: htbl
//             <    is written>: htbl[0].sent_table
   
   /* Set sent_table FALSE so updated table will be written to JPEG file. */
   htbl->sent_table = 0;
}
void * jpeg_get_large(j_common_ptr cinfo, size_t sizeofobject)
{
//             <    is read   >: sizeofobject _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   return (void *) malloc(sizeofobject);
}
void * jpeg_get_small(j_common_ptr cinfo, size_t sizeofobject)
{
//             <    is read   >: sizeofobject _MALLOC_EFFECTS:_MALLOC_
//             <    is written>: _MALLOC_EFFECTS:_MALLOC_
   return (void *) malloc(sizeofobject);
}
boolean jpeg_has_multiple_scans(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].global_state 
//                               cinfo[0].global_state
   /* Only valid after jpeg_read_header completes */
   
   if (cinfo->global_state<202||cinfo->global_state>210)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns
   return cinfo->inputctl->has_multiple_scans;
}
int jpeg_huff_decode(bitread_working_state *state, register bit_buf_type get_buffer, register int bits_left, d_derived_tbl *htbl, int min_bits)
{
//             <    is read   >: min_bits
//             <    is written>: l
   register int l = min_bits;
   register INT32 code;
//             <    is read   >: bits_left l
   if (bits_left<l) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      if (!jpeg_fill_bit_buffer(&*state, get_buffer, bits_left, l))
         return -1;
//             <    is read   >: state state[0].get_buffer
//             <    is written>: get_buffer
      get_buffer = (*state).get_buffer;
//             <    is read   >: state state[0].bits_left
//             <    is written>: bits_left
      bits_left = (*state).bits_left;
   }
//             <    is read   >: bits_left get_buffer l
//             <    is written>: bits_left code
   code = (int) (get_buffer>>(bits_left -= l))&(1<<l)-1;
//             <    is read   >: code htbl htbl[0].maxcode[l] l
   
   /* Collect the rest of the Huffman code one bit at a time. */
   /* This is per Figure F.16 in the JPEG spec. */
   
   while (code>(htbl->maxcode)[l]) {
//             <    is read   >: code
//             <    is written>: code
      code <<= 1;
//             <    is read   >: bits_left
      if (bits_left<1) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         if (!jpeg_fill_bit_buffer(&*state, get_buffer, bits_left, 1))
            return -1;
//             <    is read   >: state state[0].get_buffer
//             <    is written>: get_buffer
         get_buffer = (*state).get_buffer;
//             <    is read   >: state state[0].bits_left
//             <    is written>: bits_left
         bits_left = (*state).bits_left;
      }
//             <    is read   >: bits_left code get_buffer
//             <    is written>: bits_left code
      code |= (int) (get_buffer>>(bits_left -= 1))&(1<<1)-1;
//             <    is read   >: l
//             <    is written>: l
      l++;
   }
//             <    is read   >: get_buffer state
//             <    is written>: state[0].get_buffer
   
   /* Unload the local registers */
   state->get_buffer = get_buffer;
//             <    is read   >: bits_left state
//             <    is written>: state[0].bits_left
   state->bits_left = bits_left;
//             <    is read   >: l
   
   /* With garbage input we may reach the sentinel value l = 17. */
   
   if (l>16) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      state->cinfo->err->msg_code = JWRN_HUFF_BAD_CODE, (*state->cinfo->err->emit_message)((j_common_ptr) state->cinfo,-1);
      return 0;
   }
//             <    is read   >: code htbl htbl[0].mincode[l] 
//                               htbl[0].pub 
//                               htbl[0].pub[0].huffval[(htbl->valptr)
//                               [l]+(int) (code-(htbl->mincode)[l])
//                               ] htbl[0].valptr[l] l
   return (htbl->pub->huffval)[(htbl->valptr)[l]+(int) (code-(htbl->mincode)[l])];
}
void jpeg_idct_1x1(j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
   int dcval;
   ISLOW_MULT_TYPE *quantptr;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit+128;
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: quantptr
   
   
   /* We hardly need an inverse DCT routine for this: just take the
      * average pixel value, which is one-eighth of the DC coefficient.
      */
   quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
//             <    is read   >: coef_block coef_block[0] quantptr 
//                               quantptr[0]
//             <    is written>: dcval
   dcval = (ISLOW_MULT_TYPE) coef_block[0]*quantptr[0];
//             <    is read   >: dcval
//             <    is written>: dcval
   dcval = (int) ((INT32) dcval+((INT32) 1<<3-1)>>3);
//             <    is read   >: dcval output_buf output_buf[0] 
//                               output_col range_limit 
//                               range_limit[dcval&255*4+3]
//             <    is written>: output_buf[0][output_col]
   output_buf[0][output_col] = range_limit[dcval&255*4+3];
}
void jpeg_idct_2x2(j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
   INT32 tmp0, tmp10, z1;
   JCOEFPTR inptr;
   ISLOW_MULT_TYPE *quantptr;
   int *wsptr;
   JSAMPROW outptr;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit+128;
   int ctr;
   int workspace[8*2];
//             <    is read   >: coef_block
//             <    is written>: inptr
   /* buffers data between passes */
   
   
   /* Pass 1: process columns from input, store into work array. */
   
   inptr = coef_block;
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: quantptr
   quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
//             <    is written>: wsptr
   wsptr = workspace;
//             <    is written>: ctr
   ctr = 8;
//             <    is read   >: ctr
   while (ctr>0) {
//             <    is read   >: ctr
      /* Don't bother to process columns 2,4,6 */
      if (ctr==8-2||ctr==8-4||ctr==8-6)
         ;
      else if ((inptr[8*1]|inptr[8*3]|inptr[8*5]|inptr[8*7])==0) {
         /* AC terms all zero; we need not examine terms 2,4,6 for 2x2 output */
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: 0`1`2`dcval
         int dcval = (ISLOW_MULT_TYPE) inptr[8*0]*quantptr[8*0]<<2;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*0]

         wsptr[8*0] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = dcval;


      }
      else {
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: z1
         
         /* Even part */
         
         z1 = (ISLOW_MULT_TYPE) inptr[8*0]*quantptr[8*0];
//             <    is read   >: z1
//             <    is written>: tmp10
         tmp10 = z1<<13+2;
//             <    is read   >: inptr inptr[8*7] quantptr 
//                               quantptr[8*7]
//             <    is written>: z1
         
         /* Odd part */
         
         z1 = (ISLOW_MULT_TYPE) inptr[8*7]*quantptr[8*7];
//             <    is read   >: z1
//             <    is written>: tmp0
         tmp0 = z1*(-((INT32) 5906));
//             <    is read   >: inptr inptr[8*5] quantptr 
//                               quantptr[8*5]
//             <    is written>: z1
         /* sqrt(2) * (c7-c5+c3-c1) */
         z1 = (ISLOW_MULT_TYPE) inptr[8*5]*quantptr[8*5];
//             <    is read   >: tmp0 z1
//             <    is written>: tmp0
         tmp0 += z1*(INT32) 6967;
//             <    is read   >: inptr inptr[8*3] quantptr 
//                               quantptr[8*3]
//             <    is written>: z1
         /* sqrt(2) * (-c1+c3+c5+c7) */
         z1 = (ISLOW_MULT_TYPE) inptr[8*3]*quantptr[8*3];
//             <    is read   >: tmp0 z1
//             <    is written>: tmp0
         tmp0 += z1*(-((INT32) 10426));
//             <    is read   >: inptr inptr[8*1] quantptr 
//                               quantptr[8*1]
//             <    is written>: z1
         /* sqrt(2) * (-c1+c3-c5-c7) */
         z1 = (ISLOW_MULT_TYPE) inptr[8*1]*quantptr[8*1];
//             <    is read   >: tmp0 z1
//             <    is written>: tmp0
         tmp0 += z1*(INT32) 29692;
//             <    is read   >: tmp0 tmp10 wsptr
//             <    is written>: wsptr[8*0]
         /* sqrt(2) * (c1+c3+c5+c7) */
         
         /* Final output stage */
         
         wsptr[8*0] = (int) (tmp10+tmp0+((INT32) 1<<13-2+2-1)>>13-2+2);
//             <    is read   >: tmp0 tmp10 wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = (int) (tmp10-tmp0+((INT32) 1<<13-2+2-1)>>13-2+2);
      }
_loop_end_1:      ;
//             <    is read   >: ctr inptr quantptr wsptr
//             <    is written>: ctr inptr quantptr wsptr
      inptr++, quantptr++, wsptr++, ctr--;
   }
//             <    is written>: wsptr
   
   /* Pass 2: process 2 rows from work array, store into output array. */
   
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 0; ctr <= 1; ctr += 1) {
//             <    is read   >: ctr output_buf output_buf[ctr] 
//                               output_col
//             <    is written>: outptr
      outptr = output_buf[ctr]+output_col;
//             <    is read   >: wsptr wsptr[1] wsptr[3] wsptr[5] 
//                               wsptr[7]
      /* It's not clear whether a zero row test is worthwhile here ... */
      
      
      if ((wsptr[1]|wsptr[3]|wsptr[5]|wsptr[7])==0) {
         /* AC terms all zero */
//             <    is read   >: range_limit 
//                               range_limit[(int) ((INT32) wsptr[0]+(
//                               (INT32) 1<<2+3-1)>>2+3)
//                               &255*4+3] wsptr wsptr[0]
//             <    is written>: 0`3`4`dcval
         JSAMPLE dcval = range_limit[(int) ((INT32) wsptr[0]+((INT32) 1<<2+3-1)>>2+3)&255*4+3];
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[0]

         outptr[0] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[1]
         outptr[1] = dcval;
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
         /* advance pointer to next row */
         ;
      }
      else {
//             <    is read   >: wsptr wsptr[0]
//             <    is written>: tmp10
         
         
         /* Even part */
         
         tmp10 = (INT32) wsptr[0]<<13+2;
//             <    is read   >: wsptr wsptr[1] wsptr[3] wsptr[5] 
//                               wsptr[7]
//             <    is written>: tmp0
         
         /* Odd part */
         
         /* sqrt(2) * (c7-c5+c3-c1) */
         /* sqrt(2) * (-c1+c3+c5+c7) */
         /* sqrt(2) * (-c1+c3-c5-c7) */
         tmp0 = (INT32) wsptr[7]*(-((INT32) 5906))+(INT32) wsptr[5]*(INT32) 6967+(INT32) wsptr[3]*(-((INT32) 10426))+(INT32) wsptr[1]*(INT32) 29692;
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp10+tmp0+((INT32
//                               ) 1<<13+2+3+2-1)>>13+2+3+2)
//                               &255*4+3] tmp0 tmp10
//             <    is written>: outptr[0]
         /* sqrt(2) * (c1+c3+c5+c7) */
         
         /* Final output stage */
         
         outptr[0] = range_limit[(int) (tmp10+tmp0+((INT32) 1<<13+2+3+2-1)>>13+2+3+2)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp10-tmp0+((INT32
//                               ) 1<<13+2+3+2-1)>>13+2+3+2)
//                               &255*4+3] tmp0 tmp10
//             <    is written>: outptr[1]
         outptr[1] = range_limit[(int) (tmp10-tmp0+((INT32) 1<<13+2+3+2-1)>>13+2+3+2)&255*4+3];
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
      }
_loop_end_2:      ;
   }
}
void jpeg_idct_4x4(j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
   INT32 tmp0, tmp2, tmp10, tmp12;
   INT32 z1, z2, z3, z4;
   JCOEFPTR inptr;
   ISLOW_MULT_TYPE *quantptr;
   int *wsptr;
   JSAMPROW outptr;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit+128;
   int ctr;
   int workspace[8*4];
//             <    is read   >: coef_block
//             <    is written>: inptr
   /* buffers data between passes */
   
   
   /* Pass 1: process columns from input, store into work array. */
   
   inptr = coef_block;
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: quantptr
   quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
//             <    is written>: wsptr
   wsptr = workspace;
//             <    is written>: ctr
   ctr = 8;
//             <    is read   >: ctr
   while (ctr>0) {
//             <    is read   >: ctr
      /* Don't bother to process column 4, because second pass won't use it */
      if (ctr==8-4)
         ;
      else if ((inptr[8*1]|inptr[8*2]|inptr[8*3]|inptr[8*5]|inptr[8*6]|inptr[8*7])==0) {
         /* AC terms all zero; we need not examine term 4 for 4x4 output */
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: 0`1`2`dcval
         int dcval = (ISLOW_MULT_TYPE) inptr[8*0]*quantptr[8*0]<<2;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*0]

         wsptr[8*0] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = dcval;


      }
      else {
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: tmp0
         
         /* Even part */
         
         tmp0 = (ISLOW_MULT_TYPE) inptr[8*0]*quantptr[8*0];
//             <    is read   >: tmp0
//             <    is written>: tmp0
         tmp0 <<= 13+1;
//             <    is read   >: inptr inptr[8*2] quantptr 
//                               quantptr[8*2]
//             <    is written>: z2
         z2 = (ISLOW_MULT_TYPE) inptr[8*2]*quantptr[8*2];
//             <    is read   >: inptr inptr[8*6] quantptr 
//                               quantptr[8*6]
//             <    is written>: z3
         z3 = (ISLOW_MULT_TYPE) inptr[8*6]*quantptr[8*6];
//             <    is read   >: z2 z3
//             <    is written>: tmp2
         tmp2 = z2*(INT32) 15137+z3*(-((INT32) 6270));
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp10

         tmp10 = tmp0+tmp2;
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp12
         tmp12 = tmp0-tmp2;
//             <    is read   >: inptr inptr[8*7] quantptr 
//                               quantptr[8*7]
//             <    is written>: z1
         
         /* Odd part */
         
         z1 = (ISLOW_MULT_TYPE) inptr[8*7]*quantptr[8*7];
//             <    is read   >: inptr inptr[8*5] quantptr 
//                               quantptr[8*5]
//             <    is written>: z2
         z2 = (ISLOW_MULT_TYPE) inptr[8*5]*quantptr[8*5];
//             <    is read   >: inptr inptr[8*3] quantptr 
//                               quantptr[8*3]
//             <    is written>: z3
         z3 = (ISLOW_MULT_TYPE) inptr[8*3]*quantptr[8*3];
//             <    is read   >: inptr inptr[8*1] quantptr 
//                               quantptr[8*1]
//             <    is written>: z4
         z4 = (ISLOW_MULT_TYPE) inptr[8*1]*quantptr[8*1];
//             <    is read   >: z1 z2 z3 z4
//             <    is written>: tmp0
         /* sqrt(2) * (c3-c1) */
         /* sqrt(2) * (c3+c7) */
         /* sqrt(2) * (-c1-c5) */
         tmp0 = z1*(-((INT32) 1730))+z2*(INT32) 11893+z3*(-((INT32) 17799))+z4*(INT32) 8697;
//             <    is read   >: z1 z2 z3 z4
//             <    is written>: tmp2
         /* sqrt(2) * (c5+c7) */
         
         /* sqrt(2) * (c7-c5) */
         /* sqrt(2) * (c5-c1) */
         /* sqrt(2) * (c3-c7) */
         tmp2 = z1*(-((INT32) 4176))+z2*(-((INT32) 4926))+z3*(INT32) 7373+z4*(INT32) 20995;
//             <    is read   >: tmp10 tmp2 wsptr
//             <    is written>: wsptr[8*0]
         /* sqrt(2) * (c1+c3) */
         
         /* Final output stage */
         
         wsptr[8*0] = (int) (tmp10+tmp2+((INT32) 1<<13-2+1-1)>>13-2+1);
//             <    is read   >: tmp10 tmp2 wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = (int) (tmp10-tmp2+((INT32) 1<<13-2+1-1)>>13-2+1);
//             <    is read   >: tmp0 tmp12 wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = (int) (tmp12+tmp0+((INT32) 1<<13-2+1-1)>>13-2+1);
//             <    is read   >: tmp0 tmp12 wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = (int) (tmp12-tmp0+((INT32) 1<<13-2+1-1)>>13-2+1);
      }
_loop_end_1:      ;
//             <    is read   >: ctr inptr quantptr wsptr
//             <    is written>: ctr inptr quantptr wsptr
      inptr++, quantptr++, wsptr++, ctr--;
   }
//             <    is written>: wsptr
   
   /* Pass 2: process 4 rows from work array, store into output array. */
   
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 0; ctr <= 3; ctr += 1) {
//             <    is read   >: ctr output_buf output_buf[ctr] 
//                               output_col
//             <    is written>: outptr
      outptr = output_buf[ctr]+output_col;
//             <    is read   >: wsptr wsptr[1] wsptr[2] wsptr[3] 
//                               wsptr[5] wsptr[6] wsptr[7]
      /* It's not clear whether a zero row test is worthwhile here ... */
      
      
      
      if ((wsptr[1]|wsptr[2]|wsptr[3]|wsptr[5]|wsptr[6]|wsptr[7])==0) {
         /* AC terms all zero */
//             <    is read   >: range_limit 
//                               range_limit[(int) ((INT32) wsptr[0]+(
//                               (INT32) 1<<2+3-1)>>2+3)
//                               &255*4+3] wsptr wsptr[0]
//             <    is written>: 0`3`4`dcval
         JSAMPLE dcval = range_limit[(int) ((INT32) wsptr[0]+((INT32) 1<<2+3-1)>>2+3)&255*4+3];
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[0]

         outptr[0] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[1]
         outptr[1] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[2]
         outptr[2] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[3]
         outptr[3] = dcval;
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
         /* advance pointer to next row */
         ;
      }
      else {
//             <    is read   >: wsptr wsptr[0]
//             <    is written>: tmp0
         
         
         /* Even part */
         
         tmp0 = (INT32) wsptr[0]<<13+1;
//             <    is read   >: wsptr wsptr[2] wsptr[6]
//             <    is written>: tmp2
         tmp2 = (INT32) wsptr[2]*(INT32) 15137+(INT32) wsptr[6]*(-((INT32) 6270));
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp10

         tmp10 = tmp0+tmp2;
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp12
         tmp12 = tmp0-tmp2;
//             <    is read   >: wsptr wsptr[7]
//             <    is written>: z1
         
         /* Odd part */
         
         z1 = (INT32) wsptr[7];
//             <    is read   >: wsptr wsptr[5]
//             <    is written>: z2
         z2 = (INT32) wsptr[5];
//             <    is read   >: wsptr wsptr[3]
//             <    is written>: z3
         z3 = (INT32) wsptr[3];
//             <    is read   >: wsptr wsptr[1]
//             <    is written>: z4
         z4 = (INT32) wsptr[1];
//             <    is read   >: z1 z2 z3 z4
//             <    is written>: tmp0
         /* sqrt(2) * (c3-c1) */
         /* sqrt(2) * (c3+c7) */
         /* sqrt(2) * (-c1-c5) */
         tmp0 = z1*(-((INT32) 1730))+z2*(INT32) 11893+z3*(-((INT32) 17799))+z4*(INT32) 8697;
//             <    is read   >: z1 z2 z3 z4
//             <    is written>: tmp2
         /* sqrt(2) * (c5+c7) */
         
         /* sqrt(2) * (c7-c5) */
         /* sqrt(2) * (c5-c1) */
         /* sqrt(2) * (c3-c7) */
         tmp2 = z1*(-((INT32) 4176))+z2*(-((INT32) 4926))+z3*(INT32) 7373+z4*(INT32) 20995;
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp10+tmp2+((INT32
//                               ) 1<<13+2+3+1-1)>>13+2+3+1)
//                               &255*4+3] tmp10 tmp2
//             <    is written>: outptr[0]
         /* sqrt(2) * (c1+c3) */
         
         /* Final output stage */
         
         outptr[0] = range_limit[(int) (tmp10+tmp2+((INT32) 1<<13+2+3+1-1)>>13+2+3+1)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp10-tmp2+((INT32
//                               ) 1<<13+2+3+1-1)>>13+2+3+1)
//                               &255*4+3] tmp10 tmp2
//             <    is written>: outptr[3]
         outptr[3] = range_limit[(int) (tmp10-tmp2+((INT32) 1<<13+2+3+1-1)>>13+2+3+1)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp12+tmp0+((INT32
//                               ) 1<<13+2+3+1-1)>>13+2+3+1)
//                               &255*4+3] tmp0 tmp12
//             <    is written>: outptr[1]
         outptr[1] = range_limit[(int) (tmp12+tmp0+((INT32) 1<<13+2+3+1-1)>>13+2+3+1)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp12-tmp0+((INT32
//                               ) 1<<13+2+3+1-1)>>13+2+3+1)
//                               &255*4+3] tmp0 tmp12
//             <    is written>: outptr[2]
         outptr[2] = range_limit[(int) (tmp12-tmp0+((INT32) 1<<13+2+3+1-1)>>13+2+3+1)&255*4+3];
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
      }
_loop_end_2:      ;
   }
}
void jpeg_idct_float(j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
   float tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   float tmp10, tmp11, tmp12, tmp13;
   float z5, z10, z11, z12, z13;
   JCOEFPTR inptr;
   FLOAT_MULT_TYPE *quantptr;
   float *wsptr;
   JSAMPROW outptr;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit+128;
   int ctr;
   float workspace[64];
//             <    is read   >: coef_block
//             <    is written>: inptr
   /* buffers data between passes */
   
   
   /* Pass 1: process columns from input, store into work array. */
   
   inptr = coef_block;
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: quantptr
   quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
//             <    is written>: wsptr
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 8; ctr >= 1; ctr += -1) {
//             <    is read   >: inptr inptr[8*1] inptr[8*2] 
//                               inptr[8*3] inptr[8*4] inptr[8*5] 
//                               inptr[8*6] inptr[8*7]
      /* Due to quantization, we will usually find that many of the input
           * coefficients are zero, especially the AC terms.  We can exploit this
           * by short-circuiting the IDCT calculation for any column in which all
           * the AC terms are zero.  In that case each output is equal to the
           * DC coefficient (with scale factor as needed).
           * With typical images and quantization tables, half or more of the
           * column DCT calculations can be simplified this way.
           */
      
      
      
      if ((inptr[8*1]|inptr[8*2]|inptr[8*3]|inptr[8*4]|inptr[8*5]|inptr[8*6]|inptr[8*7])==0) {
         /* AC terms all zero */
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: dcval
         float dcval = (float) inptr[8*0]*quantptr[8*0];
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*0]

         wsptr[8*0] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*4]
         wsptr[8*4] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*5]
         wsptr[8*5] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*6]
         wsptr[8*6] = dcval;
//             <    is read   >: dcval wsptr
//             <    is written>: wsptr[8*7]
         wsptr[8*7] = dcval;
//             <    is read   >: inptr
//             <    is written>: inptr

         inptr++;
//             <    is read   >: quantptr
//             <    is written>: quantptr
         /* advance pointers to next column */
         quantptr++;
//             <    is read   >: wsptr
//             <    is written>: wsptr
         wsptr++;
      }
      else {
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: tmp0
         
         /* Even part */
         
         tmp0 = (float) inptr[8*0]*quantptr[8*0];
//             <    is read   >: inptr inptr[8*2] quantptr 
//                               quantptr[8*2]
//             <    is written>: tmp1
         tmp1 = (float) inptr[8*2]*quantptr[8*2];
//             <    is read   >: inptr inptr[8*4] quantptr 
//                               quantptr[8*4]
//             <    is written>: tmp2
         tmp2 = (float) inptr[8*4]*quantptr[8*4];
//             <    is read   >: inptr inptr[8*6] quantptr 
//                               quantptr[8*6]
//             <    is written>: tmp3
         tmp3 = (float) inptr[8*6]*quantptr[8*6];
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp10

         tmp10 = tmp0+tmp2;
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp11
         /* phase 3 */
         tmp11 = tmp0-tmp2;
//             <    is read   >: tmp1 tmp3
//             <    is written>: tmp13

         tmp13 = tmp1+tmp3;
//             <    is read   >: tmp1 tmp13 tmp3
//             <    is written>: tmp12
         /* phases 5-3 */
         tmp12 = (tmp1-tmp3)*(float) 1.414213562-tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp0
         /* 2*c4 */
         
         tmp0 = tmp10+tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp3
         /* phase 2 */
         tmp3 = tmp10-tmp13;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp1
         tmp1 = tmp11+tmp12;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp2
         tmp2 = tmp11-tmp12;
//             <    is read   >: inptr inptr[8*1] quantptr 
//                               quantptr[8*1]
//             <    is written>: tmp4
         
         /* Odd part */
         
         tmp4 = (float) inptr[8*1]*quantptr[8*1];
//             <    is read   >: inptr inptr[8*3] quantptr 
//                               quantptr[8*3]
//             <    is written>: tmp5
         tmp5 = (float) inptr[8*3]*quantptr[8*3];
//             <    is read   >: inptr inptr[8*5] quantptr 
//                               quantptr[8*5]
//             <    is written>: tmp6
         tmp6 = (float) inptr[8*5]*quantptr[8*5];
//             <    is read   >: inptr inptr[8*7] quantptr 
//                               quantptr[8*7]
//             <    is written>: tmp7
         tmp7 = (float) inptr[8*7]*quantptr[8*7];
//             <    is read   >: tmp5 tmp6
//             <    is written>: z13

         z13 = tmp6+tmp5;
//             <    is read   >: tmp5 tmp6
//             <    is written>: z10
         /* phase 6 */
         z10 = tmp6-tmp5;
//             <    is read   >: tmp4 tmp7
//             <    is written>: z11
         z11 = tmp4+tmp7;
//             <    is read   >: tmp4 tmp7
//             <    is written>: z12
         z12 = tmp4-tmp7;
//             <    is read   >: z11 z13
//             <    is written>: tmp7

         tmp7 = z11+z13;
//             <    is read   >: z11 z13
//             <    is written>: tmp11
         /* phase 5 */
         tmp11 = (z11-z13)*(float) 1.414213562;
//             <    is read   >: z10 z12
//             <    is written>: z5
         /* 2*c4 */
         
         z5 = (z10+z12)*(float) 1.847759065;
//             <    is read   >: z12 z5
//             <    is written>: tmp10
         /* 2*c2 */
         tmp10 = (float) 1.082392200*z12-z5;
//             <    is read   >: z10 z5
//             <    is written>: tmp12
         /* 2*(c2-c6) */
         tmp12 = (float) -2.613125930*z10+z5;
//             <    is read   >: tmp12 tmp7
//             <    is written>: tmp6
         /* -2*(c2+c6) */
         
         tmp6 = tmp12-tmp7;
//             <    is read   >: tmp11 tmp6
//             <    is written>: tmp5
         /* phase 2 */
         tmp5 = tmp11-tmp6;
//             <    is read   >: tmp10 tmp5
//             <    is written>: tmp4
         tmp4 = tmp10+tmp5;
//             <    is read   >: tmp0 tmp7 wsptr
//             <    is written>: wsptr[8*0]

         wsptr[8*0] = tmp0+tmp7;
//             <    is read   >: tmp0 tmp7 wsptr
//             <    is written>: wsptr[8*7]
         wsptr[8*7] = tmp0-tmp7;
//             <    is read   >: tmp1 tmp6 wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = tmp1+tmp6;
//             <    is read   >: tmp1 tmp6 wsptr
//             <    is written>: wsptr[8*6]
         wsptr[8*6] = tmp1-tmp6;
//             <    is read   >: tmp2 tmp5 wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = tmp2+tmp5;
//             <    is read   >: tmp2 tmp5 wsptr
//             <    is written>: wsptr[8*5]
         wsptr[8*5] = tmp2-tmp5;
//             <    is read   >: tmp3 tmp4 wsptr
//             <    is written>: wsptr[8*4]
         wsptr[8*4] = tmp3+tmp4;
//             <    is read   >: tmp3 tmp4 wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = tmp3-tmp4;
//             <    is read   >: inptr
//             <    is written>: inptr

         inptr++;
//             <    is read   >: quantptr
//             <    is written>: quantptr
         /* advance pointers to next column */
         quantptr++;
//             <    is read   >: wsptr
//             <    is written>: wsptr
         wsptr++;
      }
_loop_end_1:      ;
   }
//             <    is written>: wsptr
   
   /* Pass 2: process rows from work array, store into output array. */
   /* Note that we must descale the results by a factor of 8 == 2**3. */
   
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 0; ctr <= 7; ctr += 1) {
//             <    is read   >: ctr output_buf output_buf[ctr] 
//                               output_col
//             <    is written>: outptr
      outptr = output_buf[ctr]+output_col;
//             <    is read   >: wsptr wsptr[0] wsptr[4]
//             <    is written>: tmp10
      /* Rows of zeroes can be exploited in the same way as we did with columns.
           * However, the column calculation has created many nonzero AC terms, so
           * the simplification applies less often (typically 5% to 10% of the time).
           * And testing floats for zero is relatively expensive, so we don't bother.
           */
      
      /* Even part */
      
      tmp10 = wsptr[0]+wsptr[4];
//             <    is read   >: wsptr wsptr[0] wsptr[4]
//             <    is written>: tmp11
      tmp11 = wsptr[0]-wsptr[4];
//             <    is read   >: wsptr wsptr[2] wsptr[6]
//             <    is written>: tmp13

      tmp13 = wsptr[2]+wsptr[6];
//             <    is read   >: tmp13 wsptr wsptr[2] wsptr[6]
//             <    is written>: tmp12
      tmp12 = (wsptr[2]-wsptr[6])*(float) 1.414213562-tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp0

      tmp0 = tmp10+tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp3
      tmp3 = tmp10-tmp13;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp1
      tmp1 = tmp11+tmp12;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp2
      tmp2 = tmp11-tmp12;
//             <    is read   >: wsptr wsptr[3] wsptr[5]
//             <    is written>: z13
      
      /* Odd part */
      
      z13 = wsptr[5]+wsptr[3];
//             <    is read   >: wsptr wsptr[3] wsptr[5]
//             <    is written>: z10
      z10 = wsptr[5]-wsptr[3];
//             <    is read   >: wsptr wsptr[1] wsptr[7]
//             <    is written>: z11
      z11 = wsptr[1]+wsptr[7];
//             <    is read   >: wsptr wsptr[1] wsptr[7]
//             <    is written>: z12
      z12 = wsptr[1]-wsptr[7];
//             <    is read   >: z11 z13
//             <    is written>: tmp7

      tmp7 = z11+z13;
//             <    is read   >: z11 z13
//             <    is written>: tmp11
      tmp11 = (z11-z13)*(float) 1.414213562;
//             <    is read   >: z10 z12
//             <    is written>: z5
      z5 = (z10+z12)*(float) 1.847759065;
//             <    is read   >: z12 z5
//             <    is written>: tmp10
      /* 2*c2 */
      tmp10 = (float) 1.082392200*z12-z5;
//             <    is read   >: z10 z5
//             <    is written>: tmp12
      /* 2*(c2-c6) */
      tmp12 = (float) -2.613125930*z10+z5;
//             <    is read   >: tmp12 tmp7
//             <    is written>: tmp6
      /* -2*(c2+c6) */
      
      tmp6 = tmp12-tmp7;
//             <    is read   >: tmp11 tmp6
//             <    is written>: tmp5
      tmp5 = tmp11-tmp6;
//             <    is read   >: tmp10 tmp5
//             <    is written>: tmp4
      tmp4 = tmp10+tmp5;
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp0+tmp7
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp0 tmp7
//             <    is written>: outptr[0]
      
      /* Final output stage: scale down by a factor of 8 and range-limit */
      
      outptr[0] = range_limit[(int) ((INT32) (tmp0+tmp7)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp0-tmp7
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp0 tmp7
//             <    is written>: outptr[7]
      outptr[7] = range_limit[(int) ((INT32) (tmp0-tmp7)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp1+tmp6
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp1 tmp6
//             <    is written>: outptr[1]
      outptr[1] = range_limit[(int) ((INT32) (tmp1+tmp6)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp1-tmp6
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp1 tmp6
//             <    is written>: outptr[6]
      outptr[6] = range_limit[(int) ((INT32) (tmp1-tmp6)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp2+tmp5
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp2 tmp5
//             <    is written>: outptr[2]
      outptr[2] = range_limit[(int) ((INT32) (tmp2+tmp5)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp2-tmp5
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp2 tmp5
//             <    is written>: outptr[5]
      outptr[5] = range_limit[(int) ((INT32) (tmp2-tmp5)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp3+tmp4
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp3 tmp4
//             <    is written>: outptr[4]
      outptr[4] = range_limit[(int) ((INT32) (tmp3+tmp4)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) ((INT32) (tmp3-tmp4
//                               )+((INT32) 1<<3-1)>>3)
//                               &255*4+3] tmp3 tmp4
//             <    is written>: outptr[3]
      outptr[3] = range_limit[(int) ((INT32) (tmp3-tmp4)+((INT32) 1<<3-1)>>3)&255*4+3];
//             <    is read   >: wsptr
//             <    is written>: wsptr

      wsptr += 8;
   }
}
void jpeg_idct_ifast(j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
   DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   DCTELEM tmp10, tmp11, tmp12, tmp13;
   DCTELEM z5, z10, z11, z12, z13;
   JCOEFPTR inptr;
   IFAST_MULT_TYPE *quantptr;
   int *wsptr;
   JSAMPROW outptr;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit+128;
   int ctr;
   int workspace[64];
//             <    is read   >: coef_block
//             <    is written>: inptr
   /* buffers data between passes */
   /* for DESCALE */
   /* for IDESCALE */
   
   /* Pass 1: process columns from input, store into work array. */
   
   inptr = coef_block;
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: quantptr
   quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
//             <    is written>: wsptr
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 8; ctr >= 1; ctr += -1) {
//             <    is read   >: inptr inptr[8*1] inptr[8*2] 
//                               inptr[8*3] inptr[8*4] inptr[8*5] 
//                               inptr[8*6] inptr[8*7]
      /* Due to quantization, we will usually find that many of the input
           * coefficients are zero, especially the AC terms.  We can exploit this
           * by short-circuiting the IDCT calculation for any column in which all
           * the AC terms are zero.  In that case each output is equal to the
           * DC coefficient (with scale factor as needed).
           * With typical images and quantization tables, half or more of the
           * column DCT calculations can be simplified this way.
           */
      
      
      
      if ((inptr[8*1]|inptr[8*2]|inptr[8*3]|inptr[8*4]|inptr[8*5]|inptr[8*6]|inptr[8*7])==0) {
         /* AC terms all zero */
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: 0`1`2`dcval
         int dcval = (int) ((IFAST_MULT_TYPE) inptr[8*0]*quantptr[8*0]);
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*0]

         wsptr[8*0] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*4]
         wsptr[8*4] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*5]
         wsptr[8*5] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*6]
         wsptr[8*6] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*7]
         wsptr[8*7] = dcval;
//             <    is read   >: inptr
//             <    is written>: inptr

         inptr++;
//             <    is read   >: quantptr
//             <    is written>: quantptr
         /* advance pointers to next column */
         quantptr++;
//             <    is read   >: wsptr
//             <    is written>: wsptr
         wsptr++;
      }
      else {
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: tmp0
         
         /* Even part */
         
         tmp0 = (IFAST_MULT_TYPE) inptr[8*0]*quantptr[8*0];
//             <    is read   >: inptr inptr[8*2] quantptr 
//                               quantptr[8*2]
//             <    is written>: tmp1
         tmp1 = (IFAST_MULT_TYPE) inptr[8*2]*quantptr[8*2];
//             <    is read   >: inptr inptr[8*4] quantptr 
//                               quantptr[8*4]
//             <    is written>: tmp2
         tmp2 = (IFAST_MULT_TYPE) inptr[8*4]*quantptr[8*4];
//             <    is read   >: inptr inptr[8*6] quantptr 
//                               quantptr[8*6]
//             <    is written>: tmp3
         tmp3 = (IFAST_MULT_TYPE) inptr[8*6]*quantptr[8*6];
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp10

         tmp10 = tmp0+tmp2;
//             <    is read   >: tmp0 tmp2
//             <    is written>: tmp11
         /* phase 3 */
         tmp11 = tmp0-tmp2;
//             <    is read   >: tmp1 tmp3
//             <    is written>: tmp13

         tmp13 = tmp1+tmp3;
//             <    is read   >: tmp1 tmp13 tmp3
//             <    is written>: tmp12
         /* phases 5-3 */
         tmp12 = (DCTELEM) ((tmp1-tmp3)*(INT32) 362>>8)-tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp0
         /* 2*c4 */
         
         tmp0 = tmp10+tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp3
         /* phase 2 */
         tmp3 = tmp10-tmp13;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp1
         tmp1 = tmp11+tmp12;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp2
         tmp2 = tmp11-tmp12;
//             <    is read   >: inptr inptr[8*1] quantptr 
//                               quantptr[8*1]
//             <    is written>: tmp4
         
         /* Odd part */
         
         tmp4 = (IFAST_MULT_TYPE) inptr[8*1]*quantptr[8*1];
//             <    is read   >: inptr inptr[8*3] quantptr 
//                               quantptr[8*3]
//             <    is written>: tmp5
         tmp5 = (IFAST_MULT_TYPE) inptr[8*3]*quantptr[8*3];
//             <    is read   >: inptr inptr[8*5] quantptr 
//                               quantptr[8*5]
//             <    is written>: tmp6
         tmp6 = (IFAST_MULT_TYPE) inptr[8*5]*quantptr[8*5];
//             <    is read   >: inptr inptr[8*7] quantptr 
//                               quantptr[8*7]
//             <    is written>: tmp7
         tmp7 = (IFAST_MULT_TYPE) inptr[8*7]*quantptr[8*7];
//             <    is read   >: tmp5 tmp6
//             <    is written>: z13

         z13 = tmp6+tmp5;
//             <    is read   >: tmp5 tmp6
//             <    is written>: z10
         /* phase 6 */
         z10 = tmp6-tmp5;
//             <    is read   >: tmp4 tmp7
//             <    is written>: z11
         z11 = tmp4+tmp7;
//             <    is read   >: tmp4 tmp7
//             <    is written>: z12
         z12 = tmp4-tmp7;
//             <    is read   >: z11 z13
//             <    is written>: tmp7

         tmp7 = z11+z13;
//             <    is read   >: z11 z13
//             <    is written>: tmp11
         /* phase 5 */
         tmp11 = (DCTELEM) ((z11-z13)*(INT32) 362>>8);
//             <    is read   >: z10 z12
//             <    is written>: z5
         /* 2*c4 */
         
         z5 = (DCTELEM) ((z10+z12)*(INT32) 473>>8);
//             <    is read   >: z12 z5
//             <    is written>: tmp10
         /* 2*c2 */
         tmp10 = (DCTELEM) (z12*(INT32) 277>>8)-z5;
//             <    is read   >: z10 z5
//             <    is written>: tmp12
         /* 2*(c2-c6) */
         tmp12 = (DCTELEM) (z10*(-((INT32) 669))>>8)+z5;
//             <    is read   >: tmp12 tmp7
//             <    is written>: tmp6
         /* -2*(c2+c6) */
         
         tmp6 = tmp12-tmp7;
//             <    is read   >: tmp11 tmp6
//             <    is written>: tmp5
         /* phase 2 */
         tmp5 = tmp11-tmp6;
//             <    is read   >: tmp10 tmp5
//             <    is written>: tmp4
         tmp4 = tmp10+tmp5;
//             <    is read   >: tmp0 tmp7 wsptr
//             <    is written>: wsptr[8*0]
         wsptr[8*0] = (int) (tmp0+tmp7);
//             <    is read   >: tmp0 tmp7 wsptr
//             <    is written>: wsptr[8*7]
         wsptr[8*7] = (int) (tmp0-tmp7);
//             <    is read   >: tmp1 tmp6 wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = (int) (tmp1+tmp6);
//             <    is read   >: tmp1 tmp6 wsptr
//             <    is written>: wsptr[8*6]
         wsptr[8*6] = (int) (tmp1-tmp6);
//             <    is read   >: tmp2 tmp5 wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = (int) (tmp2+tmp5);
//             <    is read   >: tmp2 tmp5 wsptr
//             <    is written>: wsptr[8*5]
         wsptr[8*5] = (int) (tmp2-tmp5);
//             <    is read   >: tmp3 tmp4 wsptr
//             <    is written>: wsptr[8*4]
         wsptr[8*4] = (int) (tmp3+tmp4);
//             <    is read   >: tmp3 tmp4 wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = (int) (tmp3-tmp4);
//             <    is read   >: inptr
//             <    is written>: inptr

         inptr++;
//             <    is read   >: quantptr
//             <    is written>: quantptr
         /* advance pointers to next column */
         quantptr++;
//             <    is read   >: wsptr
//             <    is written>: wsptr
         wsptr++;
      }
_loop_end_1:      ;
   }
//             <    is written>: wsptr
   
   /* Pass 2: process rows from work array, store into output array. */
   /* Note that we must descale the results by a factor of 8 == 2**3, */
   /* and also undo the PASS1_BITS scaling. */
   
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 0; ctr <= 7; ctr += 1) {
//             <    is read   >: ctr output_buf output_buf[ctr] 
//                               output_col
//             <    is written>: outptr
      outptr = output_buf[ctr]+output_col;
//             <    is read   >: wsptr wsptr[1] wsptr[2] wsptr[3] 
//                               wsptr[4] wsptr[5] wsptr[6] wsptr[7]
      /* Rows of zeroes can be exploited in the same way as we did with columns.
           * However, the column calculation has created many nonzero AC terms, so
           * the simplification applies less often (typically 5% to 10% of the time).
           * On machines with very fast multiplication, it's possible that the
           * test takes more time than it's worth.  In that case this section
           * may be commented out.
           */
      
      
      
      if ((wsptr[1]|wsptr[2]|wsptr[3]|wsptr[4]|wsptr[5]|wsptr[6]|wsptr[7])==0) {
         /* AC terms all zero */
//             <    is read   >: range_limit 
//                               range_limit[(int) (wsptr[0]>>2+3)
//                               &255*4+3] wsptr wsptr[0]
//             <    is written>: 0`3`4`dcval
         JSAMPLE dcval = range_limit[(int) (wsptr[0]>>2+3)&255*4+3];
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[0]

         outptr[0] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[1]
         outptr[1] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[2]
         outptr[2] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[3]
         outptr[3] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[4]
         outptr[4] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[5]
         outptr[5] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[6]
         outptr[6] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[7]
         outptr[7] = dcval;
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
         /* advance pointer to next row */
         ;
      }
      else {
//             <    is read   >: wsptr wsptr[0] wsptr[4]
//             <    is written>: tmp10
         
         
         /* Even part */
         
         tmp10 = (DCTELEM) wsptr[0]+(DCTELEM) wsptr[4];
//             <    is read   >: wsptr wsptr[0] wsptr[4]
//             <    is written>: tmp11
         tmp11 = (DCTELEM) wsptr[0]-((DCTELEM) wsptr[4]);
//             <    is read   >: wsptr wsptr[2] wsptr[6]
//             <    is written>: tmp13
         tmp13 = (DCTELEM) wsptr[2]+(DCTELEM) wsptr[6];
//             <    is read   >: tmp13 wsptr wsptr[2] wsptr[6]
//             <    is written>: tmp12
         tmp12 = (DCTELEM) (((DCTELEM) wsptr[2]-((DCTELEM) wsptr[6]))*(INT32) 362>>8)-tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp0

         tmp0 = tmp10+tmp13;
//             <    is read   >: tmp10 tmp13
//             <    is written>: tmp3
         tmp3 = tmp10-tmp13;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp1
         tmp1 = tmp11+tmp12;
//             <    is read   >: tmp11 tmp12
//             <    is written>: tmp2
         tmp2 = tmp11-tmp12;
//             <    is read   >: wsptr wsptr[3] wsptr[5]
//             <    is written>: z13
         
         /* Odd part */
         
         z13 = (DCTELEM) wsptr[5]+(DCTELEM) wsptr[3];
//             <    is read   >: wsptr wsptr[3] wsptr[5]
//             <    is written>: z10
         z10 = (DCTELEM) wsptr[5]-((DCTELEM) wsptr[3]);
//             <    is read   >: wsptr wsptr[1] wsptr[7]
//             <    is written>: z11
         z11 = (DCTELEM) wsptr[1]+(DCTELEM) wsptr[7];
//             <    is read   >: wsptr wsptr[1] wsptr[7]
//             <    is written>: z12
         z12 = (DCTELEM) wsptr[1]-((DCTELEM) wsptr[7]);
//             <    is read   >: z11 z13
//             <    is written>: tmp7

         tmp7 = z11+z13;
//             <    is read   >: z11 z13
//             <    is written>: tmp11
         /* phase 5 */
         tmp11 = (DCTELEM) ((z11-z13)*(INT32) 362>>8);
//             <    is read   >: z10 z12
//             <    is written>: z5
         /* 2*c4 */
         
         z5 = (DCTELEM) ((z10+z12)*(INT32) 473>>8);
//             <    is read   >: z12 z5
//             <    is written>: tmp10
         /* 2*c2 */
         tmp10 = (DCTELEM) (z12*(INT32) 277>>8)-z5;
//             <    is read   >: z10 z5
//             <    is written>: tmp12
         /* 2*(c2-c6) */
         tmp12 = (DCTELEM) (z10*(-((INT32) 669))>>8)+z5;
//             <    is read   >: tmp12 tmp7
//             <    is written>: tmp6
         /* -2*(c2+c6) */
         
         tmp6 = tmp12-tmp7;
//             <    is read   >: tmp11 tmp6
//             <    is written>: tmp5
         /* phase 2 */
         tmp5 = tmp11-tmp6;
//             <    is read   >: tmp10 tmp5
//             <    is written>: tmp4
         tmp4 = tmp10+tmp5;
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp0+tmp7>>2+3)
//                               &255*4+3] tmp0 tmp7
//             <    is written>: outptr[0]
         
         /* Final output stage: scale down by a factor of 8 and range-limit */
         
         outptr[0] = range_limit[(int) (tmp0+tmp7>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp0-tmp7>>2+3)
//                               &255*4+3] tmp0 tmp7
//             <    is written>: outptr[7]
         outptr[7] = range_limit[(int) (tmp0-tmp7>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp1+tmp6>>2+3)
//                               &255*4+3] tmp1 tmp6
//             <    is written>: outptr[1]
         outptr[1] = range_limit[(int) (tmp1+tmp6>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp1-tmp6>>2+3)
//                               &255*4+3] tmp1 tmp6
//             <    is written>: outptr[6]
         outptr[6] = range_limit[(int) (tmp1-tmp6>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp2+tmp5>>2+3)
//                               &255*4+3] tmp2 tmp5
//             <    is written>: outptr[2]
         outptr[2] = range_limit[(int) (tmp2+tmp5>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp2-tmp5>>2+3)
//                               &255*4+3] tmp2 tmp5
//             <    is written>: outptr[5]
         outptr[5] = range_limit[(int) (tmp2-tmp5>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp3+tmp4>>2+3)
//                               &255*4+3] tmp3 tmp4
//             <    is written>: outptr[4]
         outptr[4] = range_limit[(int) (tmp3+tmp4>>2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp3-tmp4>>2+3)
//                               &255*4+3] tmp3 tmp4
//             <    is written>: outptr[3]
         outptr[3] = range_limit[(int) (tmp3-tmp4>>2+3)&255*4+3];
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
      }
_loop_end_2:      ;
   }
}
void jpeg_idct_islow(j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col)
{
   INT32 tmp0, tmp1, tmp2, tmp3;
   INT32 tmp10, tmp11, tmp12, tmp13;
   INT32 z1, z2, z3, z4, z5;
   JCOEFPTR inptr;
   ISLOW_MULT_TYPE *quantptr;
   int *wsptr;
   JSAMPROW outptr;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit+128;
   int ctr;
   int workspace[64];
//             <    is read   >: coef_block
//             <    is written>: inptr
   /* buffers data between passes */
   
   
   /* Pass 1: process columns from input, store into work array. */
   /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
   /* furthermore, we scale the results by 2**PASS1_BITS. */
   
   inptr = coef_block;
//             <    is read   >: compptr compptr[0].dct_table
//             <    is written>: quantptr
   quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
//             <    is written>: wsptr
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 8; ctr >= 1; ctr += -1) {
//             <    is read   >: inptr inptr[8*1] inptr[8*2] 
//                               inptr[8*3] inptr[8*4] inptr[8*5] 
//                               inptr[8*6] inptr[8*7]
      /* Due to quantization, we will usually find that many of the input
           * coefficients are zero, especially the AC terms.  We can exploit this
           * by short-circuiting the IDCT calculation for any column in which all
           * the AC terms are zero.  In that case each output is equal to the
           * DC coefficient (with scale factor as needed).
           * With typical images and quantization tables, half or more of the
           * column DCT calculations can be simplified this way.
           */
      
      
      
      if ((inptr[8*1]|inptr[8*2]|inptr[8*3]|inptr[8*4]|inptr[8*5]|inptr[8*6]|inptr[8*7])==0) {
         /* AC terms all zero */
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: 0`1`2`dcval
         int dcval = (ISLOW_MULT_TYPE) inptr[8*0]*quantptr[8*0]<<2;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*0]

         wsptr[8*0] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*4]
         wsptr[8*4] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*5]
         wsptr[8*5] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*6]
         wsptr[8*6] = dcval;
//             <    is read   >: 0`1`2`dcval wsptr
//             <    is written>: wsptr[8*7]
         wsptr[8*7] = dcval;
//             <    is read   >: inptr
//             <    is written>: inptr

         inptr++;
//             <    is read   >: quantptr
//             <    is written>: quantptr
         /* advance pointers to next column */
         quantptr++;
//             <    is read   >: wsptr
//             <    is written>: wsptr
         wsptr++;
      }
      else {
//             <    is read   >: inptr inptr[8*2] quantptr 
//                               quantptr[8*2]
//             <    is written>: z2
         
         /* Even part: reverse the even part of the forward DCT. */
         /* The rotator is sqrt(2)*c(-6). */
         
         z2 = (ISLOW_MULT_TYPE) inptr[8*2]*quantptr[8*2];
//             <    is read   >: inptr inptr[8*6] quantptr 
//                               quantptr[8*6]
//             <    is written>: z3
         z3 = (ISLOW_MULT_TYPE) inptr[8*6]*quantptr[8*6];
//             <    is read   >: z2 z3
//             <    is written>: z1
         z1 = (z2+z3)*(INT32) 4433;
//             <    is read   >: z1 z3
//             <    is written>: tmp2
         tmp2 = z1+z3*(-((INT32) 15137));
//             <    is read   >: z1 z2
//             <    is written>: tmp3
         tmp3 = z1+z2*(INT32) 6270;
//             <    is read   >: inptr inptr[8*0] quantptr 
//                               quantptr[8*0]
//             <    is written>: z2
         z2 = (ISLOW_MULT_TYPE) inptr[8*0]*quantptr[8*0];
//             <    is read   >: inptr inptr[8*4] quantptr 
//                               quantptr[8*4]
//             <    is written>: z3
         z3 = (ISLOW_MULT_TYPE) inptr[8*4]*quantptr[8*4];
//             <    is read   >: z2 z3
//             <    is written>: tmp0
         tmp0 = z2+z3<<13;
//             <    is read   >: z2 z3
//             <    is written>: tmp1
         tmp1 = z2-z3<<13;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10

         tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
         tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
         tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
         tmp12 = tmp1-tmp2;
//             <    is read   >: inptr inptr[8*7] quantptr 
//                               quantptr[8*7]
//             <    is written>: tmp0
         
         /* Odd part per figure 8; the matrix is unitary and hence its
              * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
              */
         
         tmp0 = (ISLOW_MULT_TYPE) inptr[8*7]*quantptr[8*7];
//             <    is read   >: inptr inptr[8*5] quantptr 
//                               quantptr[8*5]
//             <    is written>: tmp1
         tmp1 = (ISLOW_MULT_TYPE) inptr[8*5]*quantptr[8*5];
//             <    is read   >: inptr inptr[8*3] quantptr 
//                               quantptr[8*3]
//             <    is written>: tmp2
         tmp2 = (ISLOW_MULT_TYPE) inptr[8*3]*quantptr[8*3];
//             <    is read   >: inptr inptr[8*1] quantptr 
//                               quantptr[8*1]
//             <    is written>: tmp3
         tmp3 = (ISLOW_MULT_TYPE) inptr[8*1]*quantptr[8*1];
//             <    is read   >: tmp0 tmp3
//             <    is written>: z1

         z1 = tmp0+tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: z2
         z2 = tmp1+tmp2;
//             <    is read   >: tmp0 tmp2
//             <    is written>: z3
         z3 = tmp0+tmp2;
//             <    is read   >: tmp1 tmp3
//             <    is written>: z4
         z4 = tmp1+tmp3;
//             <    is read   >: z3 z4
//             <    is written>: z5
         z5 = (z3+z4)*(INT32) 9633;
//             <    is read   >: tmp0
//             <    is written>: tmp0
         /* sqrt(2) * c3 */
         
         tmp0 = tmp0*(INT32) 2446;
//             <    is read   >: tmp1
//             <    is written>: tmp1
         /* sqrt(2) * (-c1+c3+c5-c7) */
         tmp1 = tmp1*(INT32) 16819;
//             <    is read   >: tmp2
//             <    is written>: tmp2
         /* sqrt(2) * ( c1+c3-c5+c7) */
         tmp2 = tmp2*(INT32) 25172;
//             <    is read   >: tmp3
//             <    is written>: tmp3
         /* sqrt(2) * ( c1+c3+c5-c7) */
         tmp3 = tmp3*(INT32) 12299;
//             <    is read   >: z1
//             <    is written>: z1
         /* sqrt(2) * ( c1+c3-c5-c7) */
         z1 = z1*(-((INT32) 7373));
//             <    is read   >: z2
//             <    is written>: z2
         /* sqrt(2) * (c7-c3) */
         z2 = z2*(-((INT32) 20995));
//             <    is read   >: z3
//             <    is written>: z3
         /* sqrt(2) * (-c1-c3) */
         z3 = z3*(-((INT32) 16069));
//             <    is read   >: z4
//             <    is written>: z4
         /* sqrt(2) * (-c3-c5) */
         z4 = z4*(-((INT32) 3196));
//             <    is read   >: z3 z5
//             <    is written>: z3
         /* sqrt(2) * (c5-c3) */
         
         z3 += z5;
//             <    is read   >: z4 z5
//             <    is written>: z4
         z4 += z5;
//             <    is read   >: tmp0 z1 z3
//             <    is written>: tmp0

         tmp0 += z1+z3;
//             <    is read   >: tmp1 z2 z4
//             <    is written>: tmp1
         tmp1 += z2+z4;
//             <    is read   >: tmp2 z2 z3
//             <    is written>: tmp2
         tmp2 += z2+z3;
//             <    is read   >: tmp3 z1 z4
//             <    is written>: tmp3
         tmp3 += z1+z4;
//             <    is read   >: tmp10 tmp3 wsptr
//             <    is written>: wsptr[8*0]
         
         /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
         
         wsptr[8*0] = (int) (tmp10+tmp3+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp10 tmp3 wsptr
//             <    is written>: wsptr[8*7]
         wsptr[8*7] = (int) (tmp10-tmp3+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp11 tmp2 wsptr
//             <    is written>: wsptr[8*1]
         wsptr[8*1] = (int) (tmp11+tmp2+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp11 tmp2 wsptr
//             <    is written>: wsptr[8*6]
         wsptr[8*6] = (int) (tmp11-tmp2+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp1 tmp12 wsptr
//             <    is written>: wsptr[8*2]
         wsptr[8*2] = (int) (tmp12+tmp1+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp1 tmp12 wsptr
//             <    is written>: wsptr[8*5]
         wsptr[8*5] = (int) (tmp12-tmp1+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp0 tmp13 wsptr
//             <    is written>: wsptr[8*3]
         wsptr[8*3] = (int) (tmp13+tmp0+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: tmp0 tmp13 wsptr
//             <    is written>: wsptr[8*4]
         wsptr[8*4] = (int) (tmp13-tmp0+((INT32) 1<<13-2-1)>>13-2);
//             <    is read   >: inptr
//             <    is written>: inptr

         inptr++;
//             <    is read   >: quantptr
//             <    is written>: quantptr
         /* advance pointers to next column */
         quantptr++;
//             <    is read   >: wsptr
//             <    is written>: wsptr
         wsptr++;
      }
_loop_end_1:      ;
   }
//             <    is written>: wsptr
   
   /* Pass 2: process rows from work array, store into output array. */
   /* Note that we must descale the results by a factor of 8 == 2**3, */
   /* and also undo the PASS1_BITS scaling. */
   
   wsptr = workspace;
//             <    is written>: ctr
   for(ctr = 0; ctr <= 7; ctr += 1) {
//             <    is read   >: ctr output_buf output_buf[ctr] 
//                               output_col
//             <    is written>: outptr
      outptr = output_buf[ctr]+output_col;
//             <    is read   >: wsptr wsptr[1] wsptr[2] wsptr[3] 
//                               wsptr[4] wsptr[5] wsptr[6] wsptr[7]
      /* Rows of zeroes can be exploited in the same way as we did with columns.
           * However, the column calculation has created many nonzero AC terms, so
           * the simplification applies less often (typically 5% to 10% of the time).
           * On machines with very fast multiplication, it's possible that the
           * test takes more time than it's worth.  In that case this section
           * may be commented out.
           */
      
      
      
      if ((wsptr[1]|wsptr[2]|wsptr[3]|wsptr[4]|wsptr[5]|wsptr[6]|wsptr[7])==0) {
         /* AC terms all zero */
//             <    is read   >: range_limit 
//                               range_limit[(int) ((INT32) wsptr[0]+(
//                               (INT32) 1<<2+3-1)>>2+3)
//                               &255*4+3] wsptr wsptr[0]
//             <    is written>: 0`3`4`dcval
         JSAMPLE dcval = range_limit[(int) ((INT32) wsptr[0]+((INT32) 1<<2+3-1)>>2+3)&255*4+3];
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[0]

         outptr[0] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[1]
         outptr[1] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[2]
         outptr[2] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[3]
         outptr[3] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[4]
         outptr[4] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[5]
         outptr[5] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[6]
         outptr[6] = dcval;
//             <    is read   >: 0`3`4`dcval outptr
//             <    is written>: outptr[7]
         outptr[7] = dcval;
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
         /* advance pointer to next row */
         ;
      }
      else {
//             <    is read   >: wsptr wsptr[2]
//             <    is written>: z2
         
         
         /* Even part: reverse the even part of the forward DCT. */
         /* The rotator is sqrt(2)*c(-6). */
         
         z2 = (INT32) wsptr[2];
//             <    is read   >: wsptr wsptr[6]
//             <    is written>: z3
         z3 = (INT32) wsptr[6];
//             <    is read   >: z2 z3
//             <    is written>: z1
         z1 = (z2+z3)*(INT32) 4433;
//             <    is read   >: z1 z3
//             <    is written>: tmp2
         tmp2 = z1+z3*(-((INT32) 15137));
//             <    is read   >: z1 z2
//             <    is written>: tmp3
         tmp3 = z1+z2*(INT32) 6270;
//             <    is read   >: wsptr wsptr[0] wsptr[4]
//             <    is written>: tmp0
         tmp0 = (INT32) wsptr[0]+(INT32) wsptr[4]<<13;
//             <    is read   >: wsptr wsptr[0] wsptr[4]
//             <    is written>: tmp1
         tmp1 = (INT32) wsptr[0]-((INT32) wsptr[4])<<13;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp10

         tmp10 = tmp0+tmp3;
//             <    is read   >: tmp0 tmp3
//             <    is written>: tmp13
         tmp13 = tmp0-tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp11
         tmp11 = tmp1+tmp2;
//             <    is read   >: tmp1 tmp2
//             <    is written>: tmp12
         tmp12 = tmp1-tmp2;
//             <    is read   >: wsptr wsptr[7]
//             <    is written>: tmp0
         
         /* Odd part per figure 8; the matrix is unitary and hence its
              * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
              */
         
         tmp0 = (INT32) wsptr[7];
//             <    is read   >: wsptr wsptr[5]
//             <    is written>: tmp1
         tmp1 = (INT32) wsptr[5];
//             <    is read   >: wsptr wsptr[3]
//             <    is written>: tmp2
         tmp2 = (INT32) wsptr[3];
//             <    is read   >: wsptr wsptr[1]
//             <    is written>: tmp3
         tmp3 = (INT32) wsptr[1];
//             <    is read   >: tmp0 tmp3
//             <    is written>: z1

         z1 = tmp0+tmp3;
//             <    is read   >: tmp1 tmp2
//             <    is written>: z2
         z2 = tmp1+tmp2;
//             <    is read   >: tmp0 tmp2
//             <    is written>: z3
         z3 = tmp0+tmp2;
//             <    is read   >: tmp1 tmp3
//             <    is written>: z4
         z4 = tmp1+tmp3;
//             <    is read   >: z3 z4
//             <    is written>: z5
         z5 = (z3+z4)*(INT32) 9633;
//             <    is read   >: tmp0
//             <    is written>: tmp0
         /* sqrt(2) * c3 */
         
         tmp0 = tmp0*(INT32) 2446;
//             <    is read   >: tmp1
//             <    is written>: tmp1
         /* sqrt(2) * (-c1+c3+c5-c7) */
         tmp1 = tmp1*(INT32) 16819;
//             <    is read   >: tmp2
//             <    is written>: tmp2
         /* sqrt(2) * ( c1+c3-c5+c7) */
         tmp2 = tmp2*(INT32) 25172;
//             <    is read   >: tmp3
//             <    is written>: tmp3
         /* sqrt(2) * ( c1+c3+c5-c7) */
         tmp3 = tmp3*(INT32) 12299;
//             <    is read   >: z1
//             <    is written>: z1
         /* sqrt(2) * ( c1+c3-c5-c7) */
         z1 = z1*(-((INT32) 7373));
//             <    is read   >: z2
//             <    is written>: z2
         /* sqrt(2) * (c7-c3) */
         z2 = z2*(-((INT32) 20995));
//             <    is read   >: z3
//             <    is written>: z3
         /* sqrt(2) * (-c1-c3) */
         z3 = z3*(-((INT32) 16069));
//             <    is read   >: z4
//             <    is written>: z4
         /* sqrt(2) * (-c3-c5) */
         z4 = z4*(-((INT32) 3196));
//             <    is read   >: z3 z5
//             <    is written>: z3
         /* sqrt(2) * (c5-c3) */
         
         z3 += z5;
//             <    is read   >: z4 z5
//             <    is written>: z4
         z4 += z5;
//             <    is read   >: tmp0 z1 z3
//             <    is written>: tmp0

         tmp0 += z1+z3;
//             <    is read   >: tmp1 z2 z4
//             <    is written>: tmp1
         tmp1 += z2+z4;
//             <    is read   >: tmp2 z2 z3
//             <    is written>: tmp2
         tmp2 += z2+z3;
//             <    is read   >: tmp3 z1 z4
//             <    is written>: tmp3
         tmp3 += z1+z4;
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp10+tmp3+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp10 tmp3
//             <    is written>: outptr[0]
         
         /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
         
         outptr[0] = range_limit[(int) (tmp10+tmp3+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp10-tmp3+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp10 tmp3
//             <    is written>: outptr[7]
         outptr[7] = range_limit[(int) (tmp10-tmp3+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp11+tmp2+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp11 tmp2
//             <    is written>: outptr[1]
         outptr[1] = range_limit[(int) (tmp11+tmp2+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp11-tmp2+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp11 tmp2
//             <    is written>: outptr[6]
         outptr[6] = range_limit[(int) (tmp11-tmp2+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp12+tmp1+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp1 tmp12
//             <    is written>: outptr[2]
         outptr[2] = range_limit[(int) (tmp12+tmp1+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp12-tmp1+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp1 tmp12
//             <    is written>: outptr[5]
         outptr[5] = range_limit[(int) (tmp12-tmp1+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp13+tmp0+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp0 tmp13
//             <    is written>: outptr[3]
         outptr[3] = range_limit[(int) (tmp13+tmp0+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: outptr range_limit 
//                               range_limit[(int) (tmp13-tmp0+((INT32
//                               ) 1<<13+2+3-1)>>13+2+3)
//                               &255*4+3] tmp0 tmp13
//             <    is written>: outptr[4]
         outptr[4] = range_limit[(int) (tmp13-tmp0+((INT32) 1<<13+2+3-1)>>13+2+3)&255*4+3];
//             <    is read   >: wsptr
//             <    is written>: wsptr

         wsptr += 8;
      }
_loop_end_2:      ;
   }
}
boolean jpeg_input_complete(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].global_state 
//                               cinfo[0].global_state
   /* Check for valid jpeg object */
   
   if (cinfo->global_state<200||cinfo->global_state>210)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].eoi_reached
   return cinfo->inputctl->eoi_reached;
}
void jpeg_make_c_derived_tbl(j_compress_ptr cinfo, JHUFF_TBL *htbl, c_derived_tbl **pdtbl)
{
   c_derived_tbl *dtbl;
   int p, i, l, lastp, si;
   char huffsize[257];
   unsigned int huffcode[257];
   unsigned int code;
//             <    is read   >: pdtbl pdtbl[0]
   
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      *pdtbl = (c_derived_tbl *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(c_derived_tbl));
//             <    is read   >: pdtbl pdtbl[0]
//             <    is written>: dtbl
   dtbl = *pdtbl;
//             <    is written>: p
   
   /* Figure C.1: make table of Huffman code length for each symbol */
   /* Note that this is in code-length order. */
   
   p = 0;
//             <    is written>: l
   for(l = 1; l <= 16; l += 1)
//             <    is read   >: htbl htbl[0].bits[l] l
//             <    is written>: i
      for(i = 1; i <= (int) (htbl->bits)[l]; i += 1)
//             <    is read   >: htbl htbl[0].bits[l] l p
//             <    is written>: huffsize[p++] p
         huffsize[p++] = (char) l;
//             <    is read   >: p
//             <    is written>: huffsize[p]
   huffsize[p] = 0;
//             <    is read   >: p
//             <    is written>: lastp
   lastp = p;
//             <    is written>: code
   
   /* Figure C.2: generate the codes themselves */
   /* Note that this is in code-length order. */
   
   code = 0;
//             <    is read   >: huffsize[0]
//             <    is written>: si
   si = huffsize[0];
//             <    is written>: p
   p = 0;
//             <    is read   >: huffsize[p] p
   while (huffsize[p]) {
//             <    is read   >: huffsize[p] p si
      while ((int) huffsize[p]==si) {
//             <    is read   >: code p
//             <    is written>: huffcode[p++] p
         huffcode[p++] = code;
//             <    is read   >: code
//             <    is written>: code
         code++;
      }
//             <    is read   >: code
//             <    is written>: code
      code <<= 1;
//             <    is read   >: si
//             <    is written>: si
      si++;
   }
//             <    is read   >: dtbl
//             <    is written>: 
//                               dtbl[0].ehufsi[0:(size_t) (size_t)
//                               sizeof(dtbl->ehufsi)-1]
   
   /* Figure C.3: generate encoding tables */
   /* These are code and size indexed by symbol value */
   
   /* Set any codeless symbols to have code length 0;
      * this allows emit_bits to detect any attempt to emit such symbols.
      */
   memset((void *) dtbl->ehufsi, 0, (size_t) (size_t) sizeof(dtbl->ehufsi));
//             <    is read   >: lastp
//             <    is written>: p

   for(p = 0; p <= lastp-1; p += 1) {
//             <    is read   >: dtbl htbl htbl[0].huffval[p] 
//                               huffcode[p] lastp p
//             <    is written>: dtbl[0].ehufco[(htbl->huffval)[p]]
      (dtbl->ehufco)[(htbl->huffval)[p]] = huffcode[p];
//             <    is read   >: dtbl htbl htbl[0].huffval[p] 
//                               huffsize[p] lastp p
//             <    is written>: dtbl[0].ehufsi[(htbl->huffval)[p]]
      (dtbl->ehufsi)[(htbl->huffval)[p]] = huffsize[p];
   }
}
void jpeg_make_d_derived_tbl(j_decompress_ptr cinfo, JHUFF_TBL *htbl, d_derived_tbl **pdtbl)
{
   d_derived_tbl *dtbl;
   int p, i, l, si;
   int lookbits, ctr;
   char huffsize[257];
   unsigned int huffcode[257];
   unsigned int code;
//             <    is read   >: pdtbl pdtbl[0]
   
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      *pdtbl = (d_derived_tbl *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(d_derived_tbl));
//             <    is read   >: pdtbl pdtbl[0]
//             <    is written>: dtbl
   dtbl = *pdtbl;
//             <    is read   >: dtbl htbl
//             <    is written>: dtbl[0].pub
   dtbl->pub = htbl;
//             <    is written>: p
   /* fill in back link */
   
   /* Figure C.1: make table of Huffman code length for each symbol */
   /* Note that this is in code-length order. */
   
   p = 0;
//             <    is written>: l
   for(l = 1; l <= 16; l += 1)
//             <    is read   >: htbl htbl[0].bits[l] l
//             <    is written>: i
      for(i = 1; i <= (int) (htbl->bits)[l]; i += 1)
//             <    is read   >: htbl htbl[0].bits[l] l p
//             <    is written>: huffsize[p++] p
         huffsize[p++] = (char) l;
//             <    is read   >: p
//             <    is written>: huffsize[p]
   huffsize[p] = 0;
//             <    is written>: code
   
   /* Figure C.2: generate the codes themselves */
   /* Note that this is in code-length order. */
   
   code = 0;
//             <    is read   >: huffsize[0]
//             <    is written>: si
   si = huffsize[0];
//             <    is written>: p
   p = 0;
//             <    is read   >: huffsize[p] p
   while (huffsize[p]) {
//             <    is read   >: huffsize[p] p si
      while ((int) huffsize[p]==si) {
//             <    is read   >: code p
//             <    is written>: huffcode[p++] p
         huffcode[p++] = code;
//             <    is read   >: code
//             <    is written>: code
         code++;
      }
//             <    is read   >: code
//             <    is written>: code
      code <<= 1;
//             <    is read   >: si
//             <    is written>: si
      si++;
   }
//             <    is written>: p
   
   /* Figure F.15: generate decoding tables for bit-sequential decoding */
   
   p = 0;
//             <    is written>: l
   for(l = 1; l <= 16; l += 1)
//             <    is read   >: htbl htbl[0].bits[l] l
      if ((htbl->bits)[l]) {
//             <    is read   >: dtbl l p
//             <    is written>: dtbl[0].valptr[l]
         (dtbl->valptr)[l] = p;
//             <    is read   >: dtbl huffcode[p] l p
//             <    is written>: dtbl[0].mincode[l]
         /* huffval[] index of 1st symbol of code length l */
         (dtbl->mincode)[l] = huffcode[p];
//             <    is read   >: htbl htbl[0].bits[l] l p
//             <    is written>: p
         /* minimum code of length l */
         p += (htbl->bits)[l];
//             <    is read   >: dtbl huffcode[p-1] l p
//             <    is written>: dtbl[0].maxcode[l]
         (dtbl->maxcode)[l] = huffcode[p-1];
      }
      else
//             <    is read   >: dtbl l
//             <    is written>: dtbl[0].maxcode[l]
         (dtbl->maxcode)[l] = -1;
//             <    is read   >: dtbl
//             <    is written>: dtbl[0].maxcode[17]
   (dtbl->maxcode)[17] = 0xFFFFFL;
//             <may be written>: dtbl[0].look_nbits[*]
//             <    is read   >: dtbl
   /* ensures jpeg_huff_decode terminates */
   
   /* Compute lookahead tables to speed up decoding.
      * First we set all the table entries to 0, indicating "too long";
      * then we iterate through the Huffman codes that are short enough and
      * fill in all the entries that correspond to bit sequences starting
      * with that code.
      */
   
   memset((void *) dtbl->look_nbits, 0, (size_t) (size_t) sizeof(dtbl->look_nbits));
//             <    is written>: p

   p = 0;
//             <    is written>: l
   for(l = 1; l <= 8; l += 1)
//             <    is read   >: htbl htbl[0].bits[l] l
//             <    is written>: i
      for(i = 1; i <= (int) (htbl->bits)[l]; i += 1) {
//             <    is read   >: htbl htbl[0].bits[l] huffcode[p] l p
//             <    is written>: lookbits
         /* l = current code's length, p = its index in huffcode[] & huffval[]. */
         /* Generate left-justified code followed by all possible bit sequences */
         lookbits = huffcode[p]<<8-l;
//             <    is read   >: htbl htbl[0].bits[l] l
//             <    is written>: ctr
         for(ctr = 1<<8-l; ctr >= 1; ctr += -1) {
//             <    is read   >: dtbl htbl htbl[0].bits[l] l lookbits
//             <    is written>: dtbl[0].look_nbits[lookbits]
            (dtbl->look_nbits)[lookbits] = l;
//             <    is read   >: dtbl htbl htbl[0].bits[l] 
//                               htbl[0].huffval[p] l lookbits p
//             <    is written>: dtbl[0].look_sym[lookbits]
            (dtbl->look_sym)[lookbits] = (htbl->huffval)[p];
//             <    is read   >: htbl htbl[0].bits[l] l lookbits
//             <    is written>: lookbits
            lookbits++;
         }
//             <    is read   >: htbl htbl[0].bits[l] l p
//             <    is written>: p
         p++;
      }
}
long int jpeg_mem_available(j_common_ptr cinfo, long int min_bytes_needed, long int max_bytes_needed, long int already_allocated)
{
//             <    is read   >: max_bytes_needed
   return max_bytes_needed;
}
long int jpeg_mem_init(j_common_ptr cinfo)
{
   return 0;
}
void jpeg_mem_term(j_common_ptr cinfo)
{
}
void jpeg_new_colormap(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].master
//             <    is written>: master
   my_master_ptr master = (my_master_ptr) cinfo->master;
//             <    is read   >: cinfo cinfo[0].global_state
   
   /* Prevent application from calling me at wrong times */
   if (cinfo->global_state!=207)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].enable_external_quant 
//                               cinfo[0].quantize_colors
   if (cinfo->quantize_colors&&cinfo->enable_external_quant&&cinfo->colormap!=(void *) 0) {
//             <    is read   >: cinfo master 
//                               master[0].quantizer_2pass
//             <    is written>: cinfo[0].cquantize
      /* Select 2-pass quantizer for external colormap use */
      cinfo->cquantize = master->quantizer_2pass;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Notify quantizer of colormap change */
      (*cinfo->cquantize->new_color_map)(cinfo);
//             <    is read   >: master
//             <    is written>: master[0].pub.is_dummy_pass
      master->pub.is_dummy_pass = 0;
   }
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_MODE_CHANGE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
void jpeg_open_backing_store(j_common_ptr cinfo, backing_store_ptr info, long int total_bytes_needed)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JERR_NO_BACKING_STORE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
int jpeg_quality_scaling(int quality)
{
//             <    is read   >: quality
   /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
   if (quality<=0)
//             <    is written>: quality
      quality = 1;
//             <    is read   >: quality
   if (quality>100)
//             <    is written>: quality
      quality = 100;
//             <    is read   >: quality
   
   /* The basic table is used as-is (scaling 100) for a quality of 50.
      * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
      * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
      * to make all the table entries 1 (hence, minimum quantization loss).
      * Qualities 1..50 are converted to scaling percentage 5000/Q.
      */
   if (quality<50)
//             <    is read   >: quality
//             <    is written>: quality
      quality = 5000/quality;
   else
//             <    is read   >: quality
//             <    is written>: quality
      quality = 200-quality*2;
//             <    is read   >: quality

   return quality;
}
jvirt_barray_ptr * jpeg_read_coefficients(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==202) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* First call: initialize active modules */
      transdecode_master_selection(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      cinfo->global_state = 209;
   }
   else if (cinfo->global_state!=209)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
l99999:   ;
/* Absorb whole file into the coef buffer */
   if (!1) goto _break_1;
   int retcode;
//             <    is read   >: cinfo cinfo[0].progress
   /* Call progress monitor hook if present */
   if (cinfo->progress!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Absorb some more input */
   retcode = (*cinfo->inputctl->consume_input)(cinfo);
//             <    is read   >: retcode
   if (retcode==0)
      return (void *) 0;
//             <    is read   >: retcode
   if (retcode==2) goto _break_1;
//             <    is read   >: cinfo cinfo[0].progress retcode
   if (cinfo->progress!=(void *) 0&&(retcode==3||retcode==1))
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].progress cinfo[0].progress 
//                               cinfo[0].progress[0].pass_counter 
//                               cinfo[0].progress[0].pass_limit
//             <    is written>: cinfo[0].progress[0].pass_counter
      /* Advance progress counter if appropriate */
      if (++cinfo->progress->pass_counter>=cinfo->progress->pass_limit)
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].progress 
//                               cinfo[0].progress[0].pass_limit 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].progress[0].pass_limit
         /* startup underestimated number of scans; ratchet up one scan */
         cinfo->progress->pass_limit += (long int) cinfo->total_iMCU_rows;
   goto l99999;
_break_1:   ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   /* Set state so that jpeg_finish_decompress does the right thing */
   cinfo->global_state = 210;
//             <    is read   >: cinfo cinfo[0].coef 
//                               cinfo[0].coef[0].coef_arrays
   return cinfo->coef->coef_arrays;
}
int jpeg_read_header(j_decompress_ptr cinfo, boolean require_image)
{
   int retcode;
//             <    is read   >: cinfo cinfo[0].global_state 
//                               cinfo[0].global_state
   
   
   if (cinfo->global_state!=200&&cinfo->global_state!=201)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   retcode = jpeg_consume_input(cinfo);
//             <    is read   >: retcode

   if (retcode==1) {
_switch_1_case_1:      ;
//             <    is written>: retcode
      retcode = 1;
   }
   else if (retcode==2) {
_switch_1_case_2:      ;
//             <    is read   >: require_image
      if (require_image)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Complain if application wanted an image */
         cinfo->err->msg_code = JERR_NO_IMAGE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Reset to start state; it would be safer to require the application to
           * call jpeg_abort, but we can't change it now for compatibility reasons.
           * A side effect is to free any temporary memory (there shouldn't be any).
           */
      jpeg_abort((j_common_ptr) cinfo);
//             <    is written>: retcode
      /* sets state = DSTATE_START */
      retcode = 2;
   }
   else if (retcode==0) {
_switch_1_case_0:      ;
      /* no work */
      ;
   }
_break_1:   ;
//             <    is read   >: retcode

   return retcode;
}
JDIMENSION jpeg_read_raw_data(j_decompress_ptr cinfo, JSAMPIMAGE data, JDIMENSION max_lines)
{
   JDIMENSION lines_per_iMCU_row;
//             <    is read   >: cinfo cinfo[0].global_state

   if (cinfo->global_state!=206)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].output_height 
//                               cinfo[0].output_scanline
   if (cinfo->output_scanline>=cinfo->output_height) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_TOO_MUCH_DATA, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
      return 0;
   }
//             <    is read   >: cinfo cinfo[0].progress
   
   /* Call progress monitor hook if present */
   if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].output_scanline 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
      cinfo->progress->pass_counter = (long int) cinfo->output_scanline;
//             <    is read   >: cinfo cinfo[0].output_height 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_limit
      cinfo->progress->pass_limit = (long int) cinfo->output_height;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
   }
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor 
//                               cinfo[0].min_DCT_scaled_size
//             <    is written>: lines_per_iMCU_row
   
   /* Verify that at least one iMCU row can be returned. */
   lines_per_iMCU_row = cinfo->max_v_samp_factor*cinfo->min_DCT_scaled_size;
//             <    is read   >: lines_per_iMCU_row max_lines
   if (max_lines<lines_per_iMCU_row)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BUFFER_SIZE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Decompress directly into user's buffer. */
   if (!(*cinfo->coef->decompress_data)(cinfo,data))
      return 0;
//             <    is read   >: cinfo cinfo[0].output_scanline 
//                               lines_per_iMCU_row
//             <    is written>: cinfo[0].output_scanline
   /* suspension forced, can do nothing more */
   
   /* OK, we processed one iMCU row. */
   cinfo->output_scanline += lines_per_iMCU_row;
//             <    is read   >: lines_per_iMCU_row
   return lines_per_iMCU_row;
}
JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION max_lines)
{
   JDIMENSION row_ctr;
//             <    is read   >: cinfo cinfo[0].global_state

   if (cinfo->global_state!=205)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].output_height 
//                               cinfo[0].output_scanline
   if (cinfo->output_scanline>=cinfo->output_height) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_TOO_MUCH_DATA, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
      return 0;
   }
//             <    is read   >: cinfo cinfo[0].progress
   
   /* Call progress monitor hook if present */
   if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].output_scanline 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
      cinfo->progress->pass_counter = (long int) cinfo->output_scanline;
//             <    is read   >: cinfo cinfo[0].output_height 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_limit
      cinfo->progress->pass_limit = (long int) cinfo->output_height;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
   }
//             <    is written>: row_ctr
   
   /* Process some data */
   row_ctr = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->main->process_data)(cinfo,scanlines,&row_ctr,max_lines);
//             <    is read   >: cinfo cinfo[0].output_scanline 
//                               row_ctr
//             <    is written>: cinfo[0].output_scanline
   cinfo->output_scanline += row_ctr;
//             <    is read   >: row_ctr
   return row_ctr;
}
boolean jpeg_resync_to_restart(j_decompress_ptr cinfo, int desired)
{
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: marker
   int marker = cinfo->unread_marker;
//             <    is written>: action
   int action = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Always put up a warning. */
   cinfo->err->msg_code = JWRN_MUST_RESYNC, (cinfo->err->msg_parm.i)[0] = marker, (cinfo->err->msg_parm.i)[1] = desired, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
   
   /* Outer loop handles repeated decision after scanning forward. */
   while (1) {
//             <    is read   >: marker
      if (marker<(int) M_SOF0)
//             <    is written>: action
         action = 2;
      else if (marker<(int) M_RST0||marker>(int) M_RST7)
//             <    is written>: action
         action = 3;
      else if (marker==(int) M_RST0+(desired+1&7)||marker==(int) M_RST0+(desired+2&7))
//             <    is written>: action
         action = 3;
      else if (marker==(int) M_RST0+(desired-1&7)||marker==(int) M_RST0+(desired-2&7))
//             <    is written>: action
         action = 2;
      else
//             <    is written>: action
         action = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_RECOVERY_ACTION, (cinfo->err->msg_parm.i)[0] = marker, (cinfo->err->msg_parm.i)[1] = action, (*cinfo->err->emit_message)((j_common_ptr) cinfo,4);
//             <    is read   >: action
      if (action==1) goto _switch_2_case_1;
//             <    is read   >: action
      if (action==2) goto _switch_2_case_2;
//             <    is read   >: action
      if (action==3) {
_switch_2_case_3:         ;
         /* Return without advancing past this marker. */
         /* Entropy decoder will be forced to process an empty segment. */
         return 1;
      }
      goto _break_2;
_switch_2_case_2:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* Scan to the next marker, and repeat the decision loop. */
      if (!next_marker(cinfo))
         return 0;
//             <    is read   >: cinfo cinfo[0].unread_marker
//             <    is written>: marker
      marker = cinfo->unread_marker;
      goto _break_2;
_switch_2_case_1:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].unread_marker
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
      return 1;
_break_2:      ;
   }
}
void jpeg_set_colorspace(j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
{
   jpeg_component_info *compptr;
   int ci;
//             <    is read   >: cinfo cinfo[0].global_state
   /* Safety check to ensure start_compress not called yet. */
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo colorspace
//             <    is written>: cinfo[0].jpeg_color_space
   
   /* For all colorspaces, we use Q and Huff tables 0 for luminance components,
      * tables 1 for chrominance components.
      */
   
   cinfo->jpeg_color_space = colorspace;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_JFIF_header

   cinfo->write_JFIF_header = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_Adobe_marker
   /* No marker for non-JFIF colorspaces */
   cinfo->write_Adobe_marker = 0;
//             <    is read   >: colorspace
   /* write no Adobe marker by default */
   
   if (colorspace==JCS_GRAYSCALE) {
_switch_1_case_JCS_GRAYSCALE:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_JFIF_header
      cinfo->write_JFIF_header = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_components
      /* Write a JFIF marker */
      cinfo->num_components = 1;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* JFIF specifies component ID 1 */
      compptr = &(cinfo->comp_info)[0], compptr->component_id = 1, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
   }
   else if (colorspace==JCS_RGB) {
_switch_1_case_JCS_RGB:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_Adobe_marker
      cinfo->write_Adobe_marker = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_components
      /* write Adobe marker to flag RGB */
      cinfo->num_components = 3;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'R' */
      compptr = &(cinfo->comp_info)[0], compptr->component_id = 0x52, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'G' */
      compptr = &(cinfo->comp_info)[1], compptr->component_id = 0x47, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'B' */
      compptr = &(cinfo->comp_info)[2], compptr->component_id = 0x42, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
   }
   else if (colorspace==JCS_YCbCr) {
_switch_1_case_JCS_YCbCr:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_JFIF_header
      cinfo->write_JFIF_header = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_components
      /* Write a JFIF marker */
      cinfo->num_components = 3;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* JFIF specifies component IDs 1,2,3 */
      /* We default to 2x2 subsamples of chrominance */
      compptr = &(cinfo->comp_info)[0], compptr->component_id = 1, compptr->h_samp_factor = 2, compptr->v_samp_factor = 2, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      compptr = &(cinfo->comp_info)[1], compptr->component_id = 2, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no = 1, compptr->ac_tbl_no = 1;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      compptr = &(cinfo->comp_info)[2], compptr->component_id = 3, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no = 1, compptr->ac_tbl_no = 1;
   }
   else if (colorspace==JCS_CMYK) {
_switch_1_case_JCS_CMYK:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_Adobe_marker
      cinfo->write_Adobe_marker = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_components
      /* write Adobe marker to flag CMYK */
      cinfo->num_components = 4;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'C' */
      compptr = &(cinfo->comp_info)[0], compptr->component_id = 0x43, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'M' */
      compptr = &(cinfo->comp_info)[1], compptr->component_id = 0x4D, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'Y' */
      compptr = &(cinfo->comp_info)[2], compptr->component_id = 0x59, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      /* 'K' */
      compptr = &(cinfo->comp_info)[3], compptr->component_id = 0x4B, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
   }
   else if (colorspace==JCS_YCCK) {
_switch_1_case_JCS_YCCK:      ;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].write_Adobe_marker
      cinfo->write_Adobe_marker = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_components
      /* write Adobe marker to flag YCCK */
      cinfo->num_components = 4;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      compptr = &(cinfo->comp_info)[0], compptr->component_id = 1, compptr->h_samp_factor = 2, compptr->v_samp_factor = 2, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      compptr = &(cinfo->comp_info)[1], compptr->component_id = 2, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no = 1, compptr->ac_tbl_no = 1;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      compptr = &(cinfo->comp_info)[2], compptr->component_id = 3, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no = 1, compptr->ac_tbl_no = 1;
//             <    is read   >: cinfo cinfo[0].comp_info compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
      compptr = &(cinfo->comp_info)[3], compptr->component_id = 4, compptr->h_samp_factor = 2, compptr->v_samp_factor = 2, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
   }
   else if (colorspace==JCS_UNKNOWN) {
_switch_1_case_JCS_UNKNOWN:      ;
//             <    is read   >: cinfo cinfo[0].input_components
//             <    is written>: cinfo[0].num_components
      cinfo->num_components = cinfo->input_components;
//             <    is read   >: cinfo cinfo[0].num_components 
//                               cinfo[0].num_components
      if (cinfo->num_components<1||cinfo->num_components>10)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_COMPONENT_COUNT, (cinfo->err->msg_parm.i)[0] = cinfo->num_components, (cinfo->err->msg_parm.i)[1] = 10, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ci
      for(ci = 0; ci <= cinfo->num_components-1; ci += 1)
//             <    is read   >: ci cinfo cinfo[0].comp_info 
//                               cinfo[0].num_components compptr
//             <    is written>: compptr compptr[0].ac_tbl_no 
//                               compptr[0].component_id 
//                               compptr[0].dc_tbl_no 
//                               compptr[0].h_samp_factor 
//                               compptr[0].quant_tbl_no 
//                               compptr[0].v_samp_factor
         compptr = &(cinfo->comp_info)[ci], compptr->component_id = ci, compptr->h_samp_factor = 1, compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
   }
   else {
_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_J_COLORSPACE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
}
void jpeg_set_defaults(j_compress_ptr cinfo)
{
   int i;
//             <    is read   >: cinfo cinfo[0].global_state
   
   /* Safety check to ensure start_compress not called yet. */
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].comp_info
   
   /* Allocate comp_info array large enough for maximum component count.
      * Array is made permanent in case application wants to compress
      * multiple images at same param settings.
      */
   if (cinfo->comp_info==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,10*(size_t) sizeof(jpeg_component_info));
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].data_precision
   
   /* Initialize everything not dependent on the color space */
   
   cinfo->data_precision = 8;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Set up two quantization tables using default quality of 75 */
   jpeg_set_quality(cinfo, 75, 1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Set up two Huffman tables */
   std_huff_tables(cinfo);
//             <    is written>: i
   
   /* Initialize default arithmetic coding conditioning */
   for(i = 0; i <= 15; i += 1) {
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].arith_dc_L[i]
      (cinfo->arith_dc_L)[i] = 0;
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].arith_dc_U[i]
      (cinfo->arith_dc_U)[i] = 1;
//             <    is read   >: cinfo i
//             <    is written>: cinfo[0].arith_ac_K[i]
      (cinfo->arith_ac_K)[i] = 5;
   }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].scan_info
   
   /* Default is no multiple-scan output */
   cinfo->scan_info = (void *) 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].num_scans
   cinfo->num_scans = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].raw_data_in
   
   /* Expect normal source image, not raw downsampled data */
   cinfo->raw_data_in = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].arith_code
   
   /* Use Huffman coding, not arithmetic coding, by default */
   cinfo->arith_code = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].optimize_coding
   
   /* By default, don't do extra passes to optimize entropy coding */
   cinfo->optimize_coding = 0;
//             <    is read   >: cinfo cinfo[0].data_precision
   /* The standard Huffman tables are only valid for 8-bit data precision.
      * If the precision is higher, force optimization on so that usable
      * tables will be computed.  This test can be removed if default tables
      * are supplied that are valid for the desired precision.
      */
   if (cinfo->data_precision>8)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].optimize_coding
      cinfo->optimize_coding = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].CCIR601_sampling
   
   /* By default, use the simpler non-cosited sampling alignment */
   cinfo->CCIR601_sampling = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].smoothing_factor
   
   /* No input smoothing */
   cinfo->smoothing_factor = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].dct_method
   
   /* DCT algorithm preference */
   cinfo->dct_method = JDCT_ISLOW;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].restart_interval
   
   /* No restart markers */
   cinfo->restart_interval = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].restart_in_rows
   cinfo->restart_in_rows = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].density_unit
   
   /* Fill in default JFIF marker parameters.  Note that whether the marker
      * will actually be written is determined by jpeg_set_colorspace.
      */
   cinfo->density_unit = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].X_density
   /* Pixel size is unknown by default */
   cinfo->X_density = 1;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].Y_density
   /* Pixel aspect ratio is square by default */
   cinfo->Y_density = 1;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Choose JPEG colorspace based on input space, set defaults accordingly */
   
   jpeg_default_colorspace(cinfo);
}
void jpeg_set_linear_quality(j_compress_ptr cinfo, int scale_factor, boolean force_baseline)
{
   /* These are the sample quantization tables given in JPEG spec section K.1.
      * The spec says that the values given produce "good" quality, and
      * when divided by 2, "very good" quality.
      */
   
   
   
   
   
   
   
   
   
   static const  unsigned int std_luminance_quant_tbl[64] = {16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99};
   
   
   
   
   
   
   
   
   
   static const  unsigned int std_chrominance_quant_tbl[64] = {17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99};
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Set up two quantization tables using the specified scaling */
   
   jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl, scale_factor, force_baseline);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*

   jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl, scale_factor, force_baseline);
}
void jpeg_set_marker_processor(j_decompress_ptr cinfo, int marker_code, jpeg_marker_parser_method routine)
{
//             <    is read   >: marker_code
   if (marker_code==0xFE)
//             <    is read   >: cinfo cinfo[0].marker routine
//             <    is written>: cinfo[0].marker[0].process_COM
      cinfo->marker->process_COM = routine;
   else if (marker_code>=0xE0&&marker_code<=0xE0+15)
//             <    is read   >: cinfo cinfo[0].marker marker_code 
//                               routine
//             <    is written>: 
//                               cinfo[0].marker[0].process_APPn[marke
//                               r_code-0xE0]
      (cinfo->marker->process_APPn)[marker_code-0xE0] = routine;
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_UNKNOWN_MARKER, (cinfo->err->msg_parm.i)[0] = marker_code, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
void jpeg_set_quality(j_compress_ptr cinfo, int quality, boolean force_baseline)
{
//             <    is read   >: quality
//             <    is written>: quality
   /* Convert user 0-100 rating to percentage scaling */
   quality = jpeg_quality_scaling(quality);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Set up standard quality tables */
   jpeg_set_linear_quality(cinfo, quality, force_baseline);
}
void jpeg_simple_progression(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].num_components
//             <    is written>: ncomps
   int ncomps = cinfo->num_components;
   int nscans;
   jpeg_scan_info *scanptr;
//             <    is read   >: cinfo cinfo[0].global_state
   
   /* Safety check to ensure start_compress not called yet. */
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].jpeg_color_space 
//                               ncomps
   
   /* Figure space needed for script.  Calculation must match code below! */
   if (ncomps==3&&cinfo->jpeg_color_space==JCS_YCbCr)
//             <    is written>: nscans
      /* Custom script for YCbCr color images. */
      nscans = 10;
   else
//             <    is read   >: ncomps
      /* All-purpose script for other color spaces. */
      if (ncomps>4)
//             <    is read   >: ncomps
//             <    is written>: nscans
         nscans = 6*ncomps;
      else
//             <    is read   >: ncomps
//             <    is written>: nscans
         nscans = 2+4*ncomps;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Allocate space for script. */
   /* We use permanent pool just in case application re-uses script. */
   
   scanptr = (jpeg_scan_info *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,nscans*(size_t) sizeof(jpeg_scan_info));
//             <    is read   >: cinfo scanptr
//             <    is written>: cinfo[0].scan_info
   cinfo->scan_info = scanptr;
//             <    is read   >: cinfo nscans
//             <    is written>: cinfo[0].num_scans
   cinfo->num_scans = nscans;
//             <    is read   >: cinfo cinfo[0].jpeg_color_space 
//                               ncomps

   if (ncomps==3&&cinfo->jpeg_color_space==JCS_YCbCr) {
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].component_index[*] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      /* Custom script for YCbCr color images. */
      /* Initial DC scan */
      scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      /* Initial AC scan: get some luma data out in a hurry */
      scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      /* Chroma data is too small to be worth expending many scans on */
      scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      /* Complete spectral selection for luma AC */
      scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      /* Refine next bit of luma AC */
      scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].component_index[*] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      /* Finish DC successive approximation */
      scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      /* Finish AC successive approximation */
      scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);
//             <    is read   >: scanptr
//             <    is written>: scanptr scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
      /* Luma bottom bit comes last since it's usually largest scan */
      scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);
   }
   else {
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].component_index[*] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      /* All-purpose script for other color spaces. */
      /* Successive approximation first pass */
      scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      /* Successive approximation second pass */
      scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].component_index[*] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      /* Successive approximation final pass */
      scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
//             <may be written>: scanptr[0].Ah scanptr[0].Al 
//                               scanptr[0].Se scanptr[0].Ss 
//                               scanptr[0].component_index[0] 
//                               scanptr[0].comps_in_scan
//             <    is read   >: ncomps scanptr
//             <    is written>: scanptr
      scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);
   }
}
void jpeg_start_compress(j_compress_ptr cinfo, boolean write_all_tables)
{
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: write_all_tables

   if (write_all_tables)
//             <may be read   >: cinfo[0].ac_huff_tbl_ptrs[*] 
//                               cinfo[0].dc_huff_tbl_ptrs[*] 
//                               cinfo[0].quant_tbl_ptrs[*]
//             <    is read   >: cinfo
      jpeg_suppress_tables(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* mark all tables to be written */
   
   /* (Re)initialize error mgr and destination modules */
   (*cinfo->err->reset_error_mgr)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->dest->init_destination)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Perform master selection of active modules */
   jinit_compress_master(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Set up for the first pass */
   (*cinfo->master->prepare_for_pass)(cinfo);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].next_scanline
   /* Ready for application to drive first pass through jpeg_write_scanlines
      * or jpeg_write_raw_data.
      */
   cinfo->next_scanline = 0;
//             <    is read   >: cinfo cinfo[0].raw_data_in
//             <    is written>: cinfo[0].global_state
   cinfo->global_state = cinfo->raw_data_in?102:101;
}
boolean jpeg_start_decompress(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==202) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* First call: initialize master control, select active modules */
      jinit_master_decompress(cinfo);
//             <    is read   >: cinfo cinfo[0].buffered_image
      if (cinfo->buffered_image) {
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
         /* No more work here; expecting jpeg_start_output next */
         cinfo->global_state = 207;
         return 1;
      }
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
      cinfo->global_state = 203;
   }
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state==203) {
//             <    is read   >: cinfo cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].has_multiple_sca
//                               ns
      /* If file has multiple scans, absorb them all into the coef buffer */
      if (cinfo->inputctl->has_multiple_scans) {
l99999:         ;

         if (!1) goto _break_1;
         int retcode;
//             <    is read   >: cinfo cinfo[0].progress
         /* Call progress monitor hook if present */
         if (cinfo->progress!=(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* Absorb some more input */
         retcode = (*cinfo->inputctl->consume_input)(cinfo);
//             <    is read   >: retcode
         if (retcode==0)
            return 0;
//             <    is read   >: retcode
         if (retcode==2) goto _break_1;
//             <    is read   >: cinfo cinfo[0].progress retcode
         if (cinfo->progress!=(void *) 0&&(retcode==3||retcode==1))
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].progress cinfo[0].progress 
//                               cinfo[0].progress[0].pass_counter 
//                               cinfo[0].progress[0].pass_limit
//             <    is written>: cinfo[0].progress[0].pass_counter
            /* Advance progress counter if appropriate */
            if (++cinfo->progress->pass_counter>=cinfo->progress->pass_limit)
//             <    is read   >: cinfo cinfo[0].progress 
//                               cinfo[0].progress 
//                               cinfo[0].progress[0].pass_limit 
//                               cinfo[0].total_iMCU_rows
//             <    is written>: cinfo[0].progress[0].pass_limit
               /* jdmaster underestimated number of scans; ratchet up one scan */
               cinfo->progress->pass_limit += (long int) cinfo->total_iMCU_rows;
         goto l99999;
_break_1:         ;
      }
//             <    is read   >: cinfo cinfo[0].input_scan_number
//             <    is written>: cinfo[0].output_scan_number
      cinfo->output_scan_number = cinfo->input_scan_number;
   }
   else if (cinfo->global_state!=204)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Perform any dummy output passes, and set up for the final pass */
   return output_pass_setup(cinfo);
}
boolean jpeg_start_output(j_decompress_ptr cinfo, int scan_number)
{
//             <    is read   >: cinfo cinfo[0].global_state 
//                               cinfo[0].global_state

   if (cinfo->global_state!=207&&cinfo->global_state!=204)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: scan_number
   /* Limit scan number to valid range */
   if (scan_number<=0)
//             <    is written>: scan_number
      scan_number = 1;
//             <    is read   >: cinfo cinfo[0].input_scan_number 
//                               cinfo[0].inputctl 
//                               cinfo[0].inputctl[0].eoi_reached 
//                               scan_number

   if (cinfo->inputctl->eoi_reached&&scan_number>cinfo->input_scan_number)
//             <    is read   >: cinfo cinfo[0].input_scan_number
//             <    is written>: scan_number
      scan_number = cinfo->input_scan_number;
//             <    is read   >: cinfo scan_number
//             <    is written>: cinfo[0].output_scan_number
   cinfo->output_scan_number = scan_number;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Perform any dummy output passes, and set up for the real pass */
   return output_pass_setup(cinfo);
}
struct jpeg_error_mgr  * jpeg_std_error(struct jpeg_error_mgr *err)
{
//             <    is read   >: err
//             <    is written>: err[0].error_exit
   err->error_exit = error_exit;
//             <    is read   >: err
//             <    is written>: err[0].emit_message
   err->emit_message = emit_message;
//             <    is read   >: err
//             <    is written>: err[0].output_message
   err->output_message = output_message;
//             <    is read   >: err
//             <    is written>: err[0].format_message
   err->format_message = format_message;
//             <    is read   >: err
//             <    is written>: err[0].reset_error_mgr
   err->reset_error_mgr = reset_error_mgr;
//             <    is read   >: err
//             <    is written>: err[0].trace_level

   err->trace_level = 0;
//             <    is read   >: err
//             <    is written>: err[0].num_warnings
   /* default = no tracing */
   err->num_warnings = 0;
//             <    is read   >: err
//             <    is written>: err[0].msg_code
   /* no warnings emitted yet */
   err->msg_code = 0;
//             <    is read   >: err
//             <    is written>: err[0].jpeg_message_table
   /* may be useful as a flag for "no error" */
   
   /* Initialize message table pointers */
   err->jpeg_message_table = jpeg_std_message_table;
//             <    is read   >: err
//             <    is written>: err[0].last_jpeg_message
   err->last_jpeg_message = (int) JMSG_LASTMSGCODE-1;
//             <    is read   >: err
//             <    is written>: err[0].addon_message_table
   err->addon_message_table = (void *) 0;
//             <    is read   >: err
//             <    is written>: err[0].first_addon_message
   err->first_addon_message = 0;
//             <    is read   >: err
//             <    is written>: err[0].last_addon_message
   /* for safety */
   err->last_addon_message = 0;
//             <    is read   >: err

   return err;
}
void jpeg_stdio_dest(j_compress_ptr cinfo, FILE *outfile)
{
   my_dest_ptr dest;
//             <    is read   >: cinfo cinfo[0].dest
   
   /* The destination object is made permanent so that multiple JPEG images
      * can be written to the same file without re-executing jpeg_stdio_dest.
      * This makes it dangerous to use this manager and a different destination
      * manager serially with the same JPEG object, because their private object
      * sizes may be different.  Caveat programmer.
      */
   if (cinfo->dest==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* first time for this JPEG object? */
      
      cinfo->dest = (struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,(size_t) sizeof(my_destination_mgr));
//             <    is read   >: cinfo cinfo[0].dest
//             <    is written>: dest

   dest = (my_dest_ptr) cinfo->dest;
//             <    is read   >: dest
//             <    is written>: dest[0].pub.init_destination
   dest->pub.init_destination = init_destination;
//             <    is read   >: dest
//             <    is written>: dest[0].pub.empty_output_buffer
   dest->pub.empty_output_buffer = empty_output_buffer;
//             <    is read   >: dest
//             <    is written>: dest[0].pub.term_destination
   dest->pub.term_destination = term_destination;
//             <    is read   >: dest outfile
//             <    is written>: dest[0].outfile
   dest->outfile = outfile;
}
void jpeg_stdio_src(j_decompress_ptr cinfo, FILE *infile)
{
   my_src_ptr src;
//             <    is read   >: cinfo cinfo[0].src
   
   /* The source object and input buffer are made permanent so that a series
      * of JPEG images can be read from the same file by calling jpeg_stdio_src
      * only before the first one.  (If we discarded the buffer at the end of
      * one image, we'd likely lose the start of the next one.)
      * This makes it unsafe to use this manager and a different source
      * manager serially with the same JPEG object.  Caveat programmer.
      */
   if (cinfo->src==(void *) 0) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      /* first time for this JPEG object? */
      
      cinfo->src = (struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,(size_t) sizeof(my_source_mgr));
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: src
      src = (my_src_ptr) cinfo->src;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      src->buffer = (JOCTET *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,0,4096*(size_t) sizeof(JOCTET));
   }
//             <    is read   >: cinfo cinfo[0].src
//             <    is written>: src

   src = (my_src_ptr) cinfo->src;
//             <    is read   >: src
//             <    is written>: src[0].pub.init_source
   src->pub.init_source = init_source;
//             <    is read   >: src
//             <    is written>: src[0].pub.fill_input_buffer
   src->pub.fill_input_buffer = fill_input_buffer;
//             <    is read   >: src
//             <    is written>: src[0].pub.skip_input_data
   src->pub.skip_input_data = skip_input_data;
//             <    is read   >: src
//             <    is written>: src[0].pub.resync_to_restart
   src->pub.resync_to_restart = jpeg_resync_to_restart;
//             <    is read   >: src
//             <    is written>: src[0].pub.term_source
   /* use default method */
   src->pub.term_source = term_source;
//             <    is read   >: infile src
//             <    is written>: src[0].infile
   src->infile = infile;
//             <    is read   >: src
//             <    is written>: src[0].pub.bytes_in_buffer
   src->pub.bytes_in_buffer = 0;
//             <    is read   >: src
//             <    is written>: src[0].pub.next_input_byte
   /* forces fill_input_buffer on first read */
   src->pub.next_input_byte = (void *) 0;
}
void jpeg_suppress_tables(j_compress_ptr cinfo, boolean suppress)
{
   int i;
   JQUANT_TBL *qtbl;
   JHUFF_TBL *htbl;
//             <    is written>: i

   for(i = 0; i <= 3; i += 1)
//             <    is read   >: cinfo cinfo[0].quant_tbl_ptrs[i] i
//             <    is written>: qtbl
      if ((qtbl = (cinfo->quant_tbl_ptrs)[i])!=(void *) 0)
//             <    is read   >: qtbl suppress
//             <    is written>: qtbl[0].sent_table
         qtbl->sent_table = suppress;
//             <    is written>: i

   for(i = 0; i <= 3; i += 1) {
//             <    is read   >: cinfo cinfo[0].dc_huff_tbl_ptrs[i] i
//             <    is written>: htbl
      if ((htbl = (cinfo->dc_huff_tbl_ptrs)[i])!=(void *) 0)
//             <    is read   >: htbl suppress
//             <    is written>: htbl[0].sent_table
         htbl->sent_table = suppress;
//             <    is read   >: cinfo cinfo[0].ac_huff_tbl_ptrs[i] i
//             <    is written>: htbl
      if ((htbl = (cinfo->ac_huff_tbl_ptrs)[i])!=(void *) 0)
//             <    is read   >: htbl suppress
//             <    is written>: htbl[0].sent_table
         htbl->sent_table = suppress;
   }
}
void jpeg_write_coefficients(j_compress_ptr cinfo, jvirt_barray_ptr *coef_arrays)
{
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: cinfo[0].ac_huff_tbl_ptrs[*] 
//                               cinfo[0].dc_huff_tbl_ptrs[*] 
//                               cinfo[0].quant_tbl_ptrs[*]
//             <    is read   >: cinfo
   /* Mark all tables to be written */
   jpeg_suppress_tables(cinfo, 0);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* (Re)initialize error mgr and destination modules */
   (*cinfo->err->reset_error_mgr)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->dest->init_destination)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Perform master selection of active modules */
   transencode_master_selection(cinfo, coef_arrays);
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].next_scanline
   /* Wait for jpeg_finish_compress() call */
   cinfo->next_scanline = 0;
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].global_state
   /* so jpeg_write_marker works */
   cinfo->global_state = 103;
}
void jpeg_write_marker(j_compress_ptr cinfo, int marker, const JOCTET *dataptr, unsigned int datalen)
{
//             <    is read   >: cinfo cinfo[0].global_state 
//                               cinfo[0].global_state 
//                               cinfo[0].global_state 
//                               cinfo[0].next_scanline
   if (cinfo->next_scanline!=0||cinfo->global_state!=101&&cinfo->global_state!=102&&cinfo->global_state!=103)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->marker->write_any_marker)(cinfo,marker,dataptr,datalen);
}
JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo, JSAMPIMAGE data, JDIMENSION num_lines)
{
   JDIMENSION lines_per_iMCU_row;
//             <    is read   >: cinfo cinfo[0].global_state

   if (cinfo->global_state!=102)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].next_scanline
   if (cinfo->next_scanline>=cinfo->image_height) {
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_TOO_MUCH_DATA, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
      return 0;
   }
//             <    is read   >: cinfo cinfo[0].progress
   
   /* Call progress monitor hook if present */
   if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].next_scanline 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
      cinfo->progress->pass_counter = (long int) cinfo->next_scanline;
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_limit
      cinfo->progress->pass_limit = (long int) cinfo->image_height;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
   }
//             <    is read   >: cinfo cinfo[0].master 
//                               cinfo[0].master[0].call_pass_startup
   
   /* Give master control module another chance if this is first call to
      * jpeg_write_raw_data.  This lets output of the frame/scan headers be
      * delayed so that application can write COM, etc, markers between
      * jpeg_start_compress and jpeg_write_raw_data.
      */
   if (cinfo->master->call_pass_startup)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->pass_startup)(cinfo);
//             <    is read   >: cinfo cinfo[0].max_v_samp_factor
//             <    is written>: lines_per_iMCU_row
   
   /* Verify that at least one iMCU row has been passed. */
   lines_per_iMCU_row = cinfo->max_v_samp_factor*8;
//             <    is read   >: lines_per_iMCU_row num_lines
   if (num_lines<lines_per_iMCU_row)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BUFFER_SIZE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Directly compress the row. */
   if (!(*cinfo->coef->compress_data)(cinfo,data))
      /* If compressor did not consume the whole row, suspend processing. */
      return 0;
//             <    is read   >: cinfo cinfo[0].next_scanline 
//                               lines_per_iMCU_row
//             <    is written>: cinfo[0].next_scanline
   
   /* OK, we processed one iMCU row. */
   cinfo->next_scanline += lines_per_iMCU_row;
//             <    is read   >: lines_per_iMCU_row
   return lines_per_iMCU_row;
}
JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION num_lines)
{
   JDIMENSION row_ctr, rows_left;
//             <    is read   >: cinfo cinfo[0].global_state

   if (cinfo->global_state!=101)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].next_scanline
   if (cinfo->next_scanline>=cinfo->image_height)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JWRN_TOO_MUCH_DATA, (*cinfo->err->emit_message)((j_common_ptr) cinfo,-1);
//             <    is read   >: cinfo cinfo[0].progress
   
   /* Call progress monitor hook if present */
   if (cinfo->progress!=(void *) 0) {
//             <    is read   >: cinfo cinfo[0].next_scanline 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_counter
      cinfo->progress->pass_counter = (long int) cinfo->next_scanline;
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].progress
//             <    is written>: cinfo[0].progress[0].pass_limit
      cinfo->progress->pass_limit = (long int) cinfo->image_height;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->progress->progress_monitor)((j_common_ptr) cinfo);
   }
//             <    is read   >: cinfo cinfo[0].master 
//                               cinfo[0].master[0].call_pass_startup
   
   /* Give master control module another chance if this is first call to
      * jpeg_write_scanlines.  This lets output of the frame/scan headers be
      * delayed so that application can write COM, etc, markers between
      * jpeg_start_compress and jpeg_write_scanlines.
      */
   if (cinfo->master->call_pass_startup)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (*cinfo->master->pass_startup)(cinfo);
//             <    is read   >: cinfo cinfo[0].image_height 
//                               cinfo[0].next_scanline
//             <    is written>: rows_left
   
   /* Ignore any extra scanlines at bottom of image. */
   rows_left = cinfo->image_height-cinfo->next_scanline;
//             <    is read   >: num_lines rows_left
   if (num_lines>rows_left)
//             <    is read   >: rows_left
//             <    is written>: num_lines
      num_lines = rows_left;
//             <    is written>: row_ctr

   row_ctr = 0;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->main->process_data)(cinfo,scanlines,&row_ctr,num_lines);
//             <    is read   >: cinfo cinfo[0].next_scanline row_ctr
//             <    is written>: cinfo[0].next_scanline
   cinfo->next_scanline += row_ctr;
//             <    is read   >: row_ctr
   return row_ctr;
}
void jpeg_write_tables(j_compress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].global_state
   if (cinfo->global_state!=100)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_BAD_STATE, (cinfo->err->msg_parm.i)[0] = cinfo->global_state, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* (Re)initialize error mgr and destination modules */
   (*cinfo->err->reset_error_mgr)((j_common_ptr) cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   (*cinfo->dest->init_destination)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Initialize the marker writer ... bit of a crock to do it here. */
   jinit_marker_writer(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* Write them tables! */
   (*cinfo->marker->write_tables_only)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* And clean up. */
   (*cinfo->dest->term_destination)(cinfo);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   /* We can use jpeg_abort to release memory. */
   jpeg_abort((j_common_ptr) cinfo);
}
static void alloc_fs_workspace(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   size_t arraysize;
   int i;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: arraysize
   arraysize = (size_t) ((cinfo->output_width+2)*(size_t) sizeof(FSERROR));
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: i
   for(i = 0; i <= cinfo->out_color_components-1; i += 1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      (cquantize->fserrors)[i] = (FSERRPTR) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,arraysize);
}
static void color_quantize(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].colorindex
//             <    is written>: colorindex
   JSAMPARRAY colorindex = cquantize->colorindex;
   register int pixcode, ci;
   register JSAMPROW ptrin, ptrout;
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: nc
   register int nc = cinfo->out_color_components;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: input_buf input_buf[row] num_rows row
//             <    is written>: ptrin
      ptrin = input_buf[row];
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row
//             <    is written>: ptrout
      ptrout = output_buf[row];
//             <    is read   >: num_rows width
//             <    is written>: col
      for(col = width; col >= 1; col += -1) {
//             <    is read   >: num_rows width
//             <    is written>: pixcode
         pixcode = 0;
//             <    is read   >: nc num_rows width
//             <    is written>: ci
         for(ci = 0; ci <= nc-1; ci += 1)
//             <    is read   >: ci colorindex colorindex[ci] 
//                               colorindex[ci][(int)
//                               *ptrin++] nc num_rows pixcode ptrin 
//                               ptrin[0] width
//             <    is written>: pixcode ptrin
            pixcode += (int) colorindex[ci][(int) *ptrin++];
//             <    is read   >: num_rows pixcode ptrout width
//             <    is written>: ptrout ptrout[0]
         *ptrout++ = (JSAMPLE) pixcode;
      }
   }
}
static void color_quantize3(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register int pixcode;
   register JSAMPROW ptrin, ptrout;
//             <    is read   >: cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[0]
//             <    is written>: colorindex0
   JSAMPROW colorindex0 = (cquantize->colorindex)[0];
//             <    is read   >: cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[1]
//             <    is written>: colorindex1
   JSAMPROW colorindex1 = (cquantize->colorindex)[1];
//             <    is read   >: cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[2]
//             <    is written>: colorindex2
   JSAMPROW colorindex2 = (cquantize->colorindex)[2];
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: input_buf input_buf[row] num_rows row
//             <    is written>: ptrin
      ptrin = input_buf[row];
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row
//             <    is written>: ptrout
      ptrout = output_buf[row];
//             <    is read   >: num_rows width
//             <    is written>: col
      for(col = width; col >= 1; col += -1) {
//             <    is read   >: colorindex0 
//                               colorindex0[(int)
//                               *ptrin++] num_rows ptrin ptrin[0] 
//                               width
//             <    is written>: pixcode ptrin
         pixcode = (int) colorindex0[(int) *ptrin++];
//             <    is read   >: colorindex1 
//                               colorindex1[(int)
//                               *ptrin++] num_rows pixcode ptrin 
//                               ptrin[0] width
//             <    is written>: pixcode ptrin
         pixcode += (int) colorindex1[(int) *ptrin++];
//             <    is read   >: colorindex2 
//                               colorindex2[(int)
//                               *ptrin++] num_rows pixcode ptrin 
//                               ptrin[0] width
//             <    is written>: pixcode ptrin
         pixcode += (int) colorindex2[(int) *ptrin++];
//             <    is read   >: num_rows pixcode ptrout width
//             <    is written>: ptrout ptrout[0]
         *ptrout++ = (JSAMPLE) pixcode;
      }
   }
}
static void create_colorindex(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   JSAMPROW indexptr;
   int i, j, k, nci, blksize, val, pad;
//             <    is read   >: cinfo cinfo[0].dither_mode
   
   /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
      * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
      * This is not necessary in the other dithering modes.  However, we
      * flag whether it was done in case user changes dithering mode.
      */
   if (cinfo->dither_mode==JDITHER_ORDERED) {
//             <    is written>: pad
      pad = 255*2;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].is_padded
      cquantize->is_padded = 1;
   }
   else {
//             <    is written>: pad
      pad = 0;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].is_padded
      cquantize->is_padded = 0;
   }
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cquantize->colorindex = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,(JDIMENSION) (255+1+pad),(JDIMENSION) cinfo->out_color_components);
//             <    is read   >: cquantize cquantize[0].sv_actual
//             <    is written>: blksize
   
   /* blksize is number of adjacent repeated entries for a component */
   blksize = cquantize->sv_actual;
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: i

   for(i = 0; i <= cinfo->out_color_components-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].Ncolors[i] i
//             <    is written>: nci
      /* fill in colorindex entries for i'th color component */
      nci = (cquantize->Ncolors)[i];
//             <    is read   >: blksize cinfo 
//                               cinfo[0].out_color_components nci
//             <    is written>: blksize
      /* # of distinct values for this color */
      blksize = blksize/nci;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               pad
      
      /* adjust colorindex pointers to provide padding at negative indexes. */
      if (pad)
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex 
//                               cquantize[0].colorindex[i] i
//             <    is written>: cquantize[0].colorindex[i]
         (cquantize->colorindex)[i] += 255;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[i] i
//             <    is written>: indexptr
      
      /* in loop, val = index of current output value, */
      /* and k = largest j that maps to current val */
      indexptr = (cquantize->colorindex)[i];
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: val
      val = 0;
//             <    is read   >: cinfo cinfo[0].out_color_components i
//                               nci
//             <    is written>: k
      k = largest_input_value(cinfo, i, 0, nci-1);
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: j
      for(j = 0; j <= 255; j += 1) {
//             <    is read   >: j k
         while (j>k)
//             <    is read   >: cinfo cinfo[0].out_color_components i
//                               nci val
//             <    is written>: k val
            /* advance val if past boundary */
            k = largest_input_value(cinfo, i, ++val, nci-1);
//             <    is read   >: blksize cinfo 
//                               cinfo[0].out_color_components 
//                               indexptr j val
//             <    is written>: indexptr[j]
         /* premultiply so that no multiplication needed in main processing */
         indexptr[j] = (JSAMPLE) (val*blksize);
      }
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               pad
      /* Pad at both ends if necessary */
      if (pad)
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: j
         for(j = 1; j <= 255; j += 1) {
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               indexptr indexptr[0] j
//             <    is written>: indexptr[-j]
            indexptr[-j] = indexptr[0];
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               indexptr indexptr[255] j
//             <    is written>: indexptr[255+j]
            indexptr[255+j] = indexptr[255];
         }
   }
}
static void create_colormap(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   JSAMPARRAY colormap;
   /* Created colormap */
   int total_colors;
   /* Number of distinct output colors */
   int i, j, k, nci, blksize, blkdist, ptr, val;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Select number of colors for each component */
   total_colors = select_ncolors(cinfo, cquantize->Ncolors);
//             <    is read   >: cinfo cinfo[0].out_color_components
   
   /* Report selected color counts */
   if (cinfo->out_color_components==3)
      do {
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: _mp
         int *_mp = cinfo->err->msg_parm.i;
//             <    is read   >: _mp total_colors
//             <    is written>: _mp[0]
         _mp[0] = total_colors;
//             <    is read   >: _mp cquantize cquantize[0].Ncolors[0]
//             <    is written>: _mp[1]
         _mp[1] = (cquantize->Ncolors)[0];
//             <    is read   >: _mp cquantize cquantize[0].Ncolors[1]
//             <    is written>: _mp[2]
         _mp[2] = (cquantize->Ncolors)[1];
//             <    is read   >: _mp cquantize cquantize[0].Ncolors[2]
//             <    is written>: _mp[3]
         _mp[3] = (cquantize->Ncolors)[2];
//             <    is read   >: cinfo cinfo[0].err
//             <    is written>: cinfo[0].err[0].msg_code
         cinfo->err->msg_code = JTRC_QUANT_3_NCOLORS;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
      }
      while (0);
   else
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JTRC_QUANT_NCOLORS, (cinfo->err->msg_parm.i)[0] = total_colors, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   
   /* Allocate and fill in the colormap. */
   /* The colors are ordered in the map in standard row-major order, */
   /* i.e. rightmost (highest-indexed) color changes most rapidly. */
   
   colormap = (*cinfo->mem->alloc_sarray)((j_common_ptr) cinfo,1,(JDIMENSION) total_colors,(JDIMENSION) cinfo->out_color_components);
//             <    is read   >: total_colors
//             <    is written>: blkdist
   
   /* blksize is number of adjacent repeated entries for a component */
   /* blkdist is distance between groups of identical entries for a component */
   blkdist = total_colors;
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: i

   for(i = 0; i <= cinfo->out_color_components-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].Ncolors[i] i
//             <    is written>: nci
      /* fill in colormap entries for i'th color component */
      nci = (cquantize->Ncolors)[i];
//             <    is read   >: blkdist cinfo 
//                               cinfo[0].out_color_components nci
//             <    is written>: blksize
      /* # of distinct values for this color */
      blksize = blkdist/nci;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               nci
//             <    is written>: j
      for(j = 0; j <= nci-1; j += 1) {
//             <    is read   >: cinfo cinfo[0].out_color_components i
//                               j nci
//             <    is written>: val
         /* Compute j'th output value (out of nci) for component */
         val = output_value(cinfo, i, j, nci-1);
//             <    is read   >: blkdist blksize cinfo 
//                               cinfo[0].out_color_components j nci 
//                               total_colors
//             <    is written>: ptr
         /* Fill in all colormap entries that have this value of this component */
         for(ptr = j*blksize; ptr <= total_colors-1; ptr += blkdist)
//             <    is read   >: blkdist blksize cinfo 
//                               cinfo[0].out_color_components j nci 
//                               total_colors
//             <    is written>: k
            /* fill in blksize entries beginning at ptr */
            for(k = 0; k <= blksize-1; k += 1)
//             <    is read   >: blkdist blksize cinfo 
//                               cinfo[0].out_color_components 
//                               colormap colormap[i] i j k nci ptr 
//                               total_colors val
//             <    is written>: colormap[i][ptr+k]
               colormap[i][ptr+k] = (JSAMPLE) val;
      }
//             <    is read   >: blksize cinfo 
//                               cinfo[0].out_color_components
//             <    is written>: blkdist
      blkdist = blksize;
   }
//             <    is read   >: colormap cquantize
//             <    is written>: cquantize[0].sv_colormap
   
   /* Save the colormap in private storage,
      * where it will survive color quantization mode changes.
      */
   cquantize->sv_colormap = colormap;
//             <    is read   >: cquantize total_colors
//             <    is written>: cquantize[0].sv_actual
   cquantize->sv_actual = total_colors;
}
static void create_odither_tables(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   ODITHER_MATRIX_PTR odither;
   int i, j, nci;
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: i

   for(i = 0; i <= cinfo->out_color_components-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].Ncolors[i] i
//             <    is written>: nci
      nci = (cquantize->Ncolors)[i];
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: odither
      /* # of distinct values for this color */
      odither = (void *) 0;
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: j
      j = 0;
l99998:      ;
//             <    is read   >: cinfo cinfo[0].out_color_components i
//                               j
/* search for matching prior component */
      if (!(j<i)) goto _break_2;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].Ncolors[j] j 
//                               nci
      if (nci==(cquantize->Ncolors)[j]) goto l99999;
//             <    is read   >: cinfo cinfo[0].out_color_components j
//             <    is written>: j
      j++;
      goto l99998;
l99999:      ;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize cquantize[0].odither[j] j
//             <    is written>: odither
      odither = (cquantize->odither)[j];
//             <    is read   >: cinfo cinfo[0].out_color_components
_break_2:      ;
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               odither
      if (odither==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         /* need a new table? */
         odither = make_odither_array(cinfo, nci);
//             <    is read   >: cinfo cinfo[0].out_color_components 
//                               cquantize i odither
//             <    is written>: cquantize[0].odither[i]
      (cquantize->odither)[i] = odither;
   }
}
static void finish_pass_1_quant(j_decompress_ptr cinfo)
{
}
static int largest_input_value(j_decompress_ptr cinfo, int ci, int j, int maxj)
{
//             <    is read   >: j maxj
   /* Breakpoints are halfway between values returned by output_value */
   return (int) (((INT32) (2*j+1)*255+maxj)/(2*maxj));
}
static ODITHER_MATRIX_PTR make_odither_array(j_decompress_ptr cinfo, int ncolors)
{
   ODITHER_MATRIX_PTR odither;
   int j, k;
   INT32 num, den;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   odither = (ODITHER_MATRIX_PTR) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(size_t) sizeof(ODITHER_MATRIX));
//             <    is read   >: ncolors
//             <    is written>: den
   /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
      * Hence the dither value for the matrix cell with fill order f
      * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
      * On 16-bit-int machine, be careful to avoid overflow.
      */
   den = 2*16*16*(INT32) (ncolors-1);
//             <    is written>: j
   for(j = 0; j <= 15; j += 1)
//             <    is written>: k
      for(k = 0; k <= 15; k += 1) {
//             <    is read   >: j k base_dither_matrix[j][k]
//             <    is written>: num
         num = (INT32) (16*16-1-2*(int) base_dither_matrix[j][k])*255;
//             <    is read   >: den j k num odither
//             <    is written>: odither[j][k]
         /* Ensure round towards zero despite C's lack of consistency
                * about rounding negative values in integer division...
                */
         odither[j][k] = (int) (num<0?-((-num)/den):num/den);
      }
//             <    is read   >: odither
   return odither;
}
static void new_color_map_1_quant(j_decompress_ptr cinfo)
{
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JERR_MODE_CHANGE, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
}
static int output_value(j_decompress_ptr cinfo, int ci, int j, int maxj)
{
//             <    is read   >: j maxj
   /* We always provide values 0 and MAXJSAMPLE for each component;
      * any additional values are equally spaced between these limits.
      * (Forcing the upper and lower values to the limits ensures that
      * dithering can't produce a color outside the selected gamut.)
      */
   return (int) (((INT32) j*255+maxj/2)/maxj);
}
static void quantize3_ord_dither(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register int pixcode;
   register JSAMPROW input_ptr;
   register JSAMPROW output_ptr;
//             <    is read   >: cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[0]
//             <    is written>: colorindex0
   JSAMPROW colorindex0 = (cquantize->colorindex)[0];
//             <    is read   >: cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[1]
//             <    is written>: colorindex1
   JSAMPROW colorindex1 = (cquantize->colorindex)[1];
//             <    is read   >: cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[2]
//             <    is written>: colorindex2
   JSAMPROW colorindex2 = (cquantize->colorindex)[2];
   int *dither0;
   /* points to active row of dither matrix */
   int *dither1;
   int *dither2;
   int row_index, col_index;
   /* current indexes into dither matrix */
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: cquantize cquantize[0].row_index 
//                               num_rows
//             <    is written>: row_index
      row_index = cquantize->row_index;
//             <    is read   >: input_buf input_buf[row] num_rows row
//             <    is written>: input_ptr
      input_ptr = input_buf[row];
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row
//             <    is written>: output_ptr
      output_ptr = output_buf[row];
//             <    is read   >: cquantize cquantize[0].odither[0] 
//                               num_rows row_index
//             <    is written>: dither0
      dither0 = ((cquantize->odither)[0])[row_index];
//             <    is read   >: cquantize cquantize[0].odither[1] 
//                               num_rows row_index
//             <    is written>: dither1
      dither1 = ((cquantize->odither)[1])[row_index];
//             <    is read   >: cquantize cquantize[0].odither[2] 
//                               num_rows row_index
//             <    is written>: dither2
      dither2 = ((cquantize->odither)[2])[row_index];
//             <    is read   >: num_rows
//             <    is written>: col_index
      col_index = 0;
//             <    is read   >: num_rows width
//             <    is written>: col

      for(col = width; col >= 1; col += -1) {
//             <    is read   >: col_index colorindex0 
//                               colorindex0[(int)
//                               *input_ptr++ +dither0[col_index]] 
//                               dither0 dither0[col_index] input_ptr 
//                               input_ptr[0] num_rows width
//             <    is written>: input_ptr pixcode
         pixcode = (int) colorindex0[(int) *input_ptr++ +dither0[col_index]];
//             <    is read   >: col_index colorindex1 
//                               colorindex1[(int)
//                               *input_ptr++ +dither1[col_index]] 
//                               dither1 dither1[col_index] input_ptr 
//                               input_ptr[0] num_rows pixcode width
//             <    is written>: input_ptr pixcode
         pixcode += (int) colorindex1[(int) *input_ptr++ +dither1[col_index]];
//             <    is read   >: col_index colorindex2 
//                               colorindex2[(int)
//                               *input_ptr++ +dither2[col_index]] 
//                               dither2 dither2[col_index] input_ptr 
//                               input_ptr[0] num_rows pixcode width
//             <    is written>: input_ptr pixcode
         pixcode += (int) colorindex2[(int) *input_ptr++ +dither2[col_index]];
//             <    is read   >: num_rows output_ptr pixcode width
//             <    is written>: output_ptr output_ptr[0]
         *output_ptr++ = (JSAMPLE) pixcode;
//             <    is read   >: col_index num_rows width
//             <    is written>: col_index
         col_index = col_index+1&16-1;
      }
//             <    is read   >: num_rows row_index
//             <    is written>: row_index
      row_index = row_index+1&16-1;
//             <    is read   >: cquantize num_rows row_index
//             <    is written>: cquantize[0].row_index
      cquantize->row_index = row_index;
   }
}
static void quantize_fs_dither(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register LOCFSERROR cur;
   /* current error or pixel value */
   LOCFSERROR belowerr;
   /* error for pixel below cur */
   LOCFSERROR bpreverr;
   /* error for below/prev col */
   LOCFSERROR bnexterr;
   /* error for below/next col */
   LOCFSERROR delta;
   register FSERRPTR errorptr;
   /* => fserrors[] at column before current */
   register JSAMPROW input_ptr;
   register JSAMPROW output_ptr;
   JSAMPROW colorindex_ci;
   JSAMPROW colormap_ci;
   int pixcode;
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: nc
   int nc = cinfo->out_color_components;
   int dir;
   /* 1 for left-to-right, -1 for right-to-left */
   int dirnc;
   /* dir * nc */
   int ci;
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit;
//             <    is read   >: num_rows
//             <    is written>: row
   
   
   for(row = 0; row <= num_rows-1; row += 1) {
//             <may be written>: output_buf[row][*]
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row width
      /* Initialize output values to 0 so can process components separately */
      
      jzero_far((void *) output_buf[row], (size_t) (width*(size_t) sizeof(JSAMPLE)));
//             <    is read   >: nc num_rows
//             <    is written>: ci
      for(ci = 0; ci <= nc-1; ci += 1) {
//             <    is read   >: ci input_buf input_buf[row] nc 
//                               num_rows row
//             <    is written>: input_ptr
         input_ptr = input_buf[row]+ci;
//             <    is read   >: nc num_rows output_buf 
//                               output_buf[row] row
//             <    is written>: output_ptr
         output_ptr = output_buf[row];
//             <    is read   >: cquantize cquantize[0].on_odd_row nc 
//                               num_rows
         if (cquantize->on_odd_row) {
//             <    is read   >: input_ptr nc num_rows width
//             <    is written>: input_ptr
            /* work right to left in this row */
            input_ptr += (width-1)*nc;
//             <    is read   >: nc num_rows output_ptr width
//             <    is written>: output_ptr
            /* so point to rightmost pixel */
            output_ptr += width-1;
//             <    is read   >: nc num_rows
//             <    is written>: dir
            dir = -1;
//             <    is read   >: nc num_rows
//             <    is written>: dirnc
            dirnc = -nc;
//             <    is read   >: ci cquantize 
//                               cquantize[0].fserrors[ci] nc num_rows
//                               width
//             <    is written>: errorptr
            errorptr = (cquantize->fserrors)[ci]+(width+1);
         }
         else {
//             <    is read   >: nc num_rows
//             <    is written>: dir
            /* work left to right in this row */
            dir = 1;
//             <    is read   >: nc num_rows
//             <    is written>: dirnc
            dirnc = nc;
//             <    is read   >: ci cquantize 
//                               cquantize[0].fserrors[ci] nc num_rows
//             <    is written>: errorptr
            errorptr = (cquantize->fserrors)[ci];
         }
//             <    is read   >: ci cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[ci] nc 
//                               num_rows
//             <    is written>: colorindex_ci
         colorindex_ci = (cquantize->colorindex)[ci];
//             <    is read   >: ci cquantize cquantize[0].sv_colormap
//                               cquantize[0].sv_colormap[ci] nc 
//                               num_rows
//             <    is written>: colormap_ci
         colormap_ci = (cquantize->sv_colormap)[ci];
//             <    is read   >: nc num_rows
//             <    is written>: cur
         /* Preset error values: no error propagated to first pixel from left */
         cur = 0;
//             <    is read   >: nc num_rows
//             <    is written>: belowerr bpreverr
         /* and no error propagated to row below yet */
         belowerr = bpreverr = 0;
//             <    is read   >: nc num_rows width
//             <    is written>: col

         for(col = width; col >= 1; col += -1) {
//             <    is read   >: cur dir errorptr errorptr[dir] nc 
//                               num_rows width
//             <    is written>: cur
            /* cur holds the error propagated from the previous pixel on the
            	 * current line.  Add the error propagated from the previous line
            	 * to form the complete error correction term for this pixel, and
            	 * round the error term (which is expressed * 16) to an integer.
            	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
            	 * for either sign of the error value.
            	 * Note: errorptr points to *previous* column's array entry.
            	 */
            cur = cur+errorptr[dir]+8>>4;
//             <    is read   >: cur input_ptr input_ptr[0] nc 
//                               num_rows width
//             <    is written>: cur
            /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
            	 * The maximum error is +- MAXJSAMPLE; this sets the required size
            	 * of the range_limit array.
            	 */
            cur += (int) *input_ptr;
//             <    is read   >: cur nc num_rows range_limit 
//                               range_limit[cur] width
//             <    is written>: cur
            cur = (int) range_limit[cur];
//             <    is read   >: colorindex_ci colorindex_ci[cur] cur 
//                               nc num_rows width
//             <    is written>: pixcode
            /* Select output value, accumulate into output code for this pixel */
            pixcode = (int) colorindex_ci[cur];
//             <    is read   >: nc num_rows output_ptr output_ptr[0] 
//                               pixcode width
//             <    is written>: output_ptr[0]
            *output_ptr += (JSAMPLE) pixcode;
//             <    is read   >: colormap_ci colormap_ci[pixcode] cur 
//                               nc num_rows pixcode width
//             <    is written>: cur
            /* Compute actual representation error at this pixel */
            /* Note: we can do this even though we don't have the final */
            /* pixel code, because the colormap is orthogonal. */
            cur -= (int) colormap_ci[pixcode];
//             <    is read   >: cur nc num_rows width
//             <    is written>: bnexterr
            /* Compute error fractions to be propagated to adjacent pixels.
            	 * Add these into the running sums, and simultaneously shift the
            	 * next-line error sums left by 1 column.
            	 */
            bnexterr = cur;
//             <    is read   >: cur nc num_rows width
//             <    is written>: delta
            delta = cur*2;
//             <    is read   >: cur delta nc num_rows width
//             <    is written>: cur
            cur += delta;
//             <    is read   >: bpreverr cur errorptr nc num_rows 
//                               width
//             <    is written>: errorptr[0]
            /* form error * 3 */
            errorptr[0] = (FSERROR) (bpreverr+cur);
//             <    is read   >: cur delta nc num_rows width
//             <    is written>: cur
            cur += delta;
//             <    is read   >: belowerr cur nc num_rows width
//             <    is written>: bpreverr
            /* form error * 5 */
            bpreverr = belowerr+cur;
//             <    is read   >: bnexterr nc num_rows width
//             <    is written>: belowerr
            belowerr = bnexterr;
//             <    is read   >: cur delta nc num_rows width
//             <    is written>: cur
            cur += delta;
//             <    is read   >: dirnc input_ptr nc num_rows width
//             <    is written>: input_ptr
            /* form error * 7 */
            /* At this point cur contains the 7/16 error value to be propagated
            	 * to the next pixel on the current line, and all the errors for the
            	 * next line have been shifted over. We are therefore ready to move on.
            	 */
            input_ptr += dirnc;
//             <    is read   >: dir nc num_rows output_ptr width
//             <    is written>: output_ptr
            /* advance input ptr to next column */
            output_ptr += dir;
//             <    is read   >: dir errorptr nc num_rows width
//             <    is written>: errorptr
            /* advance output ptr to next column */
            errorptr += dir;
         }
//             <    is read   >: bpreverr errorptr nc num_rows
//             <    is written>: errorptr[0]
         /* Post-loop cleanup: we must unload the final error value into the
                * final fserrors[] entry.  Note we need not unload belowerr because
                * it is for the dummy column before or after the actual array.
                */
         errorptr[0] = (FSERROR) bpreverr;
      }
//             <    is read   >: cquantize cquantize[0].on_odd_row 
//                               num_rows
//             <    is written>: cquantize[0].on_odd_row
      cquantize->on_odd_row = cquantize->on_odd_row?0:1;
   }
}
static void quantize_ord_dither(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register JSAMPROW input_ptr;
   register JSAMPROW output_ptr;
   JSAMPROW colorindex_ci;
   int *dither;
   /* points to active row of dither matrix */
   int row_index, col_index;
   /* current indexes into dither matrix */
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: nc
   int nc = cinfo->out_color_components;
   int ci;
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = 0; row <= num_rows-1; row += 1) {
//             <may be written>: output_buf[row][*]
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row width
      /* Initialize output values to 0 so can process components separately */
      
      jzero_far((void *) output_buf[row], (size_t) (width*(size_t) sizeof(JSAMPLE)));
//             <    is read   >: cquantize cquantize[0].row_index 
//                               num_rows
//             <    is written>: row_index
      row_index = cquantize->row_index;
//             <    is read   >: nc num_rows
//             <    is written>: ci
      for(ci = 0; ci <= nc-1; ci += 1) {
//             <    is read   >: ci input_buf input_buf[row] nc 
//                               num_rows row
//             <    is written>: input_ptr
         input_ptr = input_buf[row]+ci;
//             <    is read   >: nc num_rows output_buf 
//                               output_buf[row] row
//             <    is written>: output_ptr
         output_ptr = output_buf[row];
//             <    is read   >: ci cquantize cquantize[0].colorindex 
//                               cquantize[0].colorindex[ci] nc 
//                               num_rows
//             <    is written>: colorindex_ci
         colorindex_ci = (cquantize->colorindex)[ci];
//             <    is read   >: ci cquantize cquantize[0].odither[ci]
//                               nc num_rows row_index
//             <    is written>: dither
         dither = ((cquantize->odither)[ci])[row_index];
//             <    is read   >: nc num_rows
//             <    is written>: col_index
         col_index = 0;
//             <    is read   >: nc num_rows width
//             <    is written>: col

         for(col = width; col >= 1; col += -1) {
//             <    is read   >: col_index colorindex_ci 
//                               colorindex_ci[(int)
//                               *input_ptr+dither[col_index]] dither 
//                               dither[col_index] input_ptr 
//                               input_ptr[0] nc num_rows output_ptr 
//                               output_ptr[0] width
//             <    is written>: output_ptr[0]
            /* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
            	 * select output value, accumulate into output code for this pixel.
            	 * Range-limiting need not be done explicitly, as we have extended
            	 * the colorindex table to produce the right answers for out-of-range
            	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
            	 * required amount of padding.
            	 */
            *output_ptr += colorindex_ci[(int) *input_ptr+dither[col_index]];
//             <    is read   >: input_ptr nc num_rows width
//             <    is written>: input_ptr
            input_ptr += nc;
//             <    is read   >: nc num_rows output_ptr width
//             <    is written>: output_ptr
            output_ptr++;
//             <    is read   >: col_index nc num_rows width
//             <    is written>: col_index
            col_index = col_index+1&16-1;
         }
      }
//             <    is read   >: num_rows row_index
//             <    is written>: row_index
      /* Advance row index for next row */
      row_index = row_index+1&16-1;
//             <    is read   >: cquantize num_rows row_index
//             <    is written>: cquantize[0].row_index
      cquantize->row_index = row_index;
   }
}
static int select_ncolors(j_decompress_ptr cinfo, int Ncolors[])
{
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: nc
   int nc = cinfo->out_color_components;
   /* number of color components */
//             <    is read   >: cinfo 
//                               cinfo[0].desired_number_of_colors
//             <    is written>: max_colors
   int max_colors = cinfo->desired_number_of_colors;
   int total_colors, iroot, i, j;
   boolean changed;
   long int temp;
   static const  int RGB_order[3] = {1, 0, 2};
//             <    is written>: iroot
   
   /* We can allocate at least the nc'th root of max_colors per component. */
   /* Compute floor(nc'th root of max_colors). */
   iroot = 1;
//             <    is read   >: max_colors temp
   do {
//             <    is read   >: iroot
//             <    is written>: iroot
      iroot++;
//             <    is read   >: iroot
//             <    is written>: temp
      temp = iroot;
//             <    is read   >: nc
//             <    is written>: i
      /* set temp = iroot ** nc */
      for(i = 1; i <= nc-1; i += 1)
//             <    is read   >: iroot nc temp
//             <    is written>: temp
         temp *= iroot;
   }
   while (temp<=(long int) max_colors);
//             <    is read   >: iroot
//             <    is written>: iroot
   /* repeat till iroot exceeds root */
   iroot--;
//             <    is read   >: iroot
   /* now iroot = floor(root) */
   
   /* Must have at least 2 color values per component */
   if (iroot<2)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_QUANT_FEW_COLORS, (cinfo->err->msg_parm.i)[0] = (int) temp, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is written>: total_colors
   
   /* Initialize to iroot color values for each component */
   total_colors = 1;
//             <    is read   >: nc
//             <    is written>: i
   for(i = 0; i <= nc-1; i += 1) {
//             <    is read   >: i iroot nc
//             <    is written>: Ncolors[i]
      Ncolors[i] = iroot;
//             <    is read   >: iroot nc total_colors
//             <    is written>: total_colors
      total_colors *= iroot;
   }
//             <    is read   >: changed
   do {
//             <    is written>: changed
      changed = 0;
//             <    is written>: i
      i = 0;
l99999:      ;
//             <    is read   >: i nc
      if (!(i<nc)) goto _break_5;
//             <may be read   >: RGB_order[*]
//             <    is read   >: cinfo cinfo[0].out_color_space i
//             <    is written>: j
      j = cinfo->out_color_space==JCS_RGB?RGB_order[i]:i;
//             <    is read   >: Ncolors[j] j total_colors
//             <    is written>: temp
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors/Ncolors[j];
//             <    is read   >: Ncolors[j] j temp
//             <    is written>: temp
      temp *= Ncolors[j]+1;
//             <    is read   >: max_colors temp
/* done in long arith to avoid oflo */
      if (temp>(long int) max_colors) goto _break_5;
//             <    is read   >: Ncolors[j] j
//             <    is written>: Ncolors[j]
      /* won't fit, done with this pass */
      Ncolors[j]++;
//             <    is read   >: temp
//             <    is written>: total_colors
      /* OK, apply the increment */
      total_colors = (int) temp;
//             <    is written>: changed
      changed = 1;
//             <    is read   >: i
//             <    is written>: i
      i++;
      goto l99999;
_break_5:      ;
   }
   while (changed);
//             <    is read   >: total_colors

   return total_colors;
}
static void start_pass_1_quant(j_decompress_ptr cinfo, boolean is_pre_scan)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   size_t arraysize;
   int i;
//             <    is read   >: cinfo cquantize 
//                               cquantize[0].sv_colormap
//             <    is written>: cinfo[0].colormap
   
   /* Install my colormap. */
   cinfo->colormap = cquantize->sv_colormap;
//             <    is read   >: cinfo cquantize 
//                               cquantize[0].sv_actual
//             <    is written>: cinfo[0].actual_number_of_colors
   cinfo->actual_number_of_colors = cquantize->sv_actual;
//             <    is read   >: cinfo cinfo[0].dither_mode
   
   /* Initialize for desired dithering mode. */
   if (cinfo->dither_mode==JDITHER_NONE) {
_switch_1_case_JDITHER_NONE:      ;
//             <    is read   >: cinfo cinfo[0].out_color_components
      if (cinfo->out_color_components==3)
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
         cquantize->pub.color_quantize = color_quantize3;
      else
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
         cquantize->pub.color_quantize = color_quantize;
   }
   else if (cinfo->dither_mode==JDITHER_ORDERED) {
_switch_1_case_JDITHER_ORDERED:      ;
//             <    is read   >: cinfo cinfo[0].out_color_components
      if (cinfo->out_color_components==3)
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
         cquantize->pub.color_quantize = quantize3_ord_dither;
      else
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
         cquantize->pub.color_quantize = quantize_ord_dither;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].row_index
      cquantize->row_index = 0;
//             <    is read   >: cquantize cquantize[0].is_padded
      /* initialize state for ordered dither */
      /* If user changed to ordered dither from another mode,
           * we must recreate the color index table with padding.
           * This will cost extra space, but probably isn't very likely.
           */
      if (!cquantize->is_padded)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         create_colorindex(cinfo);
//             <    is read   >: cquantize cquantize[0].odither[0]
      /* Create ordered-dither tables if we didn't already. */
      if ((cquantize->odither)[0]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         create_odither_tables(cinfo);
   }
   else if (cinfo->dither_mode==JDITHER_FS) {
_switch_1_case_JDITHER_FS:      ;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
      cquantize->pub.color_quantize = quantize_fs_dither;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].on_odd_row
      cquantize->on_odd_row = 0;
//             <    is read   >: cquantize cquantize[0].fserrors[0]
      /* initialize state for F-S dither */
      /* Allocate Floyd-Steinberg workspace if didn't already. */
      if ((cquantize->fserrors)[0]==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         alloc_fs_workspace(cinfo);
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: arraysize
      /* Initialize the propagated errors to zero. */
      arraysize = (size_t) ((cinfo->output_width+2)*(size_t) sizeof(FSERROR));
//             <    is read   >: cinfo cinfo[0].out_color_components
//             <    is written>: i
      for(i = 0; i <= cinfo->out_color_components-1; i += 1)
//             <may be written>: cquantize[0].fserrors[i][*]
//             <    is read   >: arraysize cinfo 
//                               cinfo[0].out_color_components 
//                               cquantize cquantize[0].fserrors[i] i
         jzero_far((void *) (cquantize->fserrors)[i], arraysize);
   }
   else {
_switch_1_default:      ;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
      cinfo->err->msg_code = JERR_NOT_COMPILED, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
   }
_break_1:   ;
}
static void compute_color(j_decompress_ptr cinfo, boxptr boxp, int icolor)
{
   /* Current algorithm: mean weighted by pixels (not colors) */
   /* Note it is important to get the rounding correct! */
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   hist3d histogram = cquantize->histogram;
   histptr histp;
   int c0, c1, c2;
   int c0min, c0max, c1min, c1max, c2min, c2max;
   long int count;
//             <    is written>: total
   long int total = 0;
//             <    is written>: c0total
   long int c0total = 0;
//             <    is written>: c1total
   long int c1total = 0;
//             <    is written>: c2total
   long int c2total = 0;
//             <    is read   >: boxp boxp[0].c0min
//             <    is written>: c0min

   c0min = boxp->c0min;
//             <    is read   >: boxp boxp[0].c0max
//             <    is written>: c0max
   c0max = boxp->c0max;
//             <    is read   >: boxp boxp[0].c1min
//             <    is written>: c1min
   c1min = boxp->c1min;
//             <    is read   >: boxp boxp[0].c1max
//             <    is written>: c1max
   c1max = boxp->c1max;
//             <    is read   >: boxp boxp[0].c2min
//             <    is written>: c2min
   c2min = boxp->c2min;
//             <    is read   >: boxp boxp[0].c2max
//             <    is written>: c2max
   c2max = boxp->c2max;
//             <    is read   >: c0max c0min
//             <    is written>: c0

   for(c0 = c0min; c0 <= c0max; c0 += 1)
//             <    is read   >: c0max c0min c1max c1min
//             <    is written>: c1
      for(c1 = c1min; c1 <= c1max; c1 += 1) {
//             <    is read   >: c0 c0max c0min c1 c1max c1min c2min
//             <    is written>: histp
         histp = &histogram[c0][c1][c2min];
//             <    is read   >: c0max c0min c1max c1min c2max c2min
//             <    is written>: c2
         for(c2 = c2min; c2 <= c2max; c2 += 1)
//             <    is read   >: c0max c0min c1max c1min c2max c2min 
//                               histp histp[0]
//             <    is written>: count histp
            if ((count = *histp++)!=0) {
//             <    is read   >: c0max c0min c1max c1min c2max c2min 
//                               count total
//             <    is written>: total
               total += count;
//             <    is read   >: c0 c0max c0min c0total c1max c1min 
//                               c2max c2min count
//             <    is written>: c0total
               c0total += ((c0<<8-5)+(1<<8-5>>1))*count;
//             <    is read   >: c0max c0min c1 c1max c1min c1total 
//                               c2max c2min count
//             <    is written>: c1total
               c1total += ((c1<<8-6)+(1<<8-6>>1))*count;
//             <    is read   >: c0max c0min c1max c1min c2 c2max 
//                               c2min c2total count
//             <    is written>: c2total
               c2total += ((c2<<8-5)+(1<<8-5>>1))*count;
            }
      }
//             <    is read   >: c0total cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[0] icolor total
//             <    is written>: cinfo[0].colormap[0][icolor]
   ((cinfo->colormap)[0])[icolor] = (JSAMPLE) ((c0total+(total>>1))/total);
//             <    is read   >: c1total cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[1] icolor total
//             <    is written>: cinfo[0].colormap[1][icolor]
   ((cinfo->colormap)[1])[icolor] = (JSAMPLE) ((c1total+(total>>1))/total);
//             <    is read   >: c2total cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[2] icolor total
//             <    is written>: cinfo[0].colormap[2][icolor]
   ((cinfo->colormap)[2])[icolor] = (JSAMPLE) ((c2total+(total>>1))/total);
}
static void fill_inverse_cmap(j_decompress_ptr cinfo, int c0, int c1, int c2)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   hist3d histogram = cquantize->histogram;
   int minc0, minc1, minc2;
   /* lower left corner of update box */
   int ic0, ic1, ic2;
   register JSAMPLE *cptr;
   /* pointer into bestcolor[] array */
   register histptr cachep;
   /* pointer into main cache array */
   /* This array lists the candidate colormap indexes. */
   JSAMPLE colorlist[255+1];
   int numcolors;
   /* number of candidate colors */
   /* This array holds the actually closest colormap index for each cell. */
   JSAMPLE bestcolor[(1<<5-3)*(1<<6-3)*(1<<5-3)];
//             <    is read   >: c0
//             <    is written>: c0
   
   /* Convert cell coordinates to update box ID */
   c0 >>= 5-3;
//             <    is read   >: c1
//             <    is written>: c1
   c1 >>= 6-3;
//             <    is read   >: c2
//             <    is written>: c2
   c2 >>= 5-3;
//             <    is read   >: c0
//             <    is written>: minc0
   
   /* Compute true coordinates of update box's origin corner.
      * Actually we compute the coordinates of the center of the corner
      * histogram cell, which are the lower bounds of the volume we care about.
      */
   minc0 = (c0<<8-5+(5-3))+(1<<8-5>>1);
//             <    is read   >: c1
//             <    is written>: minc1
   minc1 = (c1<<8-6+(6-3))+(1<<8-6>>1);
//             <    is read   >: c2
//             <    is written>: minc2
   minc2 = (c2<<8-5+(5-3))+(1<<8-5>>1);
//             <may be read   >: cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[0][*] 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[1][*] 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].colormap[2][*]
//             <may be written>: colorlist[*]
//             <    is read   >: cinfo 
//                               cinfo[0].actual_number_of_colors 
//                               minc0 minc1 minc2
//             <    is written>: numcolors
   
   /* Determine which colormap entries are close enough to be candidates
      * for the nearest entry to some cell in the update box.
      */
   numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
//             <may be read   >: cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[0][*] 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[1][*] 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].colormap[2][*] colorlist[*]
//             <    is read   >: cinfo minc0 minc1 minc2 numcolors
   
   /* Determine the actually nearest colors. */
   
   find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist, bestcolor);
//             <    is read   >: c0
//             <    is written>: c0
   
   /* Save the best color numbers (plus 1) in the main cache array */
   c0 <<= 5-3;
//             <    is read   >: c1
//             <    is written>: c1
   /* convert ID back to base cell indexes */
   c1 <<= 6-3;
//             <    is read   >: c2
//             <    is written>: c2
   c2 <<= 5-3;
//             <    is written>: cptr
   cptr = bestcolor;
//             <    is written>: ic0
   for(ic0 = 0; ic0 <= 3; ic0 += 1)
//             <    is written>: ic1
      for(ic1 = 0; ic1 <= 7; ic1 += 1) {
//             <    is read   >: c0 c1 c2 ic0 ic1
//             <    is written>: cachep
         cachep = &histogram[c0+ic0][c1+ic1][c2];
//             <    is written>: ic2
         for(ic2 = 0; ic2 <= 3; ic2 += 1)
//             <    is read   >: cachep cptr cptr[0]
//             <    is written>: cachep cachep[0] cptr
            *cachep++ = (histcell) ((int) *cptr++ +1);
      }
}
static void find_best_colors(j_decompress_ptr cinfo, int minc0, int minc1, int minc2, int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
{
   int ic0, ic1, ic2;
   int i, icolor;
   register INT32 *bptr;
   /* pointer into bestdist[] array */
   JSAMPLE *cptr;
   /* pointer into bestcolor[] array */
   INT32 dist0, dist1;
   /* initial distance values */
   register INT32 dist2;
   /* current distance in inner loop */
   INT32 xx0, xx1;
   /* distance increments */
   register INT32 xx2;
   INT32 inc0, inc1, inc2;
   /* initial values for increments */
   /* This array holds the distance to the nearest-so-far color for each cell */
   INT32 bestdist[(1<<5-3)*(1<<6-3)*(1<<5-3)];
//             <    is written>: bptr
   
   /* Initialize best-distance for each cell of the update box */
   bptr = bestdist;
//             <    is written>: i
   for(i = (1<<5-3)*(1<<6-3)*(1<<5-3)-1; i >= 0; i += -1)
//             <    is read   >: bptr
//             <    is written>: bptr bptr[0]
      *bptr++ = 0x7FFFFFFFL;
//             <    is read   >: numcolors
//             <    is written>: i
   
   /* For each color selected by find_nearby_colors,
      * compute its distance to the center of each cell in the box.
      * If that's less than best-so-far, update best distance and color number.
      */
   
   /* Nominal steps between cell centers ("x" in Thomas article) */
   
   
   
   
   for(i = 0; i <= numcolors-1; i += 1) {
//             <    is read   >: colorlist[i] i numcolors
//             <    is written>: icolor
      icolor = (int) colorlist[i];
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[0][icolor] icolor 
//                               minc0 numcolors
//             <    is written>: inc0
      /* Compute (square of) distance from minc0/c1/c2 to this color */
      inc0 = (minc0-((int) ((cinfo->colormap)[0])[icolor]))*2;
//             <    is read   >: inc0 numcolors
//             <    is written>: dist0
      dist0 = inc0*inc0;
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[1][icolor] icolor 
//                               minc1 numcolors
//             <    is written>: inc1
      inc1 = (minc1-((int) ((cinfo->colormap)[1])[icolor]))*3;
//             <    is read   >: dist0 inc1 numcolors
//             <    is written>: dist0
      dist0 += inc1*inc1;
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].colormap[2][icolor] icolor 
//                               minc2 numcolors
//             <    is written>: inc2
      inc2 = (minc2-((int) ((cinfo->colormap)[2])[icolor]))*1;
//             <    is read   >: dist0 inc2 numcolors
//             <    is written>: dist0
      dist0 += inc2*inc2;
//             <    is read   >: inc0 numcolors
//             <    is written>: inc0
      /* Form the initial difference increments */
      inc0 = inc0*2*(1<<8-5)*2+(1<<8-5)*2*(1<<8-5)*2;
//             <    is read   >: inc1 numcolors
//             <    is written>: inc1
      inc1 = inc1*2*(1<<8-6)*3+(1<<8-6)*3*(1<<8-6)*3;
//             <    is read   >: inc2 numcolors
//             <    is written>: inc2
      inc2 = inc2*2*(1<<8-5)*1+(1<<8-5)*1*(1<<8-5)*1;
//             <    is read   >: numcolors
//             <    is written>: bptr
      /* Now loop over all cells in box, updating distance per Thomas method */
      bptr = bestdist;
//             <    is read   >: numcolors
//             <    is written>: cptr
      cptr = bestcolor;
//             <    is read   >: inc0 numcolors
//             <    is written>: xx0
      xx0 = inc0;
//             <    is read   >: numcolors
//             <    is written>: ic0
      for(ic0 = (1<<5-3)-1; ic0 >= 0; ic0 += -1) {
//             <    is read   >: dist0 numcolors
//             <    is written>: dist1
         dist1 = dist0;
//             <    is read   >: inc1 numcolors
//             <    is written>: xx1
         xx1 = inc1;
//             <    is read   >: numcolors
//             <    is written>: ic1
         for(ic1 = (1<<6-3)-1; ic1 >= 0; ic1 += -1) {
//             <    is read   >: dist1 numcolors
//             <    is written>: dist2
            dist2 = dist1;
//             <    is read   >: inc2 numcolors
//             <    is written>: xx2
            xx2 = inc2;
//             <    is read   >: numcolors
//             <    is written>: ic2
            for(ic2 = (1<<5-3)-1; ic2 >= 0; ic2 += -1) {
//             <    is read   >: bptr bptr[0] dist2 numcolors
               if (dist2<*bptr) {
//             <    is read   >: bptr dist2 numcolors
//             <    is written>: bptr[0]
                  *bptr = dist2;
//             <    is read   >: cptr icolor numcolors
//             <    is written>: cptr[0]
                  *cptr = (JSAMPLE) icolor;
               }
//             <    is read   >: dist2 numcolors xx2
//             <    is written>: dist2
               dist2 += xx2;
//             <    is read   >: numcolors xx2
//             <    is written>: xx2
               xx2 += 2*(1<<8-5)*1*(1<<8-5)*1;
//             <    is read   >: bptr numcolors
//             <    is written>: bptr
               bptr++;
//             <    is read   >: cptr numcolors
//             <    is written>: cptr
               cptr++;
            }
//             <    is read   >: dist1 numcolors xx1
//             <    is written>: dist1
            dist1 += xx1;
//             <    is read   >: numcolors xx1
//             <    is written>: xx1
            xx1 += 2*(1<<8-6)*3*(1<<8-6)*3;
         }
//             <    is read   >: dist0 numcolors xx0
//             <    is written>: dist0
         dist0 += xx0;
//             <    is read   >: numcolors xx0
//             <    is written>: xx0
         xx0 += 2*(1<<8-5)*2*(1<<8-5)*2;
      }
   }
}
static boxptr find_biggest_color_pop(boxptr boxlist, int numboxes)
{
   register boxptr boxp;
   register int i;
//             <    is written>: maxc
   register long int maxc = 0;
//             <    is written>: which
   boxptr which = (void *) 0;
//             <    is read   >: boxlist
//             <    is written>: boxp
   boxp = boxlist;
//             <    is read   >: numboxes
//             <    is written>: i

   for(i = 0; i <= numboxes-1; i += 1) {
//             <    is read   >: boxp boxp[0].colorcount 
//                               boxp[0].volume maxc numboxes
      if (boxp->colorcount>maxc&&boxp->volume>0) {
//             <    is read   >: boxp numboxes
//             <    is written>: which
         which = boxp;
//             <    is read   >: boxp boxp[0].colorcount numboxes
//             <    is written>: maxc
         maxc = boxp->colorcount;
      }
//             <    is read   >: boxp numboxes
//             <    is written>: boxp
      boxp++;
   }
//             <    is read   >: which
   return which;
}
static boxptr find_biggest_volume(boxptr boxlist, int numboxes)
{
   register boxptr boxp;
   register int i;
//             <    is written>: maxv
   register INT32 maxv = 0;
//             <    is written>: which
   boxptr which = (void *) 0;
//             <    is read   >: boxlist
//             <    is written>: boxp
   boxp = boxlist;
//             <    is read   >: numboxes
//             <    is written>: i

   for(i = 0; i <= numboxes-1; i += 1) {
//             <    is read   >: boxp boxp[0].volume maxv numboxes
      if (boxp->volume>maxv) {
//             <    is read   >: boxp numboxes
//             <    is written>: which
         which = boxp;
//             <    is read   >: boxp boxp[0].volume numboxes
//             <    is written>: maxv
         maxv = boxp->volume;
      }
//             <    is read   >: boxp numboxes
//             <    is written>: boxp
      boxp++;
   }
//             <    is read   >: which
   return which;
}
static int find_nearby_colors(j_decompress_ptr cinfo, int minc0, int minc1, int minc2, JSAMPLE colorlist[])
{
//             <    is read   >: cinfo 
//                               cinfo[0].actual_number_of_colors
//             <    is written>: numcolors
   int numcolors = cinfo->actual_number_of_colors;
   int maxc0, maxc1, maxc2;
   int centerc0, centerc1, centerc2;
   int i, x, ncolors;
   INT32 minmaxdist, min_dist, max_dist, tdist;
   INT32 mindist[255+1];
//             <    is read   >: minc0
//             <    is written>: maxc0
   /* min distance to colormap entry i */
   
   /* Compute true coordinates of update box's upper corner and center.
      * Actually we compute the coordinates of the center of the upper-corner
      * histogram cell, which are the upper bounds of the volume we care about.
      * Note that since ">>" rounds down, the "center" values may be closer to
      * min than to max; hence comparisons to them must be "<=", not "<".
      */
   maxc0 = minc0+((1<<8-5+(5-3))-(1<<8-5));
//             <    is read   >: maxc0 minc0
//             <    is written>: centerc0
   centerc0 = minc0+maxc0>>1;
//             <    is read   >: minc1
//             <    is written>: maxc1
   maxc1 = minc1+((1<<8-6+(6-3))-(1<<8-6));
//             <    is read   >: maxc1 minc1
//             <    is written>: centerc1
   centerc1 = minc1+maxc1>>1;
//             <    is read   >: minc2
//             <    is written>: maxc2
   maxc2 = minc2+((1<<8-5+(5-3))-(1<<8-5));
//             <    is read   >: maxc2 minc2
//             <    is written>: centerc2
   centerc2 = minc2+maxc2>>1;
//             <    is written>: minmaxdist
   
   /* For each color in colormap, find:
      *  1. its minimum squared-distance to any point in the update box
      *     (zero if color is within update box);
      *  2. its maximum squared-distance to any point in the update box.
      * Both of these can be found by considering only the corners of the box.
      * We save the minimum distance for each color in mindist[];
      * only the smallest maximum distance is of interest.
      */
   minmaxdist = 0x7FFFFFFFL;
//             <    is read   >: numcolors
//             <    is written>: i

   for(i = 0; i <= numcolors-1; i += 1) {
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[0][i] i numcolors
//             <    is written>: x
      /* We compute the squared-c0-distance term, then add in the other two. */
      x = (int) ((cinfo->colormap)[0])[i];
//             <    is read   >: minc0 numcolors x
      if (x<minc0) {
//             <    is read   >: minc0 numcolors x
//             <    is written>: tdist
         tdist = (x-minc0)*2;
//             <    is read   >: numcolors tdist
//             <    is written>: min_dist
         min_dist = tdist*tdist;
//             <    is read   >: maxc0 numcolors x
//             <    is written>: tdist
         tdist = (x-maxc0)*2;
//             <    is read   >: numcolors tdist
//             <    is written>: max_dist
         max_dist = tdist*tdist;
      }
      else if (x>maxc0) {
//             <    is read   >: maxc0 numcolors x
//             <    is written>: tdist
         tdist = (x-maxc0)*2;
//             <    is read   >: numcolors tdist
//             <    is written>: min_dist
         min_dist = tdist*tdist;
//             <    is read   >: minc0 numcolors x
//             <    is written>: tdist
         tdist = (x-minc0)*2;
//             <    is read   >: numcolors tdist
//             <    is written>: max_dist
         max_dist = tdist*tdist;
      }
      else {
//             <    is read   >: numcolors
//             <    is written>: min_dist
         /* within cell range so no contribution to min_dist */
         min_dist = 0;
//             <    is read   >: centerc0 numcolors x
         if (x<=centerc0) {
//             <    is read   >: maxc0 numcolors x
//             <    is written>: tdist
            tdist = (x-maxc0)*2;
//             <    is read   >: numcolors tdist
//             <    is written>: max_dist
            max_dist = tdist*tdist;
         }
         else {
//             <    is read   >: minc0 numcolors x
//             <    is written>: tdist
            tdist = (x-minc0)*2;
//             <    is read   >: numcolors tdist
//             <    is written>: max_dist
            max_dist = tdist*tdist;
         }
      }
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[1][i] i numcolors
//             <    is written>: x
      x = (int) ((cinfo->colormap)[1])[i];
//             <    is read   >: minc1 numcolors x
      if (x<minc1) {
//             <    is read   >: minc1 numcolors x
//             <    is written>: tdist
         tdist = (x-minc1)*3;
//             <    is read   >: min_dist numcolors tdist
//             <    is written>: min_dist
         min_dist += tdist*tdist;
//             <    is read   >: maxc1 numcolors x
//             <    is written>: tdist
         tdist = (x-maxc1)*3;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
         max_dist += tdist*tdist;
      }
      else if (x>maxc1) {
//             <    is read   >: maxc1 numcolors x
//             <    is written>: tdist
         tdist = (x-maxc1)*3;
//             <    is read   >: min_dist numcolors tdist
//             <    is written>: min_dist
         min_dist += tdist*tdist;
//             <    is read   >: minc1 numcolors x
//             <    is written>: tdist
         tdist = (x-minc1)*3;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
         max_dist += tdist*tdist;
      }
      else
//             <    is read   >: centerc1 numcolors x
         /* within cell range so no contribution to min_dist */
         if (x<=centerc1) {
//             <    is read   >: maxc1 numcolors x
//             <    is written>: tdist
            tdist = (x-maxc1)*3;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
            max_dist += tdist*tdist;
         }
         else {
//             <    is read   >: minc1 numcolors x
//             <    is written>: tdist
            tdist = (x-minc1)*3;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
            max_dist += tdist*tdist;
         }
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].colormap[2][i] i numcolors
//             <    is written>: x
      x = (int) ((cinfo->colormap)[2])[i];
//             <    is read   >: minc2 numcolors x
      if (x<minc2) {
//             <    is read   >: minc2 numcolors x
//             <    is written>: tdist
         tdist = (x-minc2)*1;
//             <    is read   >: min_dist numcolors tdist
//             <    is written>: min_dist
         min_dist += tdist*tdist;
//             <    is read   >: maxc2 numcolors x
//             <    is written>: tdist
         tdist = (x-maxc2)*1;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
         max_dist += tdist*tdist;
      }
      else if (x>maxc2) {
//             <    is read   >: maxc2 numcolors x
//             <    is written>: tdist
         tdist = (x-maxc2)*1;
//             <    is read   >: min_dist numcolors tdist
//             <    is written>: min_dist
         min_dist += tdist*tdist;
//             <    is read   >: minc2 numcolors x
//             <    is written>: tdist
         tdist = (x-minc2)*1;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
         max_dist += tdist*tdist;
      }
      else
//             <    is read   >: centerc2 numcolors x
         /* within cell range so no contribution to min_dist */
         if (x<=centerc2) {
//             <    is read   >: maxc2 numcolors x
//             <    is written>: tdist
            tdist = (x-maxc2)*1;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
            max_dist += tdist*tdist;
         }
         else {
//             <    is read   >: minc2 numcolors x
//             <    is written>: tdist
            tdist = (x-minc2)*1;
//             <    is read   >: max_dist numcolors tdist
//             <    is written>: max_dist
            max_dist += tdist*tdist;
         }
//             <    is read   >: i min_dist numcolors
//             <    is written>: mindist[i]

      mindist[i] = min_dist;
//             <    is read   >: max_dist minmaxdist numcolors
      /* save away the results */
      if (max_dist<minmaxdist)
//             <    is read   >: max_dist numcolors
//             <    is written>: minmaxdist
         minmaxdist = max_dist;
   }
//             <    is written>: ncolors
   
   /* Now we know that no cell in the update box is more than minmaxdist
      * away from some colormap entry.  Therefore, only colors that are
      * within minmaxdist of some part of the box need be considered.
      */
   ncolors = 0;
//             <    is read   >: numcolors
//             <    is written>: i
   for(i = 0; i <= numcolors-1; i += 1)
//             <    is read   >: i mindist[i] minmaxdist numcolors
      if (mindist[i]<=minmaxdist)
//             <    is read   >: i ncolors numcolors
//             <    is written>: colorlist[ncolors++] ncolors
         colorlist[ncolors++] = (JSAMPLE) i;
//             <    is read   >: ncolors
   return ncolors;
}
static void finish_pass1(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cinfo cquantize 
//                               cquantize[0].sv_colormap
//             <    is written>: cinfo[0].colormap
   
   /* Select the representative colors and fill in cinfo->colormap */
   cinfo->colormap = cquantize->sv_colormap;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   select_colors(cinfo, cquantize->desired);
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].needs_zeroed
   /* Force next pass to zero the color index table */
   cquantize->needs_zeroed = 1;
}
static void finish_pass2(j_decompress_ptr cinfo)
{
}
static void init_error_limit(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   int *table;
   int in, out;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   table = (int *) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,(255*2+1)*(size_t) sizeof(int));
//             <    is read   >: table
//             <    is written>: table
   table += 255;
//             <    is read   >: cquantize table
//             <    is written>: cquantize[0].error_limiter
   /* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
   cquantize->error_limiter = table;
//             <    is written>: out
   
   
   /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
   out = 0;
//             <    is written>: in
   for(in = 0; in <= 15; in += 1) {
//             <    is read   >: in out table
//             <    is written>: table[in]
      table[in] = out;
//             <    is read   >: in out table
//             <    is written>: table[-in]
      table[-in] = -out;
//             <    is read   >: out
//             <    is written>: out
      out++;
   }
//             <    is read   >: in
//             <    is written>: in
   /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
   for(in = in; in <= 47; in += 1) {
//             <    is read   >: in out table
//             <    is written>: table[in]
      table[in] = out;
//             <    is read   >: in out table
//             <    is written>: table[-in]
      table[-in] = -out;
//             <    is read   >: in out
//             <    is written>: out
      out += in&1?0:1;
   }
//             <    is read   >: in
//             <    is written>: in
   /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
   for(in = in; in <= 255; in += 1) {
//             <    is read   >: in out table
//             <    is written>: table[in]
      table[in] = out;
//             <    is read   >: in out table
//             <    is written>: table[-in]
      table[-in] = -out;
   }
}
static int median_cut(j_decompress_ptr cinfo, boxptr boxlist, int numboxes, int desired_colors)
{
   int n, lb;
   int c0, c1, c2, cmax;
   register boxptr b1, b2;
l99998:   ;
//             <    is read   >: desired_colors numboxes

   if (!(numboxes<desired_colors)) goto _break_1;
//             <    is read   >: desired_colors numboxes
   /* Select box to split.
        * Current algorithm: by population for first half, then by volume.
        */
   if (numboxes*2<=desired_colors)
//             <    is read   >: boxlist numboxes
//             <    is written>: b1
      b1 = find_biggest_color_pop(boxlist, numboxes);
   else
//             <    is read   >: boxlist numboxes
//             <    is written>: b1
      b1 = find_biggest_volume(boxlist, numboxes);
//             <    is read   >: b1
   if (b1==(void *) 0) goto l99999;
//             <    is read   >: numboxes
//             <    is written>: b2
   b2 = &boxlist[numboxes];
//             <    is read   >: b1 b1[0].c0max b2
//             <    is written>: b2[0].c0max
   /* where new box will go */
   /* Copy the color bounds to the new box. */
   b2->c0max = b1->c0max;
//             <    is read   >: b1 b1[0].c1max b2
//             <    is written>: b2[0].c1max
   b2->c1max = b1->c1max;
//             <    is read   >: b1 b1[0].c2max b2
//             <    is written>: b2[0].c2max
   b2->c2max = b1->c2max;
//             <    is read   >: b1 b1[0].c0min b2
//             <    is written>: b2[0].c0min
   b2->c0min = b1->c0min;
//             <    is read   >: b1 b1[0].c1min b2
//             <    is written>: b2[0].c1min
   b2->c1min = b1->c1min;
//             <    is read   >: b1 b1[0].c2min b2
//             <    is written>: b2[0].c2min
   b2->c2min = b1->c2min;
//             <    is read   >: b1 b1[0].c0max b1[0].c0min
//             <    is written>: c0
   /* Choose which axis to split the box on.
        * Current algorithm: longest scaled axis.
        * See notes in update_box about scaling distances.
        */
   c0 = (b1->c0max-b1->c0min<<8-5)*2;
//             <    is read   >: b1 b1[0].c1max b1[0].c1min
//             <    is written>: c1
   c1 = (b1->c1max-b1->c1min<<8-6)*3;
//             <    is read   >: b1 b1[0].c2max b1[0].c2min
//             <    is written>: c2
   c2 = (b1->c2max-b1->c2min<<8-5)*1;
//             <    is read   >: c1
//             <    is written>: cmax
   /* We want to break any ties in favor of green, then red, blue last.
        * This code does the right thing for R,G,B or B,G,R color orders only.
        */
   
   cmax = c1;
//             <    is written>: n
   n = 1;
//             <    is read   >: c0 cmax
   if (c0>cmax) {
//             <    is read   >: c0
//             <    is written>: cmax
      cmax = c0;
//             <    is written>: n
      n = 0;
   }
//             <    is read   >: c2 cmax
   if (c2>cmax)
//             <    is written>: n
      n = 2;
//             <    is read   >: n
   
   
   
   
   
   /* Choose split point along selected axis, and update box bounds.
        * Current algorithm: split at halfway point.
        * (Since the box has been shrunk to minimum volume,
        * any split will produce two nonempty subboxes.)
        * Note that lb value is max for lower box, so must be < old max.
        */
   if (n==0) {
_switch_2_case_0:      ;
//             <    is read   >: b1 b1[0].c0max b1[0].c0min
//             <    is written>: lb
      lb = (b1->c0max+b1->c0min)/2;
//             <    is read   >: b1 lb
//             <    is written>: b1[0].c0max
      b1->c0max = lb;
//             <    is read   >: b2 lb
//             <    is written>: b2[0].c0min
      b2->c0min = lb+1;
   }
   else if (n==1) {
_switch_2_case_1:      ;
//             <    is read   >: b1 b1[0].c1max b1[0].c1min
//             <    is written>: lb
      lb = (b1->c1max+b1->c1min)/2;
//             <    is read   >: b1 lb
//             <    is written>: b1[0].c1max
      b1->c1max = lb;
//             <    is read   >: b2 lb
//             <    is written>: b2[0].c1min
      b2->c1min = lb+1;
   }
   else if (n==2) {
_switch_2_case_2:      ;
//             <    is read   >: b1 b1[0].c2max b1[0].c2min
//             <    is written>: lb
      lb = (b1->c2max+b1->c2min)/2;
//             <    is read   >: b1 lb
//             <    is written>: b1[0].c2max
      b1->c2max = lb;
//             <    is read   >: b2 lb
//             <    is written>: b2[0].c2min
      b2->c2min = lb+1;
   }
_break_2:   ;
//             <may be written>: b1[0].c0max b1[0].c0min b1[0].c1max 
//                               b1[0].c1min b1[0].c2max b1[0].c2min
//             <    is read   >: b1 b1[0].c0max b1[0].c0min 
//                               b1[0].c1max b1[0].c1min b1[0].c2max 
//                               b1[0].c2min cinfo cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram
//             <    is written>: b1[0].colorcount b1[0].volume
   /* Update stats for boxes */
   update_box(cinfo, b1);
//             <may be written>: b2[0].c0max b2[0].c0min b2[0].c1max 
//                               b2[0].c1min b2[0].c2max b2[0].c2min
//             <    is read   >: b2 b2[0].c0max b2[0].c0min 
//                               b2[0].c1max b2[0].c1min b2[0].c2max 
//                               b2[0].c2min cinfo cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram
//             <    is written>: b2[0].colorcount b2[0].volume
   update_box(cinfo, b2);
//             <    is read   >: numboxes
//             <    is written>: numboxes
   numboxes++;
   goto l99998;
l99999:   ;
   /* no splittable boxes left! */
   ;
_break_1:   ;
//             <    is read   >: numboxes
   return numboxes;
}
static void new_color_map_2_quant(j_decompress_ptr cinfo)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].needs_zeroed
   
   /* Reset the inverse color map */
   cquantize->needs_zeroed = 1;
}
static void pass2_fs_dither(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   hist3d histogram = cquantize->histogram;
   register LOCFSERROR cur0, cur1, cur2;
   /* current error or pixel value */
   LOCFSERROR belowerr0, belowerr1, belowerr2;
   /* error for pixel below cur */
   LOCFSERROR bpreverr0, bpreverr1, bpreverr2;
   /* error for below/prev col */
   register FSERRPTR errorptr;
   /* => fserrors[] at column before current */
   JSAMPROW inptr;
   /* => current input pixel */
   JSAMPROW outptr;
   /* => current output pixel */
   histptr cachep;
   int dir;
   /* +1 or -1 depending on direction */
   int dir3;
   /* 3*dir, for advancing inptr & errorptr */
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: cinfo cinfo[0].sample_range_limit
//             <    is written>: range_limit
   JSAMPLE *range_limit = cinfo->sample_range_limit;
//             <    is read   >: cquantize cquantize[0].error_limiter
//             <    is written>: error_limit
   int *error_limit = cquantize->error_limiter;
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[0]
//             <    is written>: colormap0
   JSAMPROW colormap0 = (cinfo->colormap)[0];
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[1]
//             <    is written>: colormap1
   JSAMPROW colormap1 = (cinfo->colormap)[1];
//             <    is read   >: cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[2]
//             <    is written>: colormap2
   JSAMPROW colormap2 = (cinfo->colormap)[2];
//             <    is read   >: num_rows
//             <    is written>: row
   
   
   for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: input_buf input_buf[row] num_rows row
//             <    is written>: inptr
      inptr = input_buf[row];
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row
//             <    is written>: outptr
      outptr = output_buf[row];
//             <    is read   >: cquantize cquantize[0].on_odd_row 
//                               num_rows
      if (cquantize->on_odd_row) {
//             <    is read   >: inptr num_rows width
//             <    is written>: inptr
         /* work right to left in this row */
         inptr += (width-1)*3;
//             <    is read   >: num_rows outptr width
//             <    is written>: outptr
         /* so point to rightmost pixel */
         outptr += width-1;
//             <    is read   >: num_rows
//             <    is written>: dir
         dir = -1;
//             <    is read   >: num_rows
//             <    is written>: dir3
         dir3 = -3;
//             <    is read   >: cquantize cquantize[0].fserrors 
//                               num_rows width
//             <    is written>: errorptr
         errorptr = cquantize->fserrors+(width+1)*3;
//             <    is read   >: cquantize num_rows
//             <    is written>: cquantize[0].on_odd_row
         /* => entry after last column */
         cquantize->on_odd_row = 0;
      }
      else {
//             <    is read   >: num_rows
//             <    is written>: dir
         /* work left to right in this row */
         dir = 1;
//             <    is read   >: num_rows
//             <    is written>: dir3
         dir3 = 3;
//             <    is read   >: cquantize cquantize[0].fserrors 
//                               num_rows
//             <    is written>: errorptr
         errorptr = cquantize->fserrors;
//             <    is read   >: cquantize num_rows
//             <    is written>: cquantize[0].on_odd_row
         /* => entry before first real column */
         cquantize->on_odd_row = 1;
      }
//             <    is read   >: num_rows
//             <    is written>: cur0 cur1 cur2
      /* Preset error values: no error propagated to first pixel from left */
      cur0 = cur1 = cur2 = 0;
//             <    is read   >: num_rows
//             <    is written>: belowerr0 belowerr1 belowerr2
      /* and no error propagated to row below yet */
      belowerr0 = belowerr1 = belowerr2 = 0;
//             <    is read   >: num_rows
//             <    is written>: bpreverr0 bpreverr1 bpreverr2
      bpreverr0 = bpreverr1 = bpreverr2 = 0;
//             <    is read   >: num_rows width
//             <    is written>: col

      for(col = width; col >= 1; col += -1) {
//             <    is read   >: cur0 dir3 errorptr errorptr[dir3+0] 
//                               num_rows width
//             <    is written>: cur0
         /* curN holds the error propagated from the previous pixel on the
                * current line.  Add the error propagated from the previous line
                * to form the complete error correction term for this pixel, and
                * round the error term (which is expressed * 16) to an integer.
                * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
                * for either sign of the error value.
                * Note: errorptr points to *previous* column's array entry.
                */
         cur0 = cur0+errorptr[dir3+0]+8>>4;
//             <    is read   >: cur1 dir3 errorptr errorptr[dir3+1] 
//                               num_rows width
//             <    is written>: cur1
         cur1 = cur1+errorptr[dir3+1]+8>>4;
//             <    is read   >: cur2 dir3 errorptr errorptr[dir3+2] 
//                               num_rows width
//             <    is written>: cur2
         cur2 = cur2+errorptr[dir3+2]+8>>4;
//             <    is read   >: cur0 error_limit error_limit[cur0] 
//                               num_rows width
//             <    is written>: cur0
         /* Limit the error using transfer function set by init_error_limit.
                * See comments with init_error_limit for rationale.
                */
         cur0 = error_limit[cur0];
//             <    is read   >: cur1 error_limit error_limit[cur1] 
//                               num_rows width
//             <    is written>: cur1
         cur1 = error_limit[cur1];
//             <    is read   >: cur2 error_limit error_limit[cur2] 
//                               num_rows width
//             <    is written>: cur2
         cur2 = error_limit[cur2];
//             <    is read   >: cur0 inptr inptr[0] num_rows width
//             <    is written>: cur0
         /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
                * The maximum error is +- MAXJSAMPLE (or less with error limiting);
                * this sets the required size of the range_limit array.
                */
         cur0 += (int) inptr[0];
//             <    is read   >: cur1 inptr inptr[1] num_rows width
//             <    is written>: cur1
         cur1 += (int) inptr[1];
//             <    is read   >: cur2 inptr inptr[2] num_rows width
//             <    is written>: cur2
         cur2 += (int) inptr[2];
//             <    is read   >: cur0 num_rows range_limit 
//                               range_limit[cur0] width
//             <    is written>: cur0
         cur0 = (int) range_limit[cur0];
//             <    is read   >: cur1 num_rows range_limit 
//                               range_limit[cur1] width
//             <    is written>: cur1
         cur1 = (int) range_limit[cur1];
//             <    is read   >: cur2 num_rows range_limit 
//                               range_limit[cur2] width
//             <    is written>: cur2
         cur2 = (int) range_limit[cur2];
//             <    is read   >: cur0 cur1 cur2 num_rows width
//             <    is written>: cachep
         /* Index into the cache with adjusted pixel value */
         cachep = &histogram[cur0>>8-5][cur1>>8-6][cur2>>8-5];
//             <    is read   >: cachep cachep[0] num_rows width
         /* If we have not seen this color before, find nearest colormap */
         /* entry and update the cache */
         if (*cachep==0)
//             <may be read   >: cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[0][*] 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[1][*] 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].colormap[2][*]
//             <    is read   >: cinfo 
//                               cinfo[0].actual_number_of_colors 
//                               cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram cur0 
//                               cur1 cur2 num_rows width
            fill_inverse_cmap(cinfo, cur0>>8-5, cur1>>8-6, cur2>>8-5);
         {
//             <    is read   >: cachep cachep[0]
//             <    is written>: pixcode
            register int pixcode = *cachep-1;
//             <    is read   >: num_rows outptr pixcode width
//             <    is written>: outptr[0]
            *outptr = (JSAMPLE) pixcode;
//             <    is read   >: colormap0 colormap0[pixcode] cur0 
//                               num_rows pixcode width
//             <    is written>: cur0
            /* Compute representation error for this pixel */
            cur0 -= (int) colormap0[pixcode];
//             <    is read   >: colormap1 colormap1[pixcode] cur1 
//                               num_rows pixcode width
//             <    is written>: cur1
            cur1 -= (int) colormap1[pixcode];
//             <    is read   >: colormap2 colormap2[pixcode] cur2 
//                               num_rows pixcode width
//             <    is written>: cur2
            cur2 -= (int) colormap2[pixcode];
         }
         {
            register LOCFSERROR bnexterr, delta;
//             <    is read   >: cur0 num_rows width
//             <    is written>: bnexterr

            bnexterr = cur0;
//             <    is read   >: cur0 num_rows width
//             <    is written>: delta
            /* Process component 0 */
            delta = cur0*2;
//             <    is read   >: cur0 delta num_rows width
//             <    is written>: cur0
            cur0 += delta;
//             <    is read   >: bpreverr0 cur0 errorptr num_rows 
//                               width
//             <    is written>: errorptr[0]
            /* form error * 3 */
            errorptr[0] = (FSERROR) (bpreverr0+cur0);
//             <    is read   >: cur0 delta num_rows width
//             <    is written>: cur0
            cur0 += delta;
//             <    is read   >: belowerr0 cur0 num_rows width
//             <    is written>: bpreverr0
            /* form error * 5 */
            bpreverr0 = belowerr0+cur0;
//             <    is read   >: bnexterr num_rows width
//             <    is written>: belowerr0
            belowerr0 = bnexterr;
//             <    is read   >: cur0 delta num_rows width
//             <    is written>: cur0
            cur0 += delta;
//             <    is read   >: cur1 num_rows width
//             <    is written>: bnexterr
            /* form error * 7 */
            bnexterr = cur1;
//             <    is read   >: cur1 num_rows width
//             <    is written>: delta
            /* Process component 1 */
            delta = cur1*2;
//             <    is read   >: cur1 delta num_rows width
//             <    is written>: cur1
            cur1 += delta;
//             <    is read   >: bpreverr1 cur1 errorptr num_rows 
//                               width
//             <    is written>: errorptr[1]
            /* form error * 3 */
            errorptr[1] = (FSERROR) (bpreverr1+cur1);
//             <    is read   >: cur1 delta num_rows width
//             <    is written>: cur1
            cur1 += delta;
//             <    is read   >: belowerr1 cur1 num_rows width
//             <    is written>: bpreverr1
            /* form error * 5 */
            bpreverr1 = belowerr1+cur1;
//             <    is read   >: bnexterr num_rows width
//             <    is written>: belowerr1
            belowerr1 = bnexterr;
//             <    is read   >: cur1 delta num_rows width
//             <    is written>: cur1
            cur1 += delta;
//             <    is read   >: cur2 num_rows width
//             <    is written>: bnexterr
            /* form error * 7 */
            bnexterr = cur2;
//             <    is read   >: cur2 num_rows width
//             <    is written>: delta
            /* Process component 2 */
            delta = cur2*2;
//             <    is read   >: cur2 delta num_rows width
//             <    is written>: cur2
            cur2 += delta;
//             <    is read   >: bpreverr2 cur2 errorptr num_rows 
//                               width
//             <    is written>: errorptr[2]
            /* form error * 3 */
            errorptr[2] = (FSERROR) (bpreverr2+cur2);
//             <    is read   >: cur2 delta num_rows width
//             <    is written>: cur2
            cur2 += delta;
//             <    is read   >: belowerr2 cur2 num_rows width
//             <    is written>: bpreverr2
            /* form error * 5 */
            bpreverr2 = belowerr2+cur2;
//             <    is read   >: bnexterr num_rows width
//             <    is written>: belowerr2
            belowerr2 = bnexterr;
//             <    is read   >: cur2 delta num_rows width
//             <    is written>: cur2
            cur2 += delta;
         }
//             <    is read   >: dir3 inptr num_rows width
//             <    is written>: inptr
         /* At this point curN contains the 7/16 error value to be propagated
                * to the next pixel on the current line, and all the errors for the
                * next line have been shifted over.  We are therefore ready to move on.
                */
         inptr += dir3;
//             <    is read   >: dir num_rows outptr width
//             <    is written>: outptr
         /* Advance pixel pointers to next column */
         outptr += dir;
//             <    is read   >: dir3 errorptr num_rows width
//             <    is written>: errorptr
         errorptr += dir3;
      }
//             <    is read   >: bpreverr0 errorptr num_rows
//             <    is written>: errorptr[0]
      /* Post-loop cleanup: we must unload the final error values into the
           * final fserrors[] entry.  Note we need not unload belowerrN because
           * it is for the dummy column before or after the actual array.
           */
      errorptr[0] = (FSERROR) bpreverr0;
//             <    is read   >: bpreverr1 errorptr num_rows
//             <    is written>: errorptr[1]
      /* unload prev errs into array */
      errorptr[1] = (FSERROR) bpreverr1;
//             <    is read   >: bpreverr2 errorptr num_rows
//             <    is written>: errorptr[2]
      errorptr[2] = (FSERROR) bpreverr2;
   }
}
static void pass2_no_dither(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   hist3d histogram = cquantize->histogram;
   register JSAMPROW inptr, outptr;
   register histptr cachep;
   register int c0, c1, c2;
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: input_buf input_buf[row] num_rows row
//             <    is written>: inptr
      inptr = input_buf[row];
//             <    is read   >: num_rows output_buf output_buf[row] 
//                               row
//             <    is written>: outptr
      outptr = output_buf[row];
//             <    is read   >: num_rows width
//             <    is written>: col
      for(col = width; col >= 1; col += -1) {
//             <    is read   >: inptr inptr[0] num_rows width
//             <    is written>: c0 inptr
         /* get pixel value and index into the cache */
         c0 = (int) *inptr++>>8-5;
//             <    is read   >: inptr inptr[0] num_rows width
//             <    is written>: c1 inptr
         c1 = (int) *inptr++>>8-6;
//             <    is read   >: inptr inptr[0] num_rows width
//             <    is written>: c2 inptr
         c2 = (int) *inptr++>>8-5;
//             <    is read   >: c0 c1 c2 num_rows width
//             <    is written>: cachep
         cachep = &histogram[c0][c1][c2];
//             <    is read   >: cachep cachep[0] num_rows width
         /* If we have not seen this color before, find nearest colormap entry */
         /* and update the cache */
         if (*cachep==0)
//             <may be read   >: cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[0][*] 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[1][*] 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].colormap[2][*]
//             <    is read   >: c0 c1 c2 cinfo 
//                               cinfo[0].actual_number_of_colors 
//                               cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram 
//                               num_rows width
            fill_inverse_cmap(cinfo, c0, c1, c2);
//             <    is read   >: cachep cachep[0] num_rows outptr 
//                               width
//             <    is written>: outptr outptr[0]
         /* Now emit the colormap index for this cell */
         *outptr++ = (JSAMPLE) (*cachep-1);
      }
   }
}
static void prescan_quantize(j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
   register JSAMPROW ptr;
   register histptr histp;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   register hist3d histogram = cquantize->histogram;
   int row;
   JDIMENSION col;
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: width
   JDIMENSION width = cinfo->output_width;
//             <    is read   >: num_rows
//             <    is written>: row

   for(row = 0; row <= num_rows-1; row += 1) {
//             <    is read   >: input_buf input_buf[row] num_rows row
//             <    is written>: ptr
      ptr = input_buf[row];
//             <    is read   >: num_rows width
//             <    is written>: col
      for(col = width; col >= 1; col += -1) {
//             <    is read   >: num_rows ptr ptr[0] ptr[1] ptr[2] 
//                               width
//             <    is written>: histp
         /* get pixel value and index into the histogram */
         histp = &histogram[(int) ptr[0]>>8-5][(int) ptr[1]>>8-6][(int) ptr[2]>>8-5];
//             <    is read   >: histp histp[0] num_rows width
//             <    is written>: histp[0]
         /* increment, check for overflow and undo increment if so. */
         if (++*histp<=0)
//             <    is read   >: histp histp[0] num_rows width
//             <    is written>: histp[0]
            (*histp)--;
//             <    is read   >: num_rows ptr width
//             <    is written>: ptr
         ptr += 3;
      }
   }
}
static void select_colors(j_decompress_ptr cinfo, int desired_colors)
{
   boxptr boxlist;
   int numboxes;
   int i;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   
   /* Allocate workspace for box list */
   boxlist = (boxptr) (*cinfo->mem->alloc_small)((j_common_ptr) cinfo,1,desired_colors*(size_t) sizeof(box));
//             <    is written>: numboxes
   /* Initialize one box containing whole space */
   numboxes = 1;
//             <    is read   >: boxlist
//             <    is written>: boxlist[0].c0min
   boxlist[0].c0min = 0;
//             <    is read   >: boxlist
//             <    is written>: boxlist[0].c0max
   boxlist[0].c0max = 255>>8-5;
//             <    is read   >: boxlist
//             <    is written>: boxlist[0].c1min
   boxlist[0].c1min = 0;
//             <    is read   >: boxlist
//             <    is written>: boxlist[0].c1max
   boxlist[0].c1max = 255>>8-6;
//             <    is read   >: boxlist
//             <    is written>: boxlist[0].c2min
   boxlist[0].c2min = 0;
//             <    is read   >: boxlist
//             <    is written>: boxlist[0].c2max
   boxlist[0].c2max = 255>>8-5;
//             <may be written>: boxlist[0].c0max boxlist[0].c0min 
//                               boxlist[0].c1max boxlist[0].c1min 
//                               boxlist[0].c2max boxlist[0].c2min
//             <    is read   >: boxlist[0].c0max boxlist[0].c0min 
//                               boxlist[0].c1max boxlist[0].c1min 
//                               boxlist[0].c2max boxlist[0].c2min 
//                               cinfo cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram
//             <    is written>: boxlist[0].colorcount 
//                               boxlist[0].volume
   /* Shrink it to actually-used volume and set its statistics */
   update_box(cinfo, &boxlist[0]);
//             <may be read   >: cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram
//             <    is read   >: boxlist cinfo desired_colors numboxes
//             <    is written>: numboxes
   /* Perform median-cut to produce final box list */
   numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
//             <    is read   >: numboxes
//             <    is written>: i
   /* Compute the representative color for each box, fill colormap */
   for(i = 0; i <= numboxes-1; i += 1)
//             <may be written>: cinfo[0].colormap[0][*] 
//                               cinfo[0].colormap[1][*] 
//                               cinfo[0].colormap[2][*]
//             <    is read   >: boxlist[i].c0max boxlist[i].c0min 
//                               boxlist[i].c1max boxlist[i].c1min 
//                               boxlist[i].c2max boxlist[i].c2min 
//                               cinfo cinfo[0].colormap 
//                               cinfo[0].colormap[0] 
//                               cinfo[0].colormap[1] 
//                               cinfo[0].colormap[2] 
//                               cinfo[0].cquantize 
//                               cinfo[0].cquantize[0].histogram i 
//                               numboxes
      compute_color(cinfo, &boxlist[i], i);
//             <    is read   >: cinfo numboxes
//             <    is written>: cinfo[0].actual_number_of_colors
   cinfo->actual_number_of_colors = numboxes;
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
   cinfo->err->msg_code = JTRC_QUANT_SELECTED, (cinfo->err->msg_parm.i)[0] = numboxes, (*cinfo->err->emit_message)((j_common_ptr) cinfo,1);
}
static void start_pass_2_quant(j_decompress_ptr cinfo, boolean is_pre_scan)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   hist3d histogram = cquantize->histogram;
   int i;
//             <    is read   >: cinfo cinfo[0].dither_mode
   
   /* Only F-S dithering or no dithering is supported. */
   /* If user asks for ordered dither, give him F-S. */
   if (cinfo->dither_mode!=JDITHER_NONE)
//             <    is read   >: cinfo
//             <    is written>: cinfo[0].dither_mode
      cinfo->dither_mode = JDITHER_FS;
//             <    is read   >: is_pre_scan

   if (is_pre_scan) {
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
      /* Set up method pointers */
      cquantize->pub.color_quantize = prescan_quantize;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.finish_pass
      cquantize->pub.finish_pass = finish_pass1;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].needs_zeroed
      cquantize->needs_zeroed = 1;
   }
   else {
//             <    is read   >: cinfo cinfo[0].dither_mode
      /* Set up method pointers */
      if (cinfo->dither_mode==JDITHER_FS)
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
         cquantize->pub.color_quantize = pass2_fs_dither;
      else
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.color_quantize
         cquantize->pub.color_quantize = pass2_no_dither;
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].pub.finish_pass
      cquantize->pub.finish_pass = finish_pass2;
//             <    is read   >: cinfo 
//                               cinfo[0].actual_number_of_colors
//             <    is written>: i
      
      /* Make sure color count is acceptable */
      i = cinfo->actual_number_of_colors;
//             <    is read   >: i
      if (i<1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_QUANT_FEW_COLORS, (cinfo->err->msg_parm.i)[0] = 1, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: i
      if (i>255+1)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
         cinfo->err->msg_code = JERR_QUANT_MANY_COLORS, (cinfo->err->msg_parm.i)[0] = 255+1, (*cinfo->err->error_exit)((j_common_ptr) cinfo);
//             <    is read   >: cinfo cinfo[0].dither_mode

      if (cinfo->dither_mode==JDITHER_FS) {
//             <    is read   >: cinfo cinfo[0].output_width
//             <    is written>: arraysize
         size_t arraysize = (size_t) ((cinfo->output_width+2)*3*(size_t) sizeof(FSERROR));
//             <    is read   >: cquantize cquantize[0].fserrors
         /* Allocate Floyd-Steinberg workspace if we didn't already. */
         if (cquantize->fserrors==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)((j_common_ptr) cinfo,1,arraysize);
//             <may be written>: cquantize[0].fserrors[*]
//             <    is read   >: arraysize cquantize 
//                               cquantize[0].fserrors
         /* Initialize the propagated errors to zero. */
         jzero_far((void *) cquantize->fserrors, arraysize);
//             <    is read   >: cquantize cquantize[0].error_limiter
         /* Make the error-limit table if we didn't already. */
         if (cquantize->error_limiter==(void *) 0)
//             <may be read   >: *ANY_MODULE*:*ANYWHERE*
//             <may be written>: *ANY_MODULE*:*ANYWHERE*
            init_error_limit(cinfo);
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].on_odd_row
         cquantize->on_odd_row = 0;
      }
   }
//             <    is read   >: cquantize cquantize[0].needs_zeroed
   /* Zero the histogram or inverse color map, if necessary */
   if (cquantize->needs_zeroed) {
//             <    is written>: i
      for(i = 0; i <= 31; i += 1)
//             <may be written>: histogram[i][*][*]
//             <    is read   >: histogram histogram[i] i
         jzero_far((void *) histogram[i], (1<<6)*(1<<5)*(size_t) sizeof(histcell));
//             <    is read   >: cquantize
//             <    is written>: cquantize[0].needs_zeroed
      cquantize->needs_zeroed = 0;
   }
}
static void update_box(j_decompress_ptr cinfo, boxptr boxp)
{
//             <    is read   >: cinfo cinfo[0].cquantize
//             <    is written>: cquantize
   my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
//             <    is read   >: cquantize cquantize[0].histogram
//             <    is written>: histogram
   hist3d histogram = cquantize->histogram;
   histptr histp;
   int c0, c1, c2;
   int c0min, c0max, c1min, c1max, c2min, c2max;
   INT32 dist0, dist1, dist2;
   long int ccount;
//             <    is read   >: boxp boxp[0].c0min
//             <    is written>: c0min

   c0min = boxp->c0min;
//             <    is read   >: boxp boxp[0].c0max
//             <    is written>: c0max
   c0max = boxp->c0max;
//             <    is read   >: boxp boxp[0].c1min
//             <    is written>: c1min
   c1min = boxp->c1min;
//             <    is read   >: boxp boxp[0].c1max
//             <    is written>: c1max
   c1max = boxp->c1max;
//             <    is read   >: boxp boxp[0].c2min
//             <    is written>: c2min
   c2min = boxp->c2min;
//             <    is read   >: boxp boxp[0].c2max
//             <    is written>: c2max
   c2max = boxp->c2max;
//             <    is read   >: c0max c0min

   if (c0max>c0min) goto l99999;
//             <    is read   >: c0max c0min
have_c0min:   if (c0max>c0min) goto l99998;
//             <    is read   >: c1max c1min
have_c0max:   if (c1max>c1min) goto l99997;
//             <    is read   >: c1max c1min
have_c1min:   if (c1max>c1min) goto l99996;
//             <    is read   >: c2max c2min
have_c1max:   if (c2max>c2min) goto l99995;
//             <    is read   >: c2max c2min
have_c2min:   if (c2max>c2min) {
   }
   else {
      goto have_c2max;
   }
//             <    is read   >: c2max
//             <    is written>: c2
   c2 = c2max;
l99989:   ;
//             <    is read   >: c2 c2min
   if (!(c2>=c2min)) goto have_c2max;
//             <    is read   >: c0min
//             <    is written>: c0
   c0 = c0min;
l99990:   ;
//             <    is read   >: c0 c0max
   if (!(c0<=c0max)) goto l99994;
//             <    is read   >: c0 c1min c2
//             <    is written>: histp
   histp = &histogram[c0][c1min][c2];
//             <    is read   >: c1min
//             <    is written>: c1
   c1 = c1min;
l99991:   ;
//             <    is read   >: c1 c1max
   if (!(c1<=c1max)) goto l99993;
//             <    is read   >: histp histp[0]
   if (*histp!=0) goto l99992;
//             <    is read   >: c1 histp
//             <    is written>: c1 histp
   c1++, histp += 1<<5;
   goto l99991;
l99992:   ;
//             <    is read   >: boxp c2
//             <    is written>: boxp[0].c2max c2max
   boxp->c2max = c2max = c2;
   goto have_c2max;
l99993:   ;
//             <    is read   >: c0
//             <    is written>: c0
   c0++;
   goto l99990;
l99994:   ;
//             <    is read   >: c2
//             <    is written>: c2
   c2--;
   goto l99989;
l99995:   ;
//             <    is read   >: c2min
//             <    is written>: c2
   c2 = c2min;
l99983:   ;
//             <    is read   >: c2 c2max
   if (!(c2<=c2max)) goto have_c2min;
//             <    is read   >: c0min
//             <    is written>: c0
   c0 = c0min;
l99984:   ;
//             <    is read   >: c0 c0max
   if (!(c0<=c0max)) goto l99988;
//             <    is read   >: c0 c1min c2
//             <    is written>: histp
   histp = &histogram[c0][c1min][c2];
//             <    is read   >: c1min
//             <    is written>: c1
   c1 = c1min;
l99985:   ;
//             <    is read   >: c1 c1max
   if (!(c1<=c1max)) goto l99987;
//             <    is read   >: histp histp[0]
   if (*histp!=0) goto l99986;
//             <    is read   >: c1 histp
//             <    is written>: c1 histp
   c1++, histp += 1<<5;
   goto l99985;
l99986:   ;
//             <    is read   >: boxp c2
//             <    is written>: boxp[0].c2min c2min
   boxp->c2min = c2min = c2;
   goto have_c2min;
l99987:   ;
//             <    is read   >: c0
//             <    is written>: c0
   c0++;
   goto l99984;
l99988:   ;
//             <    is read   >: c2
//             <    is written>: c2
   c2++;
   goto l99983;
l99996:   ;
//             <    is read   >: c1max
//             <    is written>: c1
   c1 = c1max;
l99977:   ;
//             <    is read   >: c1 c1min
   if (!(c1>=c1min)) goto have_c1max;
//             <    is read   >: c0min
//             <    is written>: c0
   c0 = c0min;
l99978:   ;
//             <    is read   >: c0 c0max
   if (!(c0<=c0max)) goto l99982;
//             <    is read   >: c0 c1 c2min
//             <    is written>: histp
   histp = &histogram[c0][c1][c2min];
//             <    is read   >: c2min
//             <    is written>: c2
   c2 = c2min;
l99979:   ;
//             <    is read   >: c2 c2max
   if (!(c2<=c2max)) goto l99981;
//             <    is read   >: histp histp[0]
//             <    is written>: histp
   if (*histp++!=0) goto l99980;
//             <    is read   >: c2
//             <    is written>: c2
   c2++;
   goto l99979;
l99980:   ;
//             <    is read   >: boxp c1
//             <    is written>: boxp[0].c1max c1max
   boxp->c1max = c1max = c1;
   goto have_c1max;
l99981:   ;
//             <    is read   >: c0
//             <    is written>: c0
   c0++;
   goto l99978;
l99982:   ;
//             <    is read   >: c1
//             <    is written>: c1
   c1--;
   goto l99977;
l99997:   ;
//             <    is read   >: c1min
//             <    is written>: c1
   c1 = c1min;
l99971:   ;
//             <    is read   >: c1 c1max
   if (!(c1<=c1max)) goto have_c1min;
//             <    is read   >: c0min
//             <    is written>: c0
   c0 = c0min;
l99972:   ;
//             <    is read   >: c0 c0max
   if (!(c0<=c0max)) goto l99976;
//             <    is read   >: c0 c1 c2min
//             <    is written>: histp
   histp = &histogram[c0][c1][c2min];
//             <    is read   >: c2min
//             <    is written>: c2
   c2 = c2min;
l99973:   ;
//             <    is read   >: c2 c2max
   if (!(c2<=c2max)) goto l99975;
//             <    is read   >: histp histp[0]
//             <    is written>: histp
   if (*histp++!=0) goto l99974;
//             <    is read   >: c2
//             <    is written>: c2
   c2++;
   goto l99973;
l99974:   ;
//             <    is read   >: boxp c1
//             <    is written>: boxp[0].c1min c1min
   boxp->c1min = c1min = c1;
   goto have_c1min;
l99975:   ;
//             <    is read   >: c0
//             <    is written>: c0
   c0++;
   goto l99972;
l99976:   ;
//             <    is read   >: c1
//             <    is written>: c1
   c1++;
   goto l99971;
l99998:   ;
//             <    is read   >: c0max
//             <    is written>: c0
   c0 = c0max;
l99965:   ;
//             <    is read   >: c0 c0min
   if (!(c0>=c0min)) goto have_c0max;
//             <    is read   >: c1min
//             <    is written>: c1
   c1 = c1min;
l99966:   ;
//             <    is read   >: c1 c1max
   if (!(c1<=c1max)) goto l99970;
//             <    is read   >: c0 c1 c2min
//             <    is written>: histp
   histp = &histogram[c0][c1][c2min];
//             <    is read   >: c2min
//             <    is written>: c2
   c2 = c2min;
l99967:   ;
//             <    is read   >: c2 c2max
   if (!(c2<=c2max)) goto l99969;
//             <    is read   >: histp histp[0]
//             <    is written>: histp
   if (*histp++!=0) goto l99968;
//             <    is read   >: c2
//             <    is written>: c2
   c2++;
   goto l99967;
l99968:   ;
//             <    is read   >: boxp c0
//             <    is written>: boxp[0].c0max c0max
   boxp->c0max = c0max = c0;
   goto have_c0max;
l99969:   ;
//             <    is read   >: c1
//             <    is written>: c1
   c1++;
   goto l99966;
l99970:   ;
//             <    is read   >: c0
//             <    is written>: c0
   c0--;
   goto l99965;
l99999:   ;
//             <    is read   >: c0min
//             <    is written>: c0
   c0 = c0min;
l99959:   ;
//             <    is read   >: c0 c0max
   if (!(c0<=c0max)) goto have_c0min;
//             <    is read   >: c1min
//             <    is written>: c1
   c1 = c1min;
l99960:   ;
//             <    is read   >: c1 c1max
   if (!(c1<=c1max)) goto l99964;
//             <    is read   >: c0 c1 c2min
//             <    is written>: histp
   histp = &histogram[c0][c1][c2min];
//             <    is read   >: c2min
//             <    is written>: c2
   c2 = c2min;
l99961:   ;
//             <    is read   >: c2 c2max
   if (!(c2<=c2max)) goto l99963;
//             <    is read   >: histp histp[0]
//             <    is written>: histp
   if (*histp++!=0) goto l99962;
//             <    is read   >: c2
//             <    is written>: c2
   c2++;
   goto l99961;
l99962:   ;
//             <    is read   >: boxp c0
//             <    is written>: boxp[0].c0min c0min
   boxp->c0min = c0min = c0;
   goto have_c0min;
l99963:   ;
//             <    is read   >: c1
//             <    is written>: c1
   c1++;
   goto l99960;
l99964:   ;
//             <    is read   >: c0
//             <    is written>: c0
   c0++;
   goto l99959;
   
   /* Update box volume.
      * We use 2-norm rather than real volume here; this biases the method
      * against making long narrow boxes, and it has the side benefit that
      * a box is splittable iff norm > 0.
      * Since the differences are expressed in histogram-cell units,
      * we have to shift back to JSAMPLE units to get consistent distances;
      * after which, we scale according to the selected distance scale factors.
      */
have_c2max:   ;
//             <    is read   >: c0max c0min
//             <    is written>: dist0
   dist0 = (c0max-c0min<<8-5)*2;
//             <    is read   >: c1max c1min
//             <    is written>: dist1
   dist1 = (c1max-c1min<<8-6)*3;
//             <    is read   >: c2max c2min
//             <    is written>: dist2
   dist2 = (c2max-c2min<<8-5)*1;
//             <    is read   >: boxp dist0 dist1 dist2
//             <    is written>: boxp[0].volume
   boxp->volume = dist0*dist0+dist1*dist1+dist2*dist2;
//             <    is written>: ccount
   
   /* Now scan remaining volume of box and compute population */
   ccount = 0;
//             <    is read   >: c0max c0min
//             <    is written>: c0
   for(c0 = c0min; c0 <= c0max; c0 += 1)
//             <    is read   >: c0max c0min c1max c1min
//             <    is written>: c1
      for(c1 = c1min; c1 <= c1max; c1 += 1) {
//             <    is read   >: c0 c0max c0min c1 c1max c1min c2min
//             <    is written>: histp
         histp = &histogram[c0][c1][c2min];
//             <    is read   >: c0max c0min c1max c1min c2max c2min
//             <    is written>: c2
         for(c2 = c2min; c2 <= c2max; c2 += 1) {
//             <    is read   >: c0max c0min c1max c1min c2max c2min 
//                               histp histp[0]
            if (*histp!=0)
//             <    is read   >: c0max c0min c1max c1min c2max c2min 
//                               ccount
//             <    is written>: ccount
               ccount++;
//             <    is read   >: c0max c0min c1max c1min c2max c2min 
//                               histp
//             <    is written>: histp
            histp++;
         }
      }
//             <    is read   >: boxp ccount
//             <    is written>: boxp[0].colorcount
   boxp->colorcount = ccount;
}
long int jround_up(long int a, long int b)
{
//             <    is read   >: a b
//             <    is written>: a
   a += b-1L;
//             <    is read   >: a b
   return a-a%b;
}
void jzero_far(void *target, size_t bytestozero)
{
//             <may be written>: target[*]
//             <    is read   >: bytestozero target
   memset((void *) target, 0, (size_t) bytestozero);
}
