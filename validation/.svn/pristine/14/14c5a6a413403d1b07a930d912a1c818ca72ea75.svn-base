!!
!! file for apsi.f
!!
      PROGRAM APSI
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
C  *********************************************************************
C  *                                                                   *
C  *    M E S O S C A L E    H Y D R O D Y N A M I C    M O D E L      *
C  *                                                                   *
C  *    PSEUDOSPECTRAL (X,Y) AND FINITE DIFFERENCE (Z), 2-D, 3-D       *
C  *                                                                   *
C  *                                LATEST REVISION 8-13-86            *
C  *                                BY  ZAPHIRIS D. CHRISTIDIS         *
C  *********************************************************************
C
      DIMENSION WORK(1200000)
      CHARACTER DUMMY
      CHARACTER*49 LABEL
      CHARACTER*14 VAR(2)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
      COMMON/LEVEL/KK1,KK2,KK3,KK4,IYHOM,IGEO,IUGX,IVGY,LT0,LT1,ICPU
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
      COMMON/SOURCE/INIT(2,2),NSOUR(2),IX(2,2),JY(2,2),KZ(2,2),
     *IVAL(2,2),NSX(2,2),NSY(2,2),NSZ(2,2),ISR(2,2)
      COMMON/CPU/CINIT,CINHC,CINVC,CINHT,CINVT,CINPI,CINHU,CINVU,
     *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN
C    *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN,TM1,TM18,TM19

C     REAL*8 CPU0,CPU1,WAL0,WAL1

      DATA WORK/1200000*0.0D0/,VAR/' SOURCES/SINKS',' INITIAL CONT'/
C (0,1)
C     BEGIN BLOCK
C (0,2)
1     FORMAT(1X,'OUTPUT FOR SPEC95 BENCHMARK: APSI INSTRUMENTED VERSION'
     x 
     &/1X,'$Revision: SPEC95 $'/)
C (0,3)
C     OPEN(13,FILE='DUMP')
C     OPEN(13)
10    FORMAT(A)
C (0,4)
20    FORMAT(A)
C (0,5)
30    FORMAT(////,10X,'*************************************************
     x 
     &********',/,10X,'*************************************************
     x 
     &********',/,10X,'*** PROGRAM TO  SOLVE FOR THE  MESOSCALE AND SYNO
     x 
     &PTIC ***',/,10X,'*** VARIATIONS OF POTENTIAL TEMPERATURE, U AND V 
     x 
     &WIND ***',/,10X,'*** COMPONENTS, AND THE MESOSCALE VERTICAL VELOCI
     x 
     &TY W ***',/,10X,'*** PRESSURE AND DISTRIBUTION OF POLLUTANTS C  HA
     x 
     &VING ***',/,10X,'*** SOURCES  Q. THE SYNOPTIC  SCALE COMPONENTS AR
     x 
     &E IN ***',/,10X,'*** QUASSI-STEADY STATE BALANCE,  WHILE THE MESOS
     x 
     &CALE ***',/,10X,'*** PRESSURE AND VELOCITY  W ARE FOUND DIAGNOSTIC
     x 
     &ALLY ***',/,10X,'*************************************************
     x 
     &********',/,10X,'*************************************************
     x 
     &********',////)
C (0,6)
40    FORMAT(I15)
C (0,7)
50    FORMAT(F20.4)
C (0,8)
C
C  ============   E N D    O F    S I M U L A T I O N  =================
C
C     CALL CPUTIM (CPU1)
C     CALL ELAPSE (WAL1)
C     WRITE (6,1234) CPU1-CPU0,MOD(WAL1-WAL0+1000000.0,1000000.0)
C     WRITE (8,1234) CPU1-CPU0,MOD(WAL1-WAL0+1000000.0,1000000.0)
C
C     WRITE(1,*)
C     WRITE(1,*) 'ELAPSED CPU TIME IN SECONDS: ',CPU1-CPU0
C MFLOPS = (CRAY MFLOP)/CPU
C     WRITE(1,*) 'MFLOPS: ',503.8054/(CPU1-CPU0)
C     WRITE(1,*) 'ELAPSED WALLCLOCK TIME IN SECONDS: ',
C    *            MOD(WAL1-WAL0+1000000.0,1000000.0)
1234  FORMAT(' TOTAL TIME USED IN THIS JOB:',/,' CPU TIME  = ',F15.3,' S
     x 
     &ECONDS.',/,' WALL TIME = ',F15.3,' SECONDS.',/)
C (0,9)
110   FORMAT(A,I5,A)
C (0,10)
120   FORMAT(/,A,I3,A,I12,A,' IX=',I3,' JY=',I3,' KZ=',I3)
C (0,11)
CX20506 CALL DOOUTX( 506 )
CY20506 CALL DOOUTY( 506 )
150   FORMAT(3A)
C (0,12)
90    FORMAT(31X,I10)
C (0,13)
100   FORMAT(31X,F17.6)
C (0,14)
CX00001 CALL MAINIX (1)
CY00001 CALL MAINIY (1)
CX60000 CALL CNTINX ()
CY60000 CALL CNTINY ()
C
C      ===== FOR  BATCH JOBS TAKE THE COMMENT OF THE NEXT TWO LINES ====
C
C     CALL ELAPSE (WAL0)
C     CALL CPUTIM (CPU0)
C
      OPEN (UNIT=1,FILE='APV',STATUS='UNKNOWN') 
C (0,15)

      WRITE (1, 1) 
C (0,16)

C     TM19=1.
      NWINDX = 0
C (0,17)
      DUMMY = 'N'
C (0,18)
C
      NSINKS = 0
C (0,19)
      OPEN (UNIT=6,FILE='APO6',STATUS='UNKNOWN') 
C (0,20)
C     OPEN(7,FILE='GRAPH')
C     OPEN(7,FILE='APO7',STATUS='UNKNOWN')
C     OPEN(8,FILE='PRINT')
      OPEN (UNIT=8,FILE='APO8',STATUS='UNKNOWN') 
C (0,21)
C     OPEN(11,FILE='BLMPR')
      OPEN (UNIT=11,FILE='APO11',STATUS='UNKNOWN') 
C (0,22)
      WRITE (6, 30) 
C (0,23)
      WRITE (8, 30) 
C (0,24)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (NWINDX.EQ.0) GOTO 99998
C (8,1)
C     BEGIN BLOCK
C (8,2)
      WRITE (6, 10) ' NEW RUN <N>, OLD RUN <O>, INTERACTIVE RUN <I> '
C (8,3)
      READ (5, 20) DUMMY
C (8,4)
      IF (DUMMY.EQ.' ') THEN
C (8,5)
         DUMMY = 'N'
      ELSE
C (8,6)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C     END BLOCK
C (7,1)
      IF (DUMMY.EQ.'O'.OR.DUMMY.EQ.'o') GOTO 99997
99998 CONTINUE
C (2,1)
      IF (DUMMY.EQ.'N'.OR.DUMMY.EQ.'n') GOTO 99996
C (5,1)
C     BEGIN BLOCK
C (5,2)
C
C     INTERACTIVE PART
C
      WRITE (6, 10) ' ENTER NUMBER OF GRID POINTS IN X,Y AND Z'
C (5,3)
      READ (5, *) NX, NY, NZ
C (5,4)
      IYHOM = 1
C (5,5)
      IF (NY.EQ.1) THEN
C (5,6)
C        BEGIN BLOCK
C (5,7)
         IYHOM = 0
C (5,8)
         WRITE (6, 10) ' HOMOGENIOUS  Y DIRECTION? (Y/<N>) '
C (5,9)
         READ (5, 20) DUMMY
C (5,10)
         IF (DUMMY.EQ.'Y'.OR.DUMMY.EQ.'y') THEN
C (5,11)
            IYHOM = 1
         ELSE
C (5,12)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C        END BLOCK
      ELSE
C (5,13)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (5,14)
      WRITE (6, 10) ' SPECIFY INITIAL TIME TO     '
C (5,15)
      READ (5, *) TSTART
C (5,16)
      NFILT = 1
C (5,17)
      WRITE (6, 10) ' ENTER MOMENTUM DIFFUSIVITY FACTOR (1-8) '
C (5,18)
      READ (5, *) NTIME
C (5,19)
      WRITE (6, 10) ' DO YOU WANT TO APPLY FILTERING (<Y>/N)'
C (5,20)
      READ (5, 20) DUMMY
C (5,21)
      IF (DUMMY.EQ.'N'.OR.DUMMY.EQ.'n') THEN
C (5,22)
         NFILT = 0
      ELSE
C (5,23)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (5,24)
      WRITE (6, 10) ' ENTER DEGREE OF IMPLICIT FILTERING (0-1)'
C (5,25)
      READ (5, *) DL
C (5,26)
C
C    TIME DEPENDENT PARAMETERS
C
      WRITE (6, 10) ' SPECIFY NUMBER OF TIME STEPS   '
C (5,27)
      READ (5, *) NT
C (5,28)
      WRITE (6, 10) ' ENTER LEAPFROG TO EULER INTERCHANE FREQUENCY '
C (5,29)
      READ (5, *) NCOUNT
C (5,30)
      WRITE (6, 10) '  SPECIFY TIME STEP DT   '
C (5,31)
      READ (5, *) DELTAT
C (5,32)
C
C     X - DEPENDENT PARAMETERS
C
      WRITE (6, 10) ' ENTER STARTING VALUE FOR  X '
C (5,33)
      READ (5, *) XSTART
C (5,34)
      WRITE (6, 10) ' ENTER SPACE STEP    DX   '
C (5,35)
      READ (5, *) DELTAX
C (5,36)
      WRITE (6, 10) ' ENTER DIFFUSION COEFFICIENT KX '
C (5,37)
      READ (5, *) DX
C (5,38)
      WRITE (6, 10) ' ENTER X-SYMMETRY, AND SPREAD OF LAKE   '
C (5,39)
      READ (5, *) SX, SIGX
C (5,40)
      WRITE (6, 10) ' ENTER X-SYMMETRY, SPREAD OF FILTER AND BASE '
C (5,41)
      READ (5, *) SFX, FLX, BASE
C (5,42)
C
C      Y-DEPENDENT PARAMETERS
C
      PHI = 40.0
C (5,43)
      IF (NY.GT.1) THEN
C (5,44)
C        BEGIN BLOCK
C (5,45)
         WRITE (6, 10) ' ENTER STARTING VALUE FOR  Y '
C (5,46)
         READ (5, *) YSTART
C (5,47)
         WRITE (6, 10) ' ENTER SPACE STEP   DY    '
C (5,48)
         READ (5, *) DELTAY
C (5,49)
         WRITE (6, 10) ' ENTER CENTRAL LATITUDE PHI '
C (5,50)
         READ (5, *) PHI
C (5,51)
         WRITE (6, 10) ' ENTER DIFFUSION COEFFICIENT KY '
C (5,52)
         READ (5, *) DY
C (5,53)
         WRITE (6, 10) ' ENTER Y-SYMMETRY, AND SPREAD OF LAKE   '
C (5,54)
         READ (5, *) SY, SIGY
C (5,55)
         WRITE (6, 10) ' ENTER Y-SYMMETRY, AND SPREAD OF FILTER '
C (5,56)
         READ (5, *) SFY, FLY
C (5,57)
         WRITE (6, 10) ' ENTER FOUR LEVELS FOR PRINTING RESULTS '
C (5,58)
         READ (5, *) KK1, KK2, KK3, KK4
C        END BLOCK
      ELSE
C (5,59)
C        BEGIN BLOCK
C (5,60)
         SY = 2.0
C (5,61)
C        SIGY= YSTART+NY*DELTAY
         SIGY = 0.1
C (5,62)
         YSTART = 0.
C (5,63)
         DELTAY = .1
C (5,64)
         DY = 0.0
C        END BLOCK
      ENDIF
C (5,65)
C
C      FOR Z DEPENDENT PARAMETERS
C
      WRITE (6, 10) ' ENTER STARTING VALUE FOR  Z '
C (5,66)
      READ (5, *) ZSTART
C (5,67)
      WRITE (6, 10) ' ENTER SPACE STEP    DZ   '
C (5,68)
      READ (5, *) DELTAZ
C (5,69)
      WRITE (6, 10) ' ENTER MINIMUM DIFFUSION COEFFICIENT KZ '
C (5,70)
      READ (5, *) DZ
C (5,71)
      WRITE (6, 10) ' VERTICAL SMOOTHING (Y/<N>) '
C (5,72)
      READ (5, 20) DUMMY
C (5,73)
      IF (DUMMY.EQ.'Y'.OR.DUMMY.EQ.'y') THEN
C (5,74)
         NSINKS = 1
      ELSE
C (5,75)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (5,76)
      WRITE (6, 10) ' NUMERICAL SCHEME? PADE=1, CRANK NICOLSON=0'
C (5,77)
      READ (5, *) NWINDY
C (5,78)
      ALPHA = .5
C (5,79)
      IF (NWINDY.EQ.0) THEN
C (5,80)
C        BEGIN BLOCK
C (5,81)
         WRITE (6, 10) ' ENTER UPWINDING PARAMETER  '
C (5,82)
         READ (5, *) ALPHA
C        END BLOCK
      ELSE
C (5,83)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (5,84)
      WRITE (6, 10) ' ENTER HEAT OSCILLATION WAVENUMBER '
C (5,85)
      READ (5, *) IB
C (5,86)
      WRITE (6, 10) ' HORIZONTAL FILTERING TIME STEP (1-10) '
C (5,87)
      READ (5, *) IK
C (5,88)
      WRITE (6, 10) ' EQUALLY SPACED Z-POINTS ? (<Y>/N) '
C (5,89)
      READ (5, 20) DUMMY
C (5,90)
      IF (DUMMY.EQ.'N'.OR.DUMMY.EQ.'n') THEN
C (5,91)
C        BEGIN BLOCK
C (5,92)
         ITY = 1
C (5,93)
         WRITE (6, 10) ' ENTER STRECHED PARAMETERS A,B   '
C (5,94)
         READ (5, *) ALP, BET
C        END BLOCK
      ELSE
C (5,95)
         ITY = 0
      ENDIF
C (5,96)
      WRITE (6, 10) ' ENTER OBSERVATION HEIGHT OR TOP OF B.L. '
C (5,97)
      READ (5, *) ZH
C (5,98)
      WRITE (6, 10) ' ENTER INITIAL MIXING HEIGHT  '
C (5,99)
      READ (5, *) H0
C (5,100)
      WRITE (6, 10) ' ENTER FRACTION OF B.L. TO BE USED AS S.L. '
C (5,101)
      READ (5, *) TSL
C (5,102)
C
C       DEFINE DEPENDENT VARIABLES
C
      WRITE (6, 10) ' ENTER OBSERVED UG, VG '
C (5,103)
      READ (5, *) UG, VG
C (5,104)
      WRITE (6, 10) ' ENTER URBAN CONSTANT ROUGHNESS LENGTH Z0 '
C (5,105)
      READ (5, *) ZNOT
C (5,106)
      WRITE (6, 10) ' ENTER LAND AND WATER ROUGHNESS LENGTHS  '
C (5,107)
      READ (5, *) ZL, ZW
C (5,108)
      WRITE (6, 10) ' ENTER ITERATION STEP DELTA AND TOLLERANCE '
C (5,109)
      READ (5, *) DUT, TOL
C (5,110)
C
      WRITE (6, 10) ' ENTER TO,TT '
C (5,111)
      READ (5, *) T1, T2
C (5,112)
      WRITE (6, 10) ' STEP OF RECALCULATING  UG, VG  TO,TT '
C (5,113)
      READ (5, *) IGEO
C (5,114)
      WRITE (6, 10) ' ENTER RATE OF CHANE OF  UG, VG (CM/HOUR) '
C (5,115)
      READ (5, *) IUGX, IVGY
C (5,116)
      WRITE (6, 10) ' ENTER RATE OF CHANE OF  TO, TT (K/10HOUR) '
C (5,117)
      READ (5, *) LT0, LT1
C (5,118)
      WRITE (6, 10) ' ENTER CPU REPORT FREQUENCY '
C (5,119)
      READ (5, *) ICPU
C (5,120)
      WRITE (6, 10) 
     &' ENTER LAND LAKE HEAT AMPLITUDE (K) AND LAG (S) '
C (5,121)
      READ (5, *) HAMP, BUMP
C (5,122)
C
C    MIXED PARAMETERS
C    BELOW IF K=1 SPECIFY FOR SOURCES , K=2 FOR INITIAL CONDITIONDS
C
      NWINDX = 0
C (5,123)
      NWINDY = 0
C (5,124)
CX10505 CALL DOINX( 505 )
CY10505 CALL DOINY( 505 )
!     INITIALLY: DO 140
      DO K = 1, 2
C (5,125)
C        BEGIN BLOCK
C (5,126)
         WRITE (6, 150) ' SPECIFY ANY ', VAR(K), ' (<Y>/N)? '
C (5,127)
         READ (5, 20) DUMMY
C (5,128)
         IF (DUMMY.EQ.'N'.OR.DUMMY.EQ.'n') THEN
C (5,129)
            NSOUR(K) = 0
         ELSE
C (5,130)
C           BEGIN BLOCK
C (5,131)
            WRITE (6, 10) ' SPECIFY THE NUMBER OF ', VAR(K)
C (5,132)
            READ (5, *) NSOUR(K)
C (5,133)
            NSOU = NSOUR(K)
C (5,134)
!     INITIALLY: DO 130
            DO L = 1, NSOU
C (5,135)
C              BEGIN BLOCK
C (5,136)
               WRITE (6, 150) ' TYPE OF', VAR(K), 
     &         '? (0=DELTA,1=GAUSS) '
C (5,137)
               READ (5, *) INIT(K,L)
C (5,138)
               WRITE (6, 110) VAR(K), L, 
     &         '  ENTER LOCATION AND VALUE '
C (5,139)
               READ (5, *) IX(K,L), JY(K,L), KZ(K,L), IVAL(K,L)
C (5,140)
               WRITE (6, 120) ' #', L, ' *** ', IVAL(K,L), 
     &         ' *** LOCATED AT', IX(K,L), JY(K,L), KZ(K,L)
C (5,141)
               IF (INIT(K,L).GT.0) THEN
C (5,142)
C                 BEGIN BLOCK
C (5,143)
                  WRITE (6, 10) ' SPECIFY THE EXTEND IN I,J,K POINTS'
C (5,144)
                  READ (5, *) NSX(K,L), NSY(K,L), NSZ(K,L)
C (5,145)
                  WRITE (6, 10) ' SPECIFY SPREAD IN SIGMA UNITS'
C (5,146)
                  READ (5, *) ISR(K,L)
C                 END BLOCK
               ELSE
C (5,147)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (5,148)
130            CONTINUE
C              END BLOCK
            ENDDO
C           END BLOCK
         ENDIF
C (5,149)
140      CONTINUE
C        END BLOCK
      ENDDO
C (5,150)
      NPSTEP = 2
C (5,151)
      NGSTEP = 2
C (5,152)
C
C   OUTPUT PARAMETERS
C
      WRITE (6, 10) 
     &' DO YOU WANT TO STORE THE RESULTS IN A FILE  (Y/<N>)'
C (5,153)
      NPRINT = 0
C (5,154)
      READ (5, 20) DUMMY
C (5,155)
      IF (DUMMY.EQ.'Y'.OR.DUMMY.EQ.'y') THEN
C (5,156)
C        BEGIN BLOCK
C (5,157)
         NPRINT = 1
C (5,158)
         WRITE (6, 10) ' ENTER STEP N FOR PRINT (EVERY OTHER N)'
C (5,159)
         READ (5, *) NPSTEP
C        END BLOCK
      ELSE
C (5,160)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (5,161)
      WRITE (6, 10) 
     &' DO YOU WANT TO STORE THE RESULTS FOR GRAPH (Y/<N>)'
C (5,162)
      NGRAPH = 0
C (5,163)
      READ (5, 20) DUMMY
C (5,164)
      IF (DUMMY.EQ.'Y'.OR.DUMMY.EQ.'y') THEN
C (5,165)
C        BEGIN BLOCK
C (5,166)
         NGRAPH = 1
C (5,167)
         WRITE (6, 10) ' ENTER STEP N FOR GRAPH (EVERY OTHER N)'
C (5,168)
         READ (5, *) NGSTEP
C        END BLOCK
      ELSE
C (5,169)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C     END BLOCK
      GOTO 160
99996 CONTINUE
C (3,1)
C     BEGIN BLOCK
C (3,2)
C
C  ============   READ RUN DATA FROM A FILE  ===========================
C
C        OPEN(9,FILE='DATA')
      OPEN (UNIT=9,FILE='apsi.in',STATUS='OLD') 
C (3,3)
CX10501 CALL DOINX( 501 )
CY10501 CALL DOINY( 501 )
!     INITIALLY: DO 70
      DO LABELS = 1, 7
C (3,4)
C        BEGIN BLOCK
C (3,5)
         READ (9, 20) LABEL
C (3,6)
         WRITE (6, 20) LABEL
C (3,7)
70       CONTINUE
C        END BLOCK
      ENDDO
C (3,8)
CX20502 CALL DOOUTX( 502 )
CY20502 CALL DOOUTY( 502 )
      READ (9, 90) NX, NY, NZ, NTIME, NFILT, NT, NCOUNT, ITY, IB, IK
     &, NWINDX, NWINDY, NSINKS, NPRINT, NPSTEP, NGRAPH, NGSTEP, NSOUR
     &(1), NSOUR(2), INIT(1,1), INIT(2,1), INIT(1,2), INIT(2,2), IX(1
     &,1), IX(2,1), IX(1,2), IX(2,2), JY(1,1), JY(2,1), JY(1,2), JY(2
     &,2), KZ(1,1), KZ(2,1), KZ(1,2), KZ(2,2), IVAL(1,1), IVAL(2,1), 
     &IVAL(1,2), IVAL(2,2), NSX(1,1), NSX(2,1), NSX(1,2), NSX(2,2), 
     &NSY(1,1), NSY(2,1), NSY(1,2), NSY(2,2), NSZ(1,1), NSZ(2,1), NSZ
     &(1,2), NSZ(2,2), ISR(1,1), ISR(2,1), ISR(1,2), ISR(2,2), KK1, 
     &KK2, KK3, KK4, IYHOM, IGEO, IUGX, IVGY, LT0, LT1, ICPU
C (3,9)
CX10503 CALL DOINX( 503 )
CY10503 CALL DOINY( 503 )
C
!     INITIALLY: DO 80
      DO LABELS = 1, 5
C (3,10)
C        BEGIN BLOCK
C (3,11)
         READ (9, 20) LABEL
C (3,12)
         WRITE (6, 20) LABEL
C (3,13)
80       CONTINUE
C        END BLOCK
      ENDDO
C (3,14)
CX20504 CALL DOOUTX( 504 )
CY20504 CALL DOOUTY( 504 )
C
      READ (9, 100) TSTART, DELTAT, XSTART, DELTAX, DX, YSTART, 
     &DELTAY, DY, ZSTART, DELTAZ, DZ, ALP, BET, ZH, UG, VG, T1, T2, 
     &DUT, TOL, ALPHA, SX, SIGX, SY, SIGY, ZNOT, HAMP, BUMP, PHI, DL
     &, SFX, SFY, FLX, FLY, BASE, TSL, H0, ZW, ZL
C     END BLOCK
      GOTO 160
99997 CONTINUE
C (6,1)
C     BEGIN BLOCK
C (6,2)
C        OPEN(10,FILE='RUN')
      OPEN (UNIT=10,FILE='APO10',STATUS='OLD') 
C (6,3)
      READ (10, 40) NX, NY, NZ, NT, NTIME, NFILT, NCOUNT, ITY, IB, IK
     &, NWINDX, NWINDY, NSINKS, NPRINT, NPSTEP, NGRAPH, NGSTEP, NSOUR
     &(1), NSOUR(2), INIT(1,1), INIT(2,1), INIT(1,2), INIT(2,2), IX(1
     &,1), IX(2,1), IX(1,2), IX(2,2), JY(1,1), JY(2,1), JY(1,2), JY(2
     &,2), KZ(1,1), KZ(2,1), KZ(1,2), KZ(2,2), IVAL(1,1), IVAL(2,1), 
     &IVAL(1,2), IVAL(2,2), NSX(1,1), NSX(2,1), NSX(1,2), NSX(2,2), 
     &NSY(1,1), NSY(2,1), NSY(1,2), NSY(2,2), NSZ(1,1), NSZ(2,1), NSZ
     &(1,2), NSZ(2,2), ISR(1,1), ISR(2,1), ISR(1,2), ISR(2,2), KK1, 
     &KK2, KK3, KK4, IYHOM
C (6,4)
      READ (10, 50) TSTART, DELTAT, XSTART, DELTAX, DX, YSTART, 
     &DELTAY, DY, ZSTART, DELTAZ, DZ, ALP, BET, ZH, UG, VG, T1, T2, 
     &DUT, TOL, ALPHA, SX, SIGX, SY, SIGY, ZNOT, HAMP, BUMP, PHI, DL
     &, SFX, SFY, FLX, FLY, BASE
C (6,5)
      CLOSE (10) 
C     END BLOCK
C (4,1)
160   CONTINUE
C     END UNSTRUCTURED
C (0,25)
C
C     CHECK FOR A CRUDE STABILITY SATISFACTION AND HEAT CONSTANTS
C
      CALL STAB(NX, NY, NTIME, TSTART, NT, IB, HAMP, BUMP, DELTAX, 
     &DELTAY, DELTAT)
C (0,26)
C
C     CALL CPUCLK(TM1,0,0.0)
C
C    CALL SUBROUTINE    PSET    TO CARRY OUT THE CALCULATIONS.
C
      CALL PSET(NX, NY, NZ, NT, NTIME, NWINDX, NWINDY, NSINKS, NFILT
     &, XSTART, YSTART, ZSTART, TSTART, DELTAX, DELTAY, DELTAZ, 
     &DELTAT, PHI, DL, DX, DY, DZ, WORK, IB, IK, ITY, NCOUNT, NPRINT
     &, NGRAPH, NPSTEP, NGSTEP)
C (0,27)
C
C     OBTAIN STATISTICS ABOUT THE PARTIAL CPU'S
C
C     TM19=-1.
      CALL STATS
C (0,28)
CX70000 CALL CNTOTX ()
CY70000 CALL CNTOTY ()
CX50000 CALL MAINOX ()
CY50000 CALL MAINOY ()
      STOP
C (0,29)
      CLOSE (1) 
C (0,30)
      CLOSE (6) 
C (0,31)
      CLOSE (8) 
C (0,32)
      CLOSE (9) 
C (0,33)
      CLOSE (10) 
C (0,34)
      CLOSE (11) 
C (0,35)
      RETURN
C     END BLOCK
      END

C
C  *********************************************************************
C  *   SUBROUTINE TO SET THE ARRAY POINTERS FOR VECTORIZING THE CODE.  *
C  *********************************************************************
C
      SUBROUTINE PSET(NX,NY,NZ,NT,NTIME,NWINDX,NWINDY,NSINKS,NFILT,
     *XSTART,YSTART,ZSTART,TSTART,DELTAX,DELTAY,DELTAZ,DELTAT,PHI,DL,
     *DX,DY,DZ,WORK,IB,IK,ITY,NCOUNT,NPRINT,NGRAPH,NPSTEP,NGSTEP)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION  WORK(1200000)
C     CHARACTER DUMMY
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
      COMMON/SOURCE/INIT(2,2),NSOUR(2),IX(2,2),JY(2,2),KZ(2,2),
     * IVAL(2,2),NSX(2,2),NSY(2,2),NSZ(2,2),ISR(2,2)
      COMMON/LEVEL/KK1,KK2,KK3,KK4,IYHOM,IGEO,IUGX,IVGY,LT0,LT1,ICPU
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
      COMMON/CPU/CINIT,CINHC,CINVC,CINHT,CINVT,CINPI,CINHU,CINVU,
     *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN
C (0,1)
      INTEGER*8 I_PIPS_RUN_STEPC
      COMMON /PIPS_RUN_STEPC/ I_PIPS_RUN_STEPC
      INTEGER*8 I_PIPS_RUN_POTT
      COMMON /PIPS_RUN_POTT/ I_PIPS_RUN_POTT
      INTEGER*8 I_PIPS_RUN_STEPT
      COMMON /PIPS_RUN_STEPT/ I_PIPS_RUN_STEPT
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_STEPU
      COMMON /PIPS_RUN_STEPU/ I_PIPS_RUN_STEPU
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_STEPV
      COMMON /PIPS_RUN_STEPV/ I_PIPS_RUN_STEPV
      INTEGER*8 I_PIPS_RUN_WZ
      COMMON /PIPS_RUN_WZ/ I_PIPS_RUN_WZ
      INTEGER*8 I_PIPS_RUN_PRES
      COMMON /PIPS_RUN_PRES/ I_PIPS_RUN_PRES
      INTEGER*8 I_PIPS_RUN_STEPP
      COMMON /PIPS_RUN_STEPP/ I_PIPS_RUN_STEPP
      INTEGER*8 I_PIPS_RUN_Q
      COMMON /PIPS_RUN_Q/ I_PIPS_RUN_Q
      INTEGER*8 I_PIPS_RUN_DKZM
      COMMON /PIPS_RUN_DKZM/ I_PIPS_RUN_DKZM
      INTEGER*8 I_PIPS_RUN_DKZH
      COMMON /PIPS_RUN_DKZH/ I_PIPS_RUN_DKZH
      INTEGER*8 I_PIPS_RUN_ELEV
      COMMON /PIPS_RUN_ELEV/ I_PIPS_RUN_ELEV
      INTEGER*8 I_PIPS_RUN_ELEVX
      COMMON /PIPS_RUN_ELEVX/ I_PIPS_RUN_ELEVX
      INTEGER*8 I_PIPS_RUN_ELEVY
      COMMON /PIPS_RUN_ELEVY/ I_PIPS_RUN_ELEVY
      INTEGER*8 I_PIPS_RUN_Z0
      COMMON /PIPS_RUN_Z0/ I_PIPS_RUN_Z0
      INTEGER*8 I_PIPS_RUN_HMIX
      COMMON /PIPS_RUN_HMIX/ I_PIPS_RUN_HMIX
      INTEGER*8 I_PIPS_RUN_STEPH
      COMMON /PIPS_RUN_STEPH/ I_PIPS_RUN_STEPH
      INTEGER*8 I_PIPS_RUN_TAVR
      COMMON /PIPS_RUN_TAVR/ I_PIPS_RUN_TAVR
      INTEGER*8 I_PIPS_RUN_OBUK
      COMMON /PIPS_RUN_OBUK/ I_PIPS_RUN_OBUK
      INTEGER*8 I_PIPS_RUN_USTR
      COMMON /PIPS_RUN_USTR/ I_PIPS_RUN_USTR
      INTEGER*8 I_PIPS_RUN_TSTR
      COMMON /PIPS_RUN_TSTR/ I_PIPS_RUN_TSTR
      INTEGER*8 I_PIPS_RUN_VDEP
      COMMON /PIPS_RUN_VDEP/ I_PIPS_RUN_VDEP
      INTEGER*8 I_PIPS_RUN_DEP
      COMMON /PIPS_RUN_DEP/ I_PIPS_RUN_DEP
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_UG
      COMMON /PIPS_RUN_UG/ I_PIPS_RUN_UG
      INTEGER*8 I_PIPS_RUN_VG
      COMMON /PIPS_RUN_VG/ I_PIPS_RUN_VG
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_RUN_FXX
      COMMON /PIPS_RUN_FXX/ I_PIPS_RUN_FXX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_RUN_FYY
      COMMON /PIPS_RUN_FYY/ I_PIPS_RUN_FYY
C     BEGIN BLOCK
C (0,2)
C    *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN,TM1,TM18,TM19
CX30003 CALL SBINX (3)
CY30003 CALL SBINY (3)
C
C **   SEPARATE DIMENSIONALITY OF PROGRAM
C
      L3 = NX*NY*NZ
C (0,3)
      L2 = NX*NY
C (0,4)
      L1 = NZ
C (0,5)
C
C ===== ALLOCATION OF GLOBAL MEMORY FOR PARAMETERS IN VECTOR FORM  =====
C
C **   MESO-CONCENTRATION OF ONE POLLUTANT C(X,Y,Z,T)                 **
      LC = 1
C (0,6)
      LAST = L3
C (0,7)
C **   PREVIOUS STEPS OF C(X,Y,Z,T-1) FOR THE TIME SCHEME             **
      LCSTEP = LAST+1
C (0,8)
      LAST = LAST+L3
C (0,9)
C **   MESO-PERTURBATION POTENTIAL TEMPERATURE POTT(X,Y,Z,T)          **
      LPOT = LAST+1
C (0,10)
      LAST = LAST+L3
C (0,11)
C **   PREVIOUS STEPS OF POTT(X,Y,Z,T-1) FOR THE TIME SCHEME          **
      LTSTEP = LAST+1
C (0,12)
      LAST = LAST+L3
C (0,13)
C **   MESO-PERTURBATION U - WIND COMPONENT UX(X,Y,Z,T)               **
      LUX = LAST+1
C (0,14)
      LAST = LAST+L3
C (0,15)
C **   PREVIOUS STEPS OF UX(X,Y,Z,T-1) FOR THE TIME SCHEME            **
      LUSTEP = LAST+1
C (0,16)
      LAST = LAST+L3
C (0,17)
C **   MESO-PERTURBATION V - WIND COMPONENT VY(X,Y,Z,T)               **
      LVY = LAST+1
C (0,18)
      LAST = LAST+L3
C (0,19)
C **   PREVIOUS STEPS OF VY(X,Y,Z,T-1) FOR THE TIME SCHEME            **
      LVSTEP = LAST+1
C (0,20)
      LAST = LAST+L3
C (0,21)
C **   MESO-PERTURBATION W - WIND COMPONENT WZ(X,Y,Z,T)               **
      LWZ = LAST+1
C (0,22)
      LAST = LAST+L3
C (0,23)
C **   MESO-PERTURBATION PRESSURE PI PRESS(X,Y,Z,T)                   **
      LPI = LAST+1
C (0,24)
      LAST = LAST+L3
C (0,25)
C **   PREVIOUS STEP OF PRESSURE PI PRESS(X,Y,Z,T)                    **
      LPSTEP = LAST+1
C (0,26)
      LAST = LAST+L3
C (0,27)
C **   SOURCES OR SINKS FOR THE POLLUTANTS  C,  Q(X,Y,Z)              **
      LQ = LAST+1
C (0,28)
      LAST = LAST+L3
C (0,29)
C **   DIFFUSSIVITY COEFFICIENT FOR MOMENTUM DKZ(X,Y,Z)=DKZM(X,Y,Z)   **
      LDKZM = LAST+1
C (0,30)
      LAST = LAST+L3
C (0,31)
C **   DIFFUSSIVITY COEFFICIENT FOR HEAT DKZ(X,Y,Z)=DKZH(X,Y,Z)       **
      LDKZH = LAST+1
C (0,32)
      LAST = LAST+L3
C (0,33)
C **   TERRAIN ELEVATION IN METERS ELEV(X,Y)                          **
      LELEV = LAST+1
C (0,34)
      LAST = LAST+L2
C (0,35)
C **   TERRAIN X-GRADIENT IN METERS ELEVX(X,Y)                        **
      LELEVX = LAST+1
C (0,36)
      LAST = LAST+L2
C (0,37)
C **   TERRAIN Y-GRADIENT IN METERS ELEVY(X,Y)                        **
      LELEVY = LAST+1
C (0,38)
      LAST = LAST+L2
C (0,39)
C **   ROUGHNESS LENGTH OF TERRAIN IN METERS Z0(X,Y)                  **
      LZ0 = LAST+1
C (0,40)
      LAST = LAST+L2
C (0,41)
C **   MIXING HEIGHT OR BOUNDARY LAYER HEIGHT HMIX(X,Y)               **
      LHMIX = LAST+1
C (0,42)
      LAST = LAST+L2
C (0,43)
C **   MIXING HEIGHT AT THE PREVIOUS TIME STEP STEPH(X,Y)             **
      LSTEPH = LAST+1
C (0,44)
      LAST = LAST+L2
C (0,45)
C **   MEAN TEMPERATURE IN THE SURFACE LAYER TAVR(X,Y)                **
      LTAVR = LAST+1
C (0,46)
      LAST = LAST+L2
C (0,47)
C **   MONIN-OBUKHOV LENGTH OBUK(X,Y)                                 **
      LOBUK = LAST+1
C (0,48)
      LAST = LAST+L2
C (0,49)
C **   FRICTION VELOCITY USTAR USTR(X,Y)                              **
      LUSTR = LAST+1
C (0,50)
      LAST = LAST+L2
C (0,51)
C **   TURBULENT  TEMPERATURE THETASTAR TSTR(X,Y)                     **
      LTSTR = LAST+1
C (0,52)
      LAST = LAST+L2
C (0,53)
C **   DRY DEPOSITION VELOCITY VDEP(X,Y)                              **
      LVDEP = LAST+1
C (0,54)
      LAST = LAST+L2
C (0,55)
C **   SURFACE DEPOSITION OF  POLLUTANTS  DEP(X,Y)                    **
      LDEP = LAST+1
C (0,56)
      LAST = LAST+L2
C (0,57)
C **   VERTICAL HEIGHT Z  ZET(Z)                                      **
      LZET = LAST+1
C (0,58)
      LAST = LAST+L1
C (0,59)
C **   UNEQUAL POINT STRECHED PARAMETER  DH/DZ = HVAR(Z)              **
      LHVAR = LAST+1
C (0,60)
      LAST = LAST+L1
C (0,61)
C **   MEAN OR SYNOPTIC U-WIND COMPONENT  UM(Z)                       **
      LUM = LAST+1
C (0,62)
      LAST = LAST+L1
C (0,63)
C **   MEAN OR SYNOPTIC V-WIND COMPONENT  VM(Z)                       **
      LVM = LAST+1
C (0,64)
      LAST = LAST+L1
C (0,65)
C **   GEOSTROPHIC U-WIND COMPONENT  UG(Z)                            **
      LUG = LAST+1
C (0,66)
      LAST = LAST+L1
C (0,67)
C **   GEOSTROPHIC V-WIND COMPONENT  VG(Z)                            **
      LVG = LAST+1
C (0,68)
      LAST = LAST+L1
C (0,69)
C **   MEAN OR SYNOPTIC POTENTIAL TEMPERATURE TM(Z)                   **
      LTM = LAST+1
C (0,70)
      LAST = LAST+L1
C (0,71)
C **   MEAN OR SYNOPTIC EDDY DIFFUSSIVITY DKM(Z)                      **
      LKM = LAST+1
C (0,72)
      LAST = LAST+L1
C (0,73)
C
C  =====       ALLOCATION OF AUXILIARY WORK SPACE     ==================
C
C **   DERIVATIVES WITH RESPECT TO X  DCDX(X,Y,Z)                     **
      LDCDX = LAST+1
C (0,74)
      LAST = LAST+L3
C (0,75)
C **   DERIVATIVES WITH RESPECT TO Y  DCDY(X,Y,Z)                     **
      LDCDY = LAST+1
C (0,76)
      LAST = LAST+L3
C (0,77)
C **   HELP VECTOR FOR PADE SCHEME -CENTER ELEMENTS-                  **
      LAN = LAST+1
C (0,78)
      LAST = LAST+L1
C (0,79)
C **   HELP VECTOR FOR PADE SCHEME -LEFT   ELEMENTS-                  **
      LBN = LAST+1
C (0,80)
      LAST = LAST+L1
C (0,81)
C **   HELP VECTOR FOR PADE SCHEME -RIGHT  ELEMENTS-                  **
      LCN = LAST+1
C (0,82)
      LAST = LAST+L1
C (0,83)
C **   UTILITY VECTOR FOR NUMERICAL WORK                              **
      LHELP = LAST+1
C (0,84)
      LAST = LAST+MAX(NX, NY, NZ)
C (0,85)
C **   ANOTHER UTILITY VECTOR FOR DIRTY WORK                          **
      LHELPA = LAST+1
C (0,86)
      LAST = LAST+MAX(NX, NY, NZ)
C (0,87)
C **    WORK VECTOR FOR THE X-FFT                                     **
      LSAVEX = LAST+1
C (0,88)
      LAST = LAST+2*NX+15
C (0,89)
C **    WORK VECTOR FOR THE Y-FFT                                     **
      LSAVEY = LAST+1
C (0,90)
      LAST = LAST+2*NY+15
C (0,91)
C **    X-WAVENUMBERS  FOR FIRST DERIVATIVES                          **
      LFX = LAST+1
C (0,92)
      LAST = LAST+NX*0.5
C (0,93)
C **    X- WEIGHTS FOR HEAT AND POLLUTANTS X,Y SPECTRAL DIFFUSION     **
      LFXC = LAST+1
C (0,94)
      LAST = LAST+NX
C (0,95)
C **    X - WEIGHTS FOR MOMENTUM HORIZONTAL SPECTRAL DIFFUSION        **
      LFXX = LAST+1
C (0,96)
      LAST = LAST+NX*0.5
C (0,97)
C **    Y-WAVENUMBERS FOR FIRST DERIVATIVES                           **
      LFY = LAST+1
C (0,98)
      LAST = LAST+NY*0.5
C (0,99)
C **    Y- WEIGHTS FOR HEAT AND POLLUTANTS X,Y SPECTRAL DIFFUSION     **
      LFYC = LAST+1
C (0,100)
      LAST = LAST+NY
C (0,101)
C **    Y - WEIGHTS FOR MOMENTUM HORIZONTAL SPECTRAL DIFFUSION        **
      LFYY = LAST+1
C (0,102)
      LAST = LAST+NY*0.5
C (0,103)
C **    X - FILTER FOR DERIVATIVE  DIFFUSION                          **
      LFILX = LAST+1
C (0,104)
      LAST = LAST+NX
C (0,105)
C **    Y - FILTER FOR DERIVATIVE  DIFFUSION                          **
      LFILY = LAST+1
C (0,106)
      LAST = LAST+NY
C (0,107)
C **    Z - FILTER FOR THE SPONGE LAYER IN Z                          **
      LFILZ = LAST+1
C (0,108)
      LAST = LAST+NZ
C (0,109)
C
C     MAKE A LAST CHECK
C
      WRITE (6, '(A,I8,A)') ' WORK ARRAY HAS ', LAST, ' ELEMENTS.  '
C (0,110)
      IF (NWINDX.EQ.1) THEN
C (0,111)
         PAUSE
      ELSE
C (0,112)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,113)
      I_PIPS_RUN_STEPC = 1200000-(LCSTEP-1)
      I_PIPS_RUN_POTT = 1200000-(LPOT-1)
      I_PIPS_RUN_STEPT = 1200000-(LTSTEP-1)
      I_PIPS_RUN_UX = 1200000-(LUX-1)
      I_PIPS_RUN_STEPU = 1200000-(LUSTEP-1)
      I_PIPS_RUN_VY = 1200000-(LVY-1)
      I_PIPS_RUN_STEPV = 1200000-(LVSTEP-1)
      I_PIPS_RUN_WZ = 1200000-(LWZ-1)
      I_PIPS_RUN_PRES = 1200000-(LPI-1)
      I_PIPS_RUN_STEPP = 1200000-(LPSTEP-1)
      I_PIPS_RUN_Q = 1200000-(LQ-1)
      I_PIPS_RUN_DKZM = 1200000-(LDKZM-1)
      I_PIPS_RUN_DKZH = 1200000-(LDKZH-1)
      I_PIPS_RUN_ELEV = 1200000-(LELEV-1)
      I_PIPS_RUN_ELEVX = 1200000-(LELEVX-1)
      I_PIPS_RUN_ELEVY = 1200000-(LELEVY-1)
      I_PIPS_RUN_Z0 = 1200000-(LZ0-1)
      I_PIPS_RUN_HMIX = 1200000-(LHMIX-1)
      I_PIPS_RUN_STEPH = 1200000-(LSTEPH-1)
      I_PIPS_RUN_TAVR = 1200000-(LTAVR-1)
      I_PIPS_RUN_OBUK = 1200000-(LOBUK-1)
      I_PIPS_RUN_USTR = 1200000-(LUSTR-1)
      I_PIPS_RUN_TSTR = 1200000-(LTSTR-1)
      I_PIPS_RUN_VDEP = 1200000-(LVDEP-1)
      I_PIPS_RUN_DEP = 1200000-(LDEP-1)
      I_PIPS_RUN_ZET = 1200000-(LZET-1)
      I_PIPS_RUN_HVAR = 1200000-(LHVAR-1)
      I_PIPS_RUN_UM = 1200000-(LUM-1)
      I_PIPS_RUN_VM = 1200000-(LVM-1)
      I_PIPS_RUN_UG = 1200000-(LUG-1)
      I_PIPS_RUN_VG = 1200000-(LVG-1)
      I_PIPS_RUN_TM = 1200000-(LTM-1)
      I_PIPS_RUN_DKM = 1200000-(LKM-1)
      I_PIPS_RUN_DCDX = 1200000-(LDCDX-1)
      I_PIPS_RUN_DCDY = 1200000-(LDCDY-1)
      I_PIPS_RUN_AN = 1200000-(LAN-1)
      I_PIPS_RUN_BN = 1200000-(LBN-1)
      I_PIPS_RUN_CN = 1200000-(LCN-1)
      I_PIPS_RUN_HELP = 1200000-(LHELP-1)
      I_PIPS_RUN_HELPA = 1200000-(LHELPA-1)
      I_PIPS_RUN_SAVEX = 1200000-(LSAVEX-1)
      I_PIPS_RUN_SAVEY = 1200000-(LSAVEY-1)
      I_PIPS_RUN_FX = 1200000-(LFX-1)
      I_PIPS_RUN_FXC = 1200000-(LFXC-1)
      I_PIPS_RUN_FXX = 1200000-(LFXX-1)
      I_PIPS_RUN_FY = 1200000-(LFY-1)
      I_PIPS_RUN_FYC = 1200000-(LFYC-1)
      I_PIPS_RUN_FYY = 1200000-(LFYY-1)
C
C
C   ====================================================================
C   *   THIS SUBROUTINE RUN DOES ALL CALCULATIONS  AND ALLOCATES       *
C   *   GLOBAL TO STATIC MEMORY FOR VECTOR OPERATIONS                  *
C   ====================================================================
C
C
      CALL RUN(NX, NY, NZ, NT, NTIME, NWINDX, NWINDY, NSINKS, NFILT, 
     &XSTART, YSTART, ZSTART, TSTART, DELTAX, DELTAY, DELTAZ, DELTAT
     &, PHI, DL, DX, DY, DZ, IB, IK, ITY, NCOUNT, NPRINT, NGRAPH, 
     &NPSTEP, NGSTEP, LAST, WORK(LC), WORK(LCSTEP), WORK(LPOT), WORK(
     &LTSTEP), WORK(LUX), WORK(LUSTEP), WORK(LVY), WORK(LVSTEP), WORK
     &(LWZ), WORK(LPI), WORK(LPSTEP), WORK(LQ), WORK(LDKZM), WORK(
     &LDKZH), WORK(LELEV), WORK(LELEVX), WORK(LELEVY), WORK(LZ0), 
     &WORK(LHMIX), WORK(LSTEPH), WORK(LTAVR), WORK(LOBUK), WORK(LUSTR
     &), WORK(LTSTR), WORK(LVDEP), WORK(LDEP), WORK(LZET), WORK(LHVAR
     &), WORK(LUM), WORK(LVM), WORK(LUG), WORK(LVG), WORK(LTM), WORK(
     &LKM), WORK(LDCDX), WORK(LDCDY), WORK(LAN), WORK(LBN), WORK(LCN)
     &, WORK(LHELP), WORK(LHELPA), WORK(LSAVEX), WORK(LSAVEY), WORK(
     &LFX), WORK(LFXC), WORK(LFXX), WORK(LFY), WORK(LFYC), WORK(LFYY)
     &, WORK(LFILX), WORK(LFILY), WORK(LFILZ))
C (0,114)
CX40004 CALL SBOUTX (4)
CY40004 CALL SBOUTY (4)
C
      RETURN
C     END BLOCK
      END
C
C
C  THIS SUBROUTINE IS CALLED BY   PSET.   IT CALLS OTHER SUB-
C  ROUTINES AND CALCULATES THE RIGHT-HAND SIDE OF THE DISCRETIZED
C  SYSTEM.
C
C
      SUBROUTINE RUN(NX,NY,NZ,NT,NTIME,NWINDX,ISH,NSMT,NFILT,
     * XSTART,YSTART,ZSTART,TSTART,DELTAX,DELTAY,DELTAZ,DELTAT,PHI,DL,
     * DX,DY,DZ,IB,IK,ITY,NCOUNT,NPRINT,NGRAPH,NPSTEP,NGSTEP,LFINAL,
     * C,STEPC,POTT,STEPT,UX,STEPU,VY,STEPV,WZ,PRES,STEPP,Q,DKZM,DKZH,
     * ELEV,ELEVX,ELEVY,Z0,HMIX,STEPH,TAVR,OBUK,USTR,TSTR,VDEP,DEP,
     * ZET,HVAR,UM,VM,UG,VG,TM,DKM,DCDX,DCDY,AN,BN,CN,HELP,HELPA,
     * SAVEX,SAVEY,FX,FXC,FXX,FY,FYC,FYY,FILX,FILY,FILZ)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C
C       VARIABLE DECLARATIONS
C
      DIMENSION  C(1200000),STEPC(I_PIPS_RUN_STEPC),POTT(I_PIPS_RUN_POTT
     x ),STEPT(I_PIPS_RUN_STEPT),UX(I_PIPS_RUN_UX),STEPU(I_PIPS_RUN_STEP
     x U),
     * VY(I_PIPS_RUN_VY),STEPV(I_PIPS_RUN_STEPV),WZ(I_PIPS_RUN_WZ),PRES(
     x I_PIPS_RUN_PRES),STEPP(I_PIPS_RUN_STEPP),Q(I_PIPS_RUN_Q),DKZM(I_P
     x IPS_RUN_DKZM),DKZH(I_PIPS_RUN_DKZH),
     * ELEV(I_PIPS_RUN_ELEV),ELEVX(I_PIPS_RUN_ELEVX),ELEVY(I_PIPS_RUN_EL
     x EVY),Z0(I_PIPS_RUN_Z0),HMIX(I_PIPS_RUN_HMIX),STEPH(I_PIPS_RUN_STE
     x PH),TAVR(I_PIPS_RUN_TAVR),
     * OBUK(I_PIPS_RUN_OBUK),USTR(I_PIPS_RUN_USTR),TSTR(I_PIPS_RUN_TSTR)
     x ,VDEP(I_PIPS_RUN_VDEP), DEP(I_PIPS_RUN_DEP),ZET(I_PIPS_RUN_ZET),H
     x VAR(I_PIPS_RUN_HVAR),
     * UM(I_PIPS_RUN_UM),VM(I_PIPS_RUN_VM),UG(I_PIPS_RUN_UG),VG(I_PIPS_R
     x UN_VG),TM(I_PIPS_RUN_TM),DKM(I_PIPS_RUN_DKM), DCDX(I_PIPS_RUN_DCD
     x X),DCDY(I_PIPS_RUN_DCDY),
     * AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN),HELP(I_PIPS
     x _RUN_HELP),HELPA(I_PIPS_RUN_HELPA), SAVEX(I_PIPS_RUN_SAVEX),SAVEY
     x (I_PIPS_RUN_SAVEY),
     * FX(I_PIPS_RUN_FX),FXC(I_PIPS_RUN_FXC),FXX(I_PIPS_RUN_FXX),FY(I_PI
     x PS_RUN_FY),FYC(I_PIPS_RUN_FYC),FYY(I_PIPS_RUN_FYY),FILX(NZ+NY+NX-
     x LFINAL+1200000),FILY(NZ-LFINAL+NY+1200000),FILZ(NZ-LFINAL+1200000
     x )
C
      COMMON/STRCH/ALP,BET,DH,ZH,UGH,VGH,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
      COMMON/SOURCE/INIT(2,2),NSOUR(2),IX(2,2),JY(2,2),KZ(2,2),
     *IVAL(2,2),NSX(2,2),NSY(2,2),NSZ(2,2),ISR(2,2)
      COMMON/LEVEL/KK1,KK2,KK3,KK4,IYHOM,IGEO,IUGX,IVGY,LT0,LT1,ICPU
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
      COMMON/CPU/CINIT,CINHC,CINVC,CINHT,CINVT,CINPI,CINHU,CINVU,
     *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN
C (0,1)
      INTEGER*8 I_PIPS_RUN_STEPC
      COMMON /PIPS_RUN_STEPC/ I_PIPS_RUN_STEPC
      INTEGER*8 I_PIPS_RUN_POTT
      COMMON /PIPS_RUN_POTT/ I_PIPS_RUN_POTT
      INTEGER*8 I_PIPS_RUN_STEPT
      COMMON /PIPS_RUN_STEPT/ I_PIPS_RUN_STEPT
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_STEPU
      COMMON /PIPS_RUN_STEPU/ I_PIPS_RUN_STEPU
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_STEPV
      COMMON /PIPS_RUN_STEPV/ I_PIPS_RUN_STEPV
      INTEGER*8 I_PIPS_RUN_WZ
      COMMON /PIPS_RUN_WZ/ I_PIPS_RUN_WZ
      INTEGER*8 I_PIPS_RUN_PRES
      COMMON /PIPS_RUN_PRES/ I_PIPS_RUN_PRES
      INTEGER*8 I_PIPS_RUN_STEPP
      COMMON /PIPS_RUN_STEPP/ I_PIPS_RUN_STEPP
      INTEGER*8 I_PIPS_RUN_Q
      COMMON /PIPS_RUN_Q/ I_PIPS_RUN_Q
      INTEGER*8 I_PIPS_RUN_DKZM
      COMMON /PIPS_RUN_DKZM/ I_PIPS_RUN_DKZM
      INTEGER*8 I_PIPS_RUN_DKZH
      COMMON /PIPS_RUN_DKZH/ I_PIPS_RUN_DKZH
      INTEGER*8 I_PIPS_RUN_ELEV
      COMMON /PIPS_RUN_ELEV/ I_PIPS_RUN_ELEV
      INTEGER*8 I_PIPS_RUN_ELEVX
      COMMON /PIPS_RUN_ELEVX/ I_PIPS_RUN_ELEVX
      INTEGER*8 I_PIPS_RUN_ELEVY
      COMMON /PIPS_RUN_ELEVY/ I_PIPS_RUN_ELEVY
      INTEGER*8 I_PIPS_RUN_Z0
      COMMON /PIPS_RUN_Z0/ I_PIPS_RUN_Z0
      INTEGER*8 I_PIPS_RUN_HMIX
      COMMON /PIPS_RUN_HMIX/ I_PIPS_RUN_HMIX
      INTEGER*8 I_PIPS_RUN_STEPH
      COMMON /PIPS_RUN_STEPH/ I_PIPS_RUN_STEPH
      INTEGER*8 I_PIPS_RUN_TAVR
      COMMON /PIPS_RUN_TAVR/ I_PIPS_RUN_TAVR
      INTEGER*8 I_PIPS_RUN_OBUK
      COMMON /PIPS_RUN_OBUK/ I_PIPS_RUN_OBUK
      INTEGER*8 I_PIPS_RUN_USTR
      COMMON /PIPS_RUN_USTR/ I_PIPS_RUN_USTR
      INTEGER*8 I_PIPS_RUN_TSTR
      COMMON /PIPS_RUN_TSTR/ I_PIPS_RUN_TSTR
      INTEGER*8 I_PIPS_RUN_VDEP
      COMMON /PIPS_RUN_VDEP/ I_PIPS_RUN_VDEP
      INTEGER*8 I_PIPS_RUN_DEP
      COMMON /PIPS_RUN_DEP/ I_PIPS_RUN_DEP
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_UG
      COMMON /PIPS_RUN_UG/ I_PIPS_RUN_UG
      INTEGER*8 I_PIPS_RUN_VG
      COMMON /PIPS_RUN_VG/ I_PIPS_RUN_VG
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_RUN_FXX
      COMMON /PIPS_RUN_FXX/ I_PIPS_RUN_FXX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_RUN_FYY
      COMMON /PIPS_RUN_FYY/ I_PIPS_RUN_FYY
      INTEGER*8 I_PIPS_DCDTZ_DKS
      COMMON /PIPS_DCDTZ_DKS/ I_PIPS_DCDTZ_DKS
      INTEGER*8 I_PIPS_DCTDX_FX
      COMMON /PIPS_DCTDX_FX/ I_PIPS_DCTDX_FX
      INTEGER*8 I_PIPS_DCTDX_FXX
      COMMON /PIPS_DCTDX_FXX/ I_PIPS_DCTDX_FXX
      INTEGER*8 I_PIPS_DCTDX_SAVEX
      COMMON /PIPS_DCTDX_SAVEX/ I_PIPS_DCTDX_SAVEX
      INTEGER*8 I_PIPS_DTDTZ_DKS
      COMMON /PIPS_DTDTZ_DKS/ I_PIPS_DTDTZ_DKS
      INTEGER*8 I_PIPS_DTDTZ_DTM
      COMMON /PIPS_DTDTZ_DTM/ I_PIPS_DTDTZ_DTM
      INTEGER*8 I_PIPS_DTDTZ_FORC
      COMMON /PIPS_DTDTZ_FORC/ I_PIPS_DTDTZ_FORC
      INTEGER*8 I_PIPS_DUDTZ_DKS
      COMMON /PIPS_DUDTZ_DKS/ I_PIPS_DUDTZ_DKS
      INTEGER*8 I_PIPS_DUDTZ_DUM
      COMMON /PIPS_DUDTZ_DUM/ I_PIPS_DUDTZ_DUM
      INTEGER*8 I_PIPS_DUDTZ_FORC
      COMMON /PIPS_DUDTZ_FORC/ I_PIPS_DUDTZ_FORC
      INTEGER*8 I_PIPS_DVDTZ_DKS
      COMMON /PIPS_DVDTZ_DKS/ I_PIPS_DVDTZ_DKS
      INTEGER*8 I_PIPS_DVDTZ_DVM
      COMMON /PIPS_DVDTZ_DVM/ I_PIPS_DVDTZ_DVM
      INTEGER*8 I_PIPS_DVDTZ_FORC
      COMMON /PIPS_DVDTZ_FORC/ I_PIPS_DVDTZ_FORC
      INTEGER*8 I_PIPS_TOPO_FILX
      COMMON /PIPS_TOPO_FILX/ I_PIPS_TOPO_FILX
      INTEGER*8 I_PIPS_TOPO_FILY
      COMMON /PIPS_TOPO_FILY/ I_PIPS_TOPO_FILY
      INTEGER*8 I_PIPS_DPDX_FILX
      COMMON /PIPS_DPDX_FILX/ I_PIPS_DPDX_FILX
      INTEGER*8 I_PIPS_DPDY_FILY
      COMMON /PIPS_DPDY_FILY/ I_PIPS_DPDY_FILY
      INTEGER*8 I_PIPS_WCONT_FILZ
      COMMON /PIPS_WCONT_FILZ/ I_PIPS_WCONT_FILZ
      INTEGER*8 I_PIPS_HORDFC_FX
      COMMON /PIPS_HORDFC_FX/ I_PIPS_HORDFC_FX
      INTEGER*8 I_PIPS_HORDFC_FXC
      COMMON /PIPS_HORDFC_FXC/ I_PIPS_HORDFC_FXC
      INTEGER*8 I_PIPS_HORDFC_FXX
      COMMON /PIPS_HORDFC_FXX/ I_PIPS_HORDFC_FXX
      INTEGER*8 I_PIPS_HORDFC_SAVEX
      COMMON /PIPS_HORDFC_SAVEX/ I_PIPS_HORDFC_SAVEX
      INTEGER*8 I_PIPS_SMIM_HELPA
      COMMON /PIPS_SMIM_HELPA/ I_PIPS_SMIM_HELPA
      INTEGER*8 I_PIPS_SMIM_AN
      COMMON /PIPS_SMIM_AN/ I_PIPS_SMIM_AN
      INTEGER*8 I_PIPS_SMIM_BN
      COMMON /PIPS_SMIM_BN/ I_PIPS_SMIM_BN
      INTEGER*8 I_PIPS_SMIM_CN
      COMMON /PIPS_SMIM_CN/ I_PIPS_SMIM_CN
      INTEGER*8 I_PIPS_STRECH_FILZ
      COMMON /PIPS_STRECH_FILZ/ I_PIPS_STRECH_FILZ
C     BEGIN BLOCK
C (0,2)
C    *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN,TM1,TM18,TM19
CX30005 CALL SBINX (5)
CY30005 CALL SBINY (5)
C
C   ********************************************************************
C   *   CALCULATE SOME CONSTANTS AND INITIALIZE SOME LOCAL VARIABLES.  *
C   *    LOOP: NUMBER OF POINTS TO LOOP FOR TIME INTEGRATION           *
C   *    H= REGULAR TIME STEP, H1=FINER TIME STEP, NCOUNT=NUMBER OF    *
C   *    FINER TIME STEPS, TEND= END OF TIME INTEGRATION, NX1,NY1 ARE  *
C   *    HALF POINTS FOR PSEUDOSPECTRAL COLLOCATIONS                   *
C   ********************************************************************
C
C    ADDITIONAL ALLOCATION OF VECTOR SPACE INDICES
C
      NX1 = NX/2
C (0,3)
      NY1 = NY/2
C (0,4)
      NXNY = NX*NY
C (0,5)
      NXNY1 = 1-NXNY
C (0,6)
      LOOP = NX*NY*NZ
C (0,7)
      LENGTH = MAX(NX, NY, NZ)
C (0,8)
C     ====================   VECTOR # 1  ===============================
      LV1 = 1
C (0,9)
      LAST = LENGTH
C (0,10)
C     ====================   VECTOR # 2  ===============================
      LV2 = LAST+1
C (0,11)
      LAST = LV2+LENGTH
C (0,12)
C     ====================   VECTOR # 3  ===============================
      LV3 = LAST+1
C (0,13)
      LAST = LV3+LENGTH
C (0,14)
C     ====================   VECTOR # 4  ===============================
      LV4 = LAST+1
C (0,15)
      LAST = LV4+LENGTH
C (0,16)
C     ====================   VECTOR # 5  ===============================
      LV5 = LAST+1
C (0,17)
      LAST = LV5+LENGTH
C (0,18)
C     ====================   VECTOR # 6  ===============================
      LV6 = LAST+1
C (0,19)
      LAST = LV6+LENGTH
C (0,20)
C     ====================   VECTOR # 7  ===============================
      LV7 = LAST+1
C (0,21)
      LAST = LV7+LENGTH
C (0,22)
C
C     SUPRESS UNDERFLOW ERRORS IN THE PROGRAM
C     A T T E N T I O N ] ] ]    O N L Y    O N     T H E     V M
C
C     CALL XUFLOW
C
C     AT THE TOP LEVEL OF THE MODEL C,POTT,UX,VY,WZ,PRES ARE ZERO
C     AND THEREFORE ARE NOT CALCULATED. AT THE BOTTOM ONLY UX,
C     UY, AND WZ ARE ZERO
C
      NZTOP = NZ-1
C (0,23)
      LOOP = NX*NY*NZTOP
C (0,24)
      PI = DATAN(1.0D0)*4.0D0
C (0,25)
      OMEGA = 7.292D-5
C (0,26)
      F = 2.D0*OMEGA*DSIN(PI*PHI/180.D0)
C (0,27)
      FHAT = 2.D0*OMEGA*DCOS(PI*PHI/180.D0)
C (0,28)
C
C     DAYLIGHT AS EXPRESSED BY STANDAR DEVIATION IN GAUSSIAN FORCING
C
      DAY = 43200.0D0
C (0,29)
      DAYL = DAY/2.4495D0
C (0,30)
C     BEGIN UNSTRUCTURED
C (1,1)
C
C     JUMP TO A REAL RUN IF CONTINUING AN INTERRUPTED RUN
C
      IF (NPRINT.EQ.1) GOTO 10
C (12,1)
C     BEGIN BLOCK
C (12,2)
C
C     INITIALIZE TEST PARAMETERS AND CPU COUNTERS
C
      CINIT = 0.0
C (12,3)
      CINHC = 0.0
C (12,4)
      CINVC = 0.0
C (12,5)
      CINHT = 0.0
C (12,6)
      CINVT = 0.0
C (12,7)
      CINPI = 0.0
C (12,8)
      CINHU = 0.0
C (12,9)
      CINVU = 0.0
C (12,10)
      CINHV = 0.0
C (12,11)
      CINVV = 0.0
C (12,12)
      CINHW = 0.0
C (12,13)
      CINVW = 0.0
C (12,14)
      CINPR = 0.0
C (12,15)
      CINBL = 0.0
C (12,16)
      CINFL = 0.0
C (12,17)
      CINMN = 0.0
C (12,18)
C     TM10=0.0
      CMASS = 0.0
C (12,19)
      HEAT = 0.0
C (12,20)
      EXNER = 0.0
C (12,21)
      UWIND = 0.0
C (12,22)
      USQ = 0.0
C (12,23)
      VWIND = 0.0
C (12,24)
      VSQ = 0.0
C (12,25)
      WWIND = 0.0
C (12,26)
      WSQ = 0.0
C (12,27)
      NSTEP = 0
C (12,28)
      TOUT = 0.0
C (12,29)
      TIME1 = TSTART
C (12,30)
      TEND1 = TSTART+NT*DELTAT
C (12,31)
      IF (NY.GT.1) THEN
C (12,32)
         IYHOM = 1
      ELSE
C (12,33)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (12,34)
C
C       SET THE INITIAL CONDITIONS FOR C
C                   AND ALSO
C       ESTABLISH THE SOURCES OR SINKS IN THE DOMAIN
C
      CALL SETALL(NX, NY, NZ, XSTART, YSTART, ZSTART, DELTAX, DELTAY
     &, DELTAZ, C, Q, CMASS)
C (12,35)
      I_PIPS_STRECH_FILZ = NZ-LFINAL+1200000
C
C       SET THE VERTICAL VARIABLE (EQUAL OR LOGARITHMIC ENCREMENTS)
C
      CALL STRECH(FILZ, HVAR, ZET, NZ, DELTAZ, NP, ITY)
C (12,36)
C
C
C     CALCULATE THE MEAN WIND COMPONENTS WITH MODIFIED EKMAN THEORY
C        DZM IS THE DIFFUSSIVITY COEFFICIENT OBTAINED THROUGH
C        THE EKMAN THEORY, WHILE DZ IS PRESET FROM DATA.
C
      CALL UVSET(NX, NY, NZ, HVAR, ZET, NP, DZ, DKM, UM, VM, UG, VG, 
     &TM, DCDX, ITY, ISH, NSMT, F)
C (12,37)
      I_PIPS_HORDFC_FX = I_PIPS_RUN_FX
      I_PIPS_HORDFC_FXC = I_PIPS_RUN_FXC
      I_PIPS_HORDFC_FXX = I_PIPS_RUN_FXX
      I_PIPS_HORDFC_SAVEX = I_PIPS_RUN_SAVEX
C
C       CALCULATE HORIZONTAL DIFFUSION COEFFICIENTS FOR THE FFT'S
C
      CALL HORDFC(NX, NX1, XSTART, DELTAX, PI, DELTAT, DX, FX, FXC, 
     &FXX, SAVEX, NTIME)
C (12,38)
      IF (NY.GT.1) THEN
C (12,39)
      I_PIPS_HORDFC_FX = I_PIPS_RUN_FY
      I_PIPS_HORDFC_FXC = I_PIPS_RUN_FYC
      I_PIPS_HORDFC_FXX = I_PIPS_RUN_FYY
      I_PIPS_HORDFC_SAVEX = I_PIPS_RUN_SAVEY
         CALL HORDFC(NY, NY1, YSTART, DELTAY, PI, DELTAT, DY, FY, FYC
     &   , FYY, SAVEY, NTIME)
      ELSE
C (12,40)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (12,41)
      I_PIPS_TOPO_FILX = NZ+NY+NX-LFINAL+1200000
      I_PIPS_TOPO_FILY = NZ-LFINAL+NY+1200000
C
C      SET THE TOPOGRAPHY MATRIX, AND GRADIENTS OF TOPOGRAPHY.
C                                      =-0.1       WATER
C       FOR  EVERY I,J: IF   ELEV(I,J) = 0.0  50% WATER, 50% LAND
C                                      > 0.0       LAND
C      ALSO SET THE SURFACE ROUGHNESS ACCORDING TO TOPOGRAPHY
C
      CALL TOPO(NX, NY, XSTART, YSTART, DELTAX, DELTAY, ELEV, ELEVX, 
     &ELEVY, Z0, HELP, HELPA, NX1, FX, FXX, FILX, SAVEX, NY1, FY, FYY
     &, FILY, SAVEY)
C (12,42)
C
C     SET THE INITIAL HEIGHT OF THE PLANETARY BOUNDARY LAYER IN X,Y
C
      CALL INITBL(NX, NY, ELEV, HMIX, H0)
C (12,43)
C
C      FIND THE INITIAL EDDY DIFFUSSIVITIY COEFFICIENTS
C
      CALL DKZMH(HELP, HELPA, TM, UM, VM, POTT, UX, VY, WZ, ZET, DKZM
     &, DKZH, DZ, Z0, ELEV, NX, NX1, NY, NY1, NZ, HMIX, STEPH, TAVR, 
     &OBUK, USTR, TSTR, VDEP, 0, F, NFILT, -1, DELTAT, SAVEX, SAVEY, 
     &FX, FY, FXC, FYC, DCDX, DCDY, TSL, DL)
C (12,44)
C
C      PRINT INITIAL RESULTS
C
      CALL PRINTR(NX, NY, NZ, NT, XSTART, YSTART, ZSTART, TSTART, DX
     &, DY, DZ, DELTAX, DELTAY, DELTAZ, DELTAT, TIME1, TOUT, 1, C, UM
     &, UX, VM, VY, TM, POTT, WZ, PRES, DKM, DKZM, DKZH, DEP, NPRINT
     &, NGRAPH, NPSTEP, NGSTEP, NSTEP, IBT, NWINDX, ISH, NSMT, NFILT
     &, IB, IK, ITY, NCOUNT, Z0, ELEV, HMIX, TAVR, OBUK, USTR, TSTR, 
     &VDEP, PHI, CMASS, UWIND, USQ, VWIND, VSQ, WWIND, WSQ, HEAT, 
     &EXNER)
C     END BLOCK
C (2,1)
C     BEGIN BLOCK
C (2,2)
CX20806 CALL DOOUTX( 806 )
CY20806 CALL DOOUTY( 806 )
C
C     CALL CPUCLK(TM2,1,BIAS)
C     CINIT=TM2-TM1
C
C ======================================================================
C ==     *********      START THE TIME INTEGRATION    **********      ==
C ======================================================================
C
10    CONTINUE
C (2,3)
CX10805 CALL DOINX( 805 )
CY10805 CALL DOINY( 805 )
      NSTEP = NSTEP+1
C (2,4)
C
C     USE ISTEP TO DESIDE WHEN THE EULER SCHEME SHOULD BE USED
C     TO SUPPRESS THE ODD-EVEN COMPUTATIONAL MODE FROM LEAPFROG SCHEME
C
      ISTEP = NSTEP
C (2,5)
      IF (MOD(NSTEP, NCOUNT).EQ.0) THEN
C (2,6)
         ISTEP = 1
      ELSE
C (2,7)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (2,8)
C
C ----   CORRECT THE HORIZONTAL BOUNDARY CONDITIONS FOR C(X,Y,Z) -------
C
C      CALL HORBC(NX,NY,NZ,NT,XSTART,YSTART,ZSTART,TSTART,
C     *DELTAX,DELTAY,DELTAZ,DELTAT,TIME1,UX,VY,C,Q)
C
C  *********************************************************************
C
C            THE  SOLUTION  OF THE COMPLETE SYSTEM IS PERFORMED BY USING
C       THE SPLITTING-UP METHOD.  IN SPECIFIC THE  HORIZONTAL  ADVECTION
C       IS  CARRIED  OUT  BY AN EXPLICIT LEAPFROG SCHEME, THE HORIZONTAL
C       DIFFUSION IS PERFORMED BY THE  METHOD  OF  THE  EIGENVALUES,  OR
C       EQUVALENTLY  BY VERTICAL MULTIPLYING THE FOURIER COEFFICIENTS BY
C       APPROPRIATE EXPONENTIALS.  THE  VERTICAL  DIFFUSION  IS  TREATED
C       WITH  A  SEMI-IMPLICIT  PADE-CRANK-NICKOLSON,  AS  WELL  AS  THE
C       VERTICAL ADVECTION.  THE PRESSURE DERIVATIVE TERMS  ARE  TREATED
C       WITH  THE SO-CALLED PRESSURE AVERAGING TECHNIQUE.  FINALLY OTHER
C       TERMS WILL BE DUBBED IN  THE  ADVECTION  PART  (CORIOLIS).   THE
C       MODEL  CALCULATES  PROGNOSTICALLY THE THE POTENTIAL TEMPERATURE,
C       U,V  WIND  COMPONENTS  AND  CONCENTRATIONS   OF   POLLUTANTS   C
C       (POTT,UX,VY,C).   THE PRESSURE AND THE VERTICAL VELOCITY WILL BE
C       CALCULATED DIAGNOSTICALLY (PRES,WZ).  THE DIFFUSIVITIES ARE ALSO
C       CALCULATED  DIAGNOSTICALLY  USING INFORMATION ON UX,VY, POTT THE
C       TOTAL PROCEDURE IS DONE IN THE FOLLOWING EIGHT STEPS:
C
C  *********************************************************************
C
C            1)  FROM  THE  INITIAL  CONDITIONS  (U,V,THETA,  AND  THEIR
C       SYNOPTIC   COUNTERPARTS)   CALCULATE   THE   EDDY    DIFFUSIVITY
C       COEFFICIENTS  FOR  HEAT  AND  MOMENTUMED  BY  ADDING  THE  ABOVE
C       MESOSCALE PERTURBATIONS TO THEIR SYNOPTIC VALUES  AND  CALCULATE
C       ONE  KZ  WHICH  WILL  BE  THE  SUM OF THE SYNOPTIC AND MESOSCALE
C       STATE.  THEN THE MESOSCALE DIFFUSIVITIES KZ WHICH APPEAR IN  THE
C       EQUATIONS WILL BE THE DIFFERENCE OF THE (SYNOPTIC+MESO)-SYNOPTIC
C       BOUNDARY CONDITIONS FOR THE MESO+SYNOPTIC KZ ARE 0.1 M*M/SEC  AT
C       Z=0,Z=ZN.   BY-PRODUCTS OF THE CALCULATION FOR THE DIFFUSIVITIES
C       ARE THE MONIN-OBUKHOV LENGTH L, THE FRICTIONAL VELOCITY U*,  THE
C       TURBULENT  POTENTIAL  TEMPERATURE  T*,  THE  CONVECTIVE VERTICAL
C       VELOCITY SCALE W*, THE PLANETARY BOUNDARY LAYER HEIGHT H  (HMIX)
C       WHICH   IS  CALCULATED  VIA  DEARDORFFS  AND  SMEDAS  PROGNOSTIC
C       RELATION, THE DRY DEPOSITION VELOCITY VD, THE VARIABLE ROUGHNESS
C       LENGTH Z0, AND THE MEAN SURFACE LAYER TEMPERATURE.
C
C            2) USE THE WIND FIELDS (U,V,W) AND THE DIFFUSIVITY PROFILES
C       KZ TO ADVECT AND MIX THE  POLLUTANTS  ACCORDINGLY.   HOMOGENIOUS
C       BOUNDARY  CONTITIONS  AT THE TOP FOR C, AND REMOVAL OF C AT Z=0,
C       ACCORDING TO RATES GIVEN BY THE DRY DEPOSITION VELOCITIES VD.
C
C            3) SOLVE THE EQUATION FOR  THE  CONSERVATION  OF  ADIABATIC
C       ENERGY  (DT/DT) IN THE MESOSCALE.  BOUNDARY CONDITIONS OF T=0 AT
C       Z=ZN, AND T=T(X,Y,T) AT Z=0.  THE LAST  CONDITION  IS  THE  OLNY
C       INPUT OF ENERGY AT THE MODEL.
C
C            4)   HAVING   CALCULATED   T,   INTEGRATE   VERTICALLY  THE
C       HYDROSTATIC  EQUATION  TO  CALCULATE  THE  HORIZONTAL   PRESSURE
C       DISTRIBUTIONS   (PI)   FOR  EACH  VERTICAL  LAYER.   (DIAGNOSTIC
C       CALCULATION).  INTEGRATION IS PERFORMED  FROM  THE  TOP  OF  THE
C       MODEL  (ZN)  WITH  DOWNWARD  DIRECTION  UNTIL THE SURFACE OF THE
C       MODEL (Z=0)
C
C            5) ONCE THE PRESSURE IS OBTAINED, IT IS AVERAGED  WITH  THE
C       PRESSURE  AT  THE  PREVIOUS TIME STEP, AND IT IS FILTERED AT THE
C       LATERAL BOUNDARIES.  THEN VIA FFT'S OBTAIN  ITS  GRADIENTS  WITH
C       RESPECT  TO  X,  AND  Y.  THEN THE PRESSURE STEP IN THE MOMENTUM
C       EQUATIONS IS PERFORMED IN THE VERTICAL DIRECTION.
C
C            6) USE THE  SYNOPTIC  PRESSURE  GRADIENT  (UG,VG)  AND  THE
C       CORIOLIS   F  TERMS  TO  SOLVE  FOR  U  AFTER  THE  GRADIENT  PI
C       PERTURBATIONS ARE ADDED.  U IS ZERO AT THE TOP AND  THE  SURFACE
C       OF THE MODEL.
C
C            7)  USE  THE  SYNOPTIC  PRESSURE  GRADIENT  (UG,VG) AND THE
C       CORIOLIS F TERMS TO SOLVE FOR V EXACTLY AS ABOVE WITH  THE  SAME
C       BOUNDARY CONTITIONS.
C
C            8) CALCULATE THE X AND Y GRADIENDS OF THE MESOSCALE U AND V
C       PERTURBATIONS VIA FFT'S AND WITH AN  IMPLICIT  METHOD  CALCULATE
C       DIAGNOSTICALLY  THE  HORIZONTAL  DISTRIBUTIONS  OF  THE VERTICAL
C       VELOCITY, BY VERICALLY INTEGRATING THE CONTINUITY EQUATION ON  A
C       LEVEL  TO  LEVEL  BASIS.  START FROM THE BOTTOM AND MARCH UPWARD
C       ASSUMING W=0 AT THE TOP AND THE BOTTOM OF THE  MODEL.   ADD  THE
C       TOPOGRAPHY   GRADIENTS   IN  THE  CALCULATIONS  TO  ACCOUNT  FOR
C       ADDITIONAL VERTICAL MOTION AS MOMENTUM MIGHT GO UP OR  DOWN  THE
C       SLOPE OF THE MODEL'S TERRAIN.
C
C
C **********************************************************************
C *   C O N S E R V A T I O N    O F   P O L L U T A N T   M A S S   C *
C *   T R E A T M E N T    O F   P O L L U T A N T S  C(X,Y,Z,T)=C(L)  *
C **********************************************************************
C
C
C     CALL CPUCLK(TM2,1,BIAS)
      MLAG = NXNY1
C (2,9)
CX10507 CALL DOINX( 507 )
CY10507 CALL DOINY( 507 )
C
C ----   FOR EACH Z FIND DC(X,Y,Z)/DX, DC(X,Y,Z)/DY,  VIA FFT'S  -------
C
!     INITIALLY: DO 20
      DO II = 1, NZTOP
C (2,10)
C        BEGIN BLOCK
C (2,11)
         MLAG = MLAG+NXNY
C (2,12)
      I_PIPS_DCTDX_FX = I_PIPS_RUN_FX
      I_PIPS_DCTDX_FXX = I_PIPS_RUN_FXC
      I_PIPS_DCTDX_SAVEX = I_PIPS_RUN_SAVEX
C
C                  HORIZONTAL DISPERSION PART          2    2    2    2
C ----   CALCULATE WITH  DIFFUSION EIGENVALUES THE  K D C/DX ,K D C/DY
C                                                    X         Y
         CALL DCTDX(NX, NY, NX1, NFILT, C(MLAG), DCDX(MLAG), HELP, 
     &   HELPA, FX, FXC, SAVEX)
C (2,13)
         IF (NY.GT.1) THEN
C (2,14)
            CALL DCTDY(NX, NY, NY1, NFILT, C(MLAG), DCDY(MLAG), HELP
     &      , HELPA, FY, FYC, SAVEY)
         ELSE
C (2,15)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (2,16)
20       CONTINUE
C        END BLOCK
      ENDDO
C (2,17)
CX20508 CALL DOOUTX( 508 )
CY20508 CALL DOOUTY( 508 )
C
C      CALCULATE THE HORIZONTAL ADVECTION OF C(X,Y,Z) BY THE WINDS
C      AND PERFORM THE HORIZONTAL TIME-INTEGRATION PART.
C
      CALL ADVC(NX, NY, NZTOP, ISTEP, LOOP, DELTAT, C, STEPC, UX, UM
     &, VY, VM, Q, DCDX, DCDY)
C (2,18)
      I_PIPS_DCDTZ_DKS = I_PIPS_RUN_DCDX-(LV2-1)
C
C     PERFORM THE VERTICAL INTEGRATION FOR THE CONCENTRATION C(X,Y,Z)
C
C     CALL CPUCLK(TM3,1,BIAS)
C     CINHC=CINHC+TM3-TM2
C
      CALL DCDTZ(NX, NY, NZ, DELTAZ, DELTAT, DZ, IB, IK, C, Q, WZ, 
     &HVAR, VDEP, ZET, HELP, HELPA, DKM, DKZH, DCDX(LV1), DCDX(LV2), 
     &TIME1, AN, BN, CN, ITY, ISH, NSMT, DEP, CMASS)
C (2,19)
C
C     CALL CPUCLK(TM4,1,BIAS)
C     CINVC=CINVC+TM4-TM3
C
C **********************************************************************
C *    T H E R M O D Y N A M I C   E N E R G Y   E Q U A T I O N       *
C *    P O T E N T I A L   T E M P E R A T U R E  T(X,Y,Z,T)=POTT(L)   *
C *    S Y N O P T I C  T E M P E R A T U R E     THETA(Z) =TM(K)      *
C **********************************************************************
C
      MLAG = NXNY1
C (2,20)
CX10509 CALL DOINX( 509 )
CY10509 CALL DOINY( 509 )
C
C ----   FOR EACH Z FIND DTHETA(X,Y,Z)/DX, DTHETA(X,Y,Z)/DY,  VIA FFT'S
C
!     INITIALLY: DO 30
      DO II = 1, NZTOP
C (2,21)
C        BEGIN BLOCK
C (2,22)
         MLAG = MLAG+NXNY
C (2,23)
      I_PIPS_DCTDX_FX = I_PIPS_RUN_FX
      I_PIPS_DCTDX_FXX = I_PIPS_RUN_FXC
      I_PIPS_DCTDX_SAVEX = I_PIPS_RUN_SAVEX
C
C        HORIZONTAL DIFFUSION         2        2     2        2
C ----   DETERMINE THE DIFFUSION   K D THETA/DX,  K D THETA/DY
C                                   X              Y
         CALL DCTDX(NX, NY, NX1, NFILT, POTT(MLAG), DCDX(MLAG), HELP
     &   , HELPA, FX, FXC, SAVEX)
C (2,24)
         IF (NY.GT.1) THEN
C (2,25)
            CALL DCTDY(NX, NY, NY1, NFILT, POTT(MLAG), DCDY(MLAG), 
     &      HELP, HELPA, FY, FYC, SAVEY)
         ELSE
C (2,26)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (2,27)
30       CONTINUE
C        END BLOCK
      ENDDO
C (2,28)
CX20510 CALL DOOUTX( 510 )
CY20510 CALL DOOUTY( 510 )
C
C ---- CALCULATE THE HORIZONTAL ADVECTION OF THETA(X,Y,Z) BY THE WINDS
C      AND PERFORM THE HORIZONTAL TIME-INTEGRATION PART.
C
      CALL ADVT(NX, NY, NZTOP, ISTEP, LOOP, DELTAT, POTT, STEPT, UX, 
     &UM, VY, VM, DCDX, DCDY)
C (2,29)
      I_PIPS_DTDTZ_DKS = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_DTDTZ_DTM = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_DTDTZ_FORC = I_PIPS_RUN_DCDX-(LV4-1)
C
C     CALL CPUCLK(TM5,1,BIAS)
C     CINHT=CINHT+TM5-TM4
C
C ----  CALCULATE THE VERTICAL ADVECTION-DIFFUSION PART OF THETA(X,Y,Z)
C
      CALL DTDTZ(NX, NY, NZ, DELTAZ, DELTAT, DZ, IB, IK, TM, POTT, WZ
     &, HVAR, ZET, HELP, HELPA, DKM, DKZH, DCDX(LV1), DCDX(LV2), DCDX
     &(LV3), DCDX(LV4), TIME1, AN, BN, CN, ITY, ISH, NSMT, ELEV, DAYL
     &, HEAT, ISTEP)
C (2,30)
C
C     CALL CPUCLK(TM6,1,BIAS)
C     CINVT=CINVT+TM6-TM5
C
C
C $$$$$$$$$$$$$$$  E N D    O F    T H E T A = P O T T    $$$$$$$$$$$$$$
C
C **********************************************************************
C *    D I A G N O S T I C   H Y D R O S T A T I C   E Q U A T I O N   *
C *    T R E A T M E N T    O F   P R E S S U R E  PI(X,Y,Z,T)=PRES(L) *
C **********************************************************************
C
C
C      VERTICALLY INTEGRATE THE HYDROSTATIC PRESSURE
C
      CALL HYD(NX, NY, NZ, PRES, STEPP, TM, POTT, ZET, HVAR, NSMT, 
     &EXNER)
C (2,31)
C
C     CALL CPUCLK(TM7,1,BIAS)
C     CINPI=CINPI+TM7-TM6
C
C $$$$$$$$$$$$$$$  E N D    O F    PI = PRESS    $$$$$$$$$$$$$$$$$$$$$$$
C
C **********************************************************************
C *               X - M O M E N T U M  E Q U A T I O N   V I A         *
C *    U - W I N D    C O M P O N E N T   U(X,Y,Z,T)=UX(L)             *
C *    S Y N O P T I C   X - W I N D  C O M P O N E N T   U(Z) =UM(K)  *
C **********************************************************************
C
      MLAG = NXNY1
C (2,32)
CX10511 CALL DOINX( 511 )
CY10511 CALL DOINY( 511 )
C
C ----   FOR EACH Z FIND DU(X,Y,Z)/DX, DV(X,Y,Z)/DY,  VIA FFT'S  -------
C
!     INITIALLY: DO 40
      DO II = 1, NZTOP
C (2,33)
C        BEGIN BLOCK
C (2,34)
         MLAG = MLAG+NXNY
C (2,35)
      I_PIPS_DCTDX_FX = I_PIPS_RUN_FX
      I_PIPS_DCTDX_FXX = I_PIPS_RUN_FXX
      I_PIPS_DCTDX_SAVEX = I_PIPS_RUN_SAVEX
C
C        HORIZONTAL DIFFUSION         2    2     2    2
C ----   DETERMINE THE  DIFFUSION  K D U/DX,  K D U/DY  WITH EIGENVALUES
C                                   X          Y
         CALL DCTDX(NX, NY, NX1, NFILT, UX(MLAG), DCDX(MLAG), HELP, 
     &   HELPA, FX, FXX, SAVEX)
C (2,36)
         IF (NY.GT.1) THEN
C (2,37)
            CALL DCTDY(NX, NY, NY1, NFILT, UX(MLAG), DCDY(MLAG), HELP
     &      , HELPA, FY, FYY, SAVEY)
         ELSE
C (2,38)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (2,39)
40       CONTINUE
C        END BLOCK
      ENDDO
C (2,40)
CX20512 CALL DOOUTX( 512 )
CY20512 CALL DOOUTY( 512 )
C
C            CALCULATE THE HORIZONTAL ADVECTION OF U(X,Y,Z) BY THE WINDS
C       AND  PERFORM  THE  HORIZONTAL   TIME-INTEGRATION   PART.    ALSO
C       CALCULATE  CONTRIBUTIONS  DUE  TO  THE  HORIZONTAL  AND VERTICAL
C       CORIOLIS COMPONENTS AS WELL  AS  EFFECTS  OF  SYNOPTIC  PRESSURE
C       GRADIENT THROUGH GEOSTROPHIC WINDS
C
      CALL ADVU(NX, NY, NZTOP, ISTEP, LOOP, DELTAT, STEPT, UX, STEPU
     &, UM, VY, VM, WZ, VG, TM, F, FHAT, DCDX, DCDY)
C (2,41)
C
C      CALCULATE THE HORIZONTAL X-PRESSURE GRADIENT WITH PSEUDOSPECTRAL
C      TRANSFORMS AND PUT IT ON THE DCDX VECTOR
C
      MLAG = NXNY1
C (2,42)
CX10513 CALL DOINX( 513 )
CY10513 CALL DOINY( 513 )
!     INITIALLY: DO 50
      DO II = 1, NZTOP
C (2,43)
C        BEGIN BLOCK
C (2,44)
         MLAG = MLAG+NXNY
C (2,45)
      I_PIPS_DPDX_FILX = NZ+NY+NX-LFINAL+1200000
         CALL DPDX(NX, NY, NX1, NFILT, PRES(MLAG), STEPP(MLAG), DCDX(
     &   MLAG), HELP, HELPA, FX, FXC, FILX, SAVEX)
C (2,46)
50       CONTINUE
C        END BLOCK
      ENDDO
C (2,47)
      I_PIPS_DUDTZ_DKS = I_PIPS_RUN_DCDY-(LV2-1)
      I_PIPS_DUDTZ_DUM = I_PIPS_RUN_DCDY-(LV3-1)
      I_PIPS_DUDTZ_FORC = I_PIPS_RUN_DCDY-(LV4-1)
CX20514 CALL DOOUTX( 514 )
CY20514 CALL DOOUTY( 514 )
C
C     CALL CPUCLK(TM8,1,BIAS)
C     CINHU=CINHU+TM8-TM7
C
C
C ----  CALCULATE THE VERTICAL ADVECTION-DIFFUSION PART OF U(X,Y,Z) ----
C
      CALL DUDTZ(NX, NY, NZ, DELTAZ, DELTAT, DZ, IB, IK, UM, UX, WZ, 
     &HVAR, ZET, HELP, HELPA, DKM, DKZM, DCDY(LV1), DCDY(LV2), DCDY(
     &LV3), DCDY(LV4), DCDX, TIME1, AN, BN, CN, ITY, ISH, NSMT, TM, 
     &UWIND, USQ, ISTEP)
C     END BLOCK
C (3,1)
C
C     CALL CPUCLK(TM9,1,BIAS)
C     CINVU=CINVU+TM9-TM8
C     TM10=TM9
C
C $$$$$$$$$$$$$$$  E N D    O F    U = UX  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$
C
      IF (IYHOM.EQ.0) GOTO 90
C (11,1)
C     BEGIN BLOCK
C (11,2)
C
C **********************************************************************
C *               Y - M O M E N T U M  E Q U A T I O N   V I A         *
C *    V - W I N D    C O M P O N E N T   V(X,Y,Z,T)=VX(L)             *
C *    S Y N O P T I C   Y - W I N D  C O M P O N E N T   V(Z) =VM(K)  *
C **********************************************************************
C
      MLAG = NXNY1
C (11,3)
CX10515 CALL DOINX( 515 )
CY10515 CALL DOINY( 515 )
C
C ----   FOR EACH Z FIND DV(X,Y,Z)/DX, DV(X,Y,Z)/DY,  VIA FFT'S  -------
C
!     INITIALLY: DO 60
      DO II = 1, NZTOP
C (11,4)
C        BEGIN BLOCK
C (11,5)
         MLAG = MLAG+NXNY
C (11,6)
      I_PIPS_DCTDX_FX = I_PIPS_RUN_FX
      I_PIPS_DCTDX_FXX = I_PIPS_RUN_FXX
      I_PIPS_DCTDX_SAVEX = I_PIPS_RUN_SAVEX
C                           2    2     2    2
C ----   DETERMINE THE   K D V/DX,  K D V/DY  WITH DIFFUSION EIGENVALUES
C                         X          Y
         CALL DCTDX(NX, NY, NX1, NFILT, VY(MLAG), DCDX(MLAG), HELP, 
     &   HELPA, FX, FXX, SAVEX)
C (11,7)
         IF (NY.GT.1) THEN
C (11,8)
            CALL DCTDY(NX, NY, NY1, NFILT, VY(MLAG), DCDY(MLAG), HELP
     &      , HELPA, FY, FYY, SAVEY)
         ELSE
C (11,9)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (11,10)
60       CONTINUE
C        END BLOCK
      ENDDO
C (11,11)
CX20516 CALL DOOUTX( 516 )
CY20516 CALL DOOUTY( 516 )
C
C            CALCULATE THE HORIZONTAL ADVECTION OF V(X,Y,Z) BY THE WINDS
C       AND  PERFORM  THE  HORIZONTAL   TIME-INTEGRATION   PART.    ALSO
C       CALCULATE   CONTRIBUTIONS   DUE   TO   THE  HORIZONTAL  CORIOLIS
C       COMPONENTS AS WELL AS  EFFECTS  OF  SYNOPTIC  PRESSURE  GRADIENT
C       THROUGH GEOSTROPHIC WINDS
C
      CALL ADVV(NX, NY, NZTOP, ISTEP, LOOP, DELTAT, STEPT, STEPU, UM
     &, VY, STEPV, VM, UG, TM, F, DCDX, DCDY)
C     END BLOCK
C (10,1)
C
C      CALCULATE THE HORIZONTAL Y-PRESSURE GRADIENT WITH PSEUSOSPECTRAL
C      TRANSFORMS AND PUT IT ON THE DCDY VECTOR ONLY IF NY>1
C
      IF (NY.EQ.1) GOTO 80
C (9,1)
C     BEGIN BLOCK
C (9,2)
C
      MLAG = NXNY1
C (9,3)
CX10517 CALL DOINX( 517 )
CY10517 CALL DOINY( 517 )
!     INITIALLY: DO 70
      DO II = 1, NZTOP
C (9,4)
C        BEGIN BLOCK
C (9,5)
         MLAG = MLAG+NXNY
C (9,6)
      I_PIPS_DPDY_FILY = NZ-LFINAL+NY+1200000
         CALL DPDY(NX, NY, NY1, NFILT, PRES(MLAG), STEPP(MLAG), DCDY(
     &   MLAG), HELP, HELPA, FY, FYC, FILY, SAVEY)
C (9,7)
70       CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (8,1)
C     BEGIN BLOCK
C (8,2)
CX20518 CALL DOOUTX( 518 )
CY20518 CALL DOOUTY( 518 )
C
C ----  CALCULATE THE VERTICAL ADVECTION-DIFFUSION PART OF V(X,Y,Z) ----
C
80    CONTINUE
C (8,3)
      I_PIPS_DVDTZ_DKS = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_DVDTZ_DVM = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_DVDTZ_FORC = I_PIPS_RUN_DCDX-(LV4-1)
C
C     CALL CPUCLK(TM10,1,BIAS)
C     CINHV=CINHV+TM10-TM9
C
      CALL DVDTZ(NX, NY, NZ, DELTAZ, DELTAT, DZ, IB, IK, VM, VY, WZ, 
     &HVAR, ZET, HELP, HELPA, DKM, DKZM, DCDX(LV1), DCDX(LV2), DCDX(
     &LV3), DCDX(LV4), DCDY, TIME1, AN, BN, CN, ITY, ISH, NSMT, TM, 
     &VWIND, VSQ, ISTEP)
C     END BLOCK
C (4,1)
C     BEGIN BLOCK
C (4,2)
C
C $$$$$$$$$$$$$$$$$$$  E N D    O F    V = VY  $$$$$$$$$$$$$$$$$$$$$$$$$
C
90    CONTINUE
C (4,3)
C
C     CALL CPUCLK(TM11,1,BIAS)
C     CINVV=CINVV+TM11-TM10
C
C **********************************************************************
C *    D I A D N O S T I C   C O N T I N U I T Y     E Q U A T I O N   *
C *    F O R   T H E  V E R T I C A L  V E L O C I T Y W(X,Y,Z,T)=WZ(L)*
C **********************************************************************
C
C
C      VERTICALLY INTEGRATE THE  SUM OF  U(X,Y,Z) AND V(X,Y,Z)
C      FIRST FIND THE GRADIENTS OF U,V VIA FFT'S
C
      MLAG = NXNY1
C (4,4)
CX10519 CALL DOINX( 519 )
CY10519 CALL DOINY( 519 )
C
C ------  FOR EACH Z FIND DU(X,Y,Z)/DX, DV(X,Y,Z)/DY,  VIA FFT'S  ------
C
!     INITIALLY: DO 100
      DO II = 1, NZTOP
C (4,5)
C        BEGIN BLOCK
C (4,6)
         MLAG = MLAG+NXNY
C (4,7)
         CALL DFTDX(NX, NY, NX1, UX(MLAG), DCDX(MLAG), HELP, FX, 
     &   SAVEX)
C (4,8)
         IF (NY.GT.1) THEN
C (4,9)
            CALL DFTDY(NX, NY, NY1, VY(MLAG), DCDY(MLAG), HELP, FY, 
     &      SAVEY)
         ELSE
C (4,10)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (4,11)
100      CONTINUE
C        END BLOCK
      ENDDO
C (4,12)
      I_PIPS_WCONT_FILZ = NZ-LFINAL+1200000
CX20520 CALL DOOUTX( 520 )
CY20520 CALL DOOUTY( 520 )
C
C     CALL CPUCLK(TM12,1,BIAS)
C     CINHW=CINHW+TM12-TM11
C
      CALL WCONT(NX, NY, NZ, UX, VY, WZ, DCDX, DCDY, ZET, ELEVX, 
     &ELEVY, HVAR, NSMT, HELP, HELPA, AN, BN, CN, ITY, WWIND, WSQ, 
     &FILZ)
C (4,13)
C
C     CALL CPUCLK(TM13,1,BIAS)
C     CINVW=CINVW+TM13-TM12
C
C $$$$$$$$$$$$$$$  E N D    O F    W = WZ   $$$$$$$$$$$$$$$$$$$$$$$$$$$$
C
C
C     TIME1 IS THE REAL TIME IN SECONDS
C
      TIME1 = TIME1+DELTAT
C (4,14)
      IF (TIME1.GT.86400) THEN
C (4,15)
         TIME1 = 0.0
      ELSE
C (4,16)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (4,17)
C
C ----   PRINT THE RESULTS.  ------
C
      CALL PRINTR(NX, NY, NZ, NT, XSTART, YSTART, ZSTART, TSTART, DX
     &, DY, DZ, DELTAX, DELTAY, DELTAZ, DELTAT, TIME1, TOUT, 1, C, UM
     &, UX, VM, VY, TM, POTT, WZ, PRES, DKM, DKZM, DKZH, DEP, NPRINT
     &, NGRAPH, NPSTEP, NGSTEP, NSTEP, IBT, NWINDX, ISH, NSMT, NFILT
     &, IB, IK, ITY, NCOUNT, Z0, ELEV, HMIX, TAVR, OBUK, USTR, TSTR, 
     &VDEP, PHI, CMASS, UWIND, USQ, VWIND, VSQ, WWIND, WSQ, HEAT, 
     &EXNER)
C (4,18)
C
C ----   FIND THE PERTURBATION EDDY DIFFUSSIVITY FROM BLM SOLVER -------
C
C     CALL CPUCLK(TM14,1,BIAS)
C     CINPR=CINPR+TM14-TM13
C
      CALL DKZMH(HELP, HELPA, TM, UM, VM, POTT, UX, VY, WZ, ZET, DKZM
     &, DKZH, DZ, Z0, ELEV, NX, NX1, NY, NY1, NZ, HMIX, STEPH, TAVR, 
     &OBUK, USTR, TSTR, VDEP, NSMT, F, NFILT, ISTEP, DELTAT, SAVEX, 
     &SAVEY, FX, FY, FXC, FYC, DCDX, DCDY, TSL, DL)
C (4,19)
C
C ----   PERFORM IMPLICIT HORIZONTAL FILTERING FOR EVERY IK TIME STEPS
C
C     CALL CPUCLK(TM15,1,BIAS)
C     CINBL=CINBL+TM15-TM14
C
      IF (MOD(NSTEP, IK).EQ.0) THEN
C (4,20)
C        BEGIN BLOCK
C (4,21)
      I_PIPS_SMIM_HELPA = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_SMIM_AN = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_SMIM_BN = I_PIPS_RUN_DCDX-(LV4-1)
      I_PIPS_SMIM_CN = I_PIPS_RUN_DCDX-(LV5-1)
         CALL SMIM(C, NX, NY, NZ, DL, DCDX(LV1), DCDX(LV2), DCDX(LV3)
     &   , DCDX(LV4), DCDX(LV5))
C (4,22)
      I_PIPS_SMIM_HELPA = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_SMIM_AN = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_SMIM_BN = I_PIPS_RUN_DCDX-(LV4-1)
      I_PIPS_SMIM_CN = I_PIPS_RUN_DCDX-(LV5-1)
         CALL SMIM(POTT, NX, NY, NZ, DL, DCDX(LV1), DCDX(LV2), DCDX(
     &   LV3), DCDX(LV4), DCDX(LV5))
C (4,23)
      I_PIPS_SMIM_HELPA = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_SMIM_AN = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_SMIM_BN = I_PIPS_RUN_DCDX-(LV4-1)
      I_PIPS_SMIM_CN = I_PIPS_RUN_DCDX-(LV5-1)
         CALL SMIM(UX, NX, NY, NZ, DL, DCDX(LV1), DCDX(LV2), DCDX(LV3
     &   ), DCDX(LV4), DCDX(LV5))
C (4,24)
      I_PIPS_SMIM_HELPA = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_SMIM_AN = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_SMIM_BN = I_PIPS_RUN_DCDX-(LV4-1)
      I_PIPS_SMIM_CN = I_PIPS_RUN_DCDX-(LV5-1)
         CALL SMIM(WZ, NX, NY, NZ, DL, DCDX(LV1), DCDX(LV2), DCDX(LV3
     &   ), DCDX(LV4), DCDX(LV5))
C (4,25)
         IF (NY.GT.1.OR.IYHOM.NE.0) THEN
C (4,26)
      I_PIPS_SMIM_HELPA = I_PIPS_RUN_DCDX-(LV2-1)
      I_PIPS_SMIM_AN = I_PIPS_RUN_DCDX-(LV3-1)
      I_PIPS_SMIM_BN = I_PIPS_RUN_DCDX-(LV4-1)
      I_PIPS_SMIM_CN = I_PIPS_RUN_DCDX-(LV5-1)
            CALL SMIM(VY, NX, NY, NZ, DL, DCDX(LV1), DCDX(LV2), DCDX(
     &      LV3), DCDX(LV4), DCDX(LV5))
         ELSE
C (4,27)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C        END BLOCK
      ELSE
C (4,28)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (4,29)
C
C     CALL CPUCLK(TM16,1,BIAS)
C     CINFL=CINFL+TM16-TM15
C
C     RECALCULATE THE MEAN POTENTIAL TEMPERATURE, GEOSTROPHIC
C     WINDS AND SYNOPTIC WINDS IF NECESSARY. THIS IDENTIFIES
C     SYNOPTIC CONDITIONS VARIABLE WITH TIME
C
      IF (MOD(NSTEP, IGEO).EQ.0) THEN
C (4,30)
C        BEGIN BLOCK
C (4,31)
         CALL SYNSET(TIME1)
C (4,32)
         CALL UVSET(NX, NY, NZ, HVAR, ZET, NP, DZ, DKM, UM, VM, UG, 
     &   VG, TM, DCDX, ITY, ISH, NSMT, F)
C
C        CALL CPUCLK(TM17,1,BIAS)
C        CINMN=CINMN+TM17-TM16
C        END BLOCK
      ELSE
C (4,34)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (4,35)
C
C ----------------     CHECK FOR THE END OF THE TIME INTERVAL.  --------
C
      IF (MOD(NSTEP, ICPU).EQ.0) THEN
C (4,36)
         CALL STATS
      ELSE
C (4,37)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C     END BLOCK
C (5,1)
C      IF(TIME1.LT.TEND1) GO TO 10
      IF (NSTEP.LT.NT) GOTO 10
C (6,1)
      IF (NSTEP.EQ.NT) THEN
      ENDIF
C (7,1)

CX40006 CALL SBOUTX (6)
CY40006 CALL SBOUTY (6)
C
C   ====================================================================
C   ==      ************    END OF THE COMPUTATIONS.  ***********     ==
C   ====================================================================
C
CX20806 CALL DOOUTX( 806 )
CY20806 CALL DOOUTY( 806 )
CX40006 CALL SBOUTX (6)
CY40006 CALL SBOUTY (6)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C *   THIS ROUTINE DOES THE HORIZONTAL ADVECTION PART OF THE SOLUTION  *
C *   FOR THE CONCENTRATION OF POLLUTANTS C USING TIME SPLITTING       *
C **********************************************************************
C
      SUBROUTINE ADVC(NX,NY,NZTOP,ISTEP,LOOP,DELTAT,C,STEPC,UX,UM,VY,VM,
     x 
     *Q,DCDX,DCDY)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DOUBLE PRECISION C(1200000),STEPC(I_PIPS_RUN_STEPC),UX(I_PIPS_RUN_
     x UX),UM(I_PIPS_RUN_UM),VY(I_PIPS_RUN_VY),VM(I_PIPS_RUN_VM),
     * Q(I_PIPS_RUN_Q),DCDX(I_PIPS_RUN_DCDX),DCDY(I_PIPS_RUN_DCDY)
C (0,1)
      INTEGER*8 I_PIPS_RUN_STEPC
      COMMON /PIPS_RUN_STEPC/ I_PIPS_RUN_STEPC
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_Q
      COMMON /PIPS_RUN_Q/ I_PIPS_RUN_Q
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_LEAPFR_F2
      COMMON /PIPS_LEAPFR_F2/ I_PIPS_LEAPFR_F2
      INTEGER*8 I_PIPS_LEAPFR_F0
      COMMON /PIPS_LEAPFR_F0/ I_PIPS_LEAPFR_F0
C     BEGIN BLOCK
C (0,2)
CX30007 CALL SBINX (7)
CY30007 CALL SBINY (7)
      L = 0
C (0,3)
      IF (NY.GT.1) THEN
C (0,4)
C        BEGIN BLOCK
C (0,5)
CX10521 CALL DOINX( 521 )
CY10521 CALL DOINY( 521 )
!     INITIALLY: DO 30
         DO K = 1, NZTOP
C (0,6)
C           BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 20
            DO J = 1, NY
C (0,8)
C              BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 10
               DO I = 1, NX
C (0,10)
C                 BEGIN BLOCK
C (0,11)
                  L = L+1
C (0,12)
                  DCDX(L) = -(UX(L)+UM(K))*DCDX(L)-(VY(L)+VM(K))*DCDY
     &            (L)+Q(L)
C (0,13)
10                CONTINUE
C                 END BLOCK
               ENDDO
C (0,14)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,15)
30          CONTINUE
C           END BLOCK
         ENDDO
CX20522 CALL DOOUTX( 522 )
CY20522 CALL DOOUTY( 522 )
C        END BLOCK
      ELSE
C (0,17)
C        BEGIN BLOCK
C (0,18)
CX10523 CALL DOINX( 523 )
CY10523 CALL DOINY( 523 )
!     INITIALLY: DO 50
         DO K = 1, NZTOP
C (0,19)
C           BEGIN BLOCK
C (0,20)
!     INITIALLY: DO 40
            DO I = 1, NX
C (0,21)
C              BEGIN BLOCK
C (0,22)
               L = L+1
C (0,23)
               DCDX(L) = -(UX(L)+UM(K))*DCDX(L)+Q(L)
C (0,24)
40             CONTINUE
C              END BLOCK
            ENDDO
C (0,25)
50          CONTINUE
C           END BLOCK
         ENDDO
CX20524 CALL DOOUTX( 524 )
CY20524 CALL DOOUTY( 524 )
C        END BLOCK
      ENDIF
C (0,27)
      I_PIPS_LEAPFR_F2 = 1200000
      I_PIPS_LEAPFR_F0 = I_PIPS_RUN_STEPC
C
C       PERFORM THE HORIZONTAL TIME-INTEGRATION PART FOR C(X,Y,Z)
C               BY USING THE LEAPFROG SCHEME
C
      CALL LEAPFR(ISTEP, LOOP, DELTAT, C, DCDX, STEPC)
C (0,28)
CX40008 CALL SBOUTX (8)
CY40008 CALL SBOUTY (8)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE SETS THE VECTORS TO PERFORM THE VERTICAL        *
C ***     INTEGRATION OF THE POLLUTANTS VIA IMPLICIT METHOD (PADE)     *
C ***     VDEP IS THE DRY DEPOSITION VELOCITY (INPUT),                 *
C **********************************************************************
C
      SUBROUTINE DCDTZ(NX,NY,NZ,DELTAZ,DELTAT,DZ,IB,IK,C,Q,WZ,HVAR,
     *VDEP,ZET,HELP,HELPA,DKM,DKZH,CONV,DKS,TIME1,AN,BN,CN,ITY,ISH,
     *NSMT,DEP,CMASS)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY,NZ),DKZH(NX,NY,NZ),WZ(NX,NY,NZ),Q(NX,NY,NZ)
      DIMENSION AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN),HE
     x LP(I_PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),DKS(I_PIPS_DCDTZ_DKS)
     x ,HVAR(I_PIPS_RUN_HVAR),ZET(I_PIPS_RUN_ZET)
      DIMENSION CONV(I_PIPS_RUN_DCDX),DKM(I_PIPS_RUN_DKM),VDEP(NX,NY),DE
     x P(NX,NY)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DCDTZ_DKS
      COMMON /PIPS_DCDTZ_DKS/ I_PIPS_DCDTZ_DKS
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
C     BEGIN BLOCK
C (0,2)
CX30009 CALL SBINX (9)
CY30009 CALL SBINY (9)
C
      CMASS = 0.0
C (0,3)
CX10525 CALL DOINX( 525 )
CY10525 CALL DOINY( 525 )
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,4)
C        BEGIN BLOCK
C (0,5)
!     INITIALLY: DO 50
         DO I = 1, NX
C (0,6)
C           BEGIN BLOCK
C (0,7)
            VD = VDEP(I,J)
C (0,8)
!     INITIALLY: DO 10
            DO K = 1, NZ
C (0,9)
C              BEGIN BLOCK
C (0,10)
               HELP(K) = C(I,J,K)
C (0,11)
               DKS(K) = DKZH(I,J,K)
C (0,12)
               CONV(K) = WZ(I,J,K)
C (0,13)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,14)
C
C     ACCUMULATE THE AMOUNT OF POLLUTANTS DEPOSITED AT THE SURFACE
C
            FLUX = VD*HELP(1)
C (0,15)
            DEP(I,J) = DEP(I,J)+DELTAT*FLUX/DELTAZ
C (0,16)
            Q(I,J,1) = -FLUX/DELTAZ
C (0,17)
C
            IF (ISH.EQ.1) THEN
C (0,18)
               CALL CPADE(DKS, HVAR, HELP, HELPA, NZ, DELTAT, DELTAZ
     &         , DZ, CONV, AN, BN, CN, IK, ITY, VD)
            ELSE
C (0,19)
               CALL CCRANK(DKS, HVAR, HELP, HELPA, NZ, DELTAT, DELTAZ
     &         , DZ, CONV, AN, BN, CN, IK, ITY, VD)
            ENDIF
C (0,20)
            IF (NSMT.EQ.1) THEN
C (0,21)
      I_PIPS_SMTH_F = I_PIPS_RUN_HELP
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
               CALL SMTH(HELP, ZET, NZ)
            ELSE
C (0,22)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,23)
!     INITIALLY: DO 30
            DO K = 1, NZ
C (0,24)
C              BEGIN BLOCK
C (0,25)
               C(I,J,K) = HELP(K)
C (0,26)
               CMASS = CMASS+HELP(K)
C (0,27)
30             CONTINUE
C              END BLOCK
            ENDDO
C (0,28)
50          CONTINUE
C           END BLOCK
         ENDDO
C (0,29)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,30)
CX20526 CALL DOOUTX( 526 )
CY20526 CALL DOOUTY( 526 )
CX40010 CALL SBOUTX (10)
CY40010 CALL SBOUTY (10)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *   THIS ROUTINE DOES THE HORIZONTAL ADVECTION PART OF THE SOLUTION  *
C *   FOR THE POTENTIAL TEMPERATURE THETA   USING TIME SPLITTING       *
C **********************************************************************
C
      SUBROUTINE  ADVT(NX,NY,NZTOP,ISTEP,LOOP,DELTAT,POTT,STEPT,UX,UM,
     *VY,VM,DCDX,DCDY)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 POTT(I_PIPS_RUN_POTT),STEPT(I_PIPS_RUN_STEPT),UX(I_PIPS_RUN
     x _UX),UM(I_PIPS_RUN_UM),VY(I_PIPS_RUN_VY),VM(I_PIPS_RUN_VM),DCDX(I
     x _PIPS_RUN_DCDX),DCDY(I_PIPS_RUN_DCDY)
C (0,1)
      INTEGER*8 I_PIPS_RUN_POTT
      COMMON /PIPS_RUN_POTT/ I_PIPS_RUN_POTT
      INTEGER*8 I_PIPS_RUN_STEPT
      COMMON /PIPS_RUN_STEPT/ I_PIPS_RUN_STEPT
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_LEAPFR_F2
      COMMON /PIPS_LEAPFR_F2/ I_PIPS_LEAPFR_F2
      INTEGER*8 I_PIPS_LEAPFR_F0
      COMMON /PIPS_LEAPFR_F0/ I_PIPS_LEAPFR_F0
C     BEGIN BLOCK
C (0,2)
CX30011 CALL SBINX (11)
CY30011 CALL SBINY (11)
C
      L = 0
C (0,3)
      IF (NY.GT.1) THEN
C (0,4)
C        BEGIN BLOCK
C (0,5)
CX10527 CALL DOINX( 527 )
CY10527 CALL DOINY( 527 )
!     INITIALLY: DO 30
         DO K = 1, NZTOP
C (0,6)
C           BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 20
            DO J = 1, NY
C (0,8)
C              BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 10
               DO I = 1, NX
C (0,10)
C                 BEGIN BLOCK
C (0,11)
                  L = L+1
C (0,12)
                  DCDX(L) = -(UX(L)+UM(K))*DCDX(L)-(VY(L)+VM(K))*DCDY
     &            (L)
C (0,13)
10                CONTINUE
C                 END BLOCK
               ENDDO
C (0,14)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,15)
30          CONTINUE
C           END BLOCK
         ENDDO
CX20528 CALL DOOUTX( 528 )
CY20528 CALL DOOUTY( 528 )
C        END BLOCK
      ELSE
C (0,17)
C        BEGIN BLOCK
C (0,18)
CX10529 CALL DOINX( 529 )
CY10529 CALL DOINY( 529 )
!     INITIALLY: DO 50
         DO K = 1, NZTOP
C (0,19)
C           BEGIN BLOCK
C (0,20)
!     INITIALLY: DO 40
            DO I = 1, NX
C (0,21)
C              BEGIN BLOCK
C (0,22)
               L = L+1
C (0,23)
               DCDX(L) = -(UX(L)+UM(K))*DCDX(L)
C (0,24)
40             CONTINUE
C              END BLOCK
            ENDDO
C (0,25)
50          CONTINUE
C           END BLOCK
         ENDDO
CX20530 CALL DOOUTX( 530 )
CY20530 CALL DOOUTY( 530 )
C        END BLOCK
      ENDIF
C (0,27)
      I_PIPS_LEAPFR_F2 = I_PIPS_RUN_POTT
      I_PIPS_LEAPFR_F0 = I_PIPS_RUN_STEPT
C
C
C                BY USING THE LEAPFROG SCHEME
C
      CALL LEAPFR(ISTEP, LOOP, DELTAT, POTT, DCDX, STEPT)
C (0,28)
CX40012 CALL SBOUTX (12)
CY40012 CALL SBOUTY (12)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE SETS THE VECTORS TO PERFORM THE VERTICAL        *
C ***     INTEGRATION OF THE POTENTIAL TEMPERATURE VIA IMPLICIT METHOD *
C **********************************************************************
C
      SUBROUTINE DTDTZ(NX,NY,NZ,DELTAZ,DELTAT,DZ,IB,IK,TM,POTT,WZ,HVAR,
     *ZET,UNT,HELPA,DKM,DKZH,CONV,DKS,DTM,FORC,TIME1,
     *AN,BN,CN,ITY,ISH,NSMT,ELEV,DAYL,HEAT,ISTEP)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION POTT(NX,NY,NZ),DKZH(NX,NY,NZ),WZ(NX,NY,NZ),ELEV(NX,NY)
      DIMENSION CONV(I_PIPS_RUN_DCDX)
      DIMENSION AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN),UN
     x T(I_PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),DKS(I_PIPS_DTDTZ_DKS),
     x HVAR(I_PIPS_RUN_HVAR),ZET(I_PIPS_RUN_ZET)
      DIMENSION DTM(I_PIPS_DTDTZ_DTM),FORC(I_PIPS_DTDTZ_FORC),DKM(I_PIPS
     x _RUN_DKM),TM(I_PIPS_RUN_TM)
C
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
      PARAMETER (PI = 3.141592653589793)
C (0,1)
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DTDTZ_DKS
      COMMON /PIPS_DTDTZ_DKS/ I_PIPS_DTDTZ_DKS
      INTEGER*8 I_PIPS_DTDTZ_DTM
      COMMON /PIPS_DTDTZ_DTM/ I_PIPS_DTDTZ_DTM
      INTEGER*8 I_PIPS_DTDTZ_FORC
      COMMON /PIPS_DTDTZ_FORC/ I_PIPS_DTDTZ_FORC
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
      INTEGER*8 I_PIPS_SMTHF_F
      COMMON /PIPS_SMTHF_F/ I_PIPS_SMTHF_F
C     BEGIN BLOCK
C (0,2)
CX30013 CALL SBINX (13)
CY30013 CALL SBINY (13)
      HEAT = 0.0
C (0,3)
      ARG = -((TIME1-BUMP)/DAYL)**2
C (0,4)
      TFORC = EXP(ARG)-FLOAT(IB)/10.
C (0,5)
C
C     UPPER BOUNDARY CONDITION FOR THETA
C
      UNT(NZ) = 0.0
C (0,6)
      NZTOP = NZ-1
C (0,7)
CX10531 CALL DOINX( 531 )
CY10531 CALL DOINY( 531 )
C
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,8)
C        BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,10)
C           BEGIN BLOCK
C (0,11)
C
C        SET THE LOWER BOUNDARY CONDITION FOR THE POTENTIAL TEMPERATURE
C        TIME VARIABLE TIME1,
C
            IF (ELEV(I,J).LT.0) THEN
C (0,12)
               AMPLT = 0.0
            ELSE
C (0,13)
               AMPLT = HAMP
            ENDIF
C (0,14)
            IF (ELEV(I,J).EQ.0.0) THEN
C (0,15)
               AMPLT = HAMP/2.
            ELSE
C (0,16)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,17)
C
C       LOWER BOUNDARY CONDITION FOR THETA ACCORDING TO LAND TYPE
C
            UNT(1) = AMPLT*TFORC
C (0,18)
C
C       PREPARE THE VECTORS FOR THE VERTICAL INTEGRATION
C       UNT : POTENTIAL TEMPERATURE TO SOLVE FOR
C       DKS : TOTAL EDDY DIFFUSIVITY COEFICIENT
C       CONV: CONVECTIVE VERTICAL VELOCITY
C       DTM : THE SYNOPTIC POTENTIAL TEMPERATURE GRADIENT
C       SYNFOR : THE TOTAL FORCING VECTOR DUE TO SYNOPTIC CONDITIONS
C
C       ALL THE TERMS THAT FOLLOW REPRESENT THE BOUNDARY LAYER FORCING
C       DUE TO THE SYNOPTIC CONDITIONS
C
            CALL DCTDXF(NZ, 1, TM, DTM, DH)
C (0,19)
C
C       SYNFOR: IS FORCING DUE TO SYNOPTIC EDDY FRICTION
C       WDTMDH: IS FORCING DUE TO THE CONVECTION OF THE MEAN
C               POTENTIAL TEMPERATURE  (WDT/DZ)
C
!     INITIALLY: DO 10
            DO K = 2, NZTOP
C (0,20)
C              BEGIN BLOCK
C (0,21)
               UNT(K) = POTT(I,J,K)
C (0,22)
               DKS(K) = DKZH(I,J,K)
C (0,23)
               CONV(K) = WZ(I,J,K)
C (0,24)
               FKP1 = (DKZH(I,J,K+1)-DKM(K+1))*DTM(K+1)*HVAR(K+1)
C (0,25)
               FKM1 = (DKZH(I,J,K-1)-DKM(K-1))*DTM(K-1)*HVAR(K-1)
C (0,26)
               WDTMDH = CONV(K)*DTM(K)*HVAR(K)
C (0,27)
               SYNFOR = HVAR(K)*(FKP1-FKM1)/(2.*DH)
C (0,28)
               FORC(K) = -WDTMDH+SYNFOR
C (0,29)
C
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,30)
      I_PIPS_SMTHF_F = I_PIPS_DTDTZ_FORC
            CALL SMTHF(FORC, ZET, NZ)
C (0,31)
            IF (ISH.EQ.1) THEN
C (0,32)
               CALL TPADE(DKS, HVAR, UNT, HELPA, NZ, DELTAT, DELTAZ, 
     &         DZ, CONV, FORC, AN, BN, CN, IK, ITY)
            ELSE
C (0,33)
               CALL TCRANK(DKS, HVAR, UNT, HELPA, NZ, DELTAT, DELTAZ
     &         , DZ, CONV, FORC, AN, BN, CN, IK, ITY)
            ENDIF
C (0,34)
            IF (NSMT.EQ.1) THEN
C (0,35)
      I_PIPS_SMTH_F = I_PIPS_RUN_HELP
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
               CALL SMTH(UNT, ZET, NZ)
            ELSE
C (0,36)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,37)
!     INITIALLY: DO 20
            DO K = 1, NZTOP
C (0,38)
C              BEGIN BLOCK
C (0,39)
               POTT(I,J,K) = UNT(K)
C (0,40)
               HEAT = HEAT+UNT(K)
C (0,41)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,42)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,43)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,44)
CX20532 CALL DOOUTX( 532 )
CY20532 CALL DOOUTY( 532 )
CX40014 CALL SBOUTX (14)
CY40014 CALL SBOUTY (14)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *      HYDROSTATIC PRESSURE CALCULATION THROUGH DERIVATIVE METHOD    *
C *      THUS FINDING THE PRESSURE BY MARCHING DOWNWARDS FROM THE      *
C *      HYDROSTATIC RELATION                                          *
C **********************************************************************
C
      SUBROUTINE HYD(NX,NY,NZ,P,PS,TM,T,ZET,HVAR,NSMT,EXNER)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 P(NX,NY,NZ),PS(NX,NY,NZ),T(NX,NY,NZ),TM(I_PIPS_RUN_TM),ZET(
     x I_PIPS_RUN_ZET),HVAR(I_PIPS_RUN_HVAR)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP
      PARAMETER (G = 9.81)
C (0,1)
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
C     BEGIN BLOCK
C (0,2)
CX30015 CALL SBINX (15)
CY30015 CALL SBINY (15)
C
      EXNER = 0.0
C (0,3)
CX10533 CALL DOINX( 533 )
CY10533 CALL DOINY( 533 )
!     INITIALLY: DO 30
      DO K = 2, NZ
C (0,4)
C        BEGIN BLOCK
C (0,5)
!     INITIALLY: DO 20
         DO I = 1, NX
C (0,6)
C           BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 10
            DO J = 1, NY
C (0,8)
C              BEGIN BLOCK
C (0,9)
               KINT = NZ-K+1
C (0,10)
               D0 = HVAR(KINT)*TM(KINT)*TM(KINT)
C (0,11)
               D1 = HVAR(KINT+1)*TM(KINT+1)*TM(KINT+1)
C (0,12)
               RAD = 0.5*(T(I,J,KINT)/D0+T(I,J,KINT+1)/D1)
C (0,13)
C
C              STORE THE PREVIOUS TIME STEPS TO USE THE PRESSURE
C              AVERAGING TECHNIQUE
C
               PS(I,J,KINT) = P(I,J,KINT)
C (0,14)
               P(I,J,KINT) = P(I,J,KINT+1)-DH*G*RAD
C (0,15)
C
C      PRESSURE FOR THE TOP IS 0 AND FOR THE LEVEL NZ+1-K,(K=2...NZ), PI
C
               EXNER = EXNER+P(I,J,KINT)
C (0,16)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,17)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,18)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,19)
CX20534 CALL DOOUTX( 534 )
CY20534 CALL DOOUTY( 534 )
CX40016 CALL SBOUTX (16)
CY40016 CALL SBOUTY (16)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *   THIS ROUTINE DOES THE HORIZONTAL ADVECTION PART OF THE SOLUTION  *
C *   FOR THE U MOMENTUM COMPONENT UX USING TIME SPLITTING             *
C **********************************************************************
C
      SUBROUTINE ADVU(NX,NY,NZTOP,ISTEP,LOOP,DELTAT,STEPT,UX,STEPU,
     *UM,VY,VM,WZ,VG,TM,F,FHAT,DCDX,DCDY)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 STEPT(I_PIPS_RUN_STEPT),UX(I_PIPS_RUN_UX),UM(I_PIPS_RUN_UM)
     x ,VY(I_PIPS_RUN_VY),VM(I_PIPS_RUN_VM),WZ(I_PIPS_RUN_WZ),DCDX(I_PIP
     x S_RUN_DCDX),DCDY(I_PIPS_RUN_DCDY)
      REAL*8 TM(I_PIPS_RUN_TM),VG(I_PIPS_RUN_VG),STEPU(I_PIPS_RUN_STEPU)
     x 
C (0,1)
      INTEGER*8 I_PIPS_RUN_STEPT
      COMMON /PIPS_RUN_STEPT/ I_PIPS_RUN_STEPT
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_STEPU
      COMMON /PIPS_RUN_STEPU/ I_PIPS_RUN_STEPU
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_WZ
      COMMON /PIPS_RUN_WZ/ I_PIPS_RUN_WZ
      INTEGER*8 I_PIPS_RUN_VG
      COMMON /PIPS_RUN_VG/ I_PIPS_RUN_VG
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_LEAPFR_F2
      COMMON /PIPS_LEAPFR_F2/ I_PIPS_LEAPFR_F2
      INTEGER*8 I_PIPS_LEAPFR_F0
      COMMON /PIPS_LEAPFR_F0/ I_PIPS_LEAPFR_F0
C     BEGIN BLOCK
C (0,2)
CX30017 CALL SBINX (17)
CY30017 CALL SBINY (17)
      L = 0
C (0,3)
      IF (NY.GT.1) THEN
C (0,4)
C        BEGIN BLOCK
C (0,5)
CX10535 CALL DOINX( 535 )
CY10535 CALL DOINY( 535 )
!     INITIALLY: DO 30
         DO K = 1, NZTOP
C (0,6)
C           BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 20
            DO J = 1, NY
C (0,8)
C              BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 10
               DO I = 1, NX
C (0,10)
C                 BEGIN BLOCK
C (0,11)
                  L = L+1
C (0,12)
                  DCDX(L) = -(UX(L)+UM(K))*DCDX(L)-(VY(L)+VM(K))*DCDY
     &            (L)+F*(VY(L)-VG(K)*STEPT(L)/TM(K))-FHAT*WZ(L)
C (0,13)
10                CONTINUE
C                 END BLOCK
               ENDDO
C (0,14)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,15)
30          CONTINUE
C           END BLOCK
         ENDDO
CX20536 CALL DOOUTX( 536 )
CY20536 CALL DOOUTY( 536 )
C        END BLOCK
      ELSE
C (0,17)
C        BEGIN BLOCK
C (0,18)
CX10537 CALL DOINX( 537 )
CY10537 CALL DOINY( 537 )
!     INITIALLY: DO 50
         DO K = 1, NZTOP
C (0,19)
C           BEGIN BLOCK
C (0,20)
!     INITIALLY: DO 40
            DO I = 1, NX
C (0,21)
C              BEGIN BLOCK
C (0,22)
               L = L+1
C (0,23)
               DCDX(L) = -(UX(L)+UM(K))*DCDX(L)+F*(VY(L)-VG(K)*STEPT(
     &         L)/TM(K))-FHAT*WZ(L)
C (0,24)
40             CONTINUE
C              END BLOCK
            ENDDO
C (0,25)
50          CONTINUE
C           END BLOCK
         ENDDO
CX20538 CALL DOOUTX( 538 )
CY20538 CALL DOOUTY( 538 )
C        END BLOCK
      ENDIF
C (0,27)
      I_PIPS_LEAPFR_F2 = I_PIPS_RUN_UX
      I_PIPS_LEAPFR_F0 = I_PIPS_RUN_STEPU
C
C       PERFORM THE HORIZONTAL TIME-INTEGRATION PART FOR U(X,Y,Z)
C                   BY USING THE LEAPFROG SCHEME
C
      CALL LEAPFR(ISTEP, LOOP, DELTAT, UX, DCDX, STEPU)
C (0,28)
CX40018 CALL SBOUTX (18)
CY40018 CALL SBOUTY (18)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE SETS THE VECTORS TO PERFORM THE VERTICAL        *
C ***     INTEGRATION OF THE U-WIND COMPONENT VIA IMPLICIT METHOD      *
C **********************************************************************
C
      SUBROUTINE DUDTZ(NX,NY,NZ,DELTAZ,DELTAT,DZ,IB,IK,UM,UX,WZ,HVAR,
     *ZET,UNU,HELPA,DKM,DKZM,CONV,DKS,DUM,FORC,DPDX,TIME1,AN,BN,CN,
     *ITY,ISH,NSMT,TM,UWIND,USQ,ISTEP)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKZM(NX,NY,NZ),DPDX(NX,NY,NZ)
      DIMENSION UX(NX,NY,NZ),WZ(NX,NY,NZ)
      DIMENSION AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN),UN
     x U(I_PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),DKS(I_PIPS_DUDTZ_DKS),
     x HVAR(I_PIPS_RUN_HVAR)
      DIMENSION DKM(I_PIPS_RUN_DKM),UM(I_PIPS_RUN_UM),TM(I_PIPS_RUN_TM),
     x ZET(I_PIPS_RUN_ZET),CONV(I_PIPS_RUN_DCDY),DUM(I_PIPS_DUDTZ_DUM),F
     x ORC(I_PIPS_DUDTZ_FORC)
C
      COMMON/STRCH/ALP,BET,DH,ZH,UGH,VGH,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_DUDTZ_DKS
      COMMON /PIPS_DUDTZ_DKS/ I_PIPS_DUDTZ_DKS
      INTEGER*8 I_PIPS_DUDTZ_DUM
      COMMON /PIPS_DUDTZ_DUM/ I_PIPS_DUDTZ_DUM
      INTEGER*8 I_PIPS_DUDTZ_FORC
      COMMON /PIPS_DUDTZ_FORC/ I_PIPS_DUDTZ_FORC
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_UCRANK_DKS
      COMMON /PIPS_UCRANK_DKS/ I_PIPS_UCRANK_DKS
      INTEGER*8 I_PIPS_UCRANK_W
      COMMON /PIPS_UCRANK_W/ I_PIPS_UCRANK_W
      INTEGER*8 I_PIPS_UCRANK_FORCN
      COMMON /PIPS_UCRANK_FORCN/ I_PIPS_UCRANK_FORCN
      INTEGER*8 I_PIPS_UPADE_DKS
      COMMON /PIPS_UPADE_DKS/ I_PIPS_UPADE_DKS
      INTEGER*8 I_PIPS_UPADE_W
      COMMON /PIPS_UPADE_W/ I_PIPS_UPADE_W
      INTEGER*8 I_PIPS_UPADE_FORCN
      COMMON /PIPS_UPADE_FORCN/ I_PIPS_UPADE_FORCN
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
      INTEGER*8 I_PIPS_SMTHF_F
      COMMON /PIPS_SMTHF_F/ I_PIPS_SMTHF_F
C     BEGIN BLOCK
C (0,2)
CX30019 CALL SBINX (19)
CY30019 CALL SBINY (19)
C
      UWIND = 0.0
C (0,3)
      USQ = 0.0
C (0,4)
C
C     UPPER AND LOUER BOUNDARY CONDITIONS FOR U
C
      UNU(1) = 0.0
C (0,5)
      UNU(NZ) = 0.0
C (0,6)
      NZTOP = NZ-1
C (0,7)
CX10539 CALL DOINX( 539 )
CY10539 CALL DOINY( 539 )
C
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,8)
C        BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,10)
C           BEGIN BLOCK
C (0,11)
C
C       PREPARE THE VECTORS FOR THE VERTICAL INTEGRATION
C       UNU : U-WIND COMPONENT TO SOLVE FOR
C       DKS : TOTAL EDDY DIFFUSIVITY COEFICIENT
C       CONV: CONVECTIVE VERTICAL VELOCITY
C       DUM : THE SYNOPTIC U-WIND GRADIENT
C       SYNFOR : THE FORCING DUE TO SYNOPTIC CONDITIONS
C
C       ALL THE TERMS THAT FOLLOW REPRESENT THE BOUNDARY LAYER FORCING
C       DUE TO THE SYNOPTIC CONDITIONS
C       WDUMDH : THE FORCING DUE TO THE VERTICAL ADVECTION OF THE
C                SYNOPTIC WIND COMPONENT (WDUDZ)
C       PGRAD  : PRESSURE GRADIENT WHICH DRIVES THE HORIZONTAL U-WIND
C
            CALL DCTDXF(NZ, 1, UM, DUM, DH)
C (0,12)
C
C        CALCULATE THE RIGHT HAND SIDE OF THE REMAINING EQUATION
C        BY ADDING THE MESOSCALE PRESSURE GRADIENTS AS WELL AS
C        THE CORIOLIS TERMS WICH PLAY THE ROLE OF ADDITIONAL FORCING.
C
C
!     INITIALLY: DO 10
            DO K = 2, NZTOP
C (0,13)
C              BEGIN BLOCK
C (0,14)
               UNU(K) = UX(I,J,K)
C (0,15)
               DKS(K) = DKZM(I,J,K)
C (0,16)
               CONV(K) = WZ(I,J,K)
C (0,17)
               FKP1 = (DKZM(I,J,K+1)-DKM(K+1))*DUM(K+1)*HVAR(K+1)
C (0,18)
               FKM1 = (DKZM(I,J,K-1)-DKM(K-1))*DUM(K-1)*HVAR(K-1)
C (0,19)
               WDUMDH = CONV(K)*DUM(K)*HVAR(K)
C (0,20)
               PGRAD = -TM(K)*DPDX(I,J,K)
C (0,21)
               SYNFOR = HVAR(K)*(FKP1-FKM1)/(2.*DH)
C (0,22)
C
               FORC(K) = -WDUMDH+PGRAD+SYNFOR
C (0,23)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,24)
      I_PIPS_SMTHF_F = I_PIPS_DUDTZ_FORC
            CALL SMTHF(FORC, ZET, NZ)
C (0,25)
C            GOTO 50
            IF (ISH.EQ.1) THEN
C (0,26)
      I_PIPS_UPADE_DKS = I_PIPS_DUDTZ_DKS
      I_PIPS_UPADE_W = I_PIPS_RUN_DCDY
      I_PIPS_UPADE_FORCN = I_PIPS_DUDTZ_FORC
               CALL UPADE(DKS, HVAR, UNU, HELPA, NZ, DELTAT, DELTAZ, 
     &         DZ, CONV, FORC, AN, BN, CN, IK, ITY)
            ELSE
C (0,27)
      I_PIPS_UCRANK_DKS = I_PIPS_DUDTZ_DKS
      I_PIPS_UCRANK_W = I_PIPS_RUN_DCDY
      I_PIPS_UCRANK_FORCN = I_PIPS_DUDTZ_FORC
               CALL UCRANK(DKS, HVAR, UNU, HELPA, NZ, DELTAT, DELTAZ
     &         , DZ, CONV, FORC, AN, BN, CN, IK, ITY)
            ENDIF
C (0,28)
            IF (NSMT.EQ.1) THEN
C (0,29)
      I_PIPS_SMTH_F = I_PIPS_RUN_HELP
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
               CALL SMTH(UNU, ZET, NZ)
            ELSE
C (0,30)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,31)
!     INITIALLY: DO 20
            DO K = 2, NZTOP
C (0,32)
C              BEGIN BLOCK
C (0,33)
               UX(I,J,K) = UNU(K)
C (0,34)
               UWIND = UWIND+UNU(K)
C (0,35)
               USQ = USQ+UNU(K)**2
C (0,36)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,37)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,38)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,39)
CX20540 CALL DOOUTX( 540 )
CY20540 CALL DOOUTY( 540 )
CX40020 CALL SBOUTX (20)
CY40020 CALL SBOUTY (20)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *   THIS ROUTINE DOES THE HORIZONTAL ADVECTION PART OF THE SOLUTION  *
C *   FOR THE Y MOMENTUM COMPONENT VY USING TIME SPLITTING             *
C **********************************************************************
C
      SUBROUTINE ADVV(NX,NY,NZTOP,ISTEP,LOOP,DELTAT,STEPT,STEPU,UM,VY,
     *STEPV,VM,UG,TM,F,DCDX,DCDY)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 STEPT(I_PIPS_RUN_STEPT),STEPU(I_PIPS_RUN_STEPU),UM(I_PIPS_R
     x UN_UM),VY(I_PIPS_RUN_VY),VM(I_PIPS_RUN_VM),DCDX(I_PIPS_RUN_DCDX),
     x DCDY(I_PIPS_RUN_DCDY),TM(I_PIPS_RUN_TM)
      REAL*8 UG(I_PIPS_RUN_UG),STEPV(I_PIPS_RUN_STEPV)
C (0,1)
      INTEGER*8 I_PIPS_RUN_STEPT
      COMMON /PIPS_RUN_STEPT/ I_PIPS_RUN_STEPT
      INTEGER*8 I_PIPS_RUN_STEPU
      COMMON /PIPS_RUN_STEPU/ I_PIPS_RUN_STEPU
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_STEPV
      COMMON /PIPS_RUN_STEPV/ I_PIPS_RUN_STEPV
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_UG
      COMMON /PIPS_RUN_UG/ I_PIPS_RUN_UG
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_LEAPFR_F2
      COMMON /PIPS_LEAPFR_F2/ I_PIPS_LEAPFR_F2
      INTEGER*8 I_PIPS_LEAPFR_F0
      COMMON /PIPS_LEAPFR_F0/ I_PIPS_LEAPFR_F0
C     BEGIN BLOCK
C (0,2)
CX30021 CALL SBINX (21)
CY30021 CALL SBINY (21)
      L = 0
C (0,3)
      IF (NY.GT.1) THEN
C (0,4)
C        BEGIN BLOCK
C (0,5)
CX10541 CALL DOINX( 541 )
CY10541 CALL DOINY( 541 )
!     INITIALLY: DO 30
         DO K = 1, NZTOP
C (0,6)
C           BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 20
            DO J = 1, NY
C (0,8)
C              BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 10
               DO I = 1, NX
C (0,10)
C                 BEGIN BLOCK
C (0,11)
                  L = L+1
C (0,12)
                  DCDX(L) = -(STEPU(L)+UM(K))*DCDX(L)-(VY(L)+VM(K))*
     &            DCDY(L)-F*(STEPU(L)-UG(K)*STEPT(L)/TM(K))
C (0,13)
10                CONTINUE
C                 END BLOCK
               ENDDO
C (0,14)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,15)
30          CONTINUE
C           END BLOCK
         ENDDO
CX20542 CALL DOOUTX( 542 )
CY20542 CALL DOOUTY( 542 )
C        END BLOCK
      ELSE
C (0,17)
C        BEGIN BLOCK
C (0,18)
CX10543 CALL DOINX( 543 )
CY10543 CALL DOINY( 543 )
!     INITIALLY: DO 50
         DO K = 1, NZTOP
C (0,19)
C           BEGIN BLOCK
C (0,20)
!     INITIALLY: DO 40
            DO I = 1, NX
C (0,21)
C              BEGIN BLOCK
C (0,22)
               L = L+1
C (0,23)
               DCDX(L) = -(STEPU(L)+UM(K))*DCDX(L)-F*(STEPU(L)-UG(K)*
     &         STEPT(L)/TM(K))
C (0,24)
40             CONTINUE
C              END BLOCK
            ENDDO
C (0,25)
50          CONTINUE
C           END BLOCK
         ENDDO
CX20544 CALL DOOUTX( 544 )
CY20544 CALL DOOUTY( 544 )
C        END BLOCK
      ENDIF
C (0,27)
      I_PIPS_LEAPFR_F2 = I_PIPS_RUN_VY
      I_PIPS_LEAPFR_F0 = I_PIPS_RUN_STEPV
C
C       PERFORM THE HORIZONTAL TIME-INTEGRATION PART FOR V(X,Y,Z)
C               BY USING THE LEAPFROG SCHEME
C
      CALL LEAPFR(ISTEP, LOOP, DELTAT, VY, DCDX, STEPV)
C (0,28)
CX40022 CALL SBOUTX (22)
CY40022 CALL SBOUTY (22)
C
      RETURN
C     END BLOCK
      END
C
C
C **********************************************************************
C ***     THIS ROUTINE SETS THE VECTORS TO PERFORM THE VERTICAL        *
C ***     INTEGRATION OF THE V-WIND COMPONENT VIA IMPLICIT METHOD      *
C **********************************************************************
C
      SUBROUTINE DVDTZ(NX,NY,NZ,DELTAZ,DELTAT,DZ,IB,IK,VM,VY,WZ,HVAR,
     *ZET,UNV,HELPA,DKM,DKZM,CONV,DKS,DVM,FORC,DPDY,
     *TIME1,AN,BN,CN,ITY,ISH,NSMT,TM,VWIND,VSQ,ISTEP)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 DKZM(NX,NY,NZ),DPDY(NX,NY,NZ),VY(NX,NY,NZ),WZ(NX,NY,NZ)
      REAL*8 AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN),UNV(I
     x _PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),DKS(I_PIPS_DVDTZ_DKS),HVA
     x R(I_PIPS_RUN_HVAR)
      REAL*8 CONV(I_PIPS_RUN_DCDX),DKM(I_PIPS_RUN_DKM),VM(I_PIPS_RUN_VM)
     x ,DVM(I_PIPS_DVDTZ_DVM),FORC(I_PIPS_DVDTZ_FORC),ZET(I_PIPS_RUN_ZET
     x ),TM(I_PIPS_RUN_TM)
C
      COMMON/STRCH/ALP,BET,DH,ZH,UGH,VGH,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DVDTZ_DKS
      COMMON /PIPS_DVDTZ_DKS/ I_PIPS_DVDTZ_DKS
      INTEGER*8 I_PIPS_DVDTZ_DVM
      COMMON /PIPS_DVDTZ_DVM/ I_PIPS_DVDTZ_DVM
      INTEGER*8 I_PIPS_DVDTZ_FORC
      COMMON /PIPS_DVDTZ_FORC/ I_PIPS_DVDTZ_FORC
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_UCRANK_DKS
      COMMON /PIPS_UCRANK_DKS/ I_PIPS_UCRANK_DKS
      INTEGER*8 I_PIPS_UCRANK_W
      COMMON /PIPS_UCRANK_W/ I_PIPS_UCRANK_W
      INTEGER*8 I_PIPS_UCRANK_FORCN
      COMMON /PIPS_UCRANK_FORCN/ I_PIPS_UCRANK_FORCN
      INTEGER*8 I_PIPS_UPADE_DKS
      COMMON /PIPS_UPADE_DKS/ I_PIPS_UPADE_DKS
      INTEGER*8 I_PIPS_UPADE_W
      COMMON /PIPS_UPADE_W/ I_PIPS_UPADE_W
      INTEGER*8 I_PIPS_UPADE_FORCN
      COMMON /PIPS_UPADE_FORCN/ I_PIPS_UPADE_FORCN
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
      INTEGER*8 I_PIPS_SMTHF_F
      COMMON /PIPS_SMTHF_F/ I_PIPS_SMTHF_F
C     BEGIN BLOCK
C (0,2)
CX30023 CALL SBINX (23)
CY30023 CALL SBINY (23)
C
      VWIND = 0.0
C (0,3)
      VSQ = 0.0
C (0,4)
C
C     UPPER AND LOUER BOUNDARY CONDITIONS FOR V
C
      UNV(1) = 0.0
C (0,5)
      UNV(NZ) = 0.0
C (0,6)
      NZTOP = NZ-1
C (0,7)
CX10545 CALL DOINX( 545 )
CY10545 CALL DOINY( 545 )
C
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,8)
C        BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,10)
C           BEGIN BLOCK
C (0,11)
C
C       PREPARE THE VECTORS FOR THE VERTICAL INTEGRATION
C       UNV : V-WIND COMPONENT TO SOLVE FOR
C       DKS : TOTAL EDDY DIFFUSIVITY COEFICIENT
C       CONV: CONVECTIVE VERTICAL VELOCITY
C       DVM : THE SYNOPTIC U-WIND GRADIENT
C       SYNFOR : THE FORCING DUE TO SYNOPTIC CONDITIONS
C
C       ALL THE TERMS THAT FOLLOW REPRESENT THE BOUNDARY LAYER FORCING
C       DUE TO THE SYNOPTIC CONDITIONS
C       WDVMDH : THE FORCING DUE TO THE VERTICAL ADVECTION OF THE
C                SYNOPTIC WIND COMPONENT (WDVDZ)
C       PGRAD  : PRESSURE GRADIENT WHICH DRIVES THE HORIZONTAL V-WIND
C
            CALL DCTDXF(NZ, 1, VM, DVM, DH)
C (0,12)
C
C        CALCULATE THE RIGHT HAND SIDE OF THE REMAINING EQUATION
C        BY ADDING THE MESOSCALE PRESSURE GRADIENTS AS WELL AS
C        THE CORIOLIS TERMS WICH PLAY THE ROLE OF ADDITIONAL FORCING.
C
C
!     INITIALLY: DO 10
            DO K = 2, NZTOP
C (0,13)
C              BEGIN BLOCK
C (0,14)
               UNV(K) = VY(I,J,K)
C (0,15)
               DKS(K) = DKZM(I,J,K)
C (0,16)
               CONV(K) = WZ(I,J,K)
C (0,17)
               FKP1 = (DKZM(I,J,K+1)-DKM(K+1))*DVM(K+1)*HVAR(K+1)
C (0,18)
               FKM1 = (DKZM(I,J,K-1)-DKM(K-1))*DVM(K-1)*HVAR(K-1)
C (0,19)
               WDVMDH = CONV(K)*DVM(K)*HVAR(K)
C (0,20)
               IF (NY.GT.1) THEN
C (0,21)
                  PGRAD = -TM(K)*DPDY(I,J,K)
               ELSE
C (0,22)
                  PGRAD = 0.0
               ENDIF
C (0,23)
               SYNFOR = HVAR(K)*(FKP1-FKM1)/(2.*DH)
C (0,24)
C
               FORC(K) = -WDVMDH+SYNFOR+PGRAD
C (0,25)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,26)
      I_PIPS_SMTHF_F = I_PIPS_DVDTZ_FORC
            CALL SMTHF(FORC, ZET, NZ)
C (0,27)
            IF (ISH.EQ.1) THEN
C (0,28)
      I_PIPS_UPADE_DKS = I_PIPS_DVDTZ_DKS
      I_PIPS_UPADE_W = I_PIPS_RUN_DCDX
      I_PIPS_UPADE_FORCN = I_PIPS_DVDTZ_FORC
               CALL UPADE(DKS, HVAR, UNV, HELPA, NZ, DELTAT, DELTAZ, 
     &         DZ, CONV, FORC, AN, BN, CN, IK, ITY)
            ELSE
C (0,29)
      I_PIPS_UCRANK_DKS = I_PIPS_DVDTZ_DKS
      I_PIPS_UCRANK_W = I_PIPS_RUN_DCDX
      I_PIPS_UCRANK_FORCN = I_PIPS_DVDTZ_FORC
               CALL UCRANK(DKS, HVAR, UNV, HELPA, NZ, DELTAT, DELTAZ
     &         , DZ, CONV, FORC, AN, BN, CN, IK, ITY)
            ENDIF
C (0,30)
            IF (NSMT.EQ.1) THEN
C (0,31)
      I_PIPS_SMTH_F = I_PIPS_RUN_HELP
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
               CALL SMTH(UNV, ZET, NZ)
            ELSE
C (0,32)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,33)
!     INITIALLY: DO 20
            DO K = 2, NZTOP
C (0,34)
C              BEGIN BLOCK
C (0,35)
               VY(I,J,K) = UNV(K)
C (0,36)
               VWIND = VWIND+UNV(K)
C (0,37)
               VSQ = VSQ+UNV(K)**2
C (0,38)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,39)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,40)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,41)
CX20546 CALL DOOUTX( 546 )
CY20546 CALL DOOUTY( 546 )
CX40024 CALL SBOUTX (24)
CY40024 CALL SBOUTY (24)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *    SOLVING FOR THE VERTICAL VELOCITY BY INTEGRATING VERTICALLY     *
C *    THE CONTINUITY EQUATION                                         *
C *    VERTICAL VELOCITY          W(X,Y,Z,T)=WZ(I,J,K)                 *
C *    U VELOCITY GRADIENT        DU/DX     =DUDX(I,J,K)               *
C *    V VELOCITY GRADIENT        DV/DY     =DVDY(I,J,K)               *
C *    X,Y TOPOGRAPHY FRADIENTS   DE/DX,DE/DY =EX(I,J),EY(I,J)         *
C **********************************************************************
C
      SUBROUTINE WCONT(NX,NY,NZ,UX,VY,WZ,DUDX,DVDY,ZET,EX,EY,
     *HVAR,NSMT,HELP,HELPA,AN,BN,CN,ITY,WWIND,WSQ,FILZ)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DUDX(NX,NY,NZ),DVDY(NX,NY,NZ),EX(NX,NY),EY(NX,NY)
      DIMENSION UX(NX,NY,NZ),VY(NX,NY,NZ),WZ(NX,NY,NZ),FILZ(I_PIPS_WCONT
     x _FILZ)
      DIMENSION HELP(I_PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_
     x RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN),ZET(I_PIPS_RUN_ZET),H
     x VAR(I_PIPS_RUN_HVAR)
C
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_WCONT_FILZ
      COMMON /PIPS_WCONT_FILZ/ I_PIPS_WCONT_FILZ
C     BEGIN BLOCK
C (0,2)
CX30025 CALL SBINX (25)
CY30025 CALL SBINY (25)
C
      WWIND = 0.0
C (0,3)
      WSQ = 0.0
C (0,4)
      HELP(1) = 0.0
C (0,5)
      HELP(NZ) = 0.0
C (0,6)
      NZTOP = NZ-1
C (0,7)
CX10547 CALL DOINX( 547 )
CY10547 CALL DOINY( 547 )
!     INITIALLY: DO 40
      DO I = 1, NX
C (0,8)
C        BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 30
         DO J = 1, NY
C (0,10)
C           BEGIN BLOCK
C (0,11)
!     INITIALLY: DO 10
            DO K = 2, NZTOP
C (0,12)
C              BEGIN BLOCK
C (0,13)
               IF (NY.EQ.1) THEN
C (0,14)
                  DV = 0.0
               ELSE
C (0,15)
                  DV = DVDY(I,J,K)
               ENDIF
C (0,16)
               HELP(K) = FILZ(K)*(DUDX(I,J,K)+DV)
C (0,17)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,18)
C
C      SOLVE IMPLICITLY FOR THE W FOR EACH VERTICAL LAYER
C
            CALL DWDZ(NZ, ZET, HVAR, HELP, HELPA, AN, BN, CN, ITY)
C (0,19)
!     INITIALLY: DO 20
            DO K = 2, NZTOP
C (0,20)
C              BEGIN BLOCK
C (0,21)
               TOPOW = UX(I,J,K)*EX(I,J)+VY(I,J,K)*EY(I,J)
C (0,22)
               WZ(I,J,K) = HELP(K)+TOPOW
C (0,23)
               WWIND = WWIND+WZ(I,J,K)
C (0,24)
               WSQ = WSQ+WZ(I,J,K)**2
C (0,25)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,26)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,27)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,28)
CX20548 CALL DOOUTX( 548 )
CY20548 CALL DOOUTY( 548 )
C
      CALL SMOOTH(WZ, NX, NY, NZ)
C (0,29)
CX40026 CALL SBOUTX (26)
CY40026 CALL SBOUTY (26)
C
      RETURN
C     END BLOCK
      END

C
C  *********************************************************************
C  *        CALCULATION OF THE DIFFUSION PART WITH EIGENVALUES         *
C  *********************************************************************
C
      SUBROUTINE HORDFC(NX,NX1,XSTART,DELTAX,PI,DELTAT,DX,FX,FXC,
     *FXX,SAVEX,NT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION FX(I_PIPS_HORDFC_FX), FXC(I_PIPS_HORDFC_FXC),FXX(I_PIPS_
     x HORDFC_FXX), SAVEX(I_PIPS_HORDFC_SAVEX)
C (0,1)
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_HORDFC_FX
      COMMON /PIPS_HORDFC_FX/ I_PIPS_HORDFC_FX
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_HORDFC_FXC
      COMMON /PIPS_HORDFC_FXC/ I_PIPS_HORDFC_FXC
      INTEGER*8 I_PIPS_RUN_FXX
      COMMON /PIPS_RUN_FXX/ I_PIPS_RUN_FXX
      INTEGER*8 I_PIPS_RUN_FYY
      COMMON /PIPS_RUN_FYY/ I_PIPS_RUN_FYY
      INTEGER*8 I_PIPS_HORDFC_FXX
      COMMON /PIPS_HORDFC_FXX/ I_PIPS_HORDFC_FXX
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_HORDFC_SAVEX
      COMMON /PIPS_HORDFC_SAVEX/ I_PIPS_HORDFC_SAVEX
      INTEGER*8 I_PIPS_RFFTI_WSAVE
      COMMON /PIPS_RFFTI_WSAVE/ I_PIPS_RFFTI_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30027 CALL SBINX (27)
CY30027 CALL SBINY (27)
      XEND = XSTART+NX*DELTAX
C (0,3)
      PIL = 2.0*PI/(NX*(XEND-XSTART))
C (0,4)
      XP = FLOAT(NX)
C (0,5)
      I_PIPS_RFFTI_WSAVE = I_PIPS_HORDFC_SAVEX
C
C     INITIALIZE  PLAIN FFT
C
      CALL RFFTI(NX, SAVEX)
C (0,6)
CX10549 CALL DOINX( 549 )
CY10549 CALL DOINY( 549 )
C
C     CALCULATE PLAIN COLLOCATION POINTS
C
!     INITIALLY: DO 10
      DO I = 1, NX1
C (0,7)
C        BEGIN BLOCK
C (0,8)
         FX(I) = PIL*(I-1)
C (0,9)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,10)
CX20550 CALL DOOUTX( 550 )
CY20550 CALL DOOUTY( 550 )
C
C     CALCULATE DIFFUSION EIGENVALUES
C
      PILDIF = 2.0*PI/(XEND-XSTART)
C (0,11)
      DH = DX*DELTAT
C (0,12)
      PILDIF = -PILDIF**2*DH
C (0,13)
CX10551 CALL DOINX( 551 )
CY10551 CALL DOINY( 551 )
!     INITIALLY: DO 20
      DO I = 2, NX1
C (0,14)
C        BEGIN BLOCK
C (0,15)
         FX(I) = FX(I)*NX
C (0,16)
         FXX(I) = EXP(NT*PILDIF*(I-1)**2)/XP
C (0,17)
         FXC(I) = EXP(PILDIF*(I-1)**2)/XP
C (0,18)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,19)
CX20552 CALL DOOUTX( 552 )
CY20552 CALL DOOUTY( 552 )
      FXX(1) = EXP(PILDIF*NX1**2)/XP
C (0,20)
      FXC(1) = EXP(NT*PILDIF*NX1**2)/XP
C (0,21)
CX40028 CALL SBOUTX (28)
CY40028 CALL SBOUTY (28)
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *    CALCULATE THE X-DERIVATIVE OF UNKNOWN FUNCTION VIA FFT'S      *
C   *    AND ADD HORIZONTAL DIFFUSION TERMS KXD2/DX2, (EIGENVALUES)    *
C   ********************************************************************
C
      SUBROUTINE DCTDX(NX,NY,NX1,NFILT,C,DCDX,HELP,HELPX,FX,FXX,SAVEX)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDX(NX,NY),
     *HELP(I_PIPS_RUN_HELP),HELPX(I_PIPS_RUN_HELPA),FX(I_PIPS_DCTDX_FX),
     x FXX(I_PIPS_DCTDX_FXX),SAVEX(I_PIPS_DCTDX_SAVEX)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_DCTDX_FX
      COMMON /PIPS_DCTDX_FX/ I_PIPS_DCTDX_FX
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_RUN_FXX
      COMMON /PIPS_RUN_FXX/ I_PIPS_RUN_FXX
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_DCTDX_FXX
      COMMON /PIPS_DCTDX_FXX/ I_PIPS_DCTDX_FXX
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_DCTDX_SAVEX
      COMMON /PIPS_DCTDX_SAVEX/ I_PIPS_DCTDX_SAVEX
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30029 CALL SBINX (29)
CY30029 CALL SBINY (29)
CX10553 CALL DOINX( 553 )
CY10553 CALL DOINY( 553 )
C
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(I) = C(I,J)
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
      I_PIPS_RFFTF_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_DCTDX_SAVEX
C
         CALL RFFTF(NX, HELP, SAVEX)
C (0,9)
C
         II1 = 0
C (0,10)
         II2 = 1
C (0,11)
         HELPX(1) = HELP(1)/NX
C (0,12)
         HELP(1) = 0.0
C (0,13)
!     INITIALLY: DO 20
         DO I = 2, NX1
C (0,14)
C           BEGIN BLOCK
C (0,15)
            II1 = II1+2
C (0,16)
            II2 = II2+2
C (0,17)
            T1 = HELP(II1)*FXX(I)
C (0,18)
            T2 = HELP(II2)*FXX(I)
C (0,19)
            HELPX(II2) = T2
C (0,20)
            HELPX(II1) = T1
C (0,21)
            HELP(II2) = T1*FX(I)
C (0,22)
            HELP(II1) = -T2*FX(I)
C (0,23)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,24)
         IF (NFILT.EQ.0) THEN
C (0,25)
            HELPX(NX) = HELP(NX)*FXX(1)
         ELSE
C (0,26)
            HELPX(NX) = 0.0
         ENDIF
C (0,27)
         HELP(NX) = 0.0
C (0,28)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELPA
      I_PIPS_RFFTB_WSAVE = I_PIPS_DCTDX_SAVEX
C
C        PERFORM BACKWARD TRANSFORMS
C
         CALL RFFTB(NX, HELPX, SAVEX)
C (0,29)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_DCTDX_SAVEX
         CALL RFFTB(NX, HELP, SAVEX)
C (0,30)
C
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,31)
C           BEGIN BLOCK
C (0,32)
            DCDX(I,J) = HELP(I)
C (0,33)
            C(I,J) = HELPX(I)
C (0,34)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,35)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,36)
CX20554 CALL DOOUTX( 554 )
CY20554 CALL DOOUTY( 554 )
CX40030 CALL SBOUTX (30)
CY40030 CALL SBOUTY (30)
C
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *    CALCULATE THE X-DERIVATIVE OF UNKNOWN FUNCTION VIA FFT'S      *
C   *     NO DIFFUSION EIGENVALUE STEP IS PERFORMED ON THE VARIABLE    *
C   ********************************************************************
C
      SUBROUTINE DCTDXD(NX,NY,NX1,NFILT,C,DCDX,HELP,HELPX,FX,FXX,SAVEX)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDX(NX,NY),
     *HELP(I_PIPS_DCTDXD_HELP),HELPX(I_PIPS_DCTDXD_HELPX),FX(I_PIPS_DCTD
     x XD_FX),FXX(I_PIPS_DCTDXD_FXX),SAVEX(I_PIPS_DCTDXD_SAVEX)
C (0,1)
      INTEGER*8 I_PIPS_DCTDXD_HELP
      COMMON /PIPS_DCTDXD_HELP/ I_PIPS_DCTDXD_HELP
      INTEGER*8 I_PIPS_DCTDXD_HELPX
      COMMON /PIPS_DCTDXD_HELPX/ I_PIPS_DCTDXD_HELPX
      INTEGER*8 I_PIPS_DCTDXD_FX
      COMMON /PIPS_DCTDXD_FX/ I_PIPS_DCTDXD_FX
      INTEGER*8 I_PIPS_DCTDXD_FXX
      COMMON /PIPS_DCTDXD_FXX/ I_PIPS_DCTDXD_FXX
      INTEGER*8 I_PIPS_DCTDXD_SAVEX
      COMMON /PIPS_DCTDXD_SAVEX/ I_PIPS_DCTDXD_SAVEX
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30031 CALL SBINX (31)
CY30031 CALL SBINY (31)
CX10555 CALL DOINX( 555 )
CY10555 CALL DOINY( 555 )
C
!     INITIALLY: DO 60
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(I) = C(I,J)
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
      I_PIPS_RFFTF_R = I_PIPS_DCTDXD_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_DCTDXD_SAVEX
C
         CALL RFFTF(NX, HELP, SAVEX)
C (0,9)
C
         FILT = -HELP(NX)/NX
C (0,10)
         II1 = 0
C (0,11)
         II2 = 1
C (0,12)
         HELP(1) = 0.0
C (0,13)
!     INITIALLY: DO 20
         DO I = 2, NX1
C (0,14)
C           BEGIN BLOCK
C (0,15)
            II1 = II1+2
C (0,16)
            II2 = II2+2
C (0,17)
            T1 = HELP(II1)
C (0,18)
            T2 = HELP(II2)
C (0,19)
            HELP(II2) = T1*FX(I)
C (0,20)
            HELP(II1) = -T2*FX(I)
C (0,21)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,22)
         HELP(NX) = 0.0
C (0,23)
      I_PIPS_RFFTB_R = I_PIPS_DCTDXD_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_DCTDXD_SAVEX
C
C        PERFORM BACKWARD TRANSFORM
C
         CALL RFFTB(NX, HELP, SAVEX)
C (0,24)
C
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,25)
C           BEGIN BLOCK
C (0,26)
            DCDX(I,J) = HELP(I)
C (0,27)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,28)
C        BEGIN UNSTRUCTURED
C (1,1)
C
C     PERFORM FILTERING
C
         IF (NFILT.EQ.0) GOTO 50
C (3,1)
!     INITIALLY: DO 40
         DO I = 1, NX
C (3,2)
C           BEGIN BLOCK
C (3,3)
            FILT = -FILT
C (3,4)
            C(I,J) = C(I,J)-FILT
C (3,5)
40          CONTINUE
C           END BLOCK
         ENDDO
C (2,1)
50       CONTINUE
C        END UNSTRUCTURED
C (0,29)
60       CONTINUE
C        END BLOCK
      ENDDO
C (0,30)
CX20556 CALL DOOUTX( 556 )
CY20556 CALL DOOUTY( 556 )
CX40032 CALL SBOUTX (32)
CY40032 CALL SBOUTY (32)
C
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *     CALCULATE THE Y-DERIVATIVE OF UNKNOWN FUNCTION VIA FFT'S     *
C   *     AND ADD HORIZONTAL DIFFUSION TERMS KYD2/DY2, (EIGENVALUES)   *
C   ********************************************************************
C
      SUBROUTINE DCTDY(NX,NY,NY1,NFILT,C,DCDY,HELP,HELPY,FY,FYY,SAVEY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDY(NX,NY),
     *HELP(I_PIPS_RUN_HELP),HELPY(I_PIPS_RUN_HELPA),FY(I_PIPS_RUN_FY),FY
     x Y(I_PIPS_RUN_FYY),SAVEY(I_PIPS_RUN_SAVEY)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_RUN_FYY
      COMMON /PIPS_RUN_FYY/ I_PIPS_RUN_FYY
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30033 CALL SBINX (33)
CY30033 CALL SBINY (33)
CX10557 CALL DOINX( 557 )
CY10557 CALL DOINY( 557 )
C
!     INITIALLY: DO 40
      DO I = 1, NX
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO J = 1, NY
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(J) = C(I,J)
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
      I_PIPS_RFFTF_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_RUN_SAVEY
C
         CALL RFFTF(NY, HELP, SAVEY)
C (0,9)
         II1 = 0
C (0,10)
         II2 = 1
C (0,11)
         HELPY(1) = HELP(1)/NY
C (0,12)
         HELP(1) = 0.0
C (0,13)
!     INITIALLY: DO 20
         DO J = 2, NY1
C (0,14)
C           BEGIN BLOCK
C (0,15)
            II1 = II1+2
C (0,16)
            II2 = II2+2
C (0,17)
            T1 = HELP(II1)*FYY(J)
C (0,18)
            T2 = HELP(II2)*FYY(J)
C (0,19)
            HELPY(II2) = T2
C (0,20)
            HELPY(II1) = T1
C (0,21)
            HELP(II2) = T1*FY(J)
C (0,22)
            HELP(II1) = -T2*FY(J)
C (0,23)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,24)
         IF (NFILT.EQ.0) THEN
C (0,25)
            HELPY(NY) = HELPY(NY)*FYY(1)
         ELSE
C (0,26)
            HELPY(NY) = 0.0
         ENDIF
C (0,27)
         HELP(NY) = 0.0
C (0,28)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELPA
      I_PIPS_RFFTB_WSAVE = I_PIPS_RUN_SAVEY
C
C        PERFORM BACKWARD TRANSFORMS
C
         CALL RFFTB(NY, HELPY, SAVEY)
C (0,29)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_RUN_SAVEY
         CALL RFFTB(NY, HELP, SAVEY)
C (0,30)
C
!     INITIALLY: DO 30
         DO J = 1, NY
C (0,31)
C           BEGIN BLOCK
C (0,32)
            DCDY(I,J) = HELP(J)
C (0,33)
            C(I,J) = HELPY(J)
C (0,34)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,35)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,36)
CX20558 CALL DOOUTX( 558 )
CY20558 CALL DOOUTY( 558 )
CX40034 CALL SBOUTX (34)
CY40034 CALL SBOUTY (34)
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *     CALCULATE THE Y-DERIVATIVE OF UNKNOWN FUNCTION VIA FFT'S     *
C   *     NO DIFFUSION EIGENVALUE STEP IS PERFORMED ON THE VARIABLE    *
C   ********************************************************************
C
      SUBROUTINE DCTDYD(NX,NY,NY1,NFILT,C,DCDY,HELP,HELPY,FY,FYY,SAVEY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDY(NX,NY),
     *HELP(I_PIPS_DCTDYD_HELP),HELPY(I_PIPS_DCTDYD_HELPY),FY(I_PIPS_DCTD
     x YD_FY),FYY(I_PIPS_DCTDYD_FYY),SAVEY(I_PIPS_DCTDYD_SAVEY)
C (0,1)
      INTEGER*8 I_PIPS_DCTDYD_HELP
      COMMON /PIPS_DCTDYD_HELP/ I_PIPS_DCTDYD_HELP
      INTEGER*8 I_PIPS_DCTDYD_HELPY
      COMMON /PIPS_DCTDYD_HELPY/ I_PIPS_DCTDYD_HELPY
      INTEGER*8 I_PIPS_DCTDYD_FY
      COMMON /PIPS_DCTDYD_FY/ I_PIPS_DCTDYD_FY
      INTEGER*8 I_PIPS_DCTDYD_FYY
      COMMON /PIPS_DCTDYD_FYY/ I_PIPS_DCTDYD_FYY
      INTEGER*8 I_PIPS_DCTDYD_SAVEY
      COMMON /PIPS_DCTDYD_SAVEY/ I_PIPS_DCTDYD_SAVEY
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30035 CALL SBINX (35)
CY30035 CALL SBINY (35)
CX10559 CALL DOINX( 559 )
CY10559 CALL DOINY( 559 )
C
!     INITIALLY: DO 60
      DO I = 1, NX
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO J = 1, NY
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(J) = C(I,J)
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
      I_PIPS_RFFTF_R = I_PIPS_DCTDYD_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_DCTDYD_SAVEY
C
         CALL RFFTF(NY, HELP, SAVEY)
C (0,9)
C
         FILT = -HELP(NY)/NY
C (0,10)
         II1 = 0
C (0,11)
         II2 = 1
C (0,12)
         HELP(1) = 0.0
C (0,13)
!     INITIALLY: DO 20
         DO J = 2, NY1
C (0,14)
C           BEGIN BLOCK
C (0,15)
            II1 = II1+2
C (0,16)
            II2 = II2+2
C (0,17)
            T1 = HELP(II1)
C (0,18)
            T2 = HELP(II2)
C (0,19)
            HELP(II2) = T1*FY(J)
C (0,20)
            HELP(II1) = -T2*FY(J)
C (0,21)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,22)
         HELP(NY) = 0.0
C (0,23)
      I_PIPS_RFFTB_R = I_PIPS_DCTDYD_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_DCTDYD_SAVEY
C
C        PERFORM BACKWARD TRANSFORM
C
         CALL RFFTB(NY, HELP, SAVEY)
C (0,24)
C
!     INITIALLY: DO 30
         DO J = 1, NY
C (0,25)
C           BEGIN BLOCK
C (0,26)
            DCDY(I,J) = HELP(J)
C (0,27)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,28)
C        BEGIN UNSTRUCTURED
C (1,1)
C
C     PERFORM FILTERING
C
         IF (NFILT.EQ.0) GOTO 50
C (3,1)
!     INITIALLY: DO 40
         DO J = 1, NY
C (3,2)
C           BEGIN BLOCK
C (3,3)
            FILT = -FILT
C (3,4)
            C(I,J) = C(I,J)-FILT
C (3,5)
40          CONTINUE
C           END BLOCK
         ENDDO
C (2,1)
50       CONTINUE
C        END UNSTRUCTURED
C (0,29)
60       CONTINUE
C        END BLOCK
      ENDDO
C (0,30)
CX20560 CALL DOOUTX( 560 )
CY20560 CALL DOOUTY( 560 )
CX40036 CALL SBOUTX (36)
CY40036 CALL SBOUTY (36)
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *     CALCULATE THE X-DERIVATIVE OF PRESSURE IMPLICT VIA FFT'S     *
C   *     AND ADD HORIZONTAL DIFFUSION TERMS KXD2/DX2, (EIGENVALUES)   *
C   ********************************************************************
C
      SUBROUTINE DPDX(NX,NY,NX1,NFILT,C,STEPC,DCDX,HELP,HELPX,
     *FX,FXX,FILX,SAVEX)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),STEPC(NX,NY),DCDX(NX,NY),
     *HELP(I_PIPS_RUN_HELP),HELPX(I_PIPS_RUN_HELPA),FX(I_PIPS_RUN_FX),FX
     x X(I_PIPS_RUN_FXC),SAVEX(I_PIPS_RUN_SAVEX),FILX(I_PIPS_DPDX_FILX)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_DPDX_FILX
      COMMON /PIPS_DPDX_FILX/ I_PIPS_DPDX_FILX
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30037 CALL SBINX (37)
CY30037 CALL SBINY (37)
CX10561 CALL DOINX( 561 )
CY10561 CALL DOINY( 561 )
C
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(I) = (C(I,J)+STEPC(I,J))/2.
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
      I_PIPS_RFFTF_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_RUN_SAVEX
C
         CALL RFFTF(NX, HELP, SAVEX)
C (0,9)
C
         II1 = 0
C (0,10)
         II2 = 1
C (0,11)
         HELP(1) = 0.0
C (0,12)
!     INITIALLY: DO 20
         DO I = 2, NX1
C (0,13)
C           BEGIN BLOCK
C (0,14)
            II1 = II1+2
C (0,15)
            II2 = II2+2
C (0,16)
            T1 = HELP(II1)*FXX(I)
C (0,17)
            T2 = HELP(II2)*FXX(I)
C (0,18)
            HELP(II2) = T1*FX(I)
C (0,19)
            HELP(II1) = -T2*FX(I)
C (0,20)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,21)
         HELP(NX) = 0.0
C (0,22)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_RUN_SAVEX
         CALL RFFTB(NX, HELP, SAVEX)
C (0,23)
C
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,24)
C           BEGIN BLOCK
C (0,25)
            DCDX(I,J) = HELP(I)*FILX(I)
C (0,26)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,27)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,28)
CX20562 CALL DOOUTX( 562 )
CY20562 CALL DOOUTY( 562 )
CX40038 CALL SBOUTX (38)
CY40038 CALL SBOUTY (38)
C
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *     CALCULATE THE Y-DERIVATIVE OF PRESSURE IMPLICI VIA FFT'S     *
C   *     AND ADD HORIZONTAL DIFFUSION TERMS KYD2/DY2, (EIGENVALUES)   *
C   ********************************************************************
C
      SUBROUTINE DPDY(NX,NY,NY1,NFILT,C,STEPC,DCDY,HELP,HELPY,
     *FY,FYY,FILY,SAVEY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDY(NX,NY),STEPC(NX,NY),
     *HELP(I_PIPS_RUN_HELP),HELPY(I_PIPS_RUN_HELPA),FY(I_PIPS_RUN_FY),FY
     x Y(I_PIPS_RUN_FYC),SAVEY(I_PIPS_RUN_SAVEY),FILY(I_PIPS_DPDY_FILY)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_DPDY_FILY
      COMMON /PIPS_DPDY_FILY/ I_PIPS_DPDY_FILY
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30039 CALL SBINX (39)
CY30039 CALL SBINY (39)
CX10563 CALL DOINX( 563 )
CY10563 CALL DOINY( 563 )
C
!     INITIALLY: DO 40
      DO I = 1, NX
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO J = 1, NY
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(J) = (C(I,J)+STEPC(I,J))/2.
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
      I_PIPS_RFFTF_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_RUN_SAVEY
C
         CALL RFFTF(NY, HELP, SAVEY)
C (0,9)
         II1 = 0
C (0,10)
         II2 = 1
C (0,11)
         HELP(1) = 0.0
C (0,12)
!     INITIALLY: DO 20
         DO J = 2, NY1
C (0,13)
C           BEGIN BLOCK
C (0,14)
            II1 = II1+2
C (0,15)
            II2 = II2+2
C (0,16)
            T1 = HELP(II1)*FYY(J)
C (0,17)
            T2 = HELP(II2)*FYY(J)
C (0,18)
            HELP(II2) = T1*FY(J)
C (0,19)
            HELP(II1) = -T2*FY(J)
C (0,20)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,21)
         HELP(NY) = 0.0
C (0,22)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_RUN_SAVEY
         CALL RFFTB(NY, HELP, SAVEY)
C (0,23)
C
!     INITIALLY: DO 30
         DO J = 1, NY
C (0,24)
C           BEGIN BLOCK
C (0,25)
            DCDY(I,J) = HELP(J)*FILY(J)
C (0,26)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,27)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,28)
CX20564 CALL DOOUTX( 564 )
CY20564 CALL DOOUTY( 564 )
CX40040 CALL SBOUTX (40)
CY40040 CALL SBOUTY (40)
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *      CALCULATE THE X-DERIVATIVE OF UNKNOWN FUNCTION VIA FFT'S    *
C   ********************************************************************
C
      SUBROUTINE DFTDX(NX,NY,NX1,F,DFDX,HELP,FX,SAVEX)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION F(NX,NY),DFDX(NX,NY),HELP(I_PIPS_RUN_HELP),FX(I_PIPS_RUN
     x _FX),SAVEX(I_PIPS_RUN_SAVEX)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30041 CALL SBINX (41)
CY30041 CALL SBINY (41)
C
      XP = FLOAT(NX)
C (0,3)
CX10565 CALL DOINX( 565 )
CY10565 CALL DOINY( 565 )
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,4)
C        BEGIN BLOCK
C (0,5)
!     INITIALLY: DO 10
         DO I = 1, NX
C (0,6)
C           BEGIN BLOCK
C (0,7)
            HELP(I) = F(I,J)
C (0,8)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,9)
      I_PIPS_RFFTF_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_RUN_SAVEX
C
C        FORWARD FFT
C
         CALL RFFTF(NX, HELP, SAVEX)
C (0,10)
C
         II1 = 0
C (0,11)
         II2 = 1
C (0,12)
         HELP(1) = 0.0
C (0,13)
!     INITIALLY: DO 20
         DO I = 2, NX1
C (0,14)
C           BEGIN BLOCK
C (0,15)
            II1 = II1+2
C (0,16)
            II2 = II2+2
C (0,17)
            T1 = HELP(II1)
C (0,18)
            T2 = HELP(II2)
C (0,19)
            HELP(II2) = T1*FX(I)/XP
C (0,20)
            HELP(II1) = -T2*FX(I)/XP
C (0,21)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,22)
         HELP(NX) = 0.0
C (0,23)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_RUN_SAVEX
C
C     BACKWARD FFT
C
         CALL RFFTB(NX, HELP, SAVEX)
C (0,24)
C
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,25)
C           BEGIN BLOCK
C (0,26)
            DFDX(I,J) = HELP(I)
C (0,27)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,28)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,29)
CX20566 CALL DOOUTX( 566 )
CY20566 CALL DOOUTY( 566 )
CX40042 CALL SBOUTX (42)
CY40042 CALL SBOUTY (42)
C
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *      CALCULATE THE Y-DERIVATIVE OF UNKNOWN FUNCTION VIA FFT'S    *
C   ********************************************************************
C
      SUBROUTINE DFTDY(NX,NY,NY1,F,DFDY,HELP,FY,SAVEY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION F(NX,NY),DFDY(NX,NY),HELP(I_PIPS_RUN_HELP),FY(I_PIPS_RUN
     x _FY),SAVEY(I_PIPS_RUN_SAVEY)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30043 CALL SBINX (43)
CY30043 CALL SBINY (43)
C
      YP = FLOAT(NY)
C (0,3)
CX10567 CALL DOINX( 567 )
CY10567 CALL DOINY( 567 )
!     INITIALLY: DO 40
      DO I = 1, NX
C (0,4)
C        BEGIN BLOCK
C (0,5)
!     INITIALLY: DO 10
         DO J = 1, NY
C (0,6)
C           BEGIN BLOCK
C (0,7)
            HELP(J) = F(I,J)
C (0,8)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,9)
      I_PIPS_RFFTF_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTF_WSAVE = I_PIPS_RUN_SAVEY
C
C        FORWARD FFT
C
         CALL RFFTF(NY, HELP, SAVEY)
C (0,10)
C
         II1 = 0
C (0,11)
         II2 = 1
C (0,12)
         HELP(1) = 0.0
C (0,13)
!     INITIALLY: DO 20
         DO J = 2, NY1
C (0,14)
C           BEGIN BLOCK
C (0,15)
            II1 = II1+2
C (0,16)
            II2 = II2+2
C (0,17)
            T1 = HELP(II1)
C (0,18)
            T2 = HELP(II2)
C (0,19)
            HELP(II2) = T1*FY(J)/YP
C (0,20)
            HELP(II1) = -T2*FY(J)/YP
C (0,21)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,22)
         HELP(NY) = 0.0
C (0,23)
      I_PIPS_RFFTB_R = I_PIPS_RUN_HELP
      I_PIPS_RFFTB_WSAVE = I_PIPS_RUN_SAVEY
C
C        BACKWARD FFT
C
         CALL RFFTB(NY, HELP, SAVEY)
C (0,24)
C
!     INITIALLY: DO 30
         DO J = 1, NY
C (0,25)
C           BEGIN BLOCK
C (0,26)
            DFDY(I,J) = HELP(J)
C (0,27)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,28)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,29)
CX20568 CALL DOOUTX( 568 )
CY20568 CALL DOOUTY( 568 )
CX40044 CALL SBOUTX (44)
CY40044 CALL SBOUTY (44)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C      INFORMATION ON THE SETUP OF ELEMENTS AND BOUNDARY CONDITIONS IN *
C      THE TRIDIAGONAL SOLVER ROUTINES    BY Z. D. CHRISTIDIS          *
C **********************************************************************
C
C        GIVEN  NUMBER OF POINTS  NZ,  Z VARIES IN (0,1) ->
C        NUMBER OF POINTS = (1,NZ)
C
C        FOR HOMOGENIOUS BOUNDARY CONDITION AT Z=0 AND  Z=1
C        WE DO NOT SOLVE FOR THE BOUNDARY POINTS. SO USE:
C        1) LOOP J=2,NZ-1
C        2) POINTS TO SOLVE FOR =NZ-2
C        3) STARTING ADDRESS IN TRID AT THE (2)   ELEMENT
C
C
C        FOR FLUX BOUNDARY CONDITION AT Z=0 , AND HOMOGENIOUS AT Z=1
C        SOLVE FOR Z=0, DO NOT SOLVE AT Z=1.  USE:
C        1) LOOP J=1,NZ-1
C        2) FOR  J=1         CN(J)=CN(J)+BN(J)
C                            BN(J)=BN(J)
C                            H0=GN(J+1)
C        3) FOR  J>1         CN(J)=CN(J)
C                            BN(J)=BN(J)
C                            H0=GN(J-1)
C        4) POINTS TO SOLVE FOR =NZ-1
C        5) STARTING ADDRESS IN TRID AT THE (1)   ELEMENT
C
C
C        FOR FLUX BOUNDARY CONDITION AT Z=NZ,
C                 AND HOMOGENIOUS AT Z=0 USE:
C        1) LOOP J=2,NZ
C        2) FOR  J=NZ        BN(J)=CN(J)+BN(J)
C                            CN(J)=CN(J)
C                            H2=GN(J-1)
C        3) FOR  J<NZ        BN(J)=BN(J)
C                            CN(J)=CN(J)
C                            H2=GN(J+1)
C        4) POINTS TO SOLVE FOR =NZ-1
C        5) STARTING ADDRESS IN TRID AT THE (2)   ELEMENT
C
C
C        FOR FLUX BOUNDARY CONDITION AT Z=NZ , AND Z=0 USE:
C        1) LOOP J=1,NZ
C        2) FOR  J=1         CN(J)=CN(J)+BN(J)
C                            BN(J)=BN(J)
C                            H0=GN(J+1)
C        3) FOR  J=NZ        BN(J)=CN(J)+BN(J)
C                            CN(J)=CN(J)
C                            H2=GN(J-1)
C        4) FOR 1<J<NZ       BN(J)=BN(J)
C                            CN(J)=CN(J)
C                            H0=GN(J-1)
C                            H2=GN(J+1)
C        5) POINTS TO SOLVE FOR =NZ
C        6) STARTING ADDRESS IN TRID AT THE (1)   ELEMENT
C
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND THE PADE DERIVATIVES AND CRANK-NICKOLSON TECHNIQUE *
C ***         FOR THE POLLUTANTS C ONLY ]]]                            *
C **********************************************************************
C
C
      SUBROUTINE CPADE(DKS,HVAR,HELP,HELPA,NS,DELTAT,DELS,DZ,W,AN,BN
     * ,CN,IK,IT,VDRY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_DCDTZ_DKS),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_
     x RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN
     x _BN),CN(I_PIPS_RUN_CN),W(I_PIPS_RUN_DCDX)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
      PARAMETER (F1 = .833333333, F2 = .083333333, F3 = .6666666666,
     *           BT = 0.166666667)
      PARAMETER (FLUX = 0.0)
C (0,1)
      INTEGER*8 I_PIPS_DCDTZ_DKS
      COMMON /PIPS_DCDTZ_DKS/ I_PIPS_DCDTZ_DKS
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30045 CALL SBINX (45)
CY30045 CALL SBINY (45)
      SS = DELTAT/(2.*DH*DH)
C (0,3)
      N1 = NS-1
C (0,4)
      NPTS = NS-1
C (0,5)
      JS = 1
C (0,6)
C
C      EXPON=EXP(2.*DH*VDRY/(DKS(1)*HVAR(1)))
C
      EXPON = 1.0
C (0,7)
CX10569 CALL DOINX( 569 )
CY10569 CALL DOINY( 569 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,8)
C        BEGIN BLOCK
C (0,9)
         BS = SS*DKS(J)*HVAR(J)*HVAR(J)
C (0,10)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C
         AN(J) = F1+2.*BS
C (0,11)
         BN(J) = F2-BS
C (0,12)
         CN(J) = F2-BS
C (0,13)
         H1 = HELP(J)
C (0,14)
         H2 = HELP(J+1)
C (0,15)
         IF (J.EQ.1) THEN
C (0,16)
C           BEGIN BLOCK
C (0,17)
            CN(J) = CN(J)+BN(J)*EXPON
C (0,18)
            H0 = HELP(J+1)
C           END BLOCK
         ELSE
C (0,19)
            H0 = HELP(J-1)
         ENDIF
C (0,20)
         HELPA(J) = (BS+F2)*(H0+H2)+(F1-2.*BS)*H1
C (0,21)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,22)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20570 CALL DOOUTX( 570 )
CY20570 CALL DOOUTY( 570 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,23)
      DELT = 1.
C (0,24)
      IF (IT.EQ.0) THEN
C (0,25)
         DELT = 0.0
      ELSE
C (0,26)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,27)

C
C      FORM THE FORCING ARRAY  TO SOLVE THE (DKS/DS)*(DC/DS) PART
C
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,28)
CX10571 CALL DOINX( 571 )
CY10571 CALL DOINY( 571 )
!     INITIALLY: DO 20
      DO J = JS, N1
C (0,29)
C        BEGIN BLOCK
C (0,30)
         AS = (HELPA(J)-W(J)/HVAR(J)-DELT*DKS(J)/ALP)*HVAR(J)*HVAR(J)
     &   *DELTAT/(4.*DH)
C (0,31)
         AN(J) = F3
C (0,32)
         BN(J) = BT+AS
C (0,33)
         CN(J) = BT-AS
C (0,34)
         H1 = HELP(J)
C (0,35)
         H2 = HELP(J+1)
C (0,36)
         IF (J.EQ.1) THEN
C (0,37)
C           BEGIN BLOCK
C (0,38)
            CN(J) = CN(J)+BN(J)*EXPON
C (0,39)
            H0 = HELP(J+1)
C           END BLOCK
         ELSE
C (0,40)
            H0 = HELP(J-1)
         ENDIF
C (0,41)
         HELPA(J) = (BT+AS)*H2+F3*H1+(BT-AS)*H0
C (0,42)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,43)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20572 CALL DOOUTX( 572 )
CY20572 CALL DOOUTY( 572 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,44)
CX40046 CALL SBOUTX (46)
CY40046 CALL SBOUTY (46)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND THE PADE DERIVATIVES AND CRANK-NICKOLSON TECHNIQUE *
C ***     COMPLEX VECTORS ONLY                                         *
C **********************************************************************
C
      SUBROUTINE PADEC(DKS,DKDS,HVAR,WM,WG,FN,NS,AN,BN,CN,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_RUN_DKM),DKDS(I_PIPS_RUN_VM),HVAR(I_PIPS_RUN_
     x HVAR)
      COMPLEX*16 WM((-64*NS+8*I_PIPS_RUN_DCDX)/16),WG((-80*NS+8*I_PIPS_R
     x UN_DCDX)/16),FN((-48*NS+8*I_PIPS_RUN_DCDX)/16),AN(8*I_PIPS_RUN_DC
     x DX/16),BN((-16*NS+8*I_PIPS_RUN_DCDX)/16),CN((-32*NS+8*I_PIPS_RUN_
     x DCDX)/16)
      COMPLEX*16 H0,H1,H2,GAMMA,CONST
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP
      PARAMETER (F1 = .8333333, F2 = .0833333)
      PARAMETER (F = 0.0001, F4 = 0.1666667, F3 = .6666667)
C (0,1)
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
C     BEGIN BLOCK
C (0,2)
CX30047 CALL SBINX (47)
CY30047 CALL SBINY (47)
      SS = DT/(2.0*DH*DH)
C (0,3)
      NS1 = NS-1
C (0,4)
      NS2 = NS-2
C (0,5)
CX10573 CALL DOINX( 573 )
CY10573 CALL DOINY( 573 )
!     INITIALLY: DO 10
      DO J = 2, NS1
C (0,6)
C        BEGIN BLOCK
C (0,7)
         BS = SS*DKS(J)*HVAR(J)*HVAR(J)
C (0,8)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = F1+2.*BS
C (0,9)
         BN(J) = F2-BS
C (0,10)
         CN(J) = F2-BS
C (0,11)
         H0 = WM(J-1)
C (0,12)
         H1 = WM(J)
C (0,13)
         H2 = WM(J+1)
C (0,14)
         IF (J.EQ.NS1) THEN
C (0,15)
            CONST = CN(J)*H2
         ELSE
C (0,16)
            CONST = (0., 0.)
         ENDIF
C (0,17)
         FN(J) = (BS+F2)*(H0+H2)+(F1-2.*BS)*H1-CONST
C (0,18)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,19)
CX20574 CALL DOOUTX( 574 )
CY20574 CALL DOOUTY( 574 )
      CALL TRIDC(NS2, BN(2), AN(2), CN(2), FN(2), WM(2))
C (0,20)
C
C      FORM THE FORCING ARRAY  TO SOLVE THE (DKS/DS)*(DC/DS) PART
C
      CALL DCTDXF(NS, 1, DKS, DKDS, DH)
C (0,21)
      DELT = 1.D0
C (0,22)
      IF (IT.EQ.0) THEN
C (0,23)
         DELT = 0.0D0
      ELSE
C (0,24)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,25)
      GAMMA = CMPLX(0.0D0, F*DT)
C (0,26)
CX10575 CALL DOINX( 575 )
CY10575 CALL DOINY( 575 )
!     INITIALLY: DO 20
      DO J = 2, NS1
C (0,27)
C        BEGIN BLOCK
C (0,28)
         AS = (DKDS(J)-DELT*DKS(J)/ALP)*HVAR(J)*HVAR(J)*DT/(4.D0*DH)
C (0,29)
         AN(J) = F3+GAMMA/3.D0
C (0,30)
         BN(J) = F4+AS+GAMMA*F2
C (0,31)
         CN(J) = F4-AS+GAMMA*F2
C (0,32)
         H0 = WM(J-1)
C (0,33)
         H1 = WM(J)
C (0,34)
         H2 = WM(J+1)
C (0,35)
         IF (J.EQ.NS1) THEN
C (0,36)
            CONST = CN(J)*H2
         ELSE
C (0,37)
            CONST = (0.D0, 0.D0)
         ENDIF
C (0,38)
         FN(J) = (AS+F4-GAMMA*F2)*H2+(F4-AS-GAMMA*F2)*H0+H1*(F3-GAMMA
     &   /3.D0)+GAMMA*WG(J)-CONST
C (0,39)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,40)
CX20576 CALL DOOUTX( 576 )
CY20576 CALL DOOUTY( 576 )
      CALL TRIDC(NS2, BN(2), AN(2), CN(2), FN(2), WM(2))
C (0,41)
CX40048 CALL SBOUTX (48)
CY40048 CALL SBOUTY (48)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYING CRANK-NICKOLSON WITH UPWINDING (A=.5 TECHNIQUE)    *
C ***              FOR POLLUTANTS C ONLY                               *
C **********************************************************************
C
      SUBROUTINE CCRANK(DKS,HVAR,HELP,HELPA,NS,DELTAT,DELS,DZ,W,AN,BN,
     * CN,IK,IT,VDRY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_DCDTZ_DKS),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_
     x RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN
     x _BN),CN(I_PIPS_RUN_CN),W(I_PIPS_RUN_DCDX)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_DCDTZ_DKS
      COMMON /PIPS_DCDTZ_DKS/ I_PIPS_DCDTZ_DKS
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30049 CALL SBINX (49)
CY30049 CALL SBINY (49)
      SCND = DELTAT/(DH*DH)
C (0,3)
      FRST = DELTAT/(2.*DH)
C (0,4)
      N1 = NS-1
C (0,5)
      DELT = 1.
C (0,6)
      NPTS = NS-1
C (0,7)
      JS = 1
C (0,8)
C
C      EXPON=EXP(2.D0*DH*VDRY/(DKS(1)*HVAR(1)))
C      FOR THE NATURAL FLUX CONDITION
C
      EXPON = 1.0D0
C (0,9)
      IF (IT.EQ.0) THEN
C (0,10)
         DELT = 0.0D0
      ELSE
C (0,11)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,12)
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,13)
      BETA = 1.D0-ALPHA
C (0,14)
CX10577 CALL DOINX( 577 )
CY10577 CALL DOINY( 577 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,15)
C        BEGIN BLOCK
C (0,16)
         DL = FRST*HVAR(J)*HVAR(J)*(HELPA(J)-W(J)/HVAR(J)-DELT*DKS(J)
     &   /ALP)
C (0,17)
         DM = SCND*HVAR(J)*HVAR(J)*DKS(J)
C (0,18)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = 1.D0+2.D0*ALPHA*DM
C (0,19)
         CN(J) = -ALPHA*(DL+DM)
C (0,20)
         BN(J) = ALPHA*(DL-DM)
C (0,21)
         H1 = HELP(J)
C (0,22)
         H2 = HELP(J+1)
C (0,23)
C
         IF (J.EQ.1) THEN
C (0,24)
C           BEGIN BLOCK
C (0,25)
            CN(J) = CN(J)+BN(J)*EXPON
C (0,26)
            H0 = HELP(J+1)
C           END BLOCK
         ELSE
C (0,27)
            H0 = HELP(J-1)
         ENDIF
C (0,28)
C
         HELPA(J) = BETA*(DL+DM)*H2+(1.D0-2.D0*BETA*DM)*H1+BETA*(DM-
     &   DL)*H0
C (0,29)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,30)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20578 CALL DOOUTX( 578 )
CY20578 CALL DOOUTY( 578 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,31)
CX40050 CALL SBOUTX (50)
CY40050 CALL SBOUTY (50)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND ONLY THE CRANK-NICKOLSON TECHNIQUE  COMPLEX MATRIX *
C **********************************************************************
C
      SUBROUTINE CRANKC(DKS,DKDS,HVAR,WM,WG,FN,NS,AN,BN,CN,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 DKS(I_PIPS_RUN_DKM),DKDS(I_PIPS_RUN_VM),HVAR(I_PIPS_RUN_HVA
     x R)
      COMPLEX*16 WM((-64*NS+8*I_PIPS_RUN_DCDX)/16),WG((-80*NS+8*I_PIPS_R
     x UN_DCDX)/16),FN((-48*NS+8*I_PIPS_RUN_DCDX)/16),AN(8*I_PIPS_RUN_DC
     x DX/16),BN((-16*NS+8*I_PIPS_RUN_DCDX)/16),CN((-32*NS+8*I_PIPS_RUN_
     x DCDX)/16)
      COMPLEX*16 H0,H1,H2,GAMMA,CONST
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP
      PARAMETER (F = 0.0001)
C (0,1)
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
C     BEGIN BLOCK
C (0,2)
CX30051 CALL SBINX (51)
CY30051 CALL SBINY (51)
      SCND = DT/(DH*DH)
C (0,3)
      FRST = DT/(2.D0*DH)
C (0,4)
      NS1 = NS-1
C (0,5)
      NS2 = NS-2
C (0,6)
      DELT = 1.
C (0,7)
      IF (IT.EQ.0) THEN
C (0,8)
         DELT = 0.0D0
      ELSE
C (0,9)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,10)
      CALL DCTDXF(NS, 1, DKS, DKDS, DH)
C (0,11)
      GAMMA = CMPLX(0.0D0, F*DT)
C (0,12)
      BETA = 1.-ALPHA
C (0,13)
CX10579 CALL DOINX( 579 )
CY10579 CALL DOINY( 579 )
!     INITIALLY: DO 10
      DO J = 2, NS1
C (0,14)
C        BEGIN BLOCK
C (0,15)
         DL = FRST*HVAR(J)*HVAR(J)*(DKDS(J)-DELT*DKS(J)/ALP)
C (0,16)
         DM = SCND*HVAR(J)*HVAR(J)*DKS(J)
C (0,17)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = 1.D0+ALPHA*(2.D0*DM+GAMMA)
C (0,18)
         CN(J) = -ALPHA*(DL+DM)
C (0,19)
         BN(J) = ALPHA*(DL-DM)
C (0,20)
         H0 = WM(J-1)
C (0,21)
         H1 = WM(J)
C (0,22)
         H2 = WM(J+1)
C (0,23)
         IF (J.EQ.NS1) THEN
C (0,24)
            CONST = CN(J)*H2
         ELSE
C (0,25)
            CONST = (0.D0, 0.D0)
         ENDIF
C (0,26)
         FN(J) = BETA*(DL+DM)*H2+(1.-BETA*(2.*DM+GAMMA))*H1+BETA*(DM-
     &   DL)*H0+GAMMA*WG(J)-CONST
C (0,27)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,28)
CX20580 CALL DOOUTX( 580 )
CY20580 CALL DOOUTY( 580 )
      CALL TRIDC(NS2, BN(2), AN(2), CN(2), FN(2), WM(2))
C (0,29)
CX40052 CALL SBOUTX (52)
CY40052 CALL SBOUTY (52)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND THE PADE DERIVATIVES AND CRANK-NICKOLSON TECHNIQUE *
C ***         FOR THE MOMENTUM U,V ONLY ]]]                            *
C **********************************************************************
C
C
      SUBROUTINE UPADE(DKS,HVAR,HELP,HELPA,NS,DELTAT,DELS,DZ,W,FORCN,
     *AN,BN,CN,IK,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_UPADE_DKS),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_
     x RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN
     x _BN),CN(I_PIPS_RUN_CN),W(I_PIPS_UPADE_W)
      DIMENSION FORCN(I_PIPS_UPADE_FORCN)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP
      PARAMETER (F1 = .833333333, F2 = .083333333, F3 = .6666666666,
     *           BT = 0.166666667)
      PARAMETER (FLUX = 0.0)
C (0,1)
      INTEGER*8 I_PIPS_DUDTZ_DKS
      COMMON /PIPS_DUDTZ_DKS/ I_PIPS_DUDTZ_DKS
      INTEGER*8 I_PIPS_DVDTZ_DKS
      COMMON /PIPS_DVDTZ_DKS/ I_PIPS_DVDTZ_DKS
      INTEGER*8 I_PIPS_UPADE_DKS
      COMMON /PIPS_UPADE_DKS/ I_PIPS_UPADE_DKS
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_UPADE_W
      COMMON /PIPS_UPADE_W/ I_PIPS_UPADE_W
      INTEGER*8 I_PIPS_DUDTZ_FORC
      COMMON /PIPS_DUDTZ_FORC/ I_PIPS_DUDTZ_FORC
      INTEGER*8 I_PIPS_DVDTZ_FORC
      COMMON /PIPS_DVDTZ_FORC/ I_PIPS_DVDTZ_FORC
      INTEGER*8 I_PIPS_UPADE_FORCN
      COMMON /PIPS_UPADE_FORCN/ I_PIPS_UPADE_FORCN
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30053 CALL SBINX (53)
CY30053 CALL SBINY (53)
      SS = DELTAT/(2.D0*DH*DH)
C (0,3)
      N1 = NS-1
C (0,4)
      NPTS = NS-2
C (0,5)
      JS = 2
C (0,6)
CX10581 CALL DOINX( 581 )
CY10581 CALL DOINY( 581 )
C
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,7)
C        BEGIN BLOCK
C (0,8)
         BS = SS*DKS(J)*HVAR(J)*HVAR(J)
C (0,9)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2U/DS2 PART
C
         AN(J) = F1+2.D0*BS
C (0,10)
         BN(J) = F2-BS
C (0,11)
         CN(J) = F2-BS
C (0,12)
         H0 = HELP(J-1)
C (0,13)
         H1 = HELP(J)
C (0,14)
         H2 = HELP(J+1)
C (0,15)
C
         HELPA(J) = (BS+F2)*(H0+H2)+(F1-2.D0*BS)*H1
C (0,16)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,17)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20582 CALL DOOUTX( 582 )
CY20582 CALL DOOUTY( 582 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,18)
      DELT = 1.D0
C (0,19)
      IF (IT.EQ.0) THEN
C (0,20)
         DELT = 0.0D0
      ELSE
C (0,21)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,22)
C
C      FORM THE FORCING ARRAY  TO SOLVE THE (DKS/DS)*(DU/DS) PART
C
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,23)
CX10583 CALL DOINX( 583 )
CY10583 CALL DOINY( 583 )
!     INITIALLY: DO 20
      DO J = JS, N1
C (0,24)
C        BEGIN BLOCK
C (0,25)
         AS = (HELPA(J)-W(J)/HVAR(J)-DELT*DKS(J)/ALP)*HVAR(J)*HVAR(J)
     &   *DELTAT/(4.D0*DH)
C (0,26)
         AN(J) = F3
C (0,27)
         BN(J) = BT+AS
C (0,28)
         CN(J) = BT-AS
C (0,29)
         H0 = HELP(J-1)
C (0,30)
         H1 = HELP(J)
C (0,31)
         H2 = HELP(J+1)
C (0,32)
C
         HELPA(J) = (BT+AS)*H2+F3*H1+(BT-AS)*H0+DELTAT*FORCN(J)
C (0,33)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,34)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20584 CALL DOOUTX( 584 )
CY20584 CALL DOOUTY( 584 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,35)
CX40054 CALL SBOUTX (54)
CY40054 CALL SBOUTY (54)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND CRANK-NICKOLSON WITH UPWINDING (A=.5 TECHNIQUE)    *
C ***              FOR MOMENTUM ONLY (U,V)                             *
C **********************************************************************
C
      SUBROUTINE UCRANK(DKS,HVAR,HELP,HELPA,NS,DELTAT,DELS,DZ,W,FORCN,
     *AN,BN,CN,IK,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_UCRANK_DKS),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS
     x _RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RU
     x N_BN),CN(I_PIPS_RUN_CN),W(I_PIPS_UCRANK_W)
      DIMENSION FORCN(I_PIPS_UCRANK_FORCN)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_DUDTZ_DKS
      COMMON /PIPS_DUDTZ_DKS/ I_PIPS_DUDTZ_DKS
      INTEGER*8 I_PIPS_DVDTZ_DKS
      COMMON /PIPS_DVDTZ_DKS/ I_PIPS_DVDTZ_DKS
      INTEGER*8 I_PIPS_UCRANK_DKS
      COMMON /PIPS_UCRANK_DKS/ I_PIPS_UCRANK_DKS
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_UCRANK_W
      COMMON /PIPS_UCRANK_W/ I_PIPS_UCRANK_W
      INTEGER*8 I_PIPS_DUDTZ_FORC
      COMMON /PIPS_DUDTZ_FORC/ I_PIPS_DUDTZ_FORC
      INTEGER*8 I_PIPS_DVDTZ_FORC
      COMMON /PIPS_DVDTZ_FORC/ I_PIPS_DVDTZ_FORC
      INTEGER*8 I_PIPS_UCRANK_FORCN
      COMMON /PIPS_UCRANK_FORCN/ I_PIPS_UCRANK_FORCN
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30055 CALL SBINX (55)
CY30055 CALL SBINY (55)
      SCND = DELTAT/(DH*DH)
C (0,3)
      FRST = DELTAT/(2.D0*DH)
C (0,4)
      N1 = NS-1
C (0,5)
      DELT = 1.D0
C (0,6)
      NPTS = NS-2
C (0,7)
      JS = 2
C (0,8)
      IF (IT.EQ.0) THEN
C (0,9)
         DELT = 0.0D0
      ELSE
C (0,10)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,11)
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,12)
      BETA = 1.D0-ALPHA
C (0,13)
CX10585 CALL DOINX( 585 )
CY10585 CALL DOINY( 585 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,14)
C        BEGIN BLOCK
C (0,15)
         DL = FRST*HVAR(J)*HVAR(J)*(HELPA(J)-W(J)/HVAR(J)-DELT*DKS(J)
     &   /ALP)
C (0,16)
         DM = SCND*HVAR(J)*HVAR(J)*DKS(J)
C (0,17)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = 1.D0+2.D0*ALPHA*DM
C (0,18)
         CN(J) = -ALPHA*(DL+DM)
C (0,19)
         BN(J) = ALPHA*(DL-DM)
C (0,20)
         H0 = HELP(J-1)
C (0,21)
         H1 = HELP(J)
C (0,22)
         H2 = HELP(J+1)
C (0,23)
C
         HELPA(J) = BETA*(DL+DM)*H2+(1.D0-2.D0*BETA*DM)*H1+BETA*(DM-
     &   DL)*H0+DELTAT*FORCN(J)
C (0,24)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,25)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20586 CALL DOOUTX( 586 )
CY20586 CALL DOOUTY( 586 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,26)
CX40056 CALL SBOUTX (56)
CY40056 CALL SBOUTY (56)
      RETURN
C     END BLOCK
      END

C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND THE PADE DERIVATIVES AND CRANK-NICKOLSON TECHNIQUE *
C ***         FOR THE POTENTIAL TEMPERATURE THETA  ONLY ]]]            *
C **********************************************************************
C
C
      SUBROUTINE TPADE(DKS,HVAR,HELP,HELPA,NS,DELTAT,DELS,DZ,W,SYNFOR,
     *AN,BN,CN,IK,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_DTDTZ_DKS),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_
     x RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN
     x _BN),CN(I_PIPS_RUN_CN),W(I_PIPS_RUN_DCDX)
      DIMENSION SYNFOR(I_PIPS_DTDTZ_FORC)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP
      PARAMETER (F1 = .833333333, F2 = .083333333, F3 = .6666666666,
     *           BT = 0.166666667)
      PARAMETER (FLUX = 0.0)
C (0,1)
      INTEGER*8 I_PIPS_DTDTZ_DKS
      COMMON /PIPS_DTDTZ_DKS/ I_PIPS_DTDTZ_DKS
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DTDTZ_FORC
      COMMON /PIPS_DTDTZ_FORC/ I_PIPS_DTDTZ_FORC
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30057 CALL SBINX (57)
CY30057 CALL SBINY (57)
      SS = DELTAT/(2.D0*DH*DH)
C (0,3)
      N1 = NS-1
C (0,4)
      NPTS = NS-2
C (0,5)
      JS = 2
C (0,6)
CX10587 CALL DOINX( 587 )
CY10587 CALL DOINY( 587 )
C
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,7)
C        BEGIN BLOCK
C (0,8)
         BS = SS*DKS(J)*HVAR(J)*HVAR(J)
C (0,9)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C
         AN(J) = F1+2.D0*BS
C (0,10)
         BN(J) = F2-BS
C (0,11)
         CN(J) = F2-BS
C (0,12)
         H0 = HELP(J-1)
C (0,13)
         H1 = HELP(J)
C (0,14)
         H2 = HELP(J+1)
C (0,15)
         IF (J.EQ.2) THEN
C (0,16)
            FORC = BN(J)*H0
         ELSE
C (0,17)
            FORC = 0.0D0
         ENDIF
C (0,18)
C
         HELPA(J) = (BS+F2)*(H0+H2)+(F1-2.D0*BS)*H1-FORC
C (0,19)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,20)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20588 CALL DOOUTX( 588 )
CY20588 CALL DOOUTY( 588 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,21)
      DELT = 1.D0
C (0,22)
      IF (IT.EQ.0) THEN
C (0,23)
         DELT = 0.0D0
      ELSE
C (0,24)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,25)
C
C      FORM THE FORCING ARRAY  TO SOLVE THE (DKS/DS)*(DC/DS) PART
C
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,26)
CX10589 CALL DOINX( 589 )
CY10589 CALL DOINY( 589 )
!     INITIALLY: DO 20
      DO J = JS, N1
C (0,27)
C        BEGIN BLOCK
C (0,28)
         AS = (HELPA(J)-W(J)/HVAR(J)-DELT*DKS(J)/ALP)*HVAR(J)*HVAR(J)
     &   *DELTAT/(4.D0*DH)
C (0,29)
         AN(J) = F3
C (0,30)
         BN(J) = BT+AS
C (0,31)
         CN(J) = BT-AS
C (0,32)
         H0 = HELP(J-1)
C (0,33)
         H1 = HELP(J)
C (0,34)
         H2 = HELP(J+1)
C (0,35)
         IF (J.EQ.2) THEN
C (0,36)
            FORC = BN(J)*H0
         ELSE
C (0,37)
            FORC = 0.0D0
         ENDIF
C (0,38)
C
         HELPA(J) = (BT+AS)*H2+F3*H1+(BT-AS)*H0-FORC+DELTAT*SYNFOR(J)
C (0,39)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,40)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20590 CALL DOOUTX( 590 )
CY20590 CALL DOOUTY( 590 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,41)
CX40058 CALL SBOUTX (58)
CY40058 CALL SBOUTY (58)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND CRANK-NICKOLSON WITH UPWINDING (A=.5 TECHNIQUE)    *
C ***              FOR POTENTIAL TEMPERATURE THETA ONLY ]]]            *
C **********************************************************************
C
      SUBROUTINE TCRANK(DKS,HVAR,HELP,HELPA,NS,DELTAT,DELS,DZ,W,SYNFOR,
     *AN,BN,CN,IK,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_DTDTZ_DKS),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_
     x RUN_HELP),HELPA(I_PIPS_RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN
     x _BN),CN(I_PIPS_RUN_CN),W(I_PIPS_RUN_DCDX)
      DIMENSION SYNFOR(I_PIPS_DTDTZ_FORC)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_DTDTZ_DKS
      COMMON /PIPS_DTDTZ_DKS/ I_PIPS_DTDTZ_DKS
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DTDTZ_FORC
      COMMON /PIPS_DTDTZ_FORC/ I_PIPS_DTDTZ_FORC
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30059 CALL SBINX (59)
CY30059 CALL SBINY (59)
      SCND = DELTAT/(DH*DH)
C (0,3)
      FRST = DELTAT/(2.D0*DH)
C (0,4)
      N1 = NS-1
C (0,5)
      DELT = 1.D0
C (0,6)
      NPTS = NS-2
C (0,7)
      JS = 2
C (0,8)
      IF (IT.EQ.0) THEN
C (0,9)
         DELT = 0.0D0
      ELSE
C (0,10)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,11)
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,12)
      BETA = 1.-ALPHA
C (0,13)
CX10591 CALL DOINX( 591 )
CY10591 CALL DOINY( 591 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,14)
C        BEGIN BLOCK
C (0,15)
         DL = FRST*HVAR(J)*HVAR(J)*(HELPA(J)-W(J)/HVAR(J)-DELT*DKS(J)
     &   /ALP)
C (0,16)
         DM = SCND*HVAR(J)*HVAR(J)*DKS(J)
C (0,17)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = 1.D0+2.D0*ALPHA*DM
C (0,18)
         CN(J) = -ALPHA*(DL+DM)
C (0,19)
         BN(J) = ALPHA*(DL-DM)
C (0,20)
         H0 = HELP(J-1)
C (0,21)
         H1 = HELP(J)
C (0,22)
         H2 = HELP(J+1)
C (0,23)
         IF (J.EQ.2) THEN
C (0,24)
            FORC = BN(J)*H0
         ELSE
C (0,25)
            FORC = 0.0D0
         ENDIF
C (0,26)
C
         HELPA(J) = BETA*(DL+DM)*H2+(1.D0-2.D0*BETA*DM)*H1+BETA*(DM-
     &   DL)*H0+DELTAT*SYNFOR(J)-FORC
C (0,27)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,28)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20592 CALL DOOUTX( 592 )
CY20592 CALL DOOUTY( 592 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,29)
CX40060 CALL SBOUTX (60)
CY40060 CALL SBOUTY (60)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND THE PADE DERIVATIVES AND CRANK-NICKOLSON TECHNIQUE *
C ***         FOR THE MEAN POTENTIAL TEMPERATURE THETA  ONLY ]]]       *
C ***     ALLOW FLUX ZERO LOWER BOUNDARY CONDITIONS FOR MEAN TM        *
C **********************************************************************
C
C
      SUBROUTINE TMPADE(DKS,HVAR,HELP,HELPA,NS,AN,BN,CN,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_RUN_DKM),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_RU
     x N_TM),HELPA(I_PIPS_RUN_VM),AN(I_PIPS_RUN_DCDX),BN(-2*NS+I_PIPS_RU
     x N_DCDX),CN(-4*NS+I_PIPS_RUN_DCDX)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA ,HAMP,BUMP
      PARAMETER (F1 = .833333333, F2 = .083333333, F3 = .6666666666,
     *           BT = 0.166666667)
      PARAMETER (FLUX = 0.0)
C (0,1)
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30061 CALL SBINX (61)
CY30061 CALL SBINY (61)
      SS = DT/(2.D0*DH*DH)
C (0,3)
C  FOR FIXED BOUNDARY CONDITIONS
C      NPTS=NS-2
C      JS=2
      N1 = NS-1
C (0,4)
      NPTS = NS-1
C (0,5)
      JS = 1
C (0,6)
CX10593 CALL DOINX( 593 )
CY10593 CALL DOINY( 593 )
C
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,7)
C        BEGIN BLOCK
C (0,8)
         BS = SS*DKS(J)*HVAR(J)*HVAR(J)
C (0,9)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C
         AN(J) = F1+2.D0*BS
C (0,10)
         BN(J) = F2-BS
C (0,11)
         CN(J) = F2-BS
C (0,12)
         H1 = HELP(J)
C (0,13)
         H2 = HELP(J+1)
C (0,14)
         FORC = 0.0D0
C (0,15)
         IF (J.EQ.1) THEN
C (0,16)
C           BEGIN BLOCK
C (0,17)
            CN(J) = CN(J)+BN(J)
C (0,18)
            H0 = HELP(J+1)
C           END BLOCK
         ELSE
C (0,19)
            H0 = HELP(J-1)
         ENDIF
C (0,20)
         IF (J.EQ.N1) THEN
C (0,21)
            FORC = CN(J)*H2
         ELSE
C (0,22)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,23)
C  FOR FIXED LOWER BOUNDARY CONDITIONS
C         H0=HELP(J-1)
C         IF(J.EQ.2) FORC=BN(J)*H0
C
         HELPA(J) = (BS+F2)*(H0+H2)+(F1-2.D0*BS)*H1-FORC
C (0,24)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,25)
      I_PIPS_TRID_BN = -2*NS+I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_CN = -4*NS+I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_VM-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_TM-(JS-1)
CX20594 CALL DOOUTX( 594 )
CY20594 CALL DOOUTY( 594 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,26)
      DELT = 1.D0
C (0,27)
      IF (IT.EQ.0) THEN
C (0,28)
         DELT = 0.0D0
      ELSE
C (0,29)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,30)
C
C      FORM THE FORCING ARRAY  TO SOLVE THE (DTM/DS)*(DK/DS) PART
C
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,31)
CX10595 CALL DOINX( 595 )
CY10595 CALL DOINY( 595 )
!     INITIALLY: DO 20
      DO J = JS, N1
C (0,32)
C        BEGIN BLOCK
C (0,33)
         AS = (HELPA(J)-DELT*DKS(J)/ALP)*HVAR(J)*HVAR(J)*DT/(4.D0*DH)
C (0,34)
         AN(J) = F3
C (0,35)
         BN(J) = BT+AS
C (0,36)
         CN(J) = BT-AS
C (0,37)
         H1 = HELP(J)
C (0,38)
         H2 = HELP(J+1)
C (0,39)
         FORC = 0.0D0
C (0,40)
C  FOR FIXED BOUNDARY CONDITIONS
C         H0=HELP(J-1)
C         IF(J.EQ.2) FORC=BN(J)*H0
         IF (J.EQ.1) THEN
C (0,41)
C           BEGIN BLOCK
C (0,42)
            CN(J) = CN(J)+BN(J)
C (0,43)
            H0 = HELP(J+1)
C           END BLOCK
         ELSE
C (0,44)
            H0 = HELP(J-1)
         ENDIF
C (0,45)
         IF (J.EQ.N1) THEN
C (0,46)
            FORC = CN(J)*H2
         ELSE
C (0,47)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,48)
C
         HELPA(J) = (BT+AS)*H2+F3*H1+(BT-AS)*H0-FORC
C (0,49)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,50)
      I_PIPS_TRID_BN = -2*NS+I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_CN = -4*NS+I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_VM-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_TM-(JS-1)
CX20596 CALL DOOUTX( 596 )
CY20596 CALL DOOUTY( 596 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,51)
CX40062 CALL SBOUTX (62)
CY40062 CALL SBOUTY (62)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES VARIABLE DIFFUSIVITIES IN Z - AXIS   *
C ***     EMPLOYIND CRANK-NICKOLSON WITH UPWINDING (A=.5 TECHNIQUE)    *
C ***     FOR THE MEAN POTENTIAL TEMPERATURE THETA ONLY ]]]            *
C ***     ALLOW FLUX ZERO LOWER BOUNDARY CONDITIONS FOR MEAN TM        *
C **********************************************************************
C
      SUBROUTINE TMCRNK(DKS,HVAR,HELP,HELPA,NS,AN,BN,CN,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKS(I_PIPS_RUN_DKM),HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_RU
     x N_TM),HELPA(I_PIPS_RUN_VM),AN(I_PIPS_RUN_DCDX),BN(-2*NS+I_PIPS_RU
     x N_DCDX),CN(-4*NS+I_PIPS_RUN_DCDX)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30063 CALL SBINX (63)
CY30063 CALL SBINY (63)
      SCND = DT/(DH*DH)
C (0,3)
      FRST = DT/(2.D0*DH)
C (0,4)
C  FOR FIXED BOUNDARY CONDITIONS
C      NPTS=NS-2
C      JS=2
      N1 = NS-1
C (0,5)
      DELT = 1.D0
C (0,6)
      NPTS = NS-1
C (0,7)
      JS = 1
C (0,8)
      IF (IT.EQ.0) THEN
C (0,9)
         DELT = 0.0D0
      ELSE
C (0,10)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,11)
      CALL DCTDXF(NS, 1, DKS, HELPA, DH)
C (0,12)
      BETA = 1.-ALPHA
C (0,13)
CX10597 CALL DOINX( 597 )
CY10597 CALL DOINY( 597 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,14)
C        BEGIN BLOCK
C (0,15)
         DL = FRST*HVAR(J)*HVAR(J)*(HELPA(J)-DELT*DKS(J)/ALP)
C (0,16)
         DM = SCND*HVAR(J)*HVAR(J)*DKS(J)
C (0,17)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = 1.D0+2.D0*ALPHA*DM
C (0,18)
         CN(J) = -ALPHA*(DL+DM)
C (0,19)
         BN(J) = ALPHA*(DL-DM)
C (0,20)
         H1 = HELP(J)
C (0,21)
         H2 = HELP(J+1)
C (0,22)
         FORC = 0.0D0
C (0,23)
C
C  FOR FIXED BOUNDARY CONDITIONS
C         H0=HELP(J-1)
C         IF(J.EQ.2) FORC=BN(J)*H0
         IF (J.EQ.1) THEN
C (0,24)
C           BEGIN BLOCK
C (0,25)
            CN(J) = CN(J)+BN(J)
C (0,26)
            H0 = HELP(J+1)
C           END BLOCK
         ELSE
C (0,27)
            H0 = HELP(J-1)
         ENDIF
C (0,28)
         IF (J.EQ.N1) THEN
C (0,29)
            FORC = CN(J)*H2
         ELSE
C (0,30)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,31)
C
         HELPA(J) = BETA*(DL+DM)*H2+(1.D0-2.D0*BETA*DM)*H1+BETA*(DM-
     &   DL)*H0-FORC
C (0,32)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,33)
      I_PIPS_TRID_BN = -2*NS+I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_CN = -4*NS+I_PIPS_RUN_DCDX-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_VM-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_TM-(JS-1)
CX20598 CALL DOOUTX( 598 )
CY20598 CALL DOOUTY( 598 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,34)
CX40064 CALL SBOUTX (64)
CY40064 CALL SBOUTY (64)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     THIS ROUTINE CALCULATES IMPLICITLY THE VERTICAL VELOCITIES   *
C ***     EMPLOYIND CRANK-NICKOLSON WITH UPWINDING (A=.5 TECHNIQUE)    *
C **********************************************************************
C
      SUBROUTINE DWDZ(NS,ZET,HVAR,HELP,HELPA,AN,BN,CN,IT)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION HVAR(I_PIPS_RUN_HVAR),HELP(I_PIPS_RUN_HELP),HELPA(I_PIPS
     x _RUN_HELPA),AN(I_PIPS_RUN_AN),BN(I_PIPS_RUN_BN),CN(I_PIPS_RUN_CN)
     x ,ZET(I_PIPS_RUN_ZET)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30065 CALL SBINX (65)
CY30065 CALL SBINY (65)
      DL = 0.5D0*DH/ALP
C (0,3)
      N1 = NS-1
C (0,4)
      NPTS = NS-2
C (0,5)
      JS = 2
C (0,6)
      IF (IT.EQ.0) THEN
C (0,7)
         DL = 0.0D0
      ELSE
C (0,8)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,9)
CX10599 CALL DOINX( 599 )
CY10599 CALL DOINY( 599 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,10)
C        BEGIN BLOCK
C (0,11)
C
C        FORM THE FORCING ARRAY  TO SOLVE THE KS(S)D2C/DS2 PART
C        AN IS THE MIDDLE DIAGONAL VECTOR,BN, THE FIRST, CN THE LAST.
C
         AN(J) = -2.D0
C (0,12)
         CN(J) = 1.D0-DL
C (0,13)
         BN(J) = 1.D0+DL
C (0,14)
         H0 = HELP(J-1)
C (0,15)
         H2 = HELP(J+1)
C (0,16)
C
         HELPA(J) = DH*(H0-H2)/(2.D0*HVAR(J))
C (0,17)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,18)
      I_PIPS_TRID_BN = I_PIPS_RUN_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_RUN_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_RUN_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_RUN_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_RUN_HELP-(JS-1)
CX20600 CALL DOOUTX( 600 )
CY20600 CALL DOOUTY( 600 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,19)
CX40066 CALL SBOUTX (66)
CY40066 CALL SBOUTY (66)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     M O D I F I E D   G A U S S I A N   E L I M I N A T I O N    *
C ***     THIS ROUTINE IS A TRIDIAGONAL MATRIX SOLVER.                 *
C ***     GIVEN THAT L IS A TRIDIAGONAL MATRIX, THE ROUTINE SOLVES     *
C ***     FOR G  AT THE SYSTEM   L*G=F WHERE  L=BN,AN,CN               *
C **********************************************************************
C
      SUBROUTINE TRID(M,BN,AN,CN,FN,GN)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION AN(I_PIPS_TRID_AN),BN(I_PIPS_TRID_BN),CN(I_PIPS_TRID_CN)
     x ,FN(I_PIPS_TRID_FN),GN(I_PIPS_TRID_GN)
C (0,1)
      INTEGER*8 I_PIPS_RUN_BN
      COMMON /PIPS_RUN_BN/ I_PIPS_RUN_BN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_RUN_AN
      COMMON /PIPS_RUN_AN/ I_PIPS_RUN_AN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_RUN_CN
      COMMON /PIPS_RUN_CN/ I_PIPS_RUN_CN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30067 CALL SBINX (67)
CY30067 CALL SBINY (67)
      M1 = M-1
C (0,3)
CX10601 CALL DOINX( 601 )
CY10601 CALL DOINY( 601 )
!     INITIALLY: DO 10
      DO I = 2, M
C (0,4)
C        BEGIN BLOCK
C (0,5)
         R = BN(I)/AN(I-1)
C (0,6)
         AN(I) = AN(I)-R*CN(I-1)
C (0,7)
         FN(I) = FN(I)-R*FN(I-1)
C (0,8)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,9)
CX20602 CALL DOOUTX( 602 )
CY20602 CALL DOOUTY( 602 )
C
C     BACK SUBSTITUTION
C
      GN(M) = FN(M)/AN(M)
C (0,10)
CX10603 CALL DOINX( 603 )
CY10603 CALL DOINY( 603 )
!     INITIALLY: DO 20
      DO I = 1, M1
C (0,11)
C        BEGIN BLOCK
C (0,12)
         II = M-I
C (0,13)
         GN(II) = (FN(II)-CN(II)*GN(II+1))/AN(II)
C (0,14)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,15)
CX20604 CALL DOOUTX( 604 )
CY20604 CALL DOOUTY( 604 )
CX40068 CALL SBOUTX (68)
CY40068 CALL SBOUTY (68)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C ***     M O D I F I E D   G A U S S I A N   E L I M I N A T I O N    *
C ***     THIS ROUTINE IS A COMPLEX TRIDIAGONAL MATRIX SOLVER.         *
C ***     GIVEN THAT L IS A TRIDIAGONAL MATRIX, THE ROUTINE SOLVES     *
C ***     FOR G  AT THE SYSTEM   L*G=F WHERE  L=BN,AN,CN               *
C **********************************************************************
C
      SUBROUTINE TRIDC(M,BN,AN,CN,FN,GN)
      COMPLEX*16 AN(8*I_PIPS_RUN_DCDX/16-(2-1)),BN((-16*(M+2)+8*I_PIPS_R
     x UN_DCDX)/16-(2-1)),CN((-32*(M+2)+8*I_PIPS_RUN_DCDX)/16-(2-1)),FN(
     x (-48*(M+2)+8*I_PIPS_RUN_DCDX)/16-(2-1)),GN((-64*(M+2)+8*I_PIPS_RU
     x N_DCDX)/16-(2-1))
      COMPLEX*16 R
C (0,1)
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
C     BEGIN BLOCK
C (0,2)
CX30069 CALL SBINX (69)
CY30069 CALL SBINY (69)
      M1 = M-1
C (0,3)
CX10605 CALL DOINX( 605 )
CY10605 CALL DOINY( 605 )
!     INITIALLY: DO 10
      DO I = 2, M
C (0,4)
C        BEGIN BLOCK
C (0,5)
         R = BN(I)/AN(I-1)
C (0,6)
         AN(I) = AN(I)-R*CN(I-1)
C (0,7)
         FN(I) = FN(I)-R*FN(I-1)
C (0,8)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,9)
CX20606 CALL DOOUTX( 606 )
CY20606 CALL DOOUTY( 606 )
C
C     BACK SUBSTITUTION
C
      GN(M) = FN(M)/AN(M)
C (0,10)
CX10607 CALL DOINX( 607 )
CY10607 CALL DOINY( 607 )
!     INITIALLY: DO 20
      DO I = 1, M1
C (0,11)
C        BEGIN BLOCK
C (0,12)
         II = M-I
C (0,13)
         GN(II) = (FN(II)-CN(II)*GN(II+1))/AN(II)
C (0,14)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,15)
CX20608 CALL DOOUTX( 608 )
CY20608 CALL DOOUTY( 608 )
CX40070 CALL SBOUTX (70)
CY40070 CALL SBOUTY (70)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *   SUBROUTINE  LIPFRG  CARRIES OUT THE TIME-INTEGRATION BY THE USE  *
C *   OF THE WELL-KNOWN LEAP-FROG (MID-POINT) RULE.                    *
C *   FOR DF/DT=LF  (L=DIFFERENTIAL OPERATOR,F=UNKOWN FUNCTION) THEN,  *
C *   F(X1)=F(X0) + 1*DT*{LUF(X0)E}  => EULER FORWARD FOR T=0  AND     *
C *   F(X2)=F(X0) + 2*DT*{LUF(X1)E}  => LEAPFROG FOR T>0               *
C **********************************************************************
C
      SUBROUTINE LEAPFR(NSTEP,LOOP,DELTAT,F2,F1,F0)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION F2(I_PIPS_LEAPFR_F2),F1(I_PIPS_RUN_DCDX),F0(I_PIPS_LEAPF
     x R_F0)
C (0,1)
      INTEGER*8 I_PIPS_RUN_POTT
      COMMON /PIPS_RUN_POTT/ I_PIPS_RUN_POTT
      INTEGER*8 I_PIPS_LEAPFR_F2
      COMMON /PIPS_LEAPFR_F2/ I_PIPS_LEAPFR_F2
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_STEPC
      COMMON /PIPS_RUN_STEPC/ I_PIPS_RUN_STEPC
      INTEGER*8 I_PIPS_RUN_STEPT
      COMMON /PIPS_RUN_STEPT/ I_PIPS_RUN_STEPT
      INTEGER*8 I_PIPS_LEAPFR_F0
      COMMON /PIPS_LEAPFR_F0/ I_PIPS_LEAPFR_F0
C     BEGIN UNSTRUCTURED
C (1,1)
CX30071 CALL SBINX (71)
CY30071 CALL SBINY (71)
C
      IF (NSTEP.GT.1) GOTO 20
C (4,1)
C     BEGIN BLOCK
C (4,2)
CX10609 CALL DOINX( 609 )
CY10609 CALL DOINY( 609 )
C
C       USE THE EXPLICIT   EULER   FORMULA AT THE STARTING
C       PHASE OF THE INTEGRATION PROCESS.
C
C
!     INITIALLY: DO 10
      DO I = 1, LOOP
C (4,3)
C        BEGIN BLOCK
C (4,4)
         F0(I) = F2(I)
C (4,5)
         F2(I) = F2(I)+DELTAT*F1(I)
C (4,6)
10       CONTINUE
C        END BLOCK
      ENDDO
CX20610 CALL DOOUTX( 610 )
CY20610 CALL DOOUTY( 610 )
CX40072 CALL SBOUTX (72)
CY40072 CALL SBOUTY (72)
C     END BLOCK
      RETURN
C (2,1)
C     BEGIN BLOCK
C (2,2)
C
C       CARRY OUT THE COMPUTATIONS WITH THE BASIC FORMULA
C       (THE LEAP-FROG RULE; THE MID-POINT RULE).
C
20    CONTINUE
C (2,3)
CX10611 CALL DOINX( 611 )
CY10611 CALL DOINY( 611 )
!     INITIALLY: DO 30
      DO I = 1, LOOP
C (2,4)
C        BEGIN BLOCK
C (2,5)
         Y2 = F2(I)
C (2,6)
         F2(I) = F0(I)+2.*DELTAT*F1(I)
C (2,7)
         F0(I) = Y2
C (2,8)
30       CONTINUE
C        END BLOCK
      ENDDO
CX20612 CALL DOOUTX( 612 )
CY20612 CALL DOOUTY( 612 )
CX40072 CALL SBOUTX (72)
CY40072 CALL SBOUTY (72)
C
C     END BLOCK
C (3,1)
      RETURN
C     END UNSTRUCTURED
      END
C
C   ********************************************************************
C   *     X-DERIVATIVE OF UNKNOWN FUNCTION VIA FINITE DIDFFERENCES     *
C   ********************************************************************
C
      SUBROUTINE DCTDXF(NX,NY,C,DCDX,DELTAX)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDX(NX,NY)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30073 CALL SBINX (73)
CY30073 CALL SBINY (73)
      D = 12.*DELTAX
C (0,3)
      NX1 = NX-1
C (0,4)
      NX2 = NX-2
C (0,5)
CX10613 CALL DOINX( 613 )
CY10613 CALL DOINY( 613 )
!     INITIALLY: DO 20
      DO J = 1, NY
C (0,6)
C        BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 10
         DO I = 3, NX2
C (0,8)
C           BEGIN BLOCK
C (0,9)
            DCDX(I,J) = (C(I-2,J)-8.*C(I-1,J)+8*C(I+1,J)-C(I+2,J))/D
C (0,10)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,11)
         DCDX(1,J) = (-25.*C(1,J)+48.*C(2,J)-36.*C(3,J)+16.*C(4,J)-3.
     &   *C(5,J))/D
C (0,12)
         DCDX(2,J) = (-3.*C(1,J)-10.*C(2,J)+18.*C(3,J)-6.*C(4,J)+C(5,
     &   J))/D
C (0,13)
         DCDX(NX,J) = (3.*C(NX-4,J)-16.*C(NX-3,J)+36.*C(NX-2,J)-48.*C
     &   (NX-1,J)+25.*C(NX,J))/D
C (0,14)
         DCDX(NX1,J) = (-C(NX-4,J)+6.*C(NX-3,J)-18.*C(NX-2,J)+10.*C(
     &   NX-1,J)+3.*C(NX,J))/D
C (0,15)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,16)
CX20614 CALL DOOUTX( 614 )
CY20614 CALL DOOUTY( 614 )
CX40074 CALL SBOUTX (74)
CY40074 CALL SBOUTY (74)
C
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *    Y-DERIVATIVE OF UNKNOWN FUNCTION VIA FINITE DIDFFERENCES      *
C   ********************************************************************
C
      SUBROUTINE DCTDYF(NX,NY,C,DCDY,DELTAY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY),DCDY(NX,NY)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30075 CALL SBINX (75)
CY30075 CALL SBINY (75)
      D = 12.*DELTAY
C (0,3)
      NY1 = NY-1
C (0,4)
      NY2 = NY-2
C (0,5)
CX10615 CALL DOINX( 615 )
CY10615 CALL DOINY( 615 )
!     INITIALLY: DO 20
      DO I = 1, NX
C (0,6)
C        BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 10
         DO J = 3, NY2
C (0,8)
C           BEGIN BLOCK
C (0,9)
            DCDY(I,J) = (C(I,J-2)-8.*C(I,J-1)+8*C(I,J+1)-C(I,J+2))/D
C (0,10)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,11)
         DCDY(I,1) = (-25.*C(I,1)+48.*C(I,2)-36.*C(I,3)+16.*C(I,4)-3.
     &   *C(I,5))/D
C (0,12)
         DCDY(I,2) = (-3.*C(I,1)-10.*C(I,2)+18.*C(I,3)-6.*C(I,4)+C(I,
     &   5))/D
C (0,13)
         DCDY(I,NY) = (3.*C(I,NY-4)-16.*C(I,NY-3)+36.*C(I,NY-2)-48.*C
     &   (I,NY-1)+25.*C(I,NY))/D
C (0,14)
         DCDY(I,NY1) = (-C(I,NY-4)+6.*C(I,NY-3)-18.*C(I,NY-2)+10.*C(I
     &   ,NY-1)+3.*C(I,NY))/D
C (0,15)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,16)
CX20616 CALL DOOUTX( 616 )
CY20616 CALL DOOUTY( 616 )
CX40076 CALL SBOUTX (76)
CY40076 CALL SBOUTY (76)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C **                  STRECH THE VERTICAL VARIABLE                     *
C **   CHANGE THE VERTICAL VARIABLE Z TO A NONDIMENSIONAL H (0,1)      *
C **   AND CALCULATE THE TERMS DH/DZ FOR THE DERIVATIVES               *
C **********************************************************************
C
      SUBROUTINE STRECH(FILZ,HVAR,ZET,NZ,DELTAZ,NP,ITYPE)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION HVAR(I_PIPS_RUN_HVAR) ,ZET(I_PIPS_RUN_ZET),FILZ(I_PIPS_S
     x TRECH_FILZ)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
      INTEGER*8 I_PIPS_STRECH_FILZ
      COMMON /PIPS_STRECH_FILZ/ I_PIPS_STRECH_FILZ
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
C     BEGIN BLOCK
C (0,2)
CX30077 CALL SBINX (77)
CY30077 CALL SBINY (77)
      D1 = FLOAT(NZ-1)
C (0,3)
      DH = 1./D1
C (0,4)
      IF (ITYPE.EQ.0) THEN
C (0,5)
         DH = DELTAZ
      ELSE
C (0,6)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,7)
      H = 0.0
C (0,8)
CX10617 CALL DOINX( 617 )
CY10617 CALL DOINY( 617 )
!     INITIALLY: DO 10
      DO K = 1, NZ
C (0,9)
C        BEGIN BLOCK
C (0,10)
         FILZ(K) = 1.0
C (0,11)
         IF (ITYPE.GT.0) THEN
C (0,12)
C           BEGIN BLOCK
C (0,13)
            ARG = H/ALP
C (0,14)
            Z = EXP(ARG)
C (0,15)
            ZET(K) = BET*(Z-1.0)
C (0,16)
            HVAR(K) = ALP/(Z*BET)
C           END BLOCK
         ELSE
C (0,17)
C           BEGIN BLOCK
C (0,18)
            ZET(K) = H
C (0,19)
            HVAR(K) = 1.
C           END BLOCK
         ENDIF
C (0,20)
         H = H+DH
C (0,21)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,22)
CX20618 CALL DOOUTX( 618 )
CY20618 CALL DOOUTY( 618 )
      FILZ(NZ) = 0.0
C (0,23)
      FILZ(NZ-1) = 0.25
C (0,24)
      FILZ(NZ-2) = 0.5
C (0,25)
      FILZ(NZ-3) = 0.75
C (0,26)
      DELTAZ = ZET(2)-ZET(1)
C (0,27)
      NP = NZ
C (0,28)
CX10619 CALL DOINX( 619 )
CY10619 CALL DOINY( 619 )
!     INITIALLY: DO 20
      DO K = 2, NZ
C (0,29)
C        BEGIN BLOCK
C (0,30)
         IF (ZH.GT.ZET(K-1).AND.ZH.LT.ZET(K)) THEN
C (0,31)
            IF (ABS(ZH-ZET(K-1)).GT.ABS(ZH-ZET(K))) THEN
C (0,32)
               NP = K
            ELSE
C (0,33)
               NP = K-1
            ENDIF
         ELSE
C (0,34)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,35)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,36)
CX20620 CALL DOOUTX( 620 )
CY20620 CALL DOOUTY( 620 )
CX40078 CALL SBOUTX (78)
CY40078 CALL SBOUTY (78)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *       THREE POINT DISTANCE WEIGHTED SMOOTHER FOR REAL VARIABLES    *
C **********************************************************************
C
      SUBROUTINE SMTH(F,Z,NZ)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 F(I_PIPS_SMTH_F),Z(I_PIPS_SMTH_Z)
C (0,1)
      INTEGER*8 I_PIPS_BLM_DKZ
      COMMON /PIPS_BLM_DKZ/ I_PIPS_BLM_DKZ
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_BLM_ZET
      COMMON /PIPS_BLM_ZET/ I_PIPS_BLM_ZET
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
C     BEGIN BLOCK
C (0,2)
CX30079 CALL SBINX (79)
CY30079 CALL SBINY (79)
      NZ1 = NZ-1
C (0,3)
      F1 = F(1)
C (0,4)
CX10621 CALL DOINX( 621 )
CY10621 CALL DOINY( 621 )
!     INITIALLY: DO 10
      DO K = 2, NZ1
C (0,5)
C        BEGIN BLOCK
C (0,6)
         F0 = 0.5*F(K)+0.125*(Z(K+1)-Z(K-1))*(F(K+1)/(Z(K+1)-Z(K))+F1
     &   /(Z(K)-Z(K-1)))
C (0,7)
         F1 = F(K)
C (0,8)
         F(K) = F0
C (0,9)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,10)
CX20622 CALL DOOUTX( 622 )
CY20622 CALL DOOUTY( 622 )
CX40080 CALL SBOUTX (80)
CY40080 CALL SBOUTY (80)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *       THREE POINT DISTANCE WEIGHTED SMOOTHER FOR FORCING FUNCTION  *
C **********************************************************************
C
      SUBROUTINE SMTHF(F,Z,NZ)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 F(I_PIPS_SMTHF_F),Z(I_PIPS_RUN_ZET)
C (0,1)
      INTEGER*8 I_PIPS_DTDTZ_FORC
      COMMON /PIPS_DTDTZ_FORC/ I_PIPS_DTDTZ_FORC
      INTEGER*8 I_PIPS_DUDTZ_FORC
      COMMON /PIPS_DUDTZ_FORC/ I_PIPS_DUDTZ_FORC
      INTEGER*8 I_PIPS_SMTHF_F
      COMMON /PIPS_SMTHF_F/ I_PIPS_SMTHF_F
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
C     BEGIN BLOCK
C (0,2)
CX30081 CALL SBINX (81)
CY30081 CALL SBINY (81)
      NZ2 = NZ-2
C (0,3)
      F1 = F(2)
C (0,4)
CX10623 CALL DOINX( 623 )
CY10623 CALL DOINY( 623 )
!     INITIALLY: DO 10
      DO K = 3, NZ2
C (0,5)
C        BEGIN BLOCK
C (0,6)
         F0 = 0.5*F(K)+0.125*(Z(K+1)-Z(K-1))*(F(K+1)/(Z(K+1)-Z(K))+F1
     &   /(Z(K)-Z(K-1)))
C (0,7)
         F1 = F(K)
C (0,8)
         F(K) = F0
C (0,9)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,10)
CX20624 CALL DOOUTX( 624 )
CY20624 CALL DOOUTY( 624 )
CX40082 CALL SBOUTX (82)
CY40082 CALL SBOUTY (82)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *       THREE POINT DISTANCE WEIGHTED SMOOTHER FOR COMPLEX VARIABLES *
C **********************************************************************
C
      SUBROUTINE CSMTH(F,Z,NZ)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 Z(I_PIPS_CSMTH_Z)
      COMPLEX*16 F(I_PIPS_CSMTH_F),F1,F0
C (0,1)
      INTEGER*8 I_PIPS_CSMTH_F
      COMMON /PIPS_CSMTH_F/ I_PIPS_CSMTH_F
      INTEGER*8 I_PIPS_CSMTH_Z
      COMMON /PIPS_CSMTH_Z/ I_PIPS_CSMTH_Z
C     BEGIN BLOCK
C (0,2)
CX30083 CALL SBINX (83)
CY30083 CALL SBINY (83)
      NZ1 = NZ-1
C (0,3)
      F1 = F(1)
C (0,4)
CX10625 CALL DOINX( 625 )
CY10625 CALL DOINY( 625 )
!     INITIALLY: DO 10
      DO K = 2, NZ1
C (0,5)
C        BEGIN BLOCK
C (0,6)
         F0 = 0.5*F(K)+0.125*(Z(K+1)-Z(K-1))*(F(K+1)/(Z(K+1)-Z(K))+F1
     &   /(Z(K)-Z(K-1)))
C (0,7)
         F1 = F(K)
C (0,8)
         F(K) = F0
C (0,9)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,10)
CX20626 CALL DOOUTX( 626 )
CY20626 CALL DOOUTY( 626 )
CX40084 CALL SBOUTX (84)
CY40084 CALL SBOUTY (84)
      RETURN
C     END BLOCK
      END
C
C  *********************************************************************
C  *                      2-D SETUP SMOOTHING ROUTINE                  *
C  *********************************************************************
C
      SUBROUTINE SMOOTH(F,NX,NY,NZ)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 F(NX*NY*NZ)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30085 CALL SBINX (85)
CY30085 CALL SBINY (85)
      MLAG = 1
C (0,3)
      NZTOP = NZ-2
C (0,4)
CX10627 CALL DOINX( 627 )
CY10627 CALL DOINY( 627 )
C
!     INITIALLY: DO 10
      DO II = 1, NZTOP
C (0,5)
C        BEGIN BLOCK
C (0,6)
         MLAG = MLAG+NX*NY
C (0,7)
         CALL HORSMT(NX, NY, F(MLAG))
C (0,8)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,9)
CX20628 CALL DOOUTX( 628 )
CY20628 CALL DOOUTY( 628 )
CX40086 CALL SBOUTX (86)
CY40086 CALL SBOUTY (86)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *         2-D SETUP IMPLICIT SMOOTHING ROUTINE                       *
C **********************************************************************
C
      SUBROUTINE SMIM(F,NX,NY,NZ,DL,HELP,HELPA,AN,BN,CN)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 F(I_PIPS_RUN_VY),HELP(I_PIPS_RUN_DCDX),HELPA(I_PIPS_SMIM_HE
     x LPA),AN(I_PIPS_SMIM_AN),BN(I_PIPS_SMIM_BN),CN(I_PIPS_SMIM_CN)
C (0,1)
      INTEGER*8 I_PIPS_RUN_POTT
      COMMON /PIPS_RUN_POTT/ I_PIPS_RUN_POTT
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_WZ
      COMMON /PIPS_RUN_WZ/ I_PIPS_RUN_WZ
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_SMIM_HELPA
      COMMON /PIPS_SMIM_HELPA/ I_PIPS_SMIM_HELPA
      INTEGER*8 I_PIPS_SMIM_AN
      COMMON /PIPS_SMIM_AN/ I_PIPS_SMIM_AN
      INTEGER*8 I_PIPS_SMIM_BN
      COMMON /PIPS_SMIM_BN/ I_PIPS_SMIM_BN
      INTEGER*8 I_PIPS_SMIM_CN
      COMMON /PIPS_SMIM_CN/ I_PIPS_SMIM_CN
      INTEGER*8 I_PIPS_HORIMS_HELP
      COMMON /PIPS_HORIMS_HELP/ I_PIPS_HORIMS_HELP
      INTEGER*8 I_PIPS_HORIMS_HELPA
      COMMON /PIPS_HORIMS_HELPA/ I_PIPS_HORIMS_HELPA
      INTEGER*8 I_PIPS_HORIMS_AN
      COMMON /PIPS_HORIMS_AN/ I_PIPS_HORIMS_AN
      INTEGER*8 I_PIPS_HORIMS_BN
      COMMON /PIPS_HORIMS_BN/ I_PIPS_HORIMS_BN
      INTEGER*8 I_PIPS_HORIMS_CN
      COMMON /PIPS_HORIMS_CN/ I_PIPS_HORIMS_CN
C     BEGIN BLOCK
C (0,2)
CX30087 CALL SBINX (87)
CY30087 CALL SBINY (87)
      MLAG = 1
C (0,3)
      NZTOP = NZ-2
C (0,4)
CX10629 CALL DOINX( 629 )
CY10629 CALL DOINY( 629 )
C
!     INITIALLY: DO 10
      DO II = 1, NZTOP
C (0,5)
C        BEGIN BLOCK
C (0,6)
         MLAG = MLAG+NX*NY
C (0,7)
      I_PIPS_HORIMS_HELP = I_PIPS_RUN_DCDX
      I_PIPS_HORIMS_HELPA = I_PIPS_SMIM_HELPA
      I_PIPS_HORIMS_AN = I_PIPS_SMIM_AN
      I_PIPS_HORIMS_BN = I_PIPS_SMIM_BN
      I_PIPS_HORIMS_CN = I_PIPS_SMIM_CN
         CALL HORIMS(NX, NY, F(MLAG), DL, HELP, HELPA, AN, BN, CN)
C (0,8)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,9)
CX20630 CALL DOOUTX( 630 )
CY20630 CALL DOOUTY( 630 )
CX40088 CALL SBOUTX (88)
CY40088 CALL SBOUTY (88)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *                2-D IMPLICIT SMOOTHING                              *
C **********************************************************************
C
      SUBROUTINE HORIMS(NX,NY,F,DL,HELP,HELPA,AN,BN,CN)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 F(NX,NY),AN(I_PIPS_HORIMS_AN),BN(I_PIPS_HORIMS_BN),CN(I_PIP
     x S_HORIMS_CN),HELP(I_PIPS_HORIMS_HELP),HELPA(I_PIPS_HORIMS_HELPA)
C (0,1)
      INTEGER*8 I_PIPS_DKZP_U
      COMMON /PIPS_DKZP_U/ I_PIPS_DKZP_U
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_HORIMS_HELP
      COMMON /PIPS_HORIMS_HELP/ I_PIPS_HORIMS_HELP
      INTEGER*8 I_PIPS_DKZP_T
      COMMON /PIPS_DKZP_T/ I_PIPS_DKZP_T
      INTEGER*8 I_PIPS_SMIM_HELPA
      COMMON /PIPS_SMIM_HELPA/ I_PIPS_SMIM_HELPA
      INTEGER*8 I_PIPS_HORIMS_HELPA
      COMMON /PIPS_HORIMS_HELPA/ I_PIPS_HORIMS_HELPA
      INTEGER*8 I_PIPS_DKZP_AN
      COMMON /PIPS_DKZP_AN/ I_PIPS_DKZP_AN
      INTEGER*8 I_PIPS_SMIM_AN
      COMMON /PIPS_SMIM_AN/ I_PIPS_SMIM_AN
      INTEGER*8 I_PIPS_HORIMS_AN
      COMMON /PIPS_HORIMS_AN/ I_PIPS_HORIMS_AN
      INTEGER*8 I_PIPS_DKZP_BN
      COMMON /PIPS_DKZP_BN/ I_PIPS_DKZP_BN
      INTEGER*8 I_PIPS_SMIM_BN
      COMMON /PIPS_SMIM_BN/ I_PIPS_SMIM_BN
      INTEGER*8 I_PIPS_HORIMS_BN
      COMMON /PIPS_HORIMS_BN/ I_PIPS_HORIMS_BN
      INTEGER*8 I_PIPS_DKZP_CN
      COMMON /PIPS_DKZP_CN/ I_PIPS_DKZP_CN
      INTEGER*8 I_PIPS_SMIM_CN
      COMMON /PIPS_SMIM_CN/ I_PIPS_SMIM_CN
      INTEGER*8 I_PIPS_HORIMS_CN
      COMMON /PIPS_HORIMS_CN/ I_PIPS_HORIMS_CN
C     BEGIN BLOCK
C (0,2)
CX30089 CALL SBINX (89)
CY30089 CALL SBINY (89)
CX10631 CALL DOINX( 631 )
CY10631 CALL DOINY( 631 )
!     INITIALLY: DO 30
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HELP(I) = F(I,J)
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
         CALL SMIMP(NX, HELP, HELPA, AN, BN, CN, DL)
C (0,9)
!     INITIALLY: DO 20
         DO I = 1, NX
C (0,10)
C           BEGIN BLOCK
C (0,11)
            F(I,J) = HELP(I)
C (0,12)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,13)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,14)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20632 CALL DOOUTX( 632 )
CY20632 CALL DOOUTY( 632 )
      IF (NY.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
CX10633 CALL DOINX( 633 )
CY10633 CALL DOINY( 633 )
!     INITIALLY: DO 60
      DO I = 1, NX
C (3,3)
C        BEGIN BLOCK
C (3,4)
!     INITIALLY: DO 40
         DO J = 1, NY
C (3,5)
C           BEGIN BLOCK
C (3,6)
            HELP(J) = F(I,J)
C (3,7)
40          CONTINUE
C           END BLOCK
         ENDDO
C (3,8)
         CALL SMIMP(NY, HELP, HELPA, AN, BN, CN, DL)
C (3,9)
!     INITIALLY: DO 50
         DO J = 1, NY
C (3,10)
C           BEGIN BLOCK
C (3,11)
            F(I,J) = HELP(J)
C (3,12)
50          CONTINUE
C           END BLOCK
         ENDDO
C (3,13)
60       CONTINUE
C        END BLOCK
      ENDDO
CX20634 CALL DOOUTX( 634 )
CY20634 CALL DOOUTY( 634 )
CX40090 CALL SBOUTX (90)
CY40090 CALL SBOUTY (90)
C     END BLOCK
C (2,1)
CX40090 CALL SBOUTX (90)
CY40090 CALL SBOUTY (90)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C ***          THIS ROUTINE SMOOTHS IMPLICITLY HORIZONTAL FIELDS       *
C ***          EMPLOYING CRANK-NICKOLSON WITH UPWINDING A=.5           *
C **********************************************************************
C
      SUBROUTINE SMIMP(N,HELP,HELPA,AN,BN,CN,DL)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION HELP(I_PIPS_HORIMS_HELP),HELPA(I_PIPS_HORIMS_HELPA),AN(I
     x _PIPS_HORIMS_AN),BN(I_PIPS_HORIMS_BN),CN(I_PIPS_HORIMS_CN)
C (0,1)
      INTEGER*8 I_PIPS_HORIMS_HELP
      COMMON /PIPS_HORIMS_HELP/ I_PIPS_HORIMS_HELP
      INTEGER*8 I_PIPS_HORIMS_HELPA
      COMMON /PIPS_HORIMS_HELPA/ I_PIPS_HORIMS_HELPA
      INTEGER*8 I_PIPS_HORIMS_AN
      COMMON /PIPS_HORIMS_AN/ I_PIPS_HORIMS_AN
      INTEGER*8 I_PIPS_HORIMS_BN
      COMMON /PIPS_HORIMS_BN/ I_PIPS_HORIMS_BN
      INTEGER*8 I_PIPS_HORIMS_CN
      COMMON /PIPS_HORIMS_CN/ I_PIPS_HORIMS_CN
      INTEGER*8 I_PIPS_TRID_BN
      COMMON /PIPS_TRID_BN/ I_PIPS_TRID_BN
      INTEGER*8 I_PIPS_TRID_AN
      COMMON /PIPS_TRID_AN/ I_PIPS_TRID_AN
      INTEGER*8 I_PIPS_TRID_CN
      COMMON /PIPS_TRID_CN/ I_PIPS_TRID_CN
      INTEGER*8 I_PIPS_TRID_FN
      COMMON /PIPS_TRID_FN/ I_PIPS_TRID_FN
      INTEGER*8 I_PIPS_TRID_GN
      COMMON /PIPS_TRID_GN/ I_PIPS_TRID_GN
C     BEGIN BLOCK
C (0,2)
CX30091 CALL SBINX (91)
CY30091 CALL SBINY (91)
      N1 = N-1
C (0,3)
      NPTS = N-2
C (0,4)
      JS = 2
C (0,5)
CX10635 CALL DOINX( 635 )
CY10635 CALL DOINY( 635 )
!     INITIALLY: DO 10
      DO J = JS, N1
C (0,6)
C        BEGIN BLOCK
C (0,7)
C
         AN(J) = 2.*(1.+DL)
C (0,8)
         CN(J) = 1.-DL
C (0,9)
         BN(J) = 1.-DL
C (0,10)
         H0 = HELP(J-1)
C (0,11)
         H1 = HELP(J)
C (0,12)
         H2 = HELP(J+1)
C (0,13)
C
         FORC = 0.0
C (0,14)
         IF (J.EQ.JS) THEN
C (0,15)
            FORC = H0*BN(J)
         ELSE
C (0,16)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,17)
         IF (J.EQ.N1) THEN
C (0,18)
            FORC = H2*CN(J)
         ELSE
C (0,19)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,20)
         HELPA(J) = H0+2.*H1+H2-FORC
C (0,21)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,22)
      I_PIPS_TRID_BN = I_PIPS_HORIMS_BN-(JS-1)
      I_PIPS_TRID_AN = I_PIPS_HORIMS_AN-(JS-1)
      I_PIPS_TRID_CN = I_PIPS_HORIMS_CN-(JS-1)
      I_PIPS_TRID_FN = I_PIPS_HORIMS_HELPA-(JS-1)
      I_PIPS_TRID_GN = I_PIPS_HORIMS_HELP-(JS-1)
CX20636 CALL DOOUTX( 636 )
CY20636 CALL DOOUTY( 636 )
      CALL TRID(NPTS, BN(JS), AN(JS), CN(JS), HELPA(JS), HELP(JS))
C (0,23)
CX40092 CALL SBOUTX (92)
CY40092 CALL SBOUTY (92)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *                         2-D SMOOTHING                              *
C **********************************************************************
C
      SUBROUTINE HORSMT(NX,NY,F)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 F(NX,NY)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30093 CALL SBINX (93)
CY30093 CALL SBINY (93)
      NX1 = NX-1
C (0,3)
      NY1 = NY-1
C (0,4)
CX10637 CALL DOINX( 637 )
CY10637 CALL DOINY( 637 )
!     INITIALLY: DO 20
      DO J = 1, NY
C (0,5)
C        BEGIN BLOCK
C (0,6)
         F1 = F(1,J)
C (0,7)
!     INITIALLY: DO 10
         DO I = 2, NX1
C (0,8)
C           BEGIN BLOCK
C (0,9)
            F0 = 0.5*F(I,J)+0.25*(F1+F(I+1,J))
C (0,10)
            F1 = F(I,J)
C (0,11)
            F(I,J) = F0
C (0,12)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,13)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,14)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20638 CALL DOOUTX( 638 )
CY20638 CALL DOOUTY( 638 )
      IF (NY.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
CX10639 CALL DOINX( 639 )
CY10639 CALL DOINY( 639 )
!     INITIALLY: DO 40
      DO I = 1, NX
C (3,3)
C        BEGIN BLOCK
C (3,4)
         F1 = F(I,1)
C (3,5)
!     INITIALLY: DO 30
         DO J = 2, NY1
C (3,6)
C           BEGIN BLOCK
C (3,7)
            F0 = 0.5*F(I,J)+0.25*(F1+F(I,J+1))
C (3,8)
            F1 = F(I,J)
C (3,9)
            F(I,J) = F0
C (3,10)
30          CONTINUE
C           END BLOCK
         ENDDO
C (3,11)
40       CONTINUE
C        END BLOCK
      ENDDO
CX20640 CALL DOOUTX( 640 )
CY20640 CALL DOOUTY( 640 )
CX40094 CALL SBOUTX (94)
CY40094 CALL SBOUTY (94)
C     END BLOCK
C (2,1)
CX40094 CALL SBOUTX (94)
CY40094 CALL SBOUTY (94)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END


C
C **********************************************************************
C **   SUBROUTINE PRINTR IS CALLED BY THE SUBROUTINES OF               *
C **   PROGRAM ADMDL  AT THE END OF EACH TIME-STEP TO PRINT RESULTS    *
C **********************************************************************
C
      SUBROUTINE PRINTR(NX,NY,NZ,NT,XSTART,YSTART,ZSTART,TSTART,DX,DY,
     *DZ,DELTAX,DELTAY,DELTAZ,DELTAT,TIME1,TOUT,NTIME,C,UM,UX,VM,VY,
     *THM,POTT,WZ,PRES,DKM,DKZM,DKZH,DEP,NPRINT,NGRAPH,NPSTEP,NGSTEP,
     *NSTEP,IBT,NWINDX,ISH,NSINKS,NFILT,IB,IK,ITY,NCOUNT,
     *Z0,ELEV,HMIX,TAVR,OBUK,USTR,TSTR,VDEP,PHI,CMASS,UWIND,USQ,VWIND,
     *VSQ,WWIND,WSQ,HEAT,EXNER)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      CHARACTER*22 TSCH(16)
      DIMENSION C(1200000),DKM(I_PIPS_RUN_DKM),DKZM(I_PIPS_RUN_DKZM),DKZ
     x H(I_PIPS_RUN_DKZH),DEP(I_PIPS_RUN_DEP),TSTR(I_PIPS_RUN_TSTR)
      DIMENSION UM(I_PIPS_RUN_UM),UX(I_PIPS_RUN_UX),VM(I_PIPS_RUN_VM),VY
     x (I_PIPS_RUN_VY),THM(I_PIPS_RUN_TM),POTT(I_PIPS_RUN_POTT),WZ(I_PIP
     x S_RUN_WZ),PRES(I_PIPS_RUN_PRES)
      DIMENSION Z0(I_PIPS_RUN_Z0),ELEV(I_PIPS_RUN_ELEV),HMIX(I_PIPS_RUN_
     x HMIX),TAVR(I_PIPS_RUN_TAVR),OBUK(I_PIPS_RUN_OBUK),USTR(I_PIPS_RUN
     x _USTR),VDEP(I_PIPS_RUN_VDEP)
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
      COMMON/SOURCE/INIT(2,2),NSOUR(2),IX(2,2),JY(2,2),KZ(2,2),
     *IVAL(2,2),NSX(2,2),NSY(2,2),NSZ(2,2),ISR(2,2)
      COMMON/LEVEL/KK1,KK2,KK3,KK4,IYHOM,IGEO,IUGX,IVGY,LT0,LT1,ICPU
      SAVE TSCH
      DATA TSCH/' LEAP  FROG 2ND IN X,Y',' 1.85 PRED-COR  2,3 X ',
     1' LM FORMULA  3RD  IN X',' 0.4  PRED-COR  2,3  X',
     2' ADAMS BASHFORD 3RD  X',' ADAMS PRED-COR 2,3  X',
     3' 1.8 PRED-COR 3,4 IN X',' ADAMS PRED-COR 3,4  X',
     4'  CRANK-NICKOLSON IN Z','  IMPLICIT PADE   IN Z',
     5'  BATCH MODE = NO     ','  BATCH MODE = YES    ',
     6'  REGULAR HEIGHT Z=H  ','  STRECHED Z, Z=F(H)  ',
     6'  NO FILTER AT ALL    ','  SPECTRAL FILTER     '/
C (0,1)
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_UX
      COMMON /PIPS_RUN_UX/ I_PIPS_RUN_UX
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_VY
      COMMON /PIPS_RUN_VY/ I_PIPS_RUN_VY
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_POTT
      COMMON /PIPS_RUN_POTT/ I_PIPS_RUN_POTT
      INTEGER*8 I_PIPS_RUN_WZ
      COMMON /PIPS_RUN_WZ/ I_PIPS_RUN_WZ
      INTEGER*8 I_PIPS_RUN_PRES
      COMMON /PIPS_RUN_PRES/ I_PIPS_RUN_PRES
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DKZM
      COMMON /PIPS_RUN_DKZM/ I_PIPS_RUN_DKZM
      INTEGER*8 I_PIPS_RUN_DKZH
      COMMON /PIPS_RUN_DKZH/ I_PIPS_RUN_DKZH
      INTEGER*8 I_PIPS_RUN_DEP
      COMMON /PIPS_RUN_DEP/ I_PIPS_RUN_DEP
      INTEGER*8 I_PIPS_RUN_Z0
      COMMON /PIPS_RUN_Z0/ I_PIPS_RUN_Z0
      INTEGER*8 I_PIPS_RUN_ELEV
      COMMON /PIPS_RUN_ELEV/ I_PIPS_RUN_ELEV
      INTEGER*8 I_PIPS_RUN_HMIX
      COMMON /PIPS_RUN_HMIX/ I_PIPS_RUN_HMIX
      INTEGER*8 I_PIPS_RUN_TAVR
      COMMON /PIPS_RUN_TAVR/ I_PIPS_RUN_TAVR
      INTEGER*8 I_PIPS_RUN_OBUK
      COMMON /PIPS_RUN_OBUK/ I_PIPS_RUN_OBUK
      INTEGER*8 I_PIPS_RUN_USTR
      COMMON /PIPS_RUN_USTR/ I_PIPS_RUN_USTR
      INTEGER*8 I_PIPS_RUN_TSTR
      COMMON /PIPS_RUN_TSTR/ I_PIPS_RUN_TSTR
      INTEGER*8 I_PIPS_RUN_VDEP
      COMMON /PIPS_RUN_VDEP/ I_PIPS_RUN_VDEP
C     BEGIN BLOCK
C (0,2)
10    FORMAT(//////,17X,' SOLVING THE EQUATION ',/,2X,' DC/DT=U*DC/DX+V*
     x 
     &DC/DY+KX*D2C/DX2+KY*DC/DY+D(KZ*DC/DZ)/DZ + Q,',/,2X,' WHERE C(X,Y,
     x 
     &Z,T0)=0 WITH PERIODIC BOUNDARY CONDITIONS IN  X,Y',/,2X,' AND FLUX
     x 
     & VERTICAL BOUNDARY CONDITIONS. ',//)
C (0,3)
20    FORMAT(//,2X,' X AXIS IS DIVIDED INTO ',I4,'  SUBINTERVALS',/,2X,'
     x 
     & Y AXIS IS DIVIDED INTO ',I4,'  SUBINTERVALS',/,2X,' Z AXIS IS DIV
     x 
     &IDED INTO ',I4,'  SUBINTERVALS',/,2X,'     ',I5,'  TIME STEPS WERE
     x 
     & REQUESTED ',//)
C (0,4)
30    FORMAT(3A,/)
C (0,5)
40    FORMAT('   Z=',F5.1,'*(EXP(H/',F4.1,')-1),  UPWIND A=',F4.1,//)
C (0,6)
50    FORMAT('   X  DOMAIN  (',F9.1,',',F9.1,'),    DX=',F9.2)
C (0,7)
60    FORMAT('   Y  DOMAIN  (',F9.1,',',F9.1,'),    DY=',F9.2)
C (0,8)
70    FORMAT('   Z  DOMAIN  (',F9.1,',',F9.1,'),    DZ=',F9.2)
C (0,9)
80    FORMAT('   T  DOMAIN  (',F9.1,',',F9.1,'),    DT=',F9.2)
C (0,10)
90    FORMAT
     &(/,'   CENTRAL LATITUDE ',F6.2,' DEG,    GRAPH STEP ',I3,/)
C (0,11)
100   FORMAT(/,'  DIFFUSIVITIES   (KX,KY,KZ) = (',3F10.2,')',/)
C (0,12)
140   FORMAT(' T(',I6,')=',F8.1,'  FUM=',E11.4,'  E=',E11.4,'  T=',E11.4
     x 
     &,'  P=',E11.4,/,8X,'TS=',F7.2,2X,'  U=',E11.4,'  V=',E11.4,'  W=',
     x 
     &E11.4)
C (0,13)
150   FORMAT(' T(',I4,')=',F6.0,'  C=',E10.3,'  E=',E10.3,'  T=',E10.3,'
     x 
     &  P=',E10.3,'  U=',E10.3,'  V=',E10.3,'  W=',E10.3)
C (0,14)
2     FORMAT(1X,'VALIDATION PARAMETERS:'/)
C (0,15)
3     FORMAT(//1X,'RESULTS FOR THIS RUN ARE:   VALID')
C (0,16)
4     FORMAT(//1X,'RESULTS FOR THIS RUN ARE: INVALID')
C (0,17)
5     FORMAT(1X,3E14.5)
C (0,18)
160   FORMAT(I15)
C (0,19)
170   FORMAT(F20.4)
C (0,20)
C     BEGIN UNSTRUCTURED
C (1,1)
CX30095 CALL SBINX (95)
CY30095 CALL SBINY (95)
C
      IF (TIME1.NE.TSTART) GOTO 99985
C (10,1)
C     BEGIN BLOCK
C (10,2)
C
C        INITIALIZE CPU TIME
C
C     CALL CPUCLK(TM,0,IBT)
C
      WRITE (6, 10) 
C (10,3)
      WRITE (6, 20) NX, NY, NZ, NT
C (10,4)
      WRITE (8, 20) NX, NY, NZ, NT
C (10,5)
      XEND = XSTART+(NX-1)*DELTAX
C (10,6)
      YEND = YSTART+(NY-1)*DELTAY
C (10,7)
      ZEND = ZSTART+(NZ-1)*DELTAZ
C (10,8)
      TEND = TSTART+(NT-1)*DELTAT
C (10,9)
      WRITE (6, 30) TSCH(11+NWINDX), TSCH(15+NFILT), TSCH(13+ITY)
C (10,10)
      WRITE (8, 30) TSCH(11+NWINDX), TSCH(15+NFILT), TSCH(13+ITY)
C (10,11)
      IF (ITY.EQ.1) THEN
C (10,12)
C        BEGIN BLOCK
C (10,13)
         WRITE (8, 40) BET, ALP, ALPHA
C (10,14)
         WRITE (6, 40) BET, ALP, ALPHA
C        END BLOCK
      ELSE
C (10,15)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (10,16)
      WRITE (6, '(4X,A,//)') 
     &'FOLLOWING NUMBERS ARE IN USER WORLD UNITS'
C (10,17)
      WRITE (8, '(4X,A,//)') 
     &'FOLLOWING NUMBERS ARE IN USER WORLD UNITS'
C (10,18)
      WRITE (6, 50) XSTART, XEND, DELTAX
C (10,19)
      WRITE (6, 60) YSTART, YEND, DELTAY
C (10,20)
      WRITE (6, 70) ZSTART, ZEND, DELTAZ
C (10,21)
      WRITE (6, 80) TSTART, TEND, DELTAT
C (10,22)
      WRITE (6, 90) PHI, NGSTEP
C (10,23)
      WRITE (6, 100) DX, DY, DZ
C (10,24)
      WRITE (8, 50) XSTART, XEND, DELTAX
C (10,25)
      WRITE (8, 60) YSTART, YEND, DELTAY
C (10,26)
      WRITE (8, 70) ZSTART, ZEND, DELTAZ
C (10,27)
      WRITE (8, 80) TSTART, TEND, DELTAT
C (10,28)
      WRITE (8, 90) PHI, NGSTEP
C (10,29)
      WRITE (8, 100) DX, DY, DZ
C (10,30)
      LT = NTIME
C (10,31)
      IF (NX.EQ.1.AND.NY.EQ.1) THEN
C (10,32)
         LT = 9
      ELSE
C (10,33)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (10,34)
      WRITE (6, 30) ' ** TIME SCHEMES USED ** ', TSCH(LT), TSCH(9+ISH
     &)
C (10,35)
      WRITE (8, 30) ' ** TIME SCHEMES USED ** ', TSCH(LT), TSCH(9+ISH
     &)
C     END BLOCK
99985 CONTINUE
C (2,1)
C
C       CPU TIME
C
C     CALL CPUCLK(TM,1,IBT)
C
C   SAVE RESULTS FOR GRAPHING
C

      IF (TOUT.LT.1.E-6) GOTO 120
C (9,1)
      IF (NGRAPH.EQ.0) GOTO 130
C (8,1)
      IF (MOD(NSTEP, NGSTEP).NE.0) GOTO 130
C (3,1)
C     BEGIN BLOCK
C (3,2)
120   CONTINUE
C (3,3)
      CALL GRAPH(NX, NY, NZ, C, UM, UX, VM, VY, THM, POTT, WZ, PRES, 
     &DKM, DKZM, DKZH, DEP, NSTEP, Z0, ELEV, HMIX, TAVR, OBUK, USTR, 
     &TSTR, VDEP)
C     END BLOCK
C (4,1)
C     BEGIN BLOCK
C (4,2)
C
C     PRINT TIME STEP, SIMULATION TIME TOTAL MASS, MOMENTUM,
C     HEAT  ENERGY AND CPU TIME
C
130   DMOM = UWIND+VWIND+WWIND
C (4,3)
      ENER = USQ+VSQ+WSQ
C (4,4)
      TS = POTT(1)+THM(1)
C (4,5)
C
      IF (MOD(NSTEP, NPSTEP).EQ.0) THEN
C (4,6)
         WRITE (6, 140) NSTEP, TIME1, CMASS, ENER, HEAT, EXNER, TS, 
     &   UWIND, VWIND, WWIND
      ELSE
C (4,7)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (4,8)
      IF (MOD(NSTEP, NPSTEP).EQ.0) THEN
C (4,9)
         WRITE (8, 150) NSTEP, TIME1, CMASS, ENER, HEAT, EXNER, UWIND
     &   , VWIND, WWIND
      ELSE
C (4,10)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (4,11)
      IF (NSTEP.EQ.NT) THEN
C (4,12)
C        BEGIN BLOCK
C (4,13)
         WRITE (1, 2) 
C (4,14)
         WRITE (1, 5) CMASS, ENER, WWIND
C (4,15)
         IF (CMASS.LT.1.0E6.AND.ENER.LT.1.0E5.AND.WWIND.LT.1.0E2
     &   ) THEN
C (4,16)
            WRITE (1, 3) 
         ELSE
C (4,17)
            WRITE (1, 4) 
         ENDIF
C        END BLOCK
      ELSE
C (4,18)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (4,19)
C
C   SAVE RESULTS FOR GRAPHING
C
      TOUT = TOUT+DELTAT
C     END BLOCK
C (5,1)
C
C     SAVE DATA IN FILE FOR RESTORING
C
      IF (MOD(NSTEP, NPSTEP).NE.0) RETURN
C (7,1)
C     BEGIN BLOCK
C (7,2)
C     OPEN(10,FILE='RUN')
      OPEN (UNIT=10,FILE='APO10',STATUS='UNKNOWN') 
C (7,3)
      WRITE (10, 160) NX, NY, NZ, NT, NTIME, NFILT, NCOUNT, ITY, IB, 
     &IK, NWINDX, ISH, NSINKS, NPRINT, NPSTEP, NGRAPH, NGSTEP, NSOUR(
     &1), NSOUR(2), INIT(1,1), INIT(2,1), INIT(1,2), INIT(2,2), IX(1,
     &1), IX(2,1), IX(1,2), IX(2,2), JY(1,1), JY(2,1), JY(1,2), JY(2,
     &2), KZ(1,1), KZ(2,1), KZ(1,2), KZ(2,2), IVAL(1,1), IVAL(2,1), 
     &IVAL(1,2), IVAL(2,2), NSX(1,1), NSX(2,1), NSX(1,2), NSX(2,2), 
     &NSY(1,1), NSY(2,1), NSY(1,2), NSY(2,2), NSZ(1,1), NSZ(2,1), NSZ
     &(1,2), NSZ(2,2), ISR(1,1), ISR(2,1), ISR(1,2), ISR(2,2), KK1, 
     &KK2, KK3, KK4
C (7,4)
      WRITE (10, 170) TIME1, DELTAT, XSTART, DELTAX, DX, YSTART, 
     &DELTAY, DY, ZSTART, DELTAZ, DZ, ALP, BET, ZH, UG, VG, T1, T2, 
     &DUT, TOL, ALPHA, SX, SIGX, SY, SIGY
C (7,5)
      CLOSE (10) 
CX40096 CALL SBOUTX (96)
CY40096 CALL SBOUTY (96)
C
C     END BLOCK
C (6,1)
CX40096 CALL SBOUTX (96)
CY40096 CALL SBOUTY (96)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C *   SUBROUTINE TO DUMP THE RESULTED MODEL GENERATED FIELDS FOR       *
C *   LATER EVALUATION BY PLOTTING BOUNDARY LAYER AND OTHER VARBLS     *
C **********************************************************************
C
      SUBROUTINE GRAPH(NX,NY,NZ,C,UM,UX,VM,VY,THM,POTT,WZ,PRES,DKM,DKZM,
     x 
     *DKZH,DEP,NSTEP,Z0,ELEV,HMIX,TAVR,OBUK,USTR,TSTR,VDEP)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION C(NX,NY,NZ),UX(NX,NY,NZ),VY(NX,NY,NZ),WZ(NX,NY,NZ),
     *POTT(NX,NY,NZ),PRES(NX,NY,NZ),DKZM(NX,NY,NZ),DKZH(NX,NY,NZ),
     *Z0(NX,NY),ELEV(NX,NY),HMIX(NX,NY),TAVR(NX,NY),
     *OBUK(NX,NY),USTR(NX,NY),VDEP(NX,NY),DEP(NX,NY),TSTR(NX,NY),
     *UM(NZ),VM(NZ),THM(NZ),DKM(NZ)
      COMMON/LEVEL/KK1,KK2,KK3,KK4,IYHOM,IGEO,IUGX,IVGY,LT0,LT1,ICPU
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX20642 CALL DOOUTX( 642 )
CY20642 CALL DOOUTY( 642 )
C
50    FORMAT(8E12.5)
C (0,3)
CX30097 CALL SBINX (97)
CY30097 CALL SBINY (97)
      IX0 = 3
C (0,4)
      IX1 = NX-2
C (0,5)
      JY0 = 1
C (0,6)
      JY1 = NY
C (0,7)
      IF (NY.GT.1) THEN
C (0,8)
C        BEGIN BLOCK
C (0,9)
         JY0 = 3
C (0,10)
         JY1 = NY-2
C        END BLOCK
      ELSE
C (0,11)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,12)
CX10641 CALL DOINX( 641 )
CY10641 CALL DOINY( 641 )
!     INITIALLY: DO 40
      DO K = 1, NZ
C (0,13)
C        BEGIN UNSTRUCTURED
C (1,1)
         IF (NY.GT.1) GOTO 99990
C (3,1)
C        BEGIN BLOCK
C (3,2)
10       CONTINUE
C (3,3)
!     INITIALLY: DO 30
         DO J = JY0, JY1
C (3,4)
C           BEGIN BLOCK
C (3,5)
!     INITIALLY: DO 20
            DO I = IX0, IX1
C (3,6)
C              BEGIN BLOCK
C (3,7)
               U = UX(I,J,K)+UM(K)
C (3,8)
               V = VY(I,J,K)+VM(K)
C (3,9)
               THETA = POTT(I,J,K)+THM(K)
C (3,10)
C
C      WRITE THE CONCENTRATION, TOTAL WIND, POT. TEMPERATURE,
C      DIFFUSIVITIES AND PRESSURE
C
C              WRITE(7,50) U,V,WZ(I,J,K),C(I,J,K),THETA,PRES(I,J,K),
C    *                     DKZM(I,J,K),DKZH(I,J,K)
C
C    WRITE BOUNDARY LAYER PARAMETERS WHEN K=1 OR AT THE SURFACE
C
               IF (K.EQ.1) THEN
C (3,11)
C                 BEGIN BLOCK
C (3,12)
                  RATE = C(I,J,1)*VDEP(I,J)
C (3,13)
                  WRITE (11, 50) RATE, TAVR(I,J), OBUK(I,J), USTR(I,J
     &            ), TSTR(I,J), HMIX(I,J), VDEP(I,J), DEP(I,J)
C                 END BLOCK
               ELSE
C (3,14)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,15)
20             CONTINUE
C              END BLOCK
            ENDDO
C (3,16)
30          CONTINUE
C           END BLOCK
         ENDDO
C        END BLOCK
         GOTO 40
99990    CONTINUE
C (2,1)
         IF (K.EQ.KK1) GOTO 10
C (7,1)
         IF (K.EQ.KK2) GOTO 10
C (6,1)
         IF (K.EQ.KK3) GOTO 10
C (5,1)
         IF (K.EQ.KK4) GOTO 10
C (4,1)
40       CONTINUE
C        END UNSTRUCTURED
      ENDDO
C (0,14)
CX40098 CALL SBOUTX (98)
CY40098 CALL SBOUTY (98)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *       RUN STATISTICS IN CPU TIMES FOR EACH OF THE EQUATIONS        *
C **********************************************************************
C
      SUBROUTINE STATS
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      COMMON/CPU/CINIT,CINHC,CINVC,CINHT,CINVT,CINPI,CINHU,CINVU,
     *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN
C (0,1)
C     BEGIN BLOCK
C (0,2)
C     IF(TM19.LT.0.) THEN
C        WRITE(6,50) CINHC,CINVC,CINHT,CINVT,CINHU,CINVU,
C    *               CINHV,CINVV,CINHW,CINVW
C        WRITE(8,50) CINHC,CINVC,CINHT,CINVT,CINHU,CINVU,
C    *               CINHV,CINVV,CINHW,CINVW
C        WRITE(6,60) SPECT,FINIT,TOTFN
C        WRITE(8,60) SPECT,FINIT,TOTFN
C                    ELSE
C        WRITE(6,70) SPECT,FINIT,TOTFN
C        WRITE(8,70) SPECT,FINIT,TOTFN
C     ENDIF
C
10    FORMAT(/,' *******************************************************
     x 
     &',/,' **      CPU STATISTICS IN SECONDS FOR THIS RUN       **',/,'
     x 
     & **                                                   **')
C (0,3)
20    FORMAT(/,' *******************************************************
     x 
     &',/,' **                 CPU REPORT (SEC)                  **',/,'
     x 
     & **                                                   **')
C (0,4)
30    FORMAT(' **          TOTAL RUN CPU  TIME =',F15.2,'     **',/,' **
     x 
     &          INITIALIZATION TIME =',F15.2,'     **',/,' **           
     x 
     &                                        **')
C (0,5)
40    FORMAT(' **      CPU FOR CONCENTRATIONS  C =',F15.2,'   **',/,' **
     x 
     &      CPU FOR TEMPERATURE THETA =',F15.2,'   **',/,' **      CPU F
     x 
     &OR EXNER PRESSURE PI =',F15.2,'   **',/,' **      CPU FOR X MOMENT
     x 
     &UM EQ.  U =',F15.2,'   **',/,' **      CPU FOR Y MOMENTUM EQ.  V =
     x 
     &',F15.2,'   **',/,' **      CPU FOR CONTINUITY EQ.  W =',F15.2,'  
     x 
     & **',/,' **      CPU FOR PRINTING UNKNOWNS =',F15.2,'   **',/,' **
     x 
     &      CPU FOR  BOUNDARY   LAYER =',F15.2,'   **',/,' **      CPU F
     x 
     &OR HIGH  PASS FILTER =',F15.2,'   **',/,' **      CPU FOR SYNOPTIC
     x 
     & VARIABLS =',F15.2,'   **',/,' **                                 
     x 
     &                  **')
C (0,6)
50    FORMAT(' **      CPU FOR SPECTRAL     IN C =',F15.2,'   **',/,' **
     x 
     &      CPU FOR DIFFERENCES  IN C =',F15.2,'   **',/,' **      CPU F
     x 
     &OR SPECTRAL     IN T =',F15.2,'   **',/,' **      CPU FOR DIFFEREN
     x 
     &CES  IN T =',F15.2,'   **',/,' **      CPU FOR SPECTRAL     IN U =
     x 
     &',F15.2,'   **',/,' **      CPU FOR DIFFERENCES  IN U =',F15.2,'  
     x 
     & **',/,' **      CPU FOR SPECTRAL     IN V =',F15.2,'   **',/,' **
     x 
     &      CPU FOR DIFFERENCES  IN V =',F15.2,'   **',/,' **      CPU F
     x 
     &OR SPECTRAL     IN W =',F15.2,'   **',/,' **      CPU FOR DIFFEREN
     x 
     &CES  IN W =',F15.2,'   **',/,' **                                 
     x 
     &                  **')
C (0,7)
60    FORMAT(' **      CPU FOR  SPECTRAL SCHEMES =',F15.2,'   **',/,' **
     x 
     &      CPU FOR FINITE DIFFERENCE =',F15.2,'   **',/,' **      CPU F
     x 
     &OR TOTAL DIFFERENCES =',F15.2,'   **',/,' **                      
     x 
     &                             **',/,' **             E N D    O F  
     x 
     &  R U N                 **',/,' **********************************
     x 
     &*********************')
C (0,8)
70    FORMAT(' **      CPU FOR  SPECTRAL SCHEMES =',F15.2,'   **',/,' **
     x 
     &      CPU FOR FINITE DIFFERENCE =',F15.2,'   **',/,' **      CPU F
     x 
     &OR TOTAL DIFFERENCES =',F15.2,'   **',/,' **                      
     x 
     &                             **',/,' *****************************
     x 
     &**************************',/)
C (0,9)
C    *CINHV,CINVV,CINHW,CINVW,CINPR,CINBL,CINFL,CINMN,TM1,TM18,TM19
CX30099 CALL SBINX (99)
CY30099 CALL SBINY (99)
C     IF(TM19.LT.0.) THEN
C        WRITE(6,10)
C        WRITE(8,10)
C                    ELSE
C        WRITE(6,20)
C        WRITE(8,20)
C     ENDIF
C
C     CALL CPUCLK(TM18,1,0)
C
C     TOTAL=TM18-TM1
C     WRITE(6,30) TOTAL,CINIT
C     WRITE(8,30) TOTAL,CINIT
      C = CINHC+CINVC
C (0,10)
      T = CINHT+CINVT
C (0,11)
      U = CINHU+CINVU
C (0,12)
      V = CINHV+CINVV
C (0,13)
      W = CINHW+CINVW
C (0,14)
      WRITE (6, 40) C, T, CINPI, U, V, W, CINPR, CINBL, CINFL, CINMN
C (0,15)
      WRITE (8, 40) C, T, CINPI, U, V, W, CINPR, CINBL, CINFL, CINMN
C (0,16)
      SPECT = CINHC+CINHT+CINHU+CINHV+CINHW
C (0,17)
      FINIT = CINVC+CINVT+CINVU+CINVV+CINVW
C (0,18)
      TOTFN = CINVC+CINVT+CINVU+CINVV+CINPI+CINVW+CINMN
C (0,19)
CX40100 CALL SBOUTX (100)
CY40100 CALL SBOUTY (100)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C * SET SOURCES OR SINKS AND INITIAL CONDITIONS FOR THE CONCENTRATIONS *
C **********************************************************************
C
      SUBROUTINE SETALL(NX,NY,NZ,XSTART,YSTART,ZSTART,
     *DELTAX,DELTAY,DELTAZ,C,Q,CMASS)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION Q(NX,NY,NZ),C(NX,NY,NZ)
      COMMON/SOURCE/INIT(2,2),NSOUR(2),IX(2,2),JY(2,2),KZ(2,2),
     * IVAL(2,2),NSX(2,2),NSY(2,2),NSZ(2,2),ISR(2,2)
      CHARACTER*21  LAB1(2,2),LQ(2)
      SAVE LAB1, LQ
      DATA LAB1/' SINGLE SOURCES      ',' SINGLE DISTURBANCES ',
     *' AREA   SOURCES      ',' AREA DISTURBANCES   '/ ,PI2/1.5708D0/
      DATA LQ/' UNNORMALIZED SOURCE ',' ACTUAL SOURCE VALUE '/
C (0,1)
C     BEGIN BLOCK
C (0,2)
10    FORMAT(/,A,I3,A,E12.4,A,' IX=',I3,' JY=',I3,' KZ=',I3,/)
C (0,3)
20    FORMAT(A,E10.2,' SPREAD IN POINTS AROUND CENTER ',3I4,/)
C (0,4)
30    FORMAT(A,E12.4,' AT GRID POINTS I,J,K ',3I4)
C (0,5)
CX30101 CALL SBINX (101)
CY30101 CALL SBINY (101)
C
      CMASS = 0.0
C (0,6)
      IF (NX.GT.1) THEN
C (0,7)
         XN = FLOAT(NX-1)
      ELSE
C (0,8)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,9)
      IF (NY.GT.1) THEN
C (0,10)
         YN = FLOAT(NY-1)
      ELSE
C (0,11)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,12)
      IF (NZ.GT.1) THEN
C (0,13)
         ZN = FLOAT(NZ-1)
      ELSE
C (0,14)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,15)
CX10643 CALL DOINX( 643 )
CY10643 CALL DOINY( 643 )
C
C        SPECIFY SOURCES  AND INITIAL CONDITIONS
C
!     INITIALLY: DO 110
      DO M = 1, 2
C (0,16)
C        BEGIN BLOCK
C (0,17)
         WRITE (6, '(/)') 
C (0,18)
         WRITE (8, '(/)') 
C (0,19)
C        M=1 SOURCES, M=2 INITIAL CONDITIONS
         NSOU = NSOUR(M)
C (0,20)
!     INITIALLY: DO 100
         DO L = 1, NSOU
C (0,21)
C           BEGIN BLOCK
C (0,22)
            IN = INIT(M,L)
C (0,23)
            LX = IX(M,L)
C (0,24)
            LY = JY(M,L)
C (0,25)
            LZ = KZ(M,L)
C (0,26)
            LSX = NSX(M,L)
C (0,27)
            LSY = NSY(M,L)
C (0,28)
            LSZ = NSZ(M,L)
C (0,29)
            VAL = FLOAT(IVAL(M,L))
C (0,30)
            SR = FLOAT(ISR(M,L))
C (0,31)
C           BEGIN UNSTRUCTURED
C (1,1)
            IF (LX.EQ.0.OR.LY.EQ.0.OR.LZ.EQ.0) GOTO 100
C (3,1)
C           BEGIN BLOCK
C (3,2)
            WRITE (8, '(/,I3,A,A)') NSOU, LAB1(M,IN+1), 
     &      ' WERE CHOSEN '
C (3,3)
            IF (IN.EQ.0.AND.M.EQ.1) THEN
C (3,4)
               Q(LX,LY,LZ) = VAL
            ELSE
C (3,5)
C              BEGIN BLOCK
C (3,6)
               C(LX,LY,LZ) = VAL
C (3,7)
               CMASS = VAL
C              END BLOCK
            ENDIF
C (3,8)
            WRITE (8, 10) ' #', L, ' ** ', VAL, ' ** LOCATED AT', LX
     &      , LY, LZ
C (3,9)
            IF (IN.GT.0) THEN
C (3,10)
C              BEGIN BLOCK
C (3,11)
               WRITE (8, 20) ' SIGMA ', SR, LSX, LSY, LSZ
C (3,12)
               I1 = LX-LSX
C (3,13)
               I2 = LX+LSX
C (3,14)
               J1 = LY-LSY
C (3,15)
               J2 = LY+LSY
C (3,16)
               K1 = LZ-LSZ
C (3,17)
               K2 = LZ+LSZ
C (3,18)
               IF (I1.LT.1) THEN
C (3,19)
                  I1 = 1
               ELSE
C (3,20)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,21)
               IF (J1.LT.1) THEN
C (3,22)
                  J1 = 1
               ELSE
C (3,23)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,24)
               IF (K1.LT.1) THEN
C (3,25)
                  K1 = 1
               ELSE
C (3,26)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,27)
               IF (I2.GT.NX) THEN
C (3,28)
                  I2 = NX
               ELSE
C (3,29)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,30)
               IF (J2.GT.NY) THEN
C (3,31)
                  J2 = NY
               ELSE
C (3,32)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,33)
               IF (K2.GT.NZ) THEN
C (3,34)
                  K2 = NZ
               ELSE
C (3,35)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,36)
               IF (NY.EQ.1) THEN
C (3,37)
C                 BEGIN BLOCK
C (3,38)
                  J1 = 1
C (3,39)
                  J2 = 1
C                 END BLOCK
               ELSE
C (3,40)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,41)
               IF (NZ.EQ.1) THEN
C (3,42)
C                 BEGIN BLOCK
C (3,43)
                  K1 = 1
C (3,44)
                  K2 = 1
C                 END BLOCK
               ELSE
C (3,45)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C (3,46)
               TOT = 0.
C (3,47)
!     INITIALLY: DO 60
               DO K = K1, K2
C (3,48)
C                 BEGIN BLOCK
C (3,49)
!     INITIALLY: DO 50
                  DO J = J1, J2
C (3,50)
C                    BEGIN BLOCK
C (3,51)
!     INITIALLY: DO 40
                     DO I = I1, I2
C (3,52)
C                       BEGIN BLOCK
C (3,53)
                        IF (NX.EQ.1) THEN
C (3,54)
C                          BEGIN BLOCK
C (3,55)
                           LX = I
C (3,56)
                           XN = 1.
C                          END BLOCK
                        ELSE
C (3,57)
C                          BEGIN BLOCK
C                          END BLOCK
                        ENDIF
C (3,58)
                        IF (NY.EQ.1) THEN
C (3,59)
C                          BEGIN BLOCK
C (3,60)
                           LY = J
C (3,61)
                           YN = 1.
C                          END BLOCK
                        ELSE
C (3,62)
C                          BEGIN BLOCK
C                          END BLOCK
                        ENDIF
C (3,63)
                        IF (NZ.EQ.1) THEN
C (3,64)
C                          BEGIN BLOCK
C (3,65)
                           LZ = K
C (3,66)
                           ZN = 1.
C                          END BLOCK
                        ELSE
C (3,67)
C                          BEGIN BLOCK
C                          END BLOCK
                        ENDIF
C (3,68)
                        X = (PI2*FLOAT(I-LX)/XN)**2
C (3,69)
                        Y = (PI2*FLOAT(J-LY)/YN)**2
C (3,70)
                        Z = (PI2*FLOAT(K-LZ)/ZN)**2
C (3,71)
                        Q1 = EXP(-SR*(X+Y+Z))
C (3,72)
                        TOT = TOT+Q1
C (3,73)
                        IF (M.EQ.1) THEN
C (3,74)
                           Q(I,J,K) = Q1
                        ELSE
C (3,75)
C                          BEGIN BLOCK
C (3,76)
                           C(I,J,K) = Q1
C (3,77)
                           CMASS = CMASS+Q1
C                          END BLOCK
                        ENDIF
C (3,78)
                        WRITE (8, 30) LQ(1), Q1, I, J, K
C (3,79)
40                      CONTINUE
C                       END BLOCK
                     ENDDO
C (3,80)
50                   CONTINUE
C                    END BLOCK
                  ENDDO
C (3,81)
60                CONTINUE
C                 END BLOCK
               ENDDO
C (3,82)
!     INITIALLY: DO 90
               DO K = K1, K2
C (3,83)
C                 BEGIN BLOCK
C (3,84)
!     INITIALLY: DO 80
                  DO J = J1, J2
C (3,85)
C                    BEGIN BLOCK
C (3,86)
!     INITIALLY: DO 70
                     DO I = I1, I2
C (3,87)
C                       BEGIN BLOCK
C (3,88)
                        IF (M.EQ.1) THEN
C (3,89)
C                          BEGIN BLOCK
C (3,90)
                           Q(I,J,K) = VAL*Q(I,J,K)/TOT
C (3,91)
                           WRITE (8, 30) LQ(2), Q(I,J,K), I, J, K
C (3,92)
                           WRITE (6, 30) LQ(2), Q(I,J,K), I, J, K
C                          END BLOCK
                        ELSE
C (3,93)
C                          BEGIN BLOCK
C (3,94)
                           C(I,J,K) = VAL*C(I,J,K)/TOT
C (3,95)
                           CMASS = CMASS+C(I,J,K)
C                          END BLOCK
                        ENDIF
C (3,96)
70                      CONTINUE
C                       END BLOCK
                     ENDDO
C (3,97)
80                   CONTINUE
C                    END BLOCK
                  ENDDO
C (3,98)
90                CONTINUE
C                 END BLOCK
               ENDDO
C              END BLOCK
            ELSE
C (3,99)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
C (2,1)
100         CONTINUE
C           END UNSTRUCTURED
C           END BLOCK
         ENDDO
C (0,32)
110      CONTINUE
C        END BLOCK
      ENDDO
C (0,33)
CX20644 CALL DOOUTX( 644 )
CY20644 CALL DOOUTY( 644 )
CX40102 CALL SBOUTX (102)
CY40102 CALL SBOUTY (102)
      RETURN
C     END BLOCK
      END
C
C  *********************************************************************
C  *        SUBROUTINE TO AJUST BOUNDARY CONDITIONS AT THE             *
C  *        END OF EACH TIME STEP. (NEUMANN B.C.)                      *
C  *********************************************************************
C
      SUBROUTINE HORBC(NX,NY,NZ,NT,XSTART,YSTART,ZSTART,TSTART,
     * DELTAX,DELTAY,DELTAZ,DELTAT,TIME1,UX,VY,C,Q)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION Q(NX,NY,NZ),C(NX,NY,NZ), UX(NX,NY,NZ), VY(NX,NY,NZ)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30103 CALL SBINX (103)
CY30103 CALL SBINY (103)
      NXB = NX-1
C (0,3)
      NXB2 = NX-2
C (0,4)
      NYB = NY-1
C (0,5)
CX10645 CALL DOINX( 645 )
CY10645 CALL DOINY( 645 )
!     INITIALLY: DO 90
      DO K = 1, NZ
C (0,6)
C        BEGIN BLOCK
C (0,7)
!     INITIALLY: DO 20
         DO I = 1, 2
C (0,8)
C           BEGIN BLOCK
C (0,9)
!     INITIALLY: DO 10
            DO J = 1, NY
C (0,10)
C              BEGIN BLOCK
C (0,11)
               Q(I,J,K) = Q(I,J,K)-ABS(UX(I,J,K))*C(I,J,K)/DELTAX
C (0,12)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,13)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,14)
!     INITIALLY: DO 40
         DO I = NXB, NX
C (0,15)
C           BEGIN BLOCK
C (0,16)
!     INITIALLY: DO 30
            DO J = 1, NY
C (0,17)
C              BEGIN BLOCK
C (0,18)
               Q(I,J,K) = Q(I,J,K)-ABS(UX(I,J,K))*C(I,J,K)/DELTAX
C (0,19)
30             CONTINUE
C              END BLOCK
            ENDDO
C (0,20)
40          CONTINUE
C           END BLOCK
         ENDDO
C (0,21)
C        BEGIN UNSTRUCTURED
C (1,1)
         IF (NY.EQ.1) GOTO 90
C (3,1)
C        BEGIN BLOCK
C (3,2)
!     INITIALLY: DO 60
         DO J = 1, 2
C (3,3)
C           BEGIN BLOCK
C (3,4)
!     INITIALLY: DO 50
            DO I = 3, NXB2
C (3,5)
C              BEGIN BLOCK
C (3,6)
               Q(I,J,K) = Q(I,J,K)-ABS(VY(I,J,K))*C(I,J,K)/DELTAY
C (3,7)
50             CONTINUE
C              END BLOCK
            ENDDO
C (3,8)
60          CONTINUE
C           END BLOCK
         ENDDO
C (3,9)
!     INITIALLY: DO 80
         DO J = NYB, NY
C (3,10)
C           BEGIN BLOCK
C (3,11)
!     INITIALLY: DO 70
            DO I = 3, NXB2
C (3,12)
C              BEGIN BLOCK
C (3,13)
               Q(I,J,K) = Q(I,J,K)-ABS(VY(I,J,K))*C(I,J,K)/DELTAY
C (3,14)
70             CONTINUE
C              END BLOCK
            ENDDO
C (3,15)
80          CONTINUE
C           END BLOCK
         ENDDO
C        END BLOCK
C (2,1)
90       CONTINUE
C        END UNSTRUCTURED
C        END BLOCK
      ENDDO
C (0,22)
CX20646 CALL DOOUTX( 646 )
CY20646 CALL DOOUTY( 646 )
CX40104 CALL SBOUTX (104)
CY40104 CALL SBOUTY (104)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *      CHECK A PRIORY THE STABILITY LIMITS OF THE SYSTEM             *
C **********************************************************************
C
      SUBROUTINE STAB(NX,NY,NTIME,TSTART,NT,IB,HAMP,BUMP,
     *DELTAX,DELTAY,DELTAT)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 H(8)
      SAVE H
      DATA H/1.D0,.72D0,.86D0,1.2D0,1.18D0,1.61D0,1.95D0,1.7D0/
C (0,1)
C     BEGIN BLOCK
C (0,2)
10    FORMAT
     &(/,' FOR LINEAR STABILITY,  UMAX <',F6.2,'  VMAX <',F6.2,/)
C (0,3)
20    FORMAT(' ** TOTAL SIMULATION PERIOD ',F10.1,'S, =',F6.2,' HOURS **
     x 
     &',/,' ** HEAT AMPLITUDE ',F6.2,' K,    LAG =',F6.2,'(H),   BIAS A 
     x 
     &',F6.1,//)
C (0,4)
30    FORMAT(' ********   LAND SURFACE FORCING  FUNCTION ********* ',//,
     x 
     &' T(X,Y,T)=',F5.1,'{EXP -((T-',F4.1,')/',F4.1,')**2 -',F4.1,'}',//
     x 
     &,' ********   TIME UNITS ARE IN HOURS        *********',/)
C (0,5)
CX30105 CALL SBINX (105)
CY30105 CALL SBINY (105)
      A1 = H(NTIME)/(DELTAT*3.14)
C (0,6)
      A2 = FLOAT(NX-2)/(FLOAT(NX)*DELTAX)
C (0,7)
      A3 = FLOAT(NY-2)/(FLOAT(NY)*DELTAY)
C (0,8)
      UT = A1/A2
C (0,9)
      IF (A3.LT.0) THEN
C (0,10)
         A1 = 0
      ELSE
C (0,11)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,12)
      VT = A1/A3
C (0,13)
      WRITE (6, 10) UT, VT
C (0,14)
      TEND1 = TSTART+NT*DELTAT
C (0,15)
      PERIOD = TEND1-TSTART
C (0,16)
      HOUR = PERIOD/3600.D0
C (0,17)
      BIAS = IB/10.D0
C (0,18)
      BAMP = BUMP/3600.D0
C (0,19)
      WRITE (6, 20) PERIOD, HOUR, HAMP, BAMP, BIAS
C (0,20)
      DUMP = 4.9
C (0,21)
      WRITE (6, 30) HAMP, BAMP, DUMP, BIAS
C (0,22)
      WRITE (8, 30) HAMP, BAMP, DUMP, BIAS
C (0,23)
CX40106 CALL SBOUTX (106)
CY40106 CALL SBOUTY (106)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *      CALCULATION OF RATES OF MEAN POTENTIAL TEMPERATURE, U,V       *
C *      WIND COMPONENTS AS WELL AS THE GEOSTROPHIC COMPONENTS         *
C **********************************************************************
C
      SUBROUTINE SYNSET(TIME)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      COMMON/LEVEL/KK1,KK2,KK3,KK4,IYHOM,IGEO,IUGX,IVGY,LT0,LT1,ICPU
      COMMON/STRCH/ALP,BET,DH,ZH,UG,VG,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30107 CALL SBINX (107)
CY30107 CALL SBINY (107)
C
C     CALCULATE NEW GEOSTROPHIC WINDS SURFACE AND TOP TEMPERATURES
C     ACCORDING TO THE GIVEN RATES OF CHANGE. NORMALLY DATA WILL BE
C     READ IN FROM AN OBSERVATIONAL NETWORK. THE RATES FOR THE WINDS
C     ARE GIVEN IN CM PER HOURS, WHILE THE TEMPERATURE CHANGES ARE
C     IN DEGREES PER TEN HOURS
C
      UG = UG+TIME*IUGX/360000.D0
C (0,3)
      VG = VG+TIME*IVGY/360000.D0
C (0,4)
      T1 = T1+TIME*LT0/36000.D0
C (0,5)
      T2 = T2+TIME*LT1/36000.D0
C (0,6)
CX40108 CALL SBOUTX (108)
CY40108 CALL SBOUTY (108)
C
      RETURN
C     END BLOCK
      END
C
C  *********************************************************************
C  *      SYNOPTIC WIND AND TEMPERATURE GENERATION   ROUTINE           *
C  *********************************************************************
C
      SUBROUTINE UVSET(NX,NY,NZ,HVAR,ZET,NP,DZ,DKM,UM,VM,UG,VG,TM,
     *WORK,ITY,IH,NSMT,F)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION HVAR(I_PIPS_RUN_HVAR),ZET(I_PIPS_RUN_ZET),TM(I_PIPS_RUN_
     x TM),DKM(I_PIPS_RUN_DKM),UM(I_PIPS_RUN_UM),VM(I_PIPS_RUN_VM),UG(I_
     x PIPS_RUN_UG),VG(I_PIPS_RUN_VG),
     *WORK(I_PIPS_RUN_DCDX)
      COMMON/STRCH/ALP,BET,DH,ZH,UGH,VGH,T1,T2,DT,TOL,ALPHA,HAMP,BUMP
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
C (0,1)
      INTEGER*8 I_PIPS_RUN_HVAR
      COMMON /PIPS_RUN_HVAR/ I_PIPS_RUN_HVAR
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_UG
      COMMON /PIPS_RUN_UG/ I_PIPS_RUN_UG
      INTEGER*8 I_PIPS_RUN_VG
      COMMON /PIPS_RUN_VG/ I_PIPS_RUN_VG
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DKZMN_WM
      COMMON /PIPS_DKZMN_WM/ I_PIPS_DKZMN_WM
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
C     BEGIN BLOCK
C (0,2)
CX30109 CALL SBINX (109)
CY30109 CALL SBINY (109)
C
C     IF THE FLOW IS TWO-DIMENSIONAL (X-Z) USE THE U PROFILE ONLY
C     WHILE IF THE DIMENSIONS ARE (X,Y) USE THE GEOSTROPHIC WINDS
C
      L = 2*NZ
C (0,3)
C      L1=NZ
C ***  TRIDIAGONAL COMPLEX/REAL VECTOR AN, FOR CENTER ELEMENTS       ***
      LA = 1
C (0,4)
      LAST = L
C (0,5)
C ***  TRIDIAGONAL COMPLEX/REAL VECTOR BN, FOR LEFT ELEMENTS         ***
      LB = LAST+1
C (0,6)
      LAST = LAST+L
C (0,7)
C ***  TRIDIAGONAL COMPLEX/REAL VECTOR CN, FOR RIGHT ELEMENTS        ***
      LC = LAST+1
C (0,8)
      LAST = LAST+L
C (0,9)
C ***  TRIDIAGONAL COMPLEX VECTOR FN, FOR FORCING                    ***
      LF = LAST+1
C (0,10)
      LAST = LAST+L
C (0,11)
C ***  COMPLEX MEAN WIND COMPONENT WM=UM+IVM                         ***
      LWM = LAST+1
C (0,12)
      LAST = LAST+L
C (0,13)
C ***  COMPLEX MEAN WIND COMPONENT WG=UG+IVG                         ***
      LWG = LAST+1
C (0,14)
      LAST = LAST+L
C (0,15)
C ***  DERIVATIVE OF DIFFUSSIVITY  DKZ
C      VM WILL PLAY THE ROLE OF DKZ AND VECTOR DUMP
C      UM WILL BECOME A VECTOR FOR TESTING CONVERGENCE
C ***
      CALL DINITU(ZET, TM, DKM, DZ, WORK(LWG), WORK(LWM), NZ, NP, UM
     &, UG, VG, F)
C (0,16)
      ITER = 0
C (0,17)
      DNORM = 0.0D0
C (0,18)
C     BEGIN UNSTRUCTURED
C (1,1)
C     BEGIN BLOCK
C (1,2)
C
C     SOLVE FOR A NEW MEAN WIND PROFILE, AND THEN CORRECT THE MEAN
C     TEMPERATURE PROFILE FOR MEAN HEAT AND MOMENTUM BALANCE.
C
10    ITER = ITER+1
C (1,3)
      IF (IH.EQ.0) THEN
C (1,4)
C        BEGIN BLOCK
C (1,5)
         CALL CRANKC(DKM, VM, HVAR, WORK(LWM), WORK(LWG), WORK(LF), 
     &   NZ, WORK(LA), WORK(LB), WORK(LC), ITY)
C (1,6)
         CALL TMCRNK(DKM, HVAR, TM, VM, NZ, WORK(LA), WORK(LB), WORK(
     &   LC), ITY)
C        END BLOCK
      ELSE
C (1,7)
C        BEGIN BLOCK
C (1,8)
         CALL PADEC(DKM, VM, HVAR, WORK(LWM), WORK(LWG), WORK(LF), NZ
     &   , WORK(LA), WORK(LB), WORK(LC), ITY)
C (1,9)
         CALL TMPADE(DKM, HVAR, TM, VM, NZ, WORK(LA), WORK(LB), WORK(
     &   LC), ITY)
C        END BLOCK
      ENDIF
C (1,10)
      I_PIPS_DKZMN_WM = (I_PIPS_RUN_DCDX-(LWM-1))*8/16
C
C     OBTAIN CORRECT DIFFUSSIVITIES
C
      CALL DKZMN(TM, WORK(LWM), ZET, DKM, DZ, ZNOT, USTAR, DL, KLAS, 
     &ZMH, F, NZ)
C (1,11)
      ITR = ITER
C (1,12)
C
C     CHECK FOR CONVERGENCE IN THE ITERATIONS
C
      CALL TEST(UM, WORK(LWM), NZ, DNORM, ITER, TOL, DT, TIMEM)
C     END BLOCK
C (2,1)
      IF (ITER.GT.29999) THEN
      ELSE
         GOTO 10
      ENDIF
C     END UNSTRUCTURED
C (0,19)
      CALL FINAL(NZ, UM, VM, UG, VG, TM, DKM, ZMH, DL, USTAR, KLAS, 
     &WORK(LWM), ZET, DNORM, ITR, NY, DT, TIMEM)
C (0,20)
C
C     SMOOTH THE VERTICAL PROFILES IF NECESSARY
C
      IF (NSMT.EQ.1) THEN
C (0,21)
C        BEGIN BLOCK
C (0,22)
      I_PIPS_SMTH_F = I_PIPS_RUN_UM
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
         CALL SMTH(UM, ZET, NZ)
C (0,23)
      I_PIPS_SMTH_F = I_PIPS_RUN_VM
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
         CALL SMTH(VM, ZET, NZ)
C        END BLOCK
      ELSE
C (0,24)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,25)
CX40110 CALL SBOUTX (110)
CY40110 CALL SBOUTY (110)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *          INITIAL CONDITION FOR THE U AND V MEAN WIND COMPONENTS    *
C **********************************************************************
C
      SUBROUTINE  DINITU(ZET,TM,DKM,DZ,WG,WM,NZ,NP,UM,UG,VG,F)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION ZET(I_PIPS_RUN_ZET),TM(I_PIPS_RUN_TM),DKM(I_PIPS_RUN_DKM
     x ),UM(I_PIPS_RUN_UM),UG(I_PIPS_RUN_UG),VG(I_PIPS_RUN_VG)
      COMPLEX*16 WG((-80*NZ+8*I_PIPS_RUN_DCDX)/16),WM((-64*NZ+8*I_PIPS_R
     x UN_DCDX)/16)
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
      COMMON/STRCH/ALP,BET,DH,ZH,UGH,VGH,T1,T2,DUT,TOL,ALPHA,HAMP,BUMP
      PARAMETER (PI = 3.141592653589793)
C (0,1)
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_UG
      COMMON /PIPS_RUN_UG/ I_PIPS_RUN_UG
      INTEGER*8 I_PIPS_RUN_VG
      COMMON /PIPS_RUN_VG/ I_PIPS_RUN_VG
      INTEGER*8 I_PIPS_DKZMN_WM
      COMMON /PIPS_DKZMN_WM/ I_PIPS_DKZMN_WM
C     BEGIN BLOCK
C (0,2)
CX30111 CALL SBINX (111)
CY30111 CALL SBINY (111)
C
C   WE DEFINE A NEW DZ FROM DZ=F*ZH*ZH/(2*PI*PI)
C
      DZIN = F*ZH*ZH/(2*PI*PI)
C (0,3)
      GAMMA = DSQRT(F/(2.0D0*DZIN))
C (0,4)
C
C     CALCULATE THE MEAN TEMPERATURE AND PRESSURE GRADIENTS
C
      DTDZ = (T2-T1)/ZH
C (0,5)
      DPDY = -F*UGH/T2
C (0,6)
      DPDX = F*VGH/T2
C (0,7)
      WG(1) = CMPLX(-T1*DPDY/F, T1*DPDX/F)
C (0,8)
C ***   LOWER BOUNDARY CONDITION ***
      WM(1) = (0.0D0, 0.0D0)
C (0,9)
      TM(1) = T1
C (0,10)
      UM(1) = 0.D0
C (0,11)
      UG(1) = -TM(1)*DPDY/F
C (0,12)
      VG(1) = TM(1)*DPDX/F
C (0,13)
CX10647 CALL DOINX( 647 )
CY10647 CALL DOINY( 647 )
!     INITIALLY: DO 10
      DO K = 2, NZ
C (0,14)
C        BEGIN BLOCK
C (0,15)
         GZ = GAMMA*ZET(K)
C (0,16)
         EGZ = EXP(-GZ)
C (0,17)
         TM(K) = T1+DTDZ*ZET(K)
C (0,18)
         UG(K) = -TM(K)*DPDY/F
C (0,19)
         VG(K) = TM(K)*DPDX/F
C (0,20)
         U0 = UG(K)*(1.D0-DCOS(GZ)*EGZ)-VG(K)*DSIN(GZ)*EGZ
C (0,21)
         V0 = VG(K)*(1.D0-DCOS(GZ)*EGZ)+UG(K)*DSIN(GZ)*EGZ
C (0,22)
         WG(K) = CMPLX(UG(K), VG(K))
C (0,23)
         WM(K) = CMPLX(U0, V0)
C (0,24)
         UM(K) = ABS(WM(K))
C (0,25)
10       CONTINUE
C        END BLOCK
      ENDDO
C (0,26)
CX20648 CALL DOOUTX( 648 )
CY20648 CALL DOOUTY( 648 )
C ***  UPPER BOUNDARY CONDITION
      WM(NZ) = WG(NZ)
C (0,27)
      I_PIPS_DKZMN_WM = (-64*NZ+8*I_PIPS_RUN_DCDX)/16
C ***  BOUNDARY LAYER SOLVER FOR FIRST DIFFUSIVITIES DZMIN->DKM
      CALL DKZMN(TM, WM, ZET, DKM, DZ, ZNOT, USTAR, DL, KLAS, ZMH, F
     &, NZ)
C (0,28)
CX40112 CALL SBOUTX (112)
CY40112 CALL SBOUTY (112)
C ***  DZ IS THE MINIMUM DIFFUSIVITY ASSIGNED IN THE BEGINING
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *            CONVERSION TO MEAN U,V COMPONENTS                       *
C **********************************************************************
C
      SUBROUTINE FINAL(NZ,UM,VM,UG,VG,TM,DKM,ZMH,DL,USTAR,KLAS,WM,
     *ZET,DNORM,ITR,NY,DT,TIMEM)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION UM(I_PIPS_RUN_UM),VM(I_PIPS_RUN_VM),TM(I_PIPS_RUN_TM),ZE
     x T(I_PIPS_RUN_ZET),DKM(I_PIPS_RUN_DKM),UG(I_PIPS_RUN_UG),VG(I_PIPS
     x _RUN_VG)
      COMPLEX*16 WM((-64*NZ+8*I_PIPS_RUN_DCDX)/16)
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
C (0,1)
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_UG
      COMMON /PIPS_RUN_UG/ I_PIPS_RUN_UG
      INTEGER*8 I_PIPS_RUN_VG
      COMMON /PIPS_RUN_VG/ I_PIPS_RUN_VG
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
C     BEGIN BLOCK
C (0,2)
10    FORMAT(/,' ***********************  MEAN PROFILES ****************
     x 
     &*******',//,' CONVERGENCE AFTER ',I6,' ITERATIONS.    NORM= ',E12.
     x 
     &4,/,' EQUIVALENT TIME FOR THE MEAN PROFILES  IS ',F10.2,' SEC. ',/
     x 
     &,' Z0=',F8.4,'   ZMIX=',F7.2,'   U*=',F9.5,'   L(',I1,')=',F12.2)
C (0,3)
20    FORMAT(//,'   K ',1X,'  HEIGHT (M)',6X,' UG(Z) ',3X,' VG(Z) ',4X,'
     x 
     & TM(Z) ',4X,'  KM(Z)  ',4X,' UM(Z)  ',4X,' VM(Z)  ',/)
C (0,4)
CX20650 CALL DOOUTX( 650 )
CY20650 CALL DOOUTY( 650 )
40    FORMAT(I4,F11.2,4X,2F10.2,4F12.2)
C (0,5)
50    FORMAT(/,' *******************************************************
     x 
     &*******',/)
C (0,6)
CX30113 CALL SBINX (113)
CY30113 CALL SBINY (113)
      WRITE (6, 10) ITR, DNORM, TIMEM, ZNOT, ZMH, USTAR, KLAS, DL
C (0,7)
      WRITE (8, 10) ITR, DNORM, TIMEM, ZNOT, ZMH, USTAR, KLAS, DL
C (0,8)
      WRITE (8, 20) 
C (0,9)
      WRITE (6, 20) 
C (0,10)
CX10649 CALL DOINX( 649 )
CY10649 CALL DOINY( 649 )
!     INITIALLY: DO 30
      DO K = 1, NZ
C (0,11)
C        BEGIN BLOCK
C (0,12)
         UM(K) = DBLE(WM(K))
C (0,13)
         VM(K) = DIMAG(WM(K))
C (0,14)
         WRITE (6, 40) K, ZET(K), UG(K), VG(K), TM(K), DKM(K), UM(K)
     &   , VM(K)
C (0,15)
         WRITE (8, 40) K, ZET(K), UG(K), VG(K), TM(K), DKM(K), UM(K)
     &   , VM(K)
C (0,16)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,17)
      WRITE (6, 50) 
C (0,18)
      WRITE (8, 50) 
C (0,19)
CX40114 CALL SBOUTX (114)
CY40114 CALL SBOUTY (114)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *                     CONVERGENCE TEST ROUTINE                       *
C **********************************************************************
C
      SUBROUTINE TEST(HELP,WM,NZ,DNORM,ITER,TOL,DT,TIMEM)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 HELP(I_PIPS_RUN_UM)
      COMPLEX*16 WM((-64*NZ+8*I_PIPS_RUN_DCDX)/16)
C (0,1)
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
C     BEGIN BLOCK
C (0,2)
CX30115 CALL SBINX (115)
CY30115 CALL SBINY (115)
C
      TIMEM = ITER*DT
C (0,3)
      DNORM = 0.0D0
C (0,4)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (TOL.GT.1) GOTO 99982
C (5,1)
C     BEGIN BLOCK
C (5,2)
CX10651 CALL DOINX( 651 )
CY10651 CALL DOINY( 651 )
!     INITIALLY: DO 10
      DO K = 1, NZ
C (5,3)
C        BEGIN BLOCK
C (5,4)
         ZNEW = ABS(WM(K))
C (5,5)
         ZOLD = HELP(K)
C (5,6)
         HELP(K) = ZNEW
C (5,7)
         DNORM = DNORM+(ZNEW-ZOLD)**2/FLOAT(NZ)
C (5,8)
10       CONTINUE
C        END BLOCK
      ENDDO
C (5,9)
CX20652 CALL DOOUTX( 652 )
CY20652 CALL DOOUTY( 652 )
      IF (DNORM.LT.TOL) THEN
C (5,10)
         ITER = 30000
      ELSE
C (5,11)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C     END BLOCK
      RETURN
99982 CONTINUE
C (2,1)
      IF (TIMEM.GT.TOL) THEN
      ELSE
         RETURN
      ENDIF
C (3,1)
C     BEGIN BLOCK
C (3,2)
      ITER = 30000
CX40116 CALL SBOUTX (116)
CY40116 CALL SBOUTY (116)
C     END BLOCK
C (4,1)
CX40116 CALL SBOUTX (116)
CY40116 CALL SBOUTY (116)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C **              SET THE TOPOGRAPHY ELEV(I,J)                        **
C **     SET THE TOPOGRAPHY MATRIX, AND GRADIENTS OF TOPOGRRAPHY.     **
C **                                     < 0.0       WATER            **
C **      FOR  EVERY I,J: IF   ELEV(I,J) = 0.0  50% WATER, 50% LAND   **
C **                                     > 0.0       LAND             **
C **********************************************************************
C
      SUBROUTINE TOPO(NX,NY,XSTART,YSTART,DELTAX,DELTAY,ELEV,ELEVX,
     *ELEVY,Z0,HELP,HELPA,NX1,FX,FXX,FILX,SAVEX,NY1,FY,FYY,FILY,SAVEY)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION ELEV(I_PIPS_RUN_ELEV),ELEVX(I_PIPS_RUN_ELEVX),ELEVY(I_PI
     x PS_RUN_ELEVY),Z0(I_PIPS_RUN_Z0),FILX(I_PIPS_TOPO_FILX),FILY(I_PIP
     x S_TOPO_FILY),
     *HELP(I_PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),FX(I_PIPS_RUN_FX),FX
     x X(I_PIPS_RUN_FXX),SAVEX(I_PIPS_RUN_SAVEX),FY(I_PIPS_RUN_FY),FYY(I
     x _PIPS_RUN_FYY),SAVEY(I_PIPS_RUN_SAVEY)
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
C (0,1)
      INTEGER*8 I_PIPS_RUN_ELEV
      COMMON /PIPS_RUN_ELEV/ I_PIPS_RUN_ELEV
      INTEGER*8 I_PIPS_RUN_ELEVX
      COMMON /PIPS_RUN_ELEVX/ I_PIPS_RUN_ELEVX
      INTEGER*8 I_PIPS_RUN_ELEVY
      COMMON /PIPS_RUN_ELEVY/ I_PIPS_RUN_ELEVY
      INTEGER*8 I_PIPS_RUN_Z0
      COMMON /PIPS_RUN_Z0/ I_PIPS_RUN_Z0
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FXX
      COMMON /PIPS_RUN_FXX/ I_PIPS_RUN_FXX
      INTEGER*8 I_PIPS_TOPO_FILX
      COMMON /PIPS_TOPO_FILX/ I_PIPS_TOPO_FILX
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FYY
      COMMON /PIPS_RUN_FYY/ I_PIPS_RUN_FYY
      INTEGER*8 I_PIPS_TOPO_FILY
      COMMON /PIPS_TOPO_FILY/ I_PIPS_TOPO_FILY
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_FILTPR_FILT
      COMMON /PIPS_FILTPR_FILT/ I_PIPS_FILTPR_FILT
C     BEGIN BLOCK
C (0,2)
CX30117 CALL SBINX (117)
CY30117 CALL SBINY (117)
CGAO      PI=4.D0*DATAN(1.D0)
      HIGH = 0.0D0
C (0,3)
      DLOW = 0.0D0
C (0,4)
C     BEGIN UNSTRUCTURED
C (1,1)
CGAO      NXY=NX*NY
C
C      NORMALLY READ THE TOPOGRAPHY AND ROUGNESS DATA FROM A FILE
C      OPEN(21,FILE='TOPO.DAT')
C      READ(21,10) (ELEV(L),L=1,NXY),(Z0(L),L=1,NXY)
C 10   FORMAT(NXF10.4)
C      OR PRODUCE THEM
C
      IF (NX.EQ.1.AND.NY.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      Y0 = (YSTART+(NY-1)*DELTAY)/SY
C (3,3)
      X0 = (XSTART+(NX-1)*DELTAX)/SX
C (3,4)
      YF0 = (YSTART+(NY-1)*DELTAY)/SFY
C (3,5)
      XF0 = (XSTART+(NX-1)*DELTAX)/SFX
C (3,6)
      IVEC = 0
C (3,7)
CX10653 CALL DOINX( 653 )
CY10653 CALL DOINY( 653 )
!     INITIALLY: DO 20
      DO J = 1, NY
C (3,8)
C        BEGIN BLOCK
C (3,9)
         Y = YSTART+(J-1)*DELTAY
C (3,10)
         Y1 = (Y-Y0)/SIGY
C (3,11)
         YF1 = (Y-YF0)/FLY
C (3,12)
         ARGFY = -YF1*YF1/2.D0
C (3,13)
         FILY(J) = EXP(ARGFY)
C (3,14)
         IF (FILY(J).GT.BASE) THEN
C (3,15)
            FILY(J) = BASE
         ELSE
C (3,16)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (3,17)
!     INITIALLY: DO 10
         DO I = 1, NX
C (3,18)
C           BEGIN BLOCK
C (3,19)
            IVEC = IVEC+1
C (3,20)
            X = XSTART+(I-1)*DELTAX
C (3,21)
            X1 = (X-X0)/SIGX
C (3,22)
            XF1 = (X-XF0)/FLX
C (3,23)
            ARG = -X1*X1/2.D0-Y1*Y1/2.D0
C (3,24)
            ARGFX = -XF1*XF1/2.D0
C (3,25)
            FIELD = EXP(ARG)
C (3,26)
            FILX(I) = EXP(ARGFX)
C (3,27)
            IF (FILX(I).GT.BASE) THEN
C (3,28)
               FILX(I) = BASE
            ELSE
C (3,29)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (3,30)
C     LAND POINTS
            IF (FIELD.LT.0.57D0) THEN
C (3,31)
C              BEGIN BLOCK
C (3,32)
               RUFNES = ZL
C (3,33)
               HEIGHT = 1.0D0
C              END BLOCK
            ELSE
C (3,34)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (3,35)
C     MIXED POINTS
            IF (FIELD.GE.0.57D0.AND.FIELD.LT.0.6D0) THEN
C (3,36)
C              BEGIN BLOCK
C (3,37)
               RUFNES = (ZL+ZW)/2.D0
C (3,38)
               HEIGHT = 0.0D0
C              END BLOCK
            ELSE
C (3,39)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (3,40)
C     WATER POINTS
            IF (FIELD.GE.0.6D0) THEN
C (3,41)
C              BEGIN BLOCK
C (3,42)
               RUFNES = ZW
C (3,43)
               HEIGHT = -1.0D0
C              END BLOCK
            ELSE
C (3,44)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (3,45)
            Z0(IVEC) = RUFNES
C (3,46)
            ELEV(IVEC) = HEIGHT
C (3,47)
            HIGH = MAX(HIGH, HEIGHT)
C (3,48)
            DLOW = MIN(DLOW, HEIGHT)
C (3,49)
10          CONTINUE
C           END BLOCK
         ENDDO
C (3,50)
20       CONTINUE
C        END BLOCK
      ENDDO
C (3,51)
CX20654 CALL DOOUTX( 654 )
CY20654 CALL DOOUTY( 654 )
C
C       CALCULATE TOPOGRAPHY GRADIENTS
C
      CALL DFTDX(NX, NY, NX1, ELEV, ELEVX, HELP, FX, SAVEX)
C (3,52)
CX10655 CALL DOINX( 655 )
CY10655 CALL DOINY( 655 )
!     INITIALLY: DO 30
      DO I = 1, NX
C (3,53)
C        BEGIN BLOCK
C (3,54)
         FILX(I) = FILX(I)/BASE
C (3,55)
30       CONTINUE
C        END BLOCK
      ENDDO
C (3,56)
      I_PIPS_FILTPR_FILT = I_PIPS_TOPO_FILX
CX20656 CALL DOOUTX( 656 )
CY20656 CALL DOOUTY( 656 )
      CALL FILTPR(FILX, NX, ' X - FILTER ')
C (3,57)
C
      IF (NY.GT.1) THEN
C (3,58)
C        BEGIN BLOCK
C (3,59)
         CALL DFTDY(NX, NY, NY1, ELEV, ELEVY, HELP, FY, SAVEY)
C (3,60)
CX10657 CALL DOINX( 657 )
CY10657 CALL DOINY( 657 )
!     INITIALLY: DO 40
         DO J = 1, NY
C (3,61)
C           BEGIN BLOCK
C (3,62)
            FILY(J) = FILY(J)/BASE
C (3,63)
40          CONTINUE
C           END BLOCK
         ENDDO
C (3,64)
      I_PIPS_FILTPR_FILT = I_PIPS_TOPO_FILY
CX20658 CALL DOOUTX( 658 )
CY20658 CALL DOOUTY( 658 )
         CALL FILTPR(FILY, NY, ' Y - FILTER ')
C        END BLOCK
      ELSE
C (3,65)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (3,66)
C
C        PLOT TOPOGRAPHY
C
      CALL TOPPLT(NX, NY, HIGH, DLOW, ELEV)
CX40118 CALL SBOUTX (118)
CY40118 CALL SBOUTY (118)
C     END BLOCK
C (2,1)
CX40118 CALL SBOUTX (118)
CY40118 CALL SBOUTY (118)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C *                   PRINT THE  TOPOGRAPHY MAP                        *
C **********************************************************************
C
       SUBROUTINE  TOPPLT(NX,NY,HIGH,DLOW,ELEV)
       IMPLICIT DOUBLE PRECISION (A-H, O-Z)
       REAL*8 ELEV(NX,NY)
       CHARACTER MAP(512)
C (0,1)
C     BEGIN BLOCK
C (0,2)
10    FORMAT(//10X,'  ****   TOPOGRAPHY  MAX = ',F10.2,' MIN = ',F10.2,'
     x 
     &  METERS   ****',//)
C (0,3)
CX20660 CALL DOOUTX( 660 )
CY20660 CALL DOOUTY( 660 )
40    FORMAT(1X,64A,/,1X,64A,/1X,64A,/,1X,64A)
C (0,4)
CX30119 CALL SBINX (119)
CY30119 CALL SBINY (119)
      WRITE (6, 10) HIGH, DLOW
C (0,5)
      WRITE (8, 10) HIGH, DLOW
C (0,6)
CX10659 CALL DOINX( 659 )
CY10659 CALL DOINY( 659 )
!     INITIALLY: DO 30
      DO J = 1, NY
C (0,7)
C        BEGIN BLOCK
C (0,8)
         JJ = NY-J+1
C (0,9)
!     INITIALLY: DO 20
         DO I = 1, NX
C (0,10)
C           BEGIN BLOCK
C (0,11)
            IF (ELEV(I,JJ).LT.0.) THEN
C (0,12)
               MAP(I) = 'W'
            ELSE
C (0,13)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,14)
            IF (ELEV(I,JJ).EQ.0.) THEN
C (0,15)
               MAP(I) = 'C'
            ELSE
C (0,16)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,17)
            IF (ELEV(I,JJ).GT.0.) THEN
C (0,18)
               MAP(I) = 'L'
            ELSE
C (0,19)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,20)
            IF (ELEV(I,JJ).GT.100.) THEN
C (0,21)
               MAP(I) = 'M'
            ELSE
C (0,22)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,23)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,24)
         WRITE (6, 40) (MAP(I), I = 1, NX)
C (0,25)
         WRITE (8, 40) (MAP(I), I = 1, NX)
C (0,26)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,27)
CX40120 CALL SBOUTX (120)
CY40120 CALL SBOUTY (120)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *    ROUTINE TO PRINT THE PRESSURE FILTER  SHAPE                     *
C **********************************************************************
C
       SUBROUTINE FILTPR(FILT,N,LABEL)
       IMPLICIT DOUBLE PRECISION (A-H, O-Z)
       REAL*8 FILT(I_PIPS_FILTPR_FILT)
       CHARACTER*12 LABEL
       INTEGER MFILT(512)
C (0,1)
      INTEGER*8 I_PIPS_TOPO_FILX
      COMMON /PIPS_TOPO_FILX/ I_PIPS_TOPO_FILX
      INTEGER*8 I_PIPS_TOPO_FILY
      COMMON /PIPS_TOPO_FILY/ I_PIPS_TOPO_FILY
      INTEGER*8 I_PIPS_FILTPR_FILT
      COMMON /PIPS_FILTPR_FILT/ I_PIPS_FILTPR_FILT
C     BEGIN BLOCK
C (0,2)
10    FORMAT(/,' **************** ',A,' ***************** ',/)
C (0,3)
30    FORMAT(1X,64I1,/,1X,64I1,/1X,64I1,/,1X,64I1)
C (0,4)
CX30121 CALL SBINX (121)
CY30121 CALL SBINY (121)
      WRITE (6, 10) LABEL
C (0,5)
      WRITE (8, 10) LABEL
C (0,6)
CX10661 CALL DOINX( 661 )
CY10661 CALL DOINY( 661 )
!     INITIALLY: DO 20
      DO I = 1, N
C (0,7)
C        BEGIN BLOCK
C (0,8)
         MFILT(I) = 10*FILT(I)
C (0,9)
         IF (MFILT(I).EQ.10) THEN
C (0,10)
            MFILT(I) = 0
         ELSE
C (0,11)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,12)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,13)
CX20662 CALL DOOUTX( 662 )
CY20662 CALL DOOUTY( 662 )
      WRITE (6, 30) (MFILT(I), I = 1, N)
C (0,14)
      WRITE (8, 30) (MFILT(I), I = 1, N)
C (0,15)
CX40122 CALL SBOUTX (122)
CY40122 CALL SBOUTY (122)
      RETURN
C     END BLOCK
      END
C
C  *********************************************************************
C  *                  ROUTINE TO PRINT THE MEAN PROFILES               *
C  *********************************************************************
C
      SUBROUTINE PRN(NZ,UM,VM,TM,DKM,ZMH,DL,USTAR,KLAS,WM,
     *ZET,DNORM,ITR)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 UM(I_PIPS_PRN_UM),VM(I_PIPS_PRN_VM),TM(I_PIPS_PRN_TM),ZET(I
     x _PIPS_PRN_ZET),DKM(I_PIPS_PRN_DKM)
      COMPLEX*16 WM(I_PIPS_PRN_WM)
      COMMON/LAKE/SX,SIGX,SY,SIGY,ZNOT,SFX,SFY,FLX,FLY,BASE,TSL,H0,ZW,ZL
     x 
C (0,1)
      INTEGER*8 I_PIPS_PRN_UM
      COMMON /PIPS_PRN_UM/ I_PIPS_PRN_UM
      INTEGER*8 I_PIPS_PRN_VM
      COMMON /PIPS_PRN_VM/ I_PIPS_PRN_VM
      INTEGER*8 I_PIPS_PRN_TM
      COMMON /PIPS_PRN_TM/ I_PIPS_PRN_TM
      INTEGER*8 I_PIPS_PRN_DKM
      COMMON /PIPS_PRN_DKM/ I_PIPS_PRN_DKM
      INTEGER*8 I_PIPS_PRN_WM
      COMMON /PIPS_PRN_WM/ I_PIPS_PRN_WM
      INTEGER*8 I_PIPS_PRN_ZET
      COMMON /PIPS_PRN_ZET/ I_PIPS_PRN_ZET
C     BEGIN BLOCK
C (0,2)
10    FORMAT(/,'  CONVERGENCE AFTER ',I6,' ITERATIONS.    NORM= ',E12.4,
     x 
     &/,' Z0=',F8.4,'   ZMIX=',F7.2,'   U*=',F9.5,'   L(',I1,')=',F12.2)
     x 
C (0,3)
20    FORMAT(//,'   K ',1X,'  HEIGHT (M)',6X,' UM(Z) ',3X,' VM(Z) ',4X,'
     x 
     & TM(Z) ',4X,'  KM(Z)  ',/)
C (0,4)
CX20664 CALL DOOUTX( 664 )
CY20664 CALL DOOUTY( 664 )
40    FORMAT(I4,F11.2,4X,2F10.2,F12.2,F12.2)
C (0,5)
CX30123 CALL SBINX (123)
CY30123 CALL SBINY (123)
      WRITE (6, 10) ITR, DNORM, ZNOT, ZMH, USTAR, KLAS, DL
C (0,6)
      WRITE (8, 10) ITR, DNORM, ZNOT, ZMH, USTAR, KLAS, DL
C (0,7)
      WRITE (8, 20) 
C (0,8)
      WRITE (6, 20) 
C (0,9)
CX10663 CALL DOINX( 663 )
CY10663 CALL DOINY( 663 )
!     INITIALLY: DO 30
      DO K = 1, NZ
C (0,10)
C        BEGIN BLOCK
C (0,11)
         WRITE (6, 40) K, ZET(K), WM(K), TM(K), DKM(K)
C (0,12)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,13)
CX40124 CALL SBOUTX (124)
CY40124 CALL SBOUTY (124)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *                 CPU  AND ELAPSE TIME MEASURES                      *
C **********************************************************************
C
C     SUBROUTINE CPUCLK(TM,INIT,RIT0)
C     REAL TMP0,TMP1
C     SAVE TMP0
CX30125 CALL SBINX (125)
CY30125 CALL SBINY (125)
C
C      IF(INIT.EQ.0) THEN
C         CALL CPUTIM (TMP0)
C         TM=TMP0
C      ENDIF
C      CALL CPUTIM (TMP1)
C      TM=TMP1-TMP0
CX40126 CALL SBOUTX (126)
CY40126 CALL SBOUTY (126)
C
C      RETURN
C      END

C
C FFTPACKAGE FOR PSEUDOSPECTRAL ADVECTION CALCULATIONS   05/04/84
C
C PURPOSE  THIS PACKAGE CONSISTS OF PROGRAMS WHICH PERFORM FAST FOURIER
C          TRANSFORMS FOR BOTH COMPLEX AND REAL PERIODIC SEQUENCES AND
C          CERTIAN OTHER SYMMETRIC SEQUENCES THAT ARE LISTED BELOW.
C
C            RFFTI     INITIALIZE  RFFTF AND RFFTB
C            RFFTF     FORWARD TRANSFORM OF A REAL PERIODIC SEQUENCE
C            RFFTB     BACKWARD TRANSFORM OF A REAL COEFFICIENT ARRAY
C
C     ******************************************************************
C
C     SUBROUTINE RFFTI(N,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE RFFTI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     BOTH RFFTF AND RFFTB. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED.
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 2*N+15.
C             THE SAME WORK ARRAY CAN BE USED FOR BOTH RFFTF AND RFFTB
C             AS LONG AS N REMAINS UNCHANGED. DIFFERENT WSAVE ARRAYS
C             ARE REQUIRED FOR DIFFERENT VALUES OF N. THE CONTENTS OF
C             WSAVE MUST NOT BE CHANGED BETWEEN CALLS OF RFFTF OR RFFTB.
C
C     ******************************************************************
C
C     SUBROUTINE RFFTF(N,R,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE RFFTF COMPUTES THE FOURIER COEFFICIENTS OF A REAL
C     PERODIC SEQUENCE (FOURIER ANALYSIS). THE TRANSFORM IS DEFINED
C     BELOW AT OUTPUT PARAMETER R.
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY R TO BE TRANSFORMED.  THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES.
C             N MAY CHANGE SO LONG AS DIFFERENT WORK ARRAYS ARE PROVIDED
C
C     R       A REAL ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE
C             TO BE TRANSFORMED
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 2*N+15.
C             IN THE PROGRAM THAT CALLS RFFTF. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE RFFTI(N,WSAVE) AND A
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C             THE SAME WSAVE ARRAY CAN BE USED BY RFFTF AND RFFTB.
C
C
C     OUTPUT PARAMETERS
C
C     R       R(1) = THE SUM FROM I=1 TO I=N OF R(I)
C
C             IF N IS EVEN SET L =N/2   , IF N IS ODD SET L = (N+1)/2
C
C               THEN FOR K = 2,...,L
C
C                  R(2*K-2) = THE SUM FROM I = 1 TO I = N OF
C
C                       R(I)*COS((K-1)*(I-1)*2*PI/N)
C
C                  R(2*K-1) = THE SUM FROM I = 1 TO I = N OF
C
C                      -R(I)*SIN((K-1)*(I-1)*2*PI/N)
C
C             IF N IS EVEN
C
C                  R(N) = THE SUM FROM I = 1 TO I = N OF
C
C                       (-1)**(I-1)*R(I)
C
C      *****  NOTE
C                  THIS TRANSFORM IS UNNORMALIZED SINCE A CALL OF RFFTF
C                  FOLLOWED BY A CALL OF RFFTB WILL MULTIPLY THE INPUT
C                  SEQUENCE BY N.
C
C     WSAVE   CONTAINS RESULTS WHICH MUST NOT BE DESTROYED BETWEEN
C             CALLS OF RFFTF OR RFFTB.
C
C
C     ******************************************************************
C
C     SUBROUTINE RFFTB(N,R,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE RFFTB COMPUTES THE REAL PERODIC SEQUENCE FROM ITS
C     FOURIER COEFFICIENTS (FOURIER SYNTHESIS). THE TRANSFORM IS DEFINED
C     BELOW AT OUTPUT PARAMETER R.
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY R TO BE TRANSFORMED.  THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES.
C             N MAY CHANGE SO LONG AS DIFFERENT WORK ARRAYS ARE PROVIDED
C
C     R       A REAL ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE
C             TO BE TRANSFORMED
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 2*N+15.
C             IN THE PROGRAM THAT CALLS RFFTB. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE RFFTI(N,WSAVE) AND A
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C             THE SAME WSAVE ARRAY CAN BE USED BY RFFTF AND RFFTB.
C
C
C     OUTPUT PARAMETERS
C
C     R       FOR N EVEN AND FOR I = 1,...,N
C
C                  R(I) = R(1)+(-1)**(I-1)*R(N)
C
C                       PLUS THE SUM FROM K=2 TO K=N/2 OF
C
C                        2.*R(2*K-2)*COS((K-1)*(I-1)*2*PI/N)
C
C                       -2.*R(2*K-1)*SIN((K-1)*(I-1)*2*PI/N)
C
C             FOR N ODD AND FOR I = 1,...,N
C
C                  R(I) = R(1) PLUS THE SUM FROM K=2 TO K=(N+1)/2 OF
C
C                       2.*R(2*K-2)*COS((K-1)*(I-1)*2*PI/N)
C
C                      -2.*R(2*K-1)*SIN((K-1)*(I-1)*2*PI/N)
C
C      *****  NOTE
C                  THIS TRANSFORM IS UNNORMALIZED SINCE A CALL OF RFFTF
C                  FOLLOWED BY A CALL OF RFFTB WILL MULTIPLY THE INPUT
C                  SEQUENCE BY N.
C
C     WSAVE   CONTAINS RESULTS WHICH MUST NOT BE DESTROYED BETWEEN
C             CALLS OF RFFTB OR RFFTF.
      SUBROUTINE RFFTI (N,WSAVE)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       WSAVE(I_PIPS_RFFTI_WSAVE)
C (0,1)
      INTEGER*8 I_PIPS_COSTI_WSAVE
      COMMON /PIPS_COSTI_WSAVE/ I_PIPS_COSTI_WSAVE
      INTEGER*8 I_PIPS_HORDFC_SAVEX
      COMMON /PIPS_HORDFC_SAVEX/ I_PIPS_HORDFC_SAVEX
      INTEGER*8 I_PIPS_RFFTI_WSAVE
      COMMON /PIPS_RFFTI_WSAVE/ I_PIPS_RFFTI_WSAVE
C     BEGIN UNSTRUCTURED
C (1,1)
CX30127 CALL SBINX (127)
CY30127 CALL SBINY (127)
      IF (N.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      CALL RFFTI1(N, WSAVE(N+1), WSAVE(2*N+1))
CX40128 CALL SBOUTX (128)
CY40128 CALL SBOUTY (128)
C     END BLOCK
C (2,1)
CX40128 CALL SBOUTX (128)
CY40128 CALL SBOUTY (128)
      RETURN
C     END UNSTRUCTURED
      END
      SUBROUTINE COSTI (N,WSAVE)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       WSAVE(I_PIPS_COSTI_WSAVE)
      PARAMETER (PI = 3.14159265358979)
C (0,1)
      INTEGER*8 I_PIPS_COSTI_WSAVE
      COMMON /PIPS_COSTI_WSAVE/ I_PIPS_COSTI_WSAVE
      INTEGER*8 I_PIPS_RFFTI_WSAVE
      COMMON /PIPS_RFFTI_WSAVE/ I_PIPS_RFFTI_WSAVE
C     BEGIN UNSTRUCTURED
C (1,1)
CX30129 CALL SBINX (129)
CY30129 CALL SBINY (129)
      IF (N.LE.3) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      NM1 = N-1
C (3,3)
      NP1 = N+1
C (3,4)
      NS2 = N/2
C (3,5)
      DT = PI/FLOAT(NM1)
C (3,6)
      FK = 0.D0
C (3,7)
CX10665 CALL DOINX( 665 )
CY10665 CALL DOINY( 665 )
!     INITIALLY: DO 101
      DO K = 2, NS2
C (3,8)
C        BEGIN BLOCK
C (3,9)
         KC = NP1-K
C (3,10)
         FK = FK+1.
C (3,11)
         WSAVE(K) = 2.D0*DSIN(FK*DT)
C (3,12)
         WSAVE(KC) = 2.D0*DCOS(FK*DT)
C (3,13)
101      CONTINUE
C        END BLOCK
      ENDDO
C (3,14)
      I_PIPS_RFFTI_WSAVE = I_PIPS_COSTI_WSAVE-(N+1-1)
CX20666 CALL DOOUTX( 666 )
CY20666 CALL DOOUTY( 666 )
      CALL RFFTI(NM1, WSAVE(N+1))
CX40130 CALL SBOUTX (130)
CY40130 CALL SBOUTY (130)
C     END BLOCK
C (2,1)
CX40130 CALL SBOUTX (130)
CY40130 CALL SBOUTY (130)
      RETURN
C     END UNSTRUCTURED
      END
      SUBROUTINE COST (N,X,WSAVE)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       X(I_PIPS_COST_X)       ,WSAVE(I_PIPS_COST_WSAVE)
C (0,1)
      INTEGER*8 I_PIPS_COST_X
      COMMON /PIPS_COST_X/ I_PIPS_COST_X
      INTEGER*8 I_PIPS_COST_WSAVE
      COMMON /PIPS_COST_WSAVE/ I_PIPS_COST_WSAVE
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30131 CALL SBINX (131)
CY30131 CALL SBINY (131)
      NM1 = N-1
C (0,3)
      NP1 = N+1
C (0,4)
      NS2 = N/2
C (0,5)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (N-2.LT.0) GOTO 106
C (4,1)
      IF (N-2.EQ.0) GOTO 101
C (5,1)
102   IF (N.GT.3) GOTO 103
C (7,1)
C     BEGIN BLOCK
C (7,2)
      X1P3 = X(1)+X(3)
C (7,3)
      TX2 = X(2)+X(2)
C (7,4)
      X(2) = X(1)-X(3)
C (7,5)
      X(1) = X1P3+TX2
C (7,6)
      X(3) = X1P3-TX2
CX40132 CALL SBOUTX (132)
CY40132 CALL SBOUTY (132)
C     END BLOCK
      GOTO 106
C (6,1)
C     BEGIN BLOCK
C (6,2)
103   C1 = X(1)-X(N)
C (6,3)
      X(1) = X(1)+X(N)
C (6,4)
CX10667 CALL DOINX( 667 )
CY10667 CALL DOINY( 667 )
!     INITIALLY: DO 104
      DO K = 2, NS2
C (6,5)
C        BEGIN BLOCK
C (6,6)
         KC = NP1-K
C (6,7)
         T1 = X(K)+X(KC)
C (6,8)
         T2 = X(K)-X(KC)
C (6,9)
         C1 = C1+WSAVE(KC)*T2
C (6,10)
         T2 = WSAVE(K)*T2
C (6,11)
         X(K) = T1-T2
C (6,12)
         X(KC) = T1+T2
C (6,13)
104      CONTINUE
C        END BLOCK
      ENDDO
C (6,14)
CX20668 CALL DOOUTX( 668 )
CY20668 CALL DOOUTY( 668 )
      MODN = MOD(N, 2)
C (6,15)
      IF (MODN.NE.0) THEN
C (6,16)
         X(NS2+1) = X(NS2+1)+X(NS2+1)
      ELSE
C (6,17)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (6,18)
      I_PIPS_RFFTF_R = I_PIPS_COST_X
      I_PIPS_RFFTF_WSAVE = I_PIPS_COST_WSAVE-(N+1-1)
      CALL RFFTF(NM1, X, WSAVE(N+1))
C (6,19)
      XIM2 = X(2)
C (6,20)
      X(2) = C1
C (6,21)
CX10669 CALL DOINX( 669 )
CY10669 CALL DOINY( 669 )
!     INITIALLY: DO 105
      DO I = 4, N, 2
C (6,22)
C        BEGIN BLOCK
C (6,23)
         XI = X(I)
C (6,24)
         X(I) = X(I-2)-X(I-1)
C (6,25)
         X(I-1) = XIM2
C (6,26)
         XIM2 = XI
C (6,27)
105      CONTINUE
C        END BLOCK
      ENDDO
C (6,28)
CX20670 CALL DOOUTX( 670 )
CY20670 CALL DOOUTY( 670 )
      IF (MODN.NE.0) THEN
C (6,29)
         X(N) = XIM2
      ELSE
C (6,30)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C     END BLOCK
      GOTO 106
C (3,1)
C     BEGIN BLOCK
C (3,2)
101   X1H = X(1)+X(2)
C (3,3)
      X(2) = X(1)-X(2)
C (3,4)
      X(1) = X1H
CX40132 CALL SBOUTX (132)
CY40132 CALL SBOUTY (132)
C     END BLOCK
C (2,1)
106   CONTINUE
C     END UNSTRUCTURED
C (0,6)
CX40132 CALL SBOUTX (132)
CY40132 CALL SBOUTY (132)
      RETURN
C     END BLOCK
      END

      SUBROUTINE RFFTI1 (N,WA,IFAC)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION  WA(-N+I_PIPS_RFFTI_WSAVE),IFAC((-16*N+8*I_PIPS_RFFTI_WS
     x AVE)/4),NTRYH(4)
      SAVE NTRYH
      DATA NTRYH(1),NTRYH(2),NTRYH(3),NTRYH(4)/4,2,3,5/
C (0,1)
      INTEGER*8 I_PIPS_RFFTI_WSAVE
      COMMON /PIPS_RFFTI_WSAVE/ I_PIPS_RFFTI_WSAVE
C     BEGIN BLOCK
C (0,2)
CX30133 CALL SBINX (133)
CY30133 CALL SBINY (133)
      NL = N
C (0,3)
      NF = 0
C (0,4)
      J = 0
C (0,5)
C     BEGIN UNSTRUCTURED
C (1,1)
101   J = J+1
C (2,1)
      IF (J-4.LE.0) GOTO 102
C (15,1)
103   NTRY = NTRY+2
C (4,1)
C     BEGIN BLOCK
C (4,2)
104   NQ = NL/NTRY
C (4,3)
      NR = NL-NTRY*NQ
C     END BLOCK
C (5,1)
      IF (NR.EQ.0) THEN
      ELSE
         GOTO 101
      ENDIF
C (6,1)
C     BEGIN BLOCK
C (6,2)
105   NF = NF+1
C (6,3)
      IFAC(NF+2) = NTRY
C (6,4)
      NL = NQ
C     END BLOCK
C (7,1)
      IF (NTRY.NE.2) GOTO 107
C (14,1)
      IF (NF.EQ.1) GOTO 107
C (13,1)
C     BEGIN BLOCK
C (13,2)
CX10671 CALL DOINX( 671 )
CY10671 CALL DOINY( 671 )
!     INITIALLY: DO 106
      DO I = 2, NF
C (13,3)
C        BEGIN BLOCK
C (13,4)
         IB = NF-I+2
C (13,5)
         IFAC(IB+2) = IFAC(IB+1)
C (13,6)
106      CONTINUE
C        END BLOCK
      ENDDO
C (13,7)
CX20672 CALL DOOUTX( 672 )
CY20672 CALL DOOUTY( 672 )
      IFAC(3) = 2
C     END BLOCK
C (8,1)
107   IF (NL.NE.1) GOTO 104
C (9,1)
C     BEGIN BLOCK
C (9,2)
      IFAC(1) = N
C (9,3)
      IFAC(2) = NF
C (9,4)
      TPI = 6.28318530717959
C (9,5)
      ARGH = TPI/FLOAT(N)
C (9,6)
      IS = 0
C (9,7)
      NFM1 = NF-1
C (9,8)
      L1 = 1
C     END BLOCK
C (10,1)
      IF (NFM1.EQ.0) RETURN
C (12,1)
C     BEGIN BLOCK
C (12,2)
CX10673 CALL DOINX( 673 )
CY10673 CALL DOINY( 673 )
!     INITIALLY: DO 110
      DO K1 = 1, NFM1
C (12,3)
C        BEGIN BLOCK
C (12,4)
         IP = IFAC(K1+2)
C (12,5)
         LD = 0
C (12,6)
         L2 = L1*IP
C (12,7)
         IDO = N/L2
C (12,8)
         IPM = IP-1
C (12,9)
!     INITIALLY: DO 109
         DO J = 1, IPM
C (12,10)
C           BEGIN BLOCK
C (12,11)
            LD = LD+L1
C (12,12)
            I = IS
C (12,13)
            ARGLD = FLOAT(LD)*ARGH
C (12,14)
            FI = 0.
C (12,15)
!     INITIALLY: DO 108
            DO II = 3, IDO, 2
C (12,16)
C              BEGIN BLOCK
C (12,17)
               I = I+2
C (12,18)
               FI = FI+1.D0
C (12,19)
               ARG = FI*ARGLD
C (12,20)
               WA(I-1) = DCOS(ARG)
C (12,21)
               WA(I) = DSIN(ARG)
C (12,22)
108            CONTINUE
C              END BLOCK
            ENDDO
C (12,23)
            IS = IS+IDO
C (12,24)
109         CONTINUE
C           END BLOCK
         ENDDO
C (12,25)
         L1 = L2
C (12,26)
110      CONTINUE
C        END BLOCK
      ENDDO
CX20674 CALL DOOUTX( 674 )
CY20674 CALL DOOUTY( 674 )
CX40134 CALL SBOUTX (134)
CY40134 CALL SBOUTY (134)
C     END BLOCK
      RETURN
C (3,1)
102   NTRY = NTRYH(J)
      GOTO 104
C (11,1)
CX40134 CALL SBOUTX (134)
CY40134 CALL SBOUTY (134)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RFFTB (N,R,WSAVE)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       R(I_PIPS_RFFTB_R)       ,WSAVE(I_PIPS_RFFTB_WSAVE)
     x 
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_DCTDX_SAVEX
      COMMON /PIPS_DCTDX_SAVEX/ I_PIPS_DCTDX_SAVEX
      INTEGER*8 I_PIPS_DCTDXD_SAVEX
      COMMON /PIPS_DCTDXD_SAVEX/ I_PIPS_DCTDXD_SAVEX
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
C     BEGIN UNSTRUCTURED
C (1,1)
CX30135 CALL SBINX (135)
CY30135 CALL SBINY (135)
      IF (N.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      CALL RFFTB1(N, R, WSAVE, WSAVE(N+1), WSAVE(2*N+1))
CX40136 CALL SBOUTX (136)
CY40136 CALL SBOUTY (136)
C     END BLOCK
C (2,1)
CX40136 CALL SBOUTX (136)
CY40136 CALL SBOUTY (136)
      RETURN
C     END UNSTRUCTURED
      END
      SUBROUTINE RFFTB1 (N,C,CH,WA,IFAC)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CH(I_PIPS_RFFTB_WSAVE)      ,C(I_PIPS_RFFTB_R)    
     x    ,WA(-N+I_PIPS_RFFTB_WSAVE)      ,IFAC((-16*N+8*I_PIPS_RFFTB_WS
     x AVE)/4)
C (0,1)
      INTEGER*8 I_PIPS_RFFTB_R
      COMMON /PIPS_RFFTB_R/ I_PIPS_RFFTB_R
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RADB2_WA1
      COMMON /PIPS_RADB2_WA1/ I_PIPS_RADB2_WA1
      INTEGER*8 I_PIPS_RADB3_WA1
      COMMON /PIPS_RADB3_WA1/ I_PIPS_RADB3_WA1
      INTEGER*8 I_PIPS_RADB3_WA2
      COMMON /PIPS_RADB3_WA2/ I_PIPS_RADB3_WA2
      INTEGER*8 I_PIPS_RADB4_WA1
      COMMON /PIPS_RADB4_WA1/ I_PIPS_RADB4_WA1
      INTEGER*8 I_PIPS_RADB4_WA2
      COMMON /PIPS_RADB4_WA2/ I_PIPS_RADB4_WA2
      INTEGER*8 I_PIPS_RADB4_WA3
      COMMON /PIPS_RADB4_WA3/ I_PIPS_RADB4_WA3
      INTEGER*8 I_PIPS_RADB5_WA1
      COMMON /PIPS_RADB5_WA1/ I_PIPS_RADB5_WA1
      INTEGER*8 I_PIPS_RADB5_WA2
      COMMON /PIPS_RADB5_WA2/ I_PIPS_RADB5_WA2
      INTEGER*8 I_PIPS_RADB5_WA3
      COMMON /PIPS_RADB5_WA3/ I_PIPS_RADB5_WA3
      INTEGER*8 I_PIPS_RADB5_WA4
      COMMON /PIPS_RADB5_WA4/ I_PIPS_RADB5_WA4
      INTEGER*8 I_PIPS_RADBG_WA
      COMMON /PIPS_RADBG_WA/ I_PIPS_RADBG_WA
C     BEGIN BLOCK
C (0,2)
CX30137 CALL SBINX (137)
CY30137 CALL SBINY (137)
      NF = IFAC(2)
C (0,3)
      NA = 0
C (0,4)
      L1 = 1
C (0,5)
      IW = 1
C (0,6)
CX10675 CALL DOINX( 675 )
CY10675 CALL DOINY( 675 )
!     INITIALLY: DO 116
      DO K1 = 1, NF
C (0,7)
C        BEGIN BLOCK
C (0,8)
         IP = IFAC(K1+2)
C (0,9)
         L2 = IP*L1
C (0,10)
         IDO = N/L2
C (0,11)
         IDL1 = IDO*L1
C (0,12)
C        BEGIN UNSTRUCTURED
C (1,1)
         IF (IP.NE.4) GOTO 103
C (27,1)
C        BEGIN BLOCK
C (27,2)
         IX2 = IW+IDO
C (27,3)
         IX3 = IX2+IDO
C        END BLOCK
C (25,1)
         IF (NA.NE.0) GOTO 101
C (26,1)
      I_PIPS_RADB4_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
      I_PIPS_RADB4_WA2 = -N+I_PIPS_RFFTB_WSAVE-(IX2-1)
      I_PIPS_RADB4_WA3 = -N+I_PIPS_RFFTB_WSAVE-(IX3-1)
         CALL RADB4(IDO, L1, C, CH, WA(IW), WA(IX2), WA(IX3))
C (23,1)
102      NA = 1-NA
         GOTO 115
C (24,1)
      I_PIPS_RADB4_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
      I_PIPS_RADB4_WA2 = -N+I_PIPS_RFFTB_WSAVE-(IX2-1)
      I_PIPS_RADB4_WA3 = -N+I_PIPS_RFFTB_WSAVE-(IX3-1)
101      CALL RADB4(IDO, L1, CH, C, WA(IW), WA(IX2), WA(IX3))
         GOTO 102
C (2,1)
103      IF (IP.NE.2) GOTO 106
C (21,1)
         IF (NA.NE.0) GOTO 104
C (22,1)
      I_PIPS_RADB2_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
         CALL RADB2(IDO, L1, C, CH, WA(IW))
C (19,1)
105      NA = 1-NA
         GOTO 115
C (20,1)
      I_PIPS_RADB2_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
104      CALL RADB2(IDO, L1, CH, C, WA(IW))
         GOTO 105
C (3,1)
106      IF (IP.NE.3) GOTO 109
C (18,1)
         IX2 = IW+IDO
C (16,1)
         IF (NA.NE.0) GOTO 107
C (17,1)
      I_PIPS_RADB3_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
      I_PIPS_RADB3_WA2 = -N+I_PIPS_RFFTB_WSAVE-(IX2-1)
         CALL RADB3(IDO, L1, C, CH, WA(IW), WA(IX2))
C (14,1)
108      NA = 1-NA
         GOTO 115
C (15,1)
      I_PIPS_RADB3_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
      I_PIPS_RADB3_WA2 = -N+I_PIPS_RFFTB_WSAVE-(IX2-1)
107      CALL RADB3(IDO, L1, CH, C, WA(IW), WA(IX2))
         GOTO 108
C (4,1)
109      IF (IP.NE.5) GOTO 112
C (13,1)
C        BEGIN BLOCK
C (13,2)
         IX2 = IW+IDO
C (13,3)
         IX3 = IX2+IDO
C (13,4)
         IX4 = IX3+IDO
C        END BLOCK
C (11,1)
         IF (NA.NE.0) GOTO 110
C (12,1)
      I_PIPS_RADB5_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
      I_PIPS_RADB5_WA2 = -N+I_PIPS_RFFTB_WSAVE-(IX2-1)
      I_PIPS_RADB5_WA3 = -N+I_PIPS_RFFTB_WSAVE-(IX3-1)
      I_PIPS_RADB5_WA4 = -N+I_PIPS_RFFTB_WSAVE-(IX4-1)
         CALL RADB5(IDO, L1, C, CH, WA(IW), WA(IX2), WA(IX3), WA(IX4)
     &   )
C (9,1)
111      NA = 1-NA
         GOTO 115
C (10,1)
      I_PIPS_RADB5_WA1 = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
      I_PIPS_RADB5_WA2 = -N+I_PIPS_RFFTB_WSAVE-(IX2-1)
      I_PIPS_RADB5_WA3 = -N+I_PIPS_RFFTB_WSAVE-(IX3-1)
      I_PIPS_RADB5_WA4 = -N+I_PIPS_RFFTB_WSAVE-(IX4-1)
110      CALL RADB5(IDO, L1, CH, C, WA(IW), WA(IX2), WA(IX3), WA(IX4)
     &   )
         GOTO 111
C (5,1)
112      IF (NA.NE.0) GOTO 113
C (28,1)
      I_PIPS_RADBG_WA = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
         CALL RADBG(IDO, IP, L1, IDL1, C, C, C, CH, CH, WA(IW))
C (7,1)
114      IF (IDO.EQ.1) THEN
C (7,2)
            NA = 1-NA
         ELSE
C (7,3)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
         GOTO 115
C (6,1)
      I_PIPS_RADBG_WA = -N+I_PIPS_RFFTB_WSAVE-(IW-1)
113      CALL RADBG(IDO, IP, L1, IDL1, CH, CH, CH, C, C, WA(IW))
         GOTO 114
C (8,1)
115      CONTINUE
C        END UNSTRUCTURED
C (0,13)
         L1 = L2
C (0,14)
         IW = IW+(IP-1)*IDO
C (0,15)
116      CONTINUE
C        END BLOCK
      ENDDO
C (0,16)
C     BEGIN UNSTRUCTURED
C (29,1)
CX20676 CALL DOOUTX( 676 )
CY20676 CALL DOOUTY( 676 )
      IF (NA.EQ.0) RETURN
C (31,1)
C     BEGIN BLOCK
C (31,2)
CX10677 CALL DOINX( 677 )
CY10677 CALL DOINY( 677 )
!     INITIALLY: DO 117
      DO I = 1, N
C (31,3)
C        BEGIN BLOCK
C (31,4)
         C(I) = CH(I)
C (31,5)
117      CONTINUE
C        END BLOCK
      ENDDO
CX20678 CALL DOOUTX( 678 )
CY20678 CALL DOOUTY( 678 )
CX40138 CALL SBOUTX (138)
CY40138 CALL SBOUTY (138)
C     END BLOCK
C (30,1)
CX40138 CALL SBOUTX (138)
CY40138 CALL SBOUTY (138)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RADB2 (IDO,L1,CC,CH,WA1)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CC(IDO,2,L1)           ,CH(IDO,L1,2)           ,
     1                WA1(I_PIPS_RADB2_WA1)
C (0,1)
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RADB2_WA1
      COMMON /PIPS_RADB2_WA1/ I_PIPS_RADB2_WA1
C     BEGIN BLOCK
C (0,2)
CX30139 CALL SBINX (139)
CY30139 CALL SBINY (139)
CX10679 CALL DOINX( 679 )
CY10679 CALL DOINY( 679 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         CH(1,K,1) = CC(1,1,K)+CC(IDO,2,K)
C (0,5)
         CH(1,K,2) = CC(1,1,K)-CC(IDO,2,K)
C (0,6)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,7)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20680 CALL DOOUTX( 680 )
CY20680 CALL DOOUTY( 680 )
      IF (IDO-2.LT.0) GOTO 107
C (6,1)
      IF (IDO-2.EQ.0) GOTO 105
C (5,1)
C     BEGIN BLOCK
C (5,2)
102   IDP2 = IDO+2
C (5,3)
CX10681 CALL DOINX( 681 )
CY10681 CALL DOINY( 681 )
!     INITIALLY: DO 104
      DO K = 1, L1
C (5,4)
C        BEGIN BLOCK
C (5,5)
!     INITIALLY: DO 103
         DO I = 3, IDO, 2
C (5,6)
C           BEGIN BLOCK
C (5,7)
            IC = IDP2-I
C (5,8)
            CH(I-1,K,1) = CC(I-1,1,K)+CC(IC-1,2,K)
C (5,9)
            TR2 = CC(I-1,1,K)-CC(IC-1,2,K)
C (5,10)
            CH(I,K,1) = CC(I,1,K)-CC(IC,2,K)
C (5,11)
            TI2 = CC(I,1,K)+CC(IC,2,K)
C (5,12)
            CH(I-1,K,2) = WA1(I-2)*TR2-WA1(I-1)*TI2
C (5,13)
            CH(I,K,2) = WA1(I-2)*TI2+WA1(I-1)*TR2
C (5,14)
103         CONTINUE
C           END BLOCK
         ENDDO
C (5,15)
104      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (4,1)
CX20682 CALL DOOUTX( 682 )
CY20682 CALL DOOUTY( 682 )
      IF (MOD(IDO, 2).EQ.1) GOTO 107
C (3,1)
C     BEGIN BLOCK
C (3,2)
105   CONTINUE
C (3,3)
CX10683 CALL DOINX( 683 )
CY10683 CALL DOINY( 683 )
!     INITIALLY: DO 106
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
         CH(IDO,K,1) = CC(IDO,1,K)+CC(IDO,1,K)
C (3,6)
         CH(IDO,K,2) = -(CC(1,2,K)+CC(1,2,K))
C (3,7)
106      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (2,1)
CX40140 CALL SBOUTX (140)
CY40140 CALL SBOUTY (140)
CX20684 CALL DOOUTX( 684 )
CY20684 CALL DOOUTY( 684 )
107   CONTINUE
C     END UNSTRUCTURED
C (0,8)
CX40140 CALL SBOUTX (140)
CY40140 CALL SBOUTY (140)
      RETURN
C     END BLOCK
      END
      SUBROUTINE RADB3 (IDO,L1,CC,CH,WA1,WA2)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CC(IDO,3,L1)           ,CH(IDO,L1,3)           ,
     1                WA1(I_PIPS_RADB3_WA1)     ,WA2(I_PIPS_RADB3_WA2)
      PARAMETER (TAUR = -.5, TAUI = .866025403784439)
C (0,1)
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RADB3_WA1
      COMMON /PIPS_RADB3_WA1/ I_PIPS_RADB3_WA1
      INTEGER*8 I_PIPS_RADB3_WA2
      COMMON /PIPS_RADB3_WA2/ I_PIPS_RADB3_WA2
C     BEGIN BLOCK
C (0,2)
CX30141 CALL SBINX (141)
CY30141 CALL SBINY (141)
CX10685 CALL DOINX( 685 )
CY10685 CALL DOINY( 685 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         TR2 = CC(IDO,2,K)+CC(IDO,2,K)
C (0,5)
         CR2 = CC(1,1,K)+TAUR*TR2
C (0,6)
         CH(1,K,1) = CC(1,1,K)+TR2
C (0,7)
         CI3 = TAUI*(CC(1,3,K)+CC(1,3,K))
C (0,8)
         CH(1,K,2) = CR2-CI3
C (0,9)
         CH(1,K,3) = CR2+CI3
C (0,10)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,11)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20686 CALL DOOUTX( 686 )
CY20686 CALL DOOUTY( 686 )
      IF (IDO.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      IDP2 = IDO+2
C (3,3)
CX10687 CALL DOINX( 687 )
CY10687 CALL DOINY( 687 )
!     INITIALLY: DO 103
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
!     INITIALLY: DO 102
         DO I = 3, IDO, 2
C (3,6)
C           BEGIN BLOCK
C (3,7)
            IC = IDP2-I
C (3,8)
            TR2 = CC(I-1,3,K)+CC(IC-1,2,K)
C (3,9)
            CR2 = CC(I-1,1,K)+TAUR*TR2
C (3,10)
            CH(I-1,K,1) = CC(I-1,1,K)+TR2
C (3,11)
            TI2 = CC(I,3,K)-CC(IC,2,K)
C (3,12)
            CI2 = CC(I,1,K)+TAUR*TI2
C (3,13)
            CH(I,K,1) = CC(I,1,K)+TI2
C (3,14)
            CR3 = TAUI*(CC(I-1,3,K)-CC(IC-1,2,K))
C (3,15)
            CI3 = TAUI*(CC(I,3,K)+CC(IC,2,K))
C (3,16)
            DR2 = CR2-CI3
C (3,17)
            DR3 = CR2+CI3
C (3,18)
            DI2 = CI2+CR3
C (3,19)
            DI3 = CI2-CR3
C (3,20)
            CH(I-1,K,2) = WA1(I-2)*DR2-WA1(I-1)*DI2
C (3,21)
            CH(I,K,2) = WA1(I-2)*DI2+WA1(I-1)*DR2
C (3,22)
            CH(I-1,K,3) = WA2(I-2)*DR3-WA2(I-1)*DI3
C (3,23)
            CH(I,K,3) = WA2(I-2)*DI3+WA2(I-1)*DR3
C (3,24)
102         CONTINUE
C           END BLOCK
         ENDDO
C (3,25)
103      CONTINUE
C        END BLOCK
      ENDDO
CX20688 CALL DOOUTX( 688 )
CY20688 CALL DOOUTY( 688 )
CX40142 CALL SBOUTX (142)
CY40142 CALL SBOUTY (142)
C     END BLOCK
C (2,1)
CX40142 CALL SBOUTX (142)
CY40142 CALL SBOUTY (142)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RADB4 (IDO,L1,CC,CH,WA1,WA2,WA3)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CC(IDO,4,L1)           ,CH(IDO,L1,4)           ,
     1                WA1(I_PIPS_RADB4_WA1)     ,WA2(I_PIPS_RADB4_WA2)  
     x    ,WA3(I_PIPS_RADB4_WA3)
      PARAMETER (SQRT2 = 1.414213562373095)
C (0,1)
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RADB4_WA1
      COMMON /PIPS_RADB4_WA1/ I_PIPS_RADB4_WA1
      INTEGER*8 I_PIPS_RADB4_WA2
      COMMON /PIPS_RADB4_WA2/ I_PIPS_RADB4_WA2
      INTEGER*8 I_PIPS_RADB4_WA3
      COMMON /PIPS_RADB4_WA3/ I_PIPS_RADB4_WA3
C     BEGIN BLOCK
C (0,2)
CX30143 CALL SBINX (143)
CY30143 CALL SBINY (143)
CX10689 CALL DOINX( 689 )
CY10689 CALL DOINY( 689 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         TR1 = CC(1,1,K)-CC(IDO,4,K)
C (0,5)
         TR2 = CC(1,1,K)+CC(IDO,4,K)
C (0,6)
         TR3 = CC(IDO,2,K)+CC(IDO,2,K)
C (0,7)
         TR4 = CC(1,3,K)+CC(1,3,K)
C (0,8)
         CH(1,K,1) = TR2+TR3
C (0,9)
         CH(1,K,2) = TR1-TR4
C (0,10)
         CH(1,K,3) = TR2-TR3
C (0,11)
         CH(1,K,4) = TR1+TR4
C (0,12)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,13)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20690 CALL DOOUTX( 690 )
CY20690 CALL DOOUTY( 690 )
      IF (IDO-2.LT.0) GOTO 107
C (6,1)
      IF (IDO-2.EQ.0) GOTO 105
C (5,1)
C     BEGIN BLOCK
C (5,2)
102   IDP2 = IDO+2
C (5,3)
CX10691 CALL DOINX( 691 )
CY10691 CALL DOINY( 691 )
!     INITIALLY: DO 104
      DO K = 1, L1
C (5,4)
C        BEGIN BLOCK
C (5,5)
!     INITIALLY: DO 103
         DO I = 3, IDO, 2
C (5,6)
C           BEGIN BLOCK
C (5,7)
            IC = IDP2-I
C (5,8)
            TI1 = CC(I,1,K)+CC(IC,4,K)
C (5,9)
            TI2 = CC(I,1,K)-CC(IC,4,K)
C (5,10)
            TI3 = CC(I,3,K)-CC(IC,2,K)
C (5,11)
            TR4 = CC(I,3,K)+CC(IC,2,K)
C (5,12)
            TR1 = CC(I-1,1,K)-CC(IC-1,4,K)
C (5,13)
            TR2 = CC(I-1,1,K)+CC(IC-1,4,K)
C (5,14)
            TI4 = CC(I-1,3,K)-CC(IC-1,2,K)
C (5,15)
            TR3 = CC(I-1,3,K)+CC(IC-1,2,K)
C (5,16)
            CH(I-1,K,1) = TR2+TR3
C (5,17)
            CR3 = TR2-TR3
C (5,18)
            CH(I,K,1) = TI2+TI3
C (5,19)
            CI3 = TI2-TI3
C (5,20)
            CR2 = TR1-TR4
C (5,21)
            CR4 = TR1+TR4
C (5,22)
            CI2 = TI1+TI4
C (5,23)
            CI4 = TI1-TI4
C (5,24)
            CH(I-1,K,2) = WA1(I-2)*CR2-WA1(I-1)*CI2
C (5,25)
            CH(I,K,2) = WA1(I-2)*CI2+WA1(I-1)*CR2
C (5,26)
            CH(I-1,K,3) = WA2(I-2)*CR3-WA2(I-1)*CI3
C (5,27)
            CH(I,K,3) = WA2(I-2)*CI3+WA2(I-1)*CR3
C (5,28)
            CH(I-1,K,4) = WA3(I-2)*CR4-WA3(I-1)*CI4
C (5,29)
            CH(I,K,4) = WA3(I-2)*CI4+WA3(I-1)*CR4
C (5,30)
103         CONTINUE
C           END BLOCK
         ENDDO
C (5,31)
104      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (4,1)
CX20692 CALL DOOUTX( 692 )
CY20692 CALL DOOUTY( 692 )
      IF (MOD(IDO, 2).EQ.1) GOTO 107
C (3,1)
C     BEGIN BLOCK
C (3,2)
105   CONTINUE
C (3,3)
CX10693 CALL DOINX( 693 )
CY10693 CALL DOINY( 693 )
!     INITIALLY: DO 106
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
         TI1 = CC(1,2,K)+CC(1,4,K)
C (3,6)
         TI2 = CC(1,4,K)-CC(1,2,K)
C (3,7)
         TR1 = CC(IDO,1,K)-CC(IDO,3,K)
C (3,8)
         TR2 = CC(IDO,1,K)+CC(IDO,3,K)
C (3,9)
         CH(IDO,K,1) = TR2+TR2
C (3,10)
         CH(IDO,K,2) = SQRT2*(TR1-TI1)
C (3,11)
         CH(IDO,K,3) = TI2+TI2
C (3,12)
         CH(IDO,K,4) = -SQRT2*(TR1+TI1)
C (3,13)
106      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (2,1)
CX40144 CALL SBOUTX (144)
CY40144 CALL SBOUTY (144)
CX20694 CALL DOOUTX( 694 )
CY20694 CALL DOOUTY( 694 )
107   CONTINUE
C     END UNSTRUCTURED
C (0,14)
CX40144 CALL SBOUTX (144)
CY40144 CALL SBOUTY (144)
      RETURN
C     END BLOCK
      END
      SUBROUTINE RADB5 (IDO,L1,CC,CH,WA1,WA2,WA3,WA4)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CC(IDO,5,L1)           ,CH(IDO,L1,5)           ,
     1                WA1(I_PIPS_RADB5_WA1)     ,WA2(I_PIPS_RADB5_WA2)  
     x    ,WA3(I_PIPS_RADB5_WA3)     ,WA4(I_PIPS_RADB5_WA4)
      PARAMETER (TR11 = .309016994374947, TI11 = .951056516295154,
     *           TR12 = -.809016994374947, TI12 = .587785252292473)
C (0,1)
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RADB5_WA1
      COMMON /PIPS_RADB5_WA1/ I_PIPS_RADB5_WA1
      INTEGER*8 I_PIPS_RADB5_WA2
      COMMON /PIPS_RADB5_WA2/ I_PIPS_RADB5_WA2
      INTEGER*8 I_PIPS_RADB5_WA3
      COMMON /PIPS_RADB5_WA3/ I_PIPS_RADB5_WA3
      INTEGER*8 I_PIPS_RADB5_WA4
      COMMON /PIPS_RADB5_WA4/ I_PIPS_RADB5_WA4
C     BEGIN BLOCK
C (0,2)
CX30145 CALL SBINX (145)
CY30145 CALL SBINY (145)
CX10695 CALL DOINX( 695 )
CY10695 CALL DOINY( 695 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         TI5 = CC(1,3,K)+CC(1,3,K)
C (0,5)
         TI4 = CC(1,5,K)+CC(1,5,K)
C (0,6)
         TR2 = CC(IDO,2,K)+CC(IDO,2,K)
C (0,7)
         TR3 = CC(IDO,4,K)+CC(IDO,4,K)
C (0,8)
         CH(1,K,1) = CC(1,1,K)+TR2+TR3
C (0,9)
         CR2 = CC(1,1,K)+TR11*TR2+TR12*TR3
C (0,10)
         CR3 = CC(1,1,K)+TR12*TR2+TR11*TR3
C (0,11)
         CI5 = TI11*TI5+TI12*TI4
C (0,12)
         CI4 = TI12*TI5-TI11*TI4
C (0,13)
         CH(1,K,2) = CR2-CI5
C (0,14)
         CH(1,K,3) = CR3-CI4
C (0,15)
         CH(1,K,4) = CR3+CI4
C (0,16)
         CH(1,K,5) = CR2+CI5
C (0,17)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,18)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20696 CALL DOOUTX( 696 )
CY20696 CALL DOOUTY( 696 )
      IF (IDO.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      IDP2 = IDO+2
C (3,3)
CX10697 CALL DOINX( 697 )
CY10697 CALL DOINY( 697 )
!     INITIALLY: DO 103
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
!     INITIALLY: DO 102
         DO I = 3, IDO, 2
C (3,6)
C           BEGIN BLOCK
C (3,7)
            IC = IDP2-I
C (3,8)
            TI5 = CC(I,3,K)+CC(IC,2,K)
C (3,9)
            TI2 = CC(I,3,K)-CC(IC,2,K)
C (3,10)
            TI4 = CC(I,5,K)+CC(IC,4,K)
C (3,11)
            TI3 = CC(I,5,K)-CC(IC,4,K)
C (3,12)
            TR5 = CC(I-1,3,K)-CC(IC-1,2,K)
C (3,13)
            TR2 = CC(I-1,3,K)+CC(IC-1,2,K)
C (3,14)
            TR4 = CC(I-1,5,K)-CC(IC-1,4,K)
C (3,15)
            TR3 = CC(I-1,5,K)+CC(IC-1,4,K)
C (3,16)
            CH(I-1,K,1) = CC(I-1,1,K)+TR2+TR3
C (3,17)
            CH(I,K,1) = CC(I,1,K)+TI2+TI3
C (3,18)
            CR2 = CC(I-1,1,K)+TR11*TR2+TR12*TR3
C (3,19)
            CI2 = CC(I,1,K)+TR11*TI2+TR12*TI3
C (3,20)
            CR3 = CC(I-1,1,K)+TR12*TR2+TR11*TR3
C (3,21)
            CI3 = CC(I,1,K)+TR12*TI2+TR11*TI3
C (3,22)
            CR5 = TI11*TR5+TI12*TR4
C (3,23)
            CI5 = TI11*TI5+TI12*TI4
C (3,24)
            CR4 = TI12*TR5-TI11*TR4
C (3,25)
            CI4 = TI12*TI5-TI11*TI4
C (3,26)
            DR3 = CR3-CI4
C (3,27)
            DR4 = CR3+CI4
C (3,28)
            DI3 = CI3+CR4
C (3,29)
            DI4 = CI3-CR4
C (3,30)
            DR5 = CR2+CI5
C (3,31)
            DR2 = CR2-CI5
C (3,32)
            DI5 = CI2-CR5
C (3,33)
            DI2 = CI2+CR5
C (3,34)
            CH(I-1,K,2) = WA1(I-2)*DR2-WA1(I-1)*DI2
C (3,35)
            CH(I,K,2) = WA1(I-2)*DI2+WA1(I-1)*DR2
C (3,36)
            CH(I-1,K,3) = WA2(I-2)*DR3-WA2(I-1)*DI3
C (3,37)
            CH(I,K,3) = WA2(I-2)*DI3+WA2(I-1)*DR3
C (3,38)
            CH(I-1,K,4) = WA3(I-2)*DR4-WA3(I-1)*DI4
C (3,39)
            CH(I,K,4) = WA3(I-2)*DI4+WA3(I-1)*DR4
C (3,40)
            CH(I-1,K,5) = WA4(I-2)*DR5-WA4(I-1)*DI5
C (3,41)
            CH(I,K,5) = WA4(I-2)*DI5+WA4(I-1)*DR5
C (3,42)
102         CONTINUE
C           END BLOCK
         ENDDO
C (3,43)
103      CONTINUE
C        END BLOCK
      ENDDO
CX20698 CALL DOOUTX( 698 )
CY20698 CALL DOOUTY( 698 )
CX40146 CALL SBOUTX (146)
CY40146 CALL SBOUTY (146)
C     END BLOCK
C (2,1)
CX40146 CALL SBOUTX (146)
CY40146 CALL SBOUTY (146)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RADBG (IDO,IP,L1,IDL1,CC,C1,C2,CH,CH2,WA)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CH(IDO,L1,IP)          ,CC(IDO,IP,L1)          ,
     1                C1(IDO,L1,IP)          ,C2(IDL1,IP),
     2                CH2(IDL1,IP)           ,WA(I_PIPS_RADBG_WA)
      PARAMETER (TPI = 6.28318530717959)
C (0,1)
      INTEGER*8 I_PIPS_RFFTB_WSAVE
      COMMON /PIPS_RFFTB_WSAVE/ I_PIPS_RFFTB_WSAVE
      INTEGER*8 I_PIPS_RADBG_WA
      COMMON /PIPS_RADBG_WA/ I_PIPS_RADBG_WA
C     BEGIN BLOCK
C (0,2)
CX30147 CALL SBINX (147)
CY30147 CALL SBINY (147)
      ARG = TPI/FLOAT(IP)
C (0,3)
      DCP = DCOS(ARG)
C (0,4)
      DSP = DSIN(ARG)
C (0,5)
      IDP2 = IDO+2
C (0,6)
      NBD = (IDO-1)/2
C (0,7)
      IPP2 = IP+2
C (0,8)
      IPPH = (IP+1)/2
C (0,9)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (IDO.LT.L1) GOTO 103
C (19,1)
C     BEGIN BLOCK
C (19,2)
CX10699 CALL DOINX( 699 )
CY10699 CALL DOINY( 699 )
!     INITIALLY: DO 102
      DO K = 1, L1
C (19,3)
C        BEGIN BLOCK
C (19,4)
!     INITIALLY: DO 101
         DO I = 1, IDO
C (19,5)
C           BEGIN BLOCK
C (19,6)
            CH(I,K,1) = CC(I,1,K)
C (19,7)
101         CONTINUE
C           END BLOCK
         ENDDO
C (19,8)
102      CONTINUE
C        END BLOCK
      ENDDO
CX20700 CALL DOOUTX( 700 )
CY20700 CALL DOOUTY( 700 )
C     END BLOCK
C (3,1)
C     BEGIN BLOCK
C (3,2)
CX20702 CALL DOOUTX( 702 )
CY20702 CALL DOOUTY( 702 )
106   CONTINUE
C (3,3)
CX10703 CALL DOINX( 703 )
CY10703 CALL DOINY( 703 )
!     INITIALLY: DO 108
      DO J = 2, IPPH
C (3,4)
C        BEGIN BLOCK
C (3,5)
         JC = IPP2-J
C (3,6)
         J2 = J+J
C (3,7)
!     INITIALLY: DO 107
         DO K = 1, L1
C (3,8)
C           BEGIN BLOCK
C (3,9)
            CH(1,K,J) = CC(IDO,J2-2,K)+CC(IDO,J2-2,K)
C (3,10)
            CH(1,K,JC) = CC(1,J2-1,K)+CC(1,J2-1,K)
C (3,11)
107         CONTINUE
C           END BLOCK
         ENDDO
C (3,12)
108      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (4,1)
CX20704 CALL DOOUTX( 704 )
CY20704 CALL DOOUTY( 704 )
      IF (IDO.EQ.1) GOTO 116
C (17,1)
      IF (NBD.LT.L1) GOTO 112
C (18,1)
C     BEGIN BLOCK
C (18,2)
CX10705 CALL DOINX( 705 )
CY10705 CALL DOINY( 705 )
!     INITIALLY: DO 111
      DO J = 2, IPPH
C (18,3)
C        BEGIN BLOCK
C (18,4)
         JC = IPP2-J
C (18,5)
!     INITIALLY: DO 110
         DO K = 1, L1
C (18,6)
C           BEGIN BLOCK
C (18,7)
!     INITIALLY: DO 109
            DO I = 3, IDO, 2
C (18,8)
C              BEGIN BLOCK
C (18,9)
               IC = IDP2-I
C (18,10)
               CH(I-1,K,J) = CC(I-1,2*J-1,K)+CC(IC-1,2*J-2,K)
C (18,11)
               CH(I-1,K,JC) = CC(I-1,2*J-1,K)-CC(IC-1,2*J-2,K)
C (18,12)
               CH(I,K,J) = CC(I,2*J-1,K)-CC(IC,2*J-2,K)
C (18,13)
               CH(I,K,JC) = CC(I,2*J-1,K)+CC(IC,2*J-2,K)
C (18,14)
109            CONTINUE
C              END BLOCK
            ENDDO
C (18,15)
110         CONTINUE
C           END BLOCK
         ENDDO
C (18,16)
111      CONTINUE
C        END BLOCK
      ENDDO
CX20706 CALL DOOUTX( 706 )
CY20706 CALL DOOUTY( 706 )
C     END BLOCK
C (5,1)
C     BEGIN BLOCK
C (5,2)
CX20708 CALL DOOUTX( 708 )
CY20708 CALL DOOUTY( 708 )
116   AR1 = 1.
C (5,3)
      AI1 = 0.
C (5,4)
CX10709 CALL DOINX( 709 )
CY10709 CALL DOINY( 709 )
!     INITIALLY: DO 120
      DO L = 2, IPPH
C (5,5)
C        BEGIN BLOCK
C (5,6)
         LC = IPP2-L
C (5,7)
         AR1H = DCP*AR1-DSP*AI1
C (5,8)
         AI1 = DCP*AI1+DSP*AR1
C (5,9)
         AR1 = AR1H
C (5,10)
!     INITIALLY: DO 117
         DO IK = 1, IDL1
C (5,11)
C           BEGIN BLOCK
C (5,12)
            C2(IK,L) = CH2(IK,1)+AR1*CH2(IK,2)
C (5,13)
            C2(IK,LC) = AI1*CH2(IK,IP)
C (5,14)
117         CONTINUE
C           END BLOCK
         ENDDO
C (5,15)
         DC2 = AR1
C (5,16)
         DS2 = AI1
C (5,17)
         AR2 = AR1
C (5,18)
         AI2 = AI1
C (5,19)
!     INITIALLY: DO 119
         DO J = 3, IPPH
C (5,20)
C           BEGIN BLOCK
C (5,21)
            JC = IPP2-J
C (5,22)
            AR2H = DC2*AR2-DS2*AI2
C (5,23)
            AI2 = DC2*AI2+DS2*AR2
C (5,24)
            AR2 = AR2H
C (5,25)
!     INITIALLY: DO 118
            DO IK = 1, IDL1
C (5,26)
C              BEGIN BLOCK
C (5,27)
               C2(IK,L) = C2(IK,L)+AR2*CH2(IK,J)
C (5,28)
               C2(IK,LC) = C2(IK,LC)+AI2*CH2(IK,JC)
C (5,29)
118            CONTINUE
C              END BLOCK
            ENDDO
C (5,30)
119         CONTINUE
C           END BLOCK
         ENDDO
C (5,31)
120      CONTINUE
C        END BLOCK
      ENDDO
C (5,32)
CX20710 CALL DOOUTX( 710 )
CY20710 CALL DOOUTY( 710 )
CX10711 CALL DOINX( 711 )
CY10711 CALL DOINY( 711 )
!     INITIALLY: DO 122
      DO J = 2, IPPH
C (5,33)
C        BEGIN BLOCK
C (5,34)
!     INITIALLY: DO 121
         DO IK = 1, IDL1
C (5,35)
C           BEGIN BLOCK
C (5,36)
            CH2(IK,1) = CH2(IK,1)+CH2(IK,J)
C (5,37)
121         CONTINUE
C           END BLOCK
         ENDDO
C (5,38)
122      CONTINUE
C        END BLOCK
      ENDDO
C (5,39)
CX20712 CALL DOOUTX( 712 )
CY20712 CALL DOOUTY( 712 )
CX10713 CALL DOINX( 713 )
CY10713 CALL DOINY( 713 )
!     INITIALLY: DO 124
      DO J = 2, IPPH
C (5,40)
C        BEGIN BLOCK
C (5,41)
         JC = IPP2-J
C (5,42)
!     INITIALLY: DO 123
         DO K = 1, L1
C (5,43)
C           BEGIN BLOCK
C (5,44)
            CH(1,K,J) = C1(1,K,J)-C1(1,K,JC)
C (5,45)
            CH(1,K,JC) = C1(1,K,J)+C1(1,K,JC)
C (5,46)
123         CONTINUE
C           END BLOCK
         ENDDO
C (5,47)
124      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (6,1)
CX20714 CALL DOOUTX( 714 )
CY20714 CALL DOOUTY( 714 )
      IF (IDO.EQ.1) GOTO 99984
C (14,1)
      IF (NBD.LT.L1) GOTO 128
C (15,1)
C     BEGIN BLOCK
C (15,2)
CX10715 CALL DOINX( 715 )
CY10715 CALL DOINY( 715 )
!     INITIALLY: DO 127
      DO J = 2, IPPH
C (15,3)
C        BEGIN BLOCK
C (15,4)
         JC = IPP2-J
C (15,5)
!     INITIALLY: DO 126
         DO K = 1, L1
C (15,6)
C           BEGIN BLOCK
C (15,7)
!     INITIALLY: DO 125
            DO I = 3, IDO, 2
C (15,8)
C              BEGIN BLOCK
C (15,9)
               CH(I-1,K,J) = C1(I-1,K,J)-C1(I,K,JC)
C (15,10)
               CH(I-1,K,JC) = C1(I-1,K,J)+C1(I,K,JC)
C (15,11)
               CH(I,K,J) = C1(I,K,J)+C1(I-1,K,JC)
C (15,12)
               CH(I,K,JC) = C1(I,K,J)-C1(I-1,K,JC)
C (15,13)
125            CONTINUE
C              END BLOCK
            ENDDO
C (15,14)
126         CONTINUE
C           END BLOCK
         ENDDO
C (15,15)
127      CONTINUE
C        END BLOCK
      ENDDO
CX20716 CALL DOOUTX( 716 )
CY20716 CALL DOOUTY( 716 )
C     END BLOCK
99984 CONTINUE
C (7,1)
CX20718 CALL DOOUTX( 718 )
CY20718 CALL DOOUTY( 718 )
      IF (IDO.EQ.1) GOTO 143
C (12,1)
C     BEGIN BLOCK
C (12,2)
CX10719 CALL DOINX( 719 )
CY10719 CALL DOINY( 719 )
!     INITIALLY: DO 133
      DO IK = 1, IDL1
C (12,3)
C        BEGIN BLOCK
C (12,4)
         C2(IK,1) = CH2(IK,1)
C (12,5)
133      CONTINUE
C        END BLOCK
      ENDDO
C (12,6)
CX20720 CALL DOOUTX( 720 )
CY20720 CALL DOOUTY( 720 )
CX10721 CALL DOINX( 721 )
CY10721 CALL DOINY( 721 )
!     INITIALLY: DO 135
      DO J = 2, IP
C (12,7)
C        BEGIN BLOCK
C (12,8)
!     INITIALLY: DO 134
         DO K = 1, L1
C (12,9)
C           BEGIN BLOCK
C (12,10)
            C1(1,K,J) = CH(1,K,J)
C (12,11)
134         CONTINUE
C           END BLOCK
         ENDDO
C (12,12)
135      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (10,1)
CX20722 CALL DOOUTX( 722 )
CY20722 CALL DOOUTY( 722 )
      IF (NBD.GT.L1) GOTO 139
C (11,1)
C     BEGIN BLOCK
C (11,2)
      IS = -IDO
C (11,3)
CX10723 CALL DOINX( 723 )
CY10723 CALL DOINY( 723 )
!     INITIALLY: DO 138
      DO J = 2, IP
C (11,4)
C        BEGIN BLOCK
C (11,5)
         IS = IS+IDO
C (11,6)
         IDIJ = IS
C (11,7)
!     INITIALLY: DO 137
         DO I = 3, IDO, 2
C (11,8)
C           BEGIN BLOCK
C (11,9)
            IDIJ = IDIJ+2
C (11,10)
!     INITIALLY: DO 136
            DO K = 1, L1
C (11,11)
C              BEGIN BLOCK
C (11,12)
               C1(I-1,K,J) = WA(IDIJ-1)*CH(I-1,K,J)-WA(IDIJ)*CH(I,K,J
     &         )
C (11,13)
               C1(I,K,J) = WA(IDIJ-1)*CH(I,K,J)+WA(IDIJ)*CH(I-1,K,J)
C (11,14)
136            CONTINUE
C              END BLOCK
            ENDDO
C (11,15)
137         CONTINUE
C           END BLOCK
         ENDDO
C (11,16)
138      CONTINUE
C        END BLOCK
      ENDDO
CX20724 CALL DOOUTX( 724 )
CY20724 CALL DOOUTY( 724 )
C     END BLOCK
      GOTO 143
C (9,1)
C     BEGIN BLOCK
C (9,2)
139   IS = -IDO
C (9,3)
CX10725 CALL DOINX( 725 )
CY10725 CALL DOINY( 725 )
!     INITIALLY: DO 142
      DO J = 2, IP
C (9,4)
C        BEGIN BLOCK
C (9,5)
         IS = IS+IDO
C (9,6)
!     INITIALLY: DO 141
         DO K = 1, L1
C (9,7)
C           BEGIN BLOCK
C (9,8)
            IDIJ = IS
C (9,9)
!     INITIALLY: DO 140
            DO I = 3, IDO, 2
C (9,10)
C              BEGIN BLOCK
C (9,11)
               IDIJ = IDIJ+2
C (9,12)
               C1(I-1,K,J) = WA(IDIJ-1)*CH(I-1,K,J)-WA(IDIJ)*CH(I,K,J
     &         )
C (9,13)
               C1(I,K,J) = WA(IDIJ-1)*CH(I,K,J)+WA(IDIJ)*CH(I-1,K,J)
C (9,14)
140            CONTINUE
C              END BLOCK
            ENDDO
C (9,15)
141         CONTINUE
C           END BLOCK
         ENDDO
C (9,16)
142      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 143
C (13,1)
C     BEGIN BLOCK
C (13,2)
128   CONTINUE
C (13,3)
CX10717 CALL DOINX( 717 )
CY10717 CALL DOINY( 717 )
!     INITIALLY: DO 131
      DO J = 2, IPPH
C (13,4)
C        BEGIN BLOCK
C (13,5)
         JC = IPP2-J
C (13,6)
!     INITIALLY: DO 130
         DO I = 3, IDO, 2
C (13,7)
C           BEGIN BLOCK
C (13,8)
!     INITIALLY: DO 129
            DO K = 1, L1
C (13,9)
C              BEGIN BLOCK
C (13,10)
               CH(I-1,K,J) = C1(I-1,K,J)-C1(I,K,JC)
C (13,11)
               CH(I-1,K,JC) = C1(I-1,K,J)+C1(I,K,JC)
C (13,12)
               CH(I,K,J) = C1(I,K,J)+C1(I-1,K,JC)
C (13,13)
               CH(I,K,JC) = C1(I,K,J)-C1(I-1,K,JC)
C (13,14)
129            CONTINUE
C              END BLOCK
            ENDDO
C (13,15)
130         CONTINUE
C           END BLOCK
         ENDDO
C (13,16)
131      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 99984
C (16,1)
C     BEGIN BLOCK
C (16,2)
112   CONTINUE
C (16,3)
CX10707 CALL DOINX( 707 )
CY10707 CALL DOINY( 707 )
!     INITIALLY: DO 115
      DO J = 2, IPPH
C (16,4)
C        BEGIN BLOCK
C (16,5)
         JC = IPP2-J
C (16,6)
!     INITIALLY: DO 114
         DO I = 3, IDO, 2
C (16,7)
C           BEGIN BLOCK
C (16,8)
            IC = IDP2-I
C (16,9)
!     INITIALLY: DO 113
            DO K = 1, L1
C (16,10)
C              BEGIN BLOCK
C (16,11)
               CH(I-1,K,J) = CC(I-1,2*J-1,K)+CC(IC-1,2*J-2,K)
C (16,12)
               CH(I-1,K,JC) = CC(I-1,2*J-1,K)-CC(IC-1,2*J-2,K)
C (16,13)
               CH(I,K,J) = CC(I,2*J-1,K)-CC(IC,2*J-2,K)
C (16,14)
               CH(I,K,JC) = CC(I,2*J-1,K)+CC(IC,2*J-2,K)
C (16,15)
113            CONTINUE
C              END BLOCK
            ENDDO
C (16,16)
114         CONTINUE
C           END BLOCK
         ENDDO
C (16,17)
115      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 116
C (2,1)
C     BEGIN BLOCK
C (2,2)
103   CONTINUE
C (2,3)
CX10701 CALL DOINX( 701 )
CY10701 CALL DOINY( 701 )
!     INITIALLY: DO 105
      DO I = 1, IDO
C (2,4)
C        BEGIN BLOCK
C (2,5)
!     INITIALLY: DO 104
         DO K = 1, L1
C (2,6)
C           BEGIN BLOCK
C (2,7)
            CH(I,K,1) = CC(I,1,K)
C (2,8)
104         CONTINUE
C           END BLOCK
         ENDDO
C (2,9)
105      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 106
C (8,1)
CX20726 CALL DOOUTX( 726 )
CY20726 CALL DOOUTY( 726 )
143   CONTINUE
C     END UNSTRUCTURED
C (0,10)
CX40148 CALL SBOUTX (148)
CY40148 CALL SBOUTY (148)
CX40148 CALL SBOUTX (148)
CY40148 CALL SBOUTY (148)
      RETURN
C     END BLOCK
      END
      SUBROUTINE RFFTF (N,R,WSAVE)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       R(I_PIPS_RFFTF_R)       ,WSAVE(I_PIPS_RFFTF_WSAVE)
     x 
C (0,1)
      INTEGER*8 I_PIPS_COST_X
      COMMON /PIPS_COST_X/ I_PIPS_COST_X
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_COST_WSAVE
      COMMON /PIPS_COST_WSAVE/ I_PIPS_COST_WSAVE
      INTEGER*8 I_PIPS_DCTDX_SAVEX
      COMMON /PIPS_DCTDX_SAVEX/ I_PIPS_DCTDX_SAVEX
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
C     BEGIN UNSTRUCTURED
C (1,1)
CX30149 CALL SBINX (149)
CY30149 CALL SBINY (149)
      IF (N.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      CALL RFFTF1(N, R, WSAVE, WSAVE(N+1), WSAVE(2*N+1))
CX40150 CALL SBOUTX (150)
CY40150 CALL SBOUTY (150)
C     END BLOCK
C (2,1)
CX40150 CALL SBOUTX (150)
CY40150 CALL SBOUTY (150)
      RETURN
C     END UNSTRUCTURED
      END
      SUBROUTINE RFFTF1 (N,C,CH,WA,IFAC)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CH(I_PIPS_RFFTF_WSAVE)      ,C(I_PIPS_RFFTF_R)    
     x    ,WA(-N+I_PIPS_RFFTF_WSAVE)      ,IFAC((-16*N+8*I_PIPS_RFFTF_WS
     x AVE)/4)
C (0,1)
      INTEGER*8 I_PIPS_RFFTF_R
      COMMON /PIPS_RFFTF_R/ I_PIPS_RFFTF_R
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
      INTEGER*8 I_PIPS_RADF2_WA1
      COMMON /PIPS_RADF2_WA1/ I_PIPS_RADF2_WA1
      INTEGER*8 I_PIPS_RADF3_WA1
      COMMON /PIPS_RADF3_WA1/ I_PIPS_RADF3_WA1
      INTEGER*8 I_PIPS_RADF3_WA2
      COMMON /PIPS_RADF3_WA2/ I_PIPS_RADF3_WA2
      INTEGER*8 I_PIPS_RADF4_WA1
      COMMON /PIPS_RADF4_WA1/ I_PIPS_RADF4_WA1
      INTEGER*8 I_PIPS_RADF4_WA2
      COMMON /PIPS_RADF4_WA2/ I_PIPS_RADF4_WA2
      INTEGER*8 I_PIPS_RADF4_WA3
      COMMON /PIPS_RADF4_WA3/ I_PIPS_RADF4_WA3
      INTEGER*8 I_PIPS_RADF5_WA1
      COMMON /PIPS_RADF5_WA1/ I_PIPS_RADF5_WA1
      INTEGER*8 I_PIPS_RADF5_WA2
      COMMON /PIPS_RADF5_WA2/ I_PIPS_RADF5_WA2
      INTEGER*8 I_PIPS_RADF5_WA3
      COMMON /PIPS_RADF5_WA3/ I_PIPS_RADF5_WA3
      INTEGER*8 I_PIPS_RADF5_WA4
      COMMON /PIPS_RADF5_WA4/ I_PIPS_RADF5_WA4
      INTEGER*8 I_PIPS_RADFG_WA
      COMMON /PIPS_RADFG_WA/ I_PIPS_RADFG_WA
C     BEGIN BLOCK
C (0,2)
CX30151 CALL SBINX (151)
CY30151 CALL SBINY (151)
      NF = IFAC(2)
C (0,3)
      NA = 1
C (0,4)
      L2 = N
C (0,5)
      IW = N
C (0,6)
CX10727 CALL DOINX( 727 )
CY10727 CALL DOINY( 727 )
!     INITIALLY: DO 111
      DO K1 = 1, NF
C (0,7)
C        BEGIN BLOCK
C (0,8)
         KH = NF-K1
C (0,9)
         IP = IFAC(KH+3)
C (0,10)
         L1 = L2/IP
C (0,11)
         IDO = N/L2
C (0,12)
         IDL1 = IDO*L1
C (0,13)
         IW = IW-(IP-1)*IDO
C (0,14)
         NA = 1-NA
C (0,15)
C        BEGIN UNSTRUCTURED
C (1,1)
         IF (IP.NE.4) GOTO 102
C (24,1)
C        BEGIN BLOCK
C (24,2)
         IX2 = IW+IDO
C (24,3)
         IX3 = IX2+IDO
C        END BLOCK
C (22,1)
         IF (NA.NE.0) GOTO 101
C (23,1)
      I_PIPS_RADF4_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
      I_PIPS_RADF4_WA2 = -N+I_PIPS_RFFTF_WSAVE-(IX2-1)
      I_PIPS_RADF4_WA3 = -N+I_PIPS_RFFTF_WSAVE-(IX3-1)
         CALL RADF4(IDO, L1, C, CH, WA(IW), WA(IX2), WA(IX3))
         GOTO 110
C (21,1)
      I_PIPS_RADF4_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
      I_PIPS_RADF4_WA2 = -N+I_PIPS_RFFTF_WSAVE-(IX2-1)
      I_PIPS_RADF4_WA3 = -N+I_PIPS_RFFTF_WSAVE-(IX3-1)
101      CALL RADF4(IDO, L1, CH, C, WA(IW), WA(IX2), WA(IX3))
         GOTO 110
C (2,1)
102      IF (IP.NE.2) GOTO 104
C (19,1)
         IF (NA.NE.0) GOTO 103
C (20,1)
      I_PIPS_RADF2_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
         CALL RADF2(IDO, L1, C, CH, WA(IW))
         GOTO 110
C (18,1)
      I_PIPS_RADF2_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
103      CALL RADF2(IDO, L1, CH, C, WA(IW))
         GOTO 110
C (3,1)
104      IF (IP.NE.3) GOTO 106
C (17,1)
         IX2 = IW+IDO
C (15,1)
         IF (NA.NE.0) GOTO 105
C (16,1)
      I_PIPS_RADF3_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
      I_PIPS_RADF3_WA2 = -N+I_PIPS_RFFTF_WSAVE-(IX2-1)
         CALL RADF3(IDO, L1, C, CH, WA(IW), WA(IX2))
         GOTO 110
C (14,1)
      I_PIPS_RADF3_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
      I_PIPS_RADF3_WA2 = -N+I_PIPS_RFFTF_WSAVE-(IX2-1)
105      CALL RADF3(IDO, L1, CH, C, WA(IW), WA(IX2))
         GOTO 110
C (4,1)
106      IF (IP.NE.5) GOTO 108
C (13,1)
C        BEGIN BLOCK
C (13,2)
         IX2 = IW+IDO
C (13,3)
         IX3 = IX2+IDO
C (13,4)
         IX4 = IX3+IDO
C        END BLOCK
C (11,1)
         IF (NA.NE.0) GOTO 107
C (12,1)
      I_PIPS_RADF5_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
      I_PIPS_RADF5_WA2 = -N+I_PIPS_RFFTF_WSAVE-(IX2-1)
      I_PIPS_RADF5_WA3 = -N+I_PIPS_RFFTF_WSAVE-(IX3-1)
      I_PIPS_RADF5_WA4 = -N+I_PIPS_RFFTF_WSAVE-(IX4-1)
         CALL RADF5(IDO, L1, C, CH, WA(IW), WA(IX2), WA(IX3), WA(IX4)
     &   )
         GOTO 110
C (10,1)
      I_PIPS_RADF5_WA1 = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
      I_PIPS_RADF5_WA2 = -N+I_PIPS_RFFTF_WSAVE-(IX2-1)
      I_PIPS_RADF5_WA3 = -N+I_PIPS_RFFTF_WSAVE-(IX3-1)
      I_PIPS_RADF5_WA4 = -N+I_PIPS_RFFTF_WSAVE-(IX4-1)
107      CALL RADF5(IDO, L1, CH, C, WA(IW), WA(IX2), WA(IX3), WA(IX4)
     &   )
         GOTO 110
C (5,1)
108      IF (IDO.EQ.1) THEN
C (5,2)
            NA = 1-NA
         ELSE
C (5,3)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (6,1)
         IF (NA.NE.0) GOTO 109
C (9,1)
C        BEGIN BLOCK
C (9,2)
      I_PIPS_RADFG_WA = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
         CALL RADFG(IDO, IP, L1, IDL1, C, C, C, CH, CH, WA(IW))
C (9,3)
         NA = 1
C        END BLOCK
         GOTO 110
C (7,1)
C        BEGIN BLOCK
C (7,2)
      I_PIPS_RADFG_WA = -N+I_PIPS_RFFTF_WSAVE-(IW-1)
109      CALL RADFG(IDO, IP, L1, IDL1, CH, CH, CH, C, C, WA(IW))
C (7,3)
         NA = 0
C        END BLOCK
C (8,1)
110      CONTINUE
C        END UNSTRUCTURED
C (0,16)
         L2 = L1
C (0,17)
111      CONTINUE
C        END BLOCK
      ENDDO
C (0,18)
C     BEGIN UNSTRUCTURED
C (25,1)
CX20728 CALL DOOUTX( 728 )
CY20728 CALL DOOUTY( 728 )
      IF (NA.EQ.1) RETURN
C (27,1)
C     BEGIN BLOCK
C (27,2)
CX10729 CALL DOINX( 729 )
CY10729 CALL DOINY( 729 )
!     INITIALLY: DO 112
      DO I = 1, N
C (27,3)
C        BEGIN BLOCK
C (27,4)
         C(I) = CH(I)
C (27,5)
112      CONTINUE
C        END BLOCK
      ENDDO
CX20730 CALL DOOUTX( 730 )
CY20730 CALL DOOUTY( 730 )
CX40152 CALL SBOUTX (152)
CY40152 CALL SBOUTY (152)
C     END BLOCK
C (26,1)
CX40152 CALL SBOUTX (152)
CY40152 CALL SBOUTY (152)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RADF2 (IDO,L1,CC,CH,WA1)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CH(IDO,2,L1)           ,CC(IDO,L1,2)           ,
     1                WA1(I_PIPS_RADF2_WA1)
C (0,1)
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
      INTEGER*8 I_PIPS_RADF2_WA1
      COMMON /PIPS_RADF2_WA1/ I_PIPS_RADF2_WA1
C     BEGIN BLOCK
C (0,2)
CX30153 CALL SBINX (153)
CY30153 CALL SBINY (153)
CX10731 CALL DOINX( 731 )
CY10731 CALL DOINY( 731 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         CH(1,1,K) = CC(1,K,1)+CC(1,K,2)
C (0,5)
         CH(IDO,2,K) = CC(1,K,1)-CC(1,K,2)
C (0,6)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,7)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20732 CALL DOOUTX( 732 )
CY20732 CALL DOOUTY( 732 )
      IF (IDO-2.LT.0) GOTO 107
C (6,1)
      IF (IDO-2.EQ.0) GOTO 105
C (5,1)
C     BEGIN BLOCK
C (5,2)
102   IDP2 = IDO+2
C (5,3)
CX10733 CALL DOINX( 733 )
CY10733 CALL DOINY( 733 )
!     INITIALLY: DO 104
      DO K = 1, L1
C (5,4)
C        BEGIN BLOCK
C (5,5)
!     INITIALLY: DO 103
         DO I = 3, IDO, 2
C (5,6)
C           BEGIN BLOCK
C (5,7)
            IC = IDP2-I
C (5,8)
            TR2 = WA1(I-2)*CC(I-1,K,2)+WA1(I-1)*CC(I,K,2)
C (5,9)
            TI2 = WA1(I-2)*CC(I,K,2)-WA1(I-1)*CC(I-1,K,2)
C (5,10)
            CH(I,1,K) = CC(I,K,1)+TI2
C (5,11)
            CH(IC,2,K) = TI2-CC(I,K,1)
C (5,12)
            CH(I-1,1,K) = CC(I-1,K,1)+TR2
C (5,13)
            CH(IC-1,2,K) = CC(I-1,K,1)-TR2
C (5,14)
103         CONTINUE
C           END BLOCK
         ENDDO
C (5,15)
104      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (4,1)
CX20734 CALL DOOUTX( 734 )
CY20734 CALL DOOUTY( 734 )
      IF (MOD(IDO, 2).EQ.1) GOTO 107
C (3,1)
C     BEGIN BLOCK
C (3,2)
105   CONTINUE
C (3,3)
CX10735 CALL DOINX( 735 )
CY10735 CALL DOINY( 735 )
!     INITIALLY: DO 106
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
         CH(1,2,K) = -CC(IDO,K,2)
C (3,6)
         CH(IDO,1,K) = CC(IDO,K,1)
C (3,7)
106      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (2,1)
CX40154 CALL SBOUTX (154)
CY40154 CALL SBOUTY (154)
CX20736 CALL DOOUTX( 736 )
CY20736 CALL DOOUTY( 736 )
107   CONTINUE
C     END UNSTRUCTURED
C (0,8)
CX40154 CALL SBOUTX (154)
CY40154 CALL SBOUTY (154)
      RETURN
C     END BLOCK
      END
      SUBROUTINE RADF3 (IDO,L1,CC,CH,WA1,WA2)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CH(IDO,3,L1)           ,CC(IDO,L1,3)           ,
     1                WA1(I_PIPS_RADF3_WA1)     ,WA2(I_PIPS_RADF3_WA2)
      PARAMETER (TAUR = -.5, TAUI = .866025403784439)
C (0,1)
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
      INTEGER*8 I_PIPS_RADF3_WA1
      COMMON /PIPS_RADF3_WA1/ I_PIPS_RADF3_WA1
      INTEGER*8 I_PIPS_RADF3_WA2
      COMMON /PIPS_RADF3_WA2/ I_PIPS_RADF3_WA2
C     BEGIN BLOCK
C (0,2)
CX30155 CALL SBINX (155)
CY30155 CALL SBINY (155)
CX10737 CALL DOINX( 737 )
CY10737 CALL DOINY( 737 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         CR2 = CC(1,K,2)+CC(1,K,3)
C (0,5)
         CH(1,1,K) = CC(1,K,1)+CR2
C (0,6)
         CH(1,3,K) = TAUI*(CC(1,K,3)-CC(1,K,2))
C (0,7)
         CH(IDO,2,K) = CC(1,K,1)+TAUR*CR2
C (0,8)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,9)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20738 CALL DOOUTX( 738 )
CY20738 CALL DOOUTY( 738 )
      IF (IDO.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      IDP2 = IDO+2
C (3,3)
CX10739 CALL DOINX( 739 )
CY10739 CALL DOINY( 739 )
!     INITIALLY: DO 103
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
!     INITIALLY: DO 102
         DO I = 3, IDO, 2
C (3,6)
C           BEGIN BLOCK
C (3,7)
            IC = IDP2-I
C (3,8)
            DR2 = WA1(I-2)*CC(I-1,K,2)+WA1(I-1)*CC(I,K,2)
C (3,9)
            DI2 = WA1(I-2)*CC(I,K,2)-WA1(I-1)*CC(I-1,K,2)
C (3,10)
            DR3 = WA2(I-2)*CC(I-1,K,3)+WA2(I-1)*CC(I,K,3)
C (3,11)
            DI3 = WA2(I-2)*CC(I,K,3)-WA2(I-1)*CC(I-1,K,3)
C (3,12)
            CR2 = DR2+DR3
C (3,13)
            CI2 = DI2+DI3
C (3,14)
            CH(I-1,1,K) = CC(I-1,K,1)+CR2
C (3,15)
            CH(I,1,K) = CC(I,K,1)+CI2
C (3,16)
            TR2 = CC(I-1,K,1)+TAUR*CR2
C (3,17)
            TI2 = CC(I,K,1)+TAUR*CI2
C (3,18)
            TR3 = TAUI*(DI2-DI3)
C (3,19)
            TI3 = TAUI*(DR3-DR2)
C (3,20)
            CH(I-1,3,K) = TR2+TR3
C (3,21)
            CH(IC-1,2,K) = TR2-TR3
C (3,22)
            CH(I,3,K) = TI2+TI3
C (3,23)
            CH(IC,2,K) = TI3-TI2
C (3,24)
102         CONTINUE
C           END BLOCK
         ENDDO
C (3,25)
103      CONTINUE
C        END BLOCK
      ENDDO
CX20740 CALL DOOUTX( 740 )
CY20740 CALL DOOUTY( 740 )
CX40156 CALL SBOUTX (156)
CY40156 CALL SBOUTY (156)
C     END BLOCK
C (2,1)
CX40156 CALL SBOUTX (156)
CY40156 CALL SBOUTY (156)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RADF4 (IDO,L1,CC,CH,WA1,WA2,WA3)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CC(IDO,L1,4)           ,CH(IDO,4,L1)           ,
     1                WA1(I_PIPS_RADF4_WA1)     ,WA2(I_PIPS_RADF4_WA2)  
     x    ,WA3(I_PIPS_RADF4_WA3)
      PARAMETER (HSQT2 = .7071067811865475)
C (0,1)
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
      INTEGER*8 I_PIPS_RADF4_WA1
      COMMON /PIPS_RADF4_WA1/ I_PIPS_RADF4_WA1
      INTEGER*8 I_PIPS_RADF4_WA2
      COMMON /PIPS_RADF4_WA2/ I_PIPS_RADF4_WA2
      INTEGER*8 I_PIPS_RADF4_WA3
      COMMON /PIPS_RADF4_WA3/ I_PIPS_RADF4_WA3
C     BEGIN BLOCK
C (0,2)
CX30157 CALL SBINX (157)
CY30157 CALL SBINY (157)
CX10741 CALL DOINX( 741 )
CY10741 CALL DOINY( 741 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         TR1 = CC(1,K,2)+CC(1,K,4)
C (0,5)
         TR2 = CC(1,K,1)+CC(1,K,3)
C (0,6)
         CH(1,1,K) = TR1+TR2
C (0,7)
         CH(IDO,4,K) = TR2-TR1
C (0,8)
         CH(IDO,2,K) = CC(1,K,1)-CC(1,K,3)
C (0,9)
         CH(1,3,K) = CC(1,K,4)-CC(1,K,2)
C (0,10)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,11)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20742 CALL DOOUTX( 742 )
CY20742 CALL DOOUTY( 742 )
      IF (IDO-2.LT.0) GOTO 107
C (6,1)
      IF (IDO-2.EQ.0) GOTO 105
C (5,1)
C     BEGIN BLOCK
C (5,2)
102   IDP2 = IDO+2
C (5,3)
CX10743 CALL DOINX( 743 )
CY10743 CALL DOINY( 743 )
!     INITIALLY: DO 104
      DO K = 1, L1
C (5,4)
C        BEGIN BLOCK
C (5,5)
!     INITIALLY: DO 103
         DO I = 3, IDO, 2
C (5,6)
C           BEGIN BLOCK
C (5,7)
            IC = IDP2-I
C (5,8)
            CR2 = WA1(I-2)*CC(I-1,K,2)+WA1(I-1)*CC(I,K,2)
C (5,9)
            CI2 = WA1(I-2)*CC(I,K,2)-WA1(I-1)*CC(I-1,K,2)
C (5,10)
            CR3 = WA2(I-2)*CC(I-1,K,3)+WA2(I-1)*CC(I,K,3)
C (5,11)
            CI3 = WA2(I-2)*CC(I,K,3)-WA2(I-1)*CC(I-1,K,3)
C (5,12)
            CR4 = WA3(I-2)*CC(I-1,K,4)+WA3(I-1)*CC(I,K,4)
C (5,13)
            CI4 = WA3(I-2)*CC(I,K,4)-WA3(I-1)*CC(I-1,K,4)
C (5,14)
            TR1 = CR2+CR4
C (5,15)
            TR4 = CR4-CR2
C (5,16)
            TI1 = CI2+CI4
C (5,17)
            TI4 = CI2-CI4
C (5,18)
            TI2 = CC(I,K,1)+CI3
C (5,19)
            TI3 = CC(I,K,1)-CI3
C (5,20)
            TR2 = CC(I-1,K,1)+CR3
C (5,21)
            TR3 = CC(I-1,K,1)-CR3
C (5,22)
            CH(I-1,1,K) = TR1+TR2
C (5,23)
            CH(IC-1,4,K) = TR2-TR1
C (5,24)
            CH(I,1,K) = TI1+TI2
C (5,25)
            CH(IC,4,K) = TI1-TI2
C (5,26)
            CH(I-1,3,K) = TI4+TR3
C (5,27)
            CH(IC-1,2,K) = TR3-TI4
C (5,28)
            CH(I,3,K) = TR4+TI3
C (5,29)
            CH(IC,2,K) = TR4-TI3
C (5,30)
103         CONTINUE
C           END BLOCK
         ENDDO
C (5,31)
104      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (4,1)
CX20744 CALL DOOUTX( 744 )
CY20744 CALL DOOUTY( 744 )
      IF (MOD(IDO, 2).EQ.1) GOTO 107
C (3,1)
C     BEGIN BLOCK
C (3,2)
105   CONTINUE
C (3,3)
CX10745 CALL DOINX( 745 )
CY10745 CALL DOINY( 745 )
!     INITIALLY: DO 106
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
         TI1 = -HSQT2*(CC(IDO,K,2)+CC(IDO,K,4))
C (3,6)
         TR1 = HSQT2*(CC(IDO,K,2)-CC(IDO,K,4))
C (3,7)
         CH(IDO,1,K) = TR1+CC(IDO,K,1)
C (3,8)
         CH(IDO,3,K) = CC(IDO,K,1)-TR1
C (3,9)
         CH(1,2,K) = TI1-CC(IDO,K,3)
C (3,10)
         CH(1,4,K) = TI1+CC(IDO,K,3)
C (3,11)
106      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (2,1)
CX40158 CALL SBOUTX (158)
CY40158 CALL SBOUTY (158)
CX20746 CALL DOOUTX( 746 )
CY20746 CALL DOOUTY( 746 )
107   CONTINUE
C     END UNSTRUCTURED
C (0,12)
CX40158 CALL SBOUTX (158)
CY40158 CALL SBOUTY (158)
      RETURN
C     END BLOCK
      END
      SUBROUTINE RADF5 (IDO,L1,CC,CH,WA1,WA2,WA3,WA4)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CC(IDO,L1,5)           ,CH(IDO,5,L1)           ,
     1                WA1(I_PIPS_RADF5_WA1)     ,WA2(I_PIPS_RADF5_WA2)  
     x    ,WA3(I_PIPS_RADF5_WA3)     ,WA4(I_PIPS_RADF5_WA4)
      PARAMETER (TR11 = .309016994374947, TI11 = .951056516295154,
     *           TR12 = -.809016994374947, TI12 = .587785252292473)
C (0,1)
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
      INTEGER*8 I_PIPS_RADF5_WA1
      COMMON /PIPS_RADF5_WA1/ I_PIPS_RADF5_WA1
      INTEGER*8 I_PIPS_RADF5_WA2
      COMMON /PIPS_RADF5_WA2/ I_PIPS_RADF5_WA2
      INTEGER*8 I_PIPS_RADF5_WA3
      COMMON /PIPS_RADF5_WA3/ I_PIPS_RADF5_WA3
      INTEGER*8 I_PIPS_RADF5_WA4
      COMMON /PIPS_RADF5_WA4/ I_PIPS_RADF5_WA4
C     BEGIN BLOCK
C (0,2)
CX30159 CALL SBINX (159)
CY30159 CALL SBINY (159)
CX10747 CALL DOINX( 747 )
CY10747 CALL DOINY( 747 )
!     INITIALLY: DO 101
      DO K = 1, L1
C (0,3)
C        BEGIN BLOCK
C (0,4)
         CR2 = CC(1,K,5)+CC(1,K,2)
C (0,5)
         CI5 = CC(1,K,5)-CC(1,K,2)
C (0,6)
         CR3 = CC(1,K,4)+CC(1,K,3)
C (0,7)
         CI4 = CC(1,K,4)-CC(1,K,3)
C (0,8)
         CH(1,1,K) = CC(1,K,1)+CR2+CR3
C (0,9)
         CH(IDO,2,K) = CC(1,K,1)+TR11*CR2+TR12*CR3
C (0,10)
         CH(1,3,K) = TI11*CI5+TI12*CI4
C (0,11)
         CH(IDO,4,K) = CC(1,K,1)+TR12*CR2+TR11*CR3
C (0,12)
         CH(1,5,K) = TI12*CI5-TI11*CI4
C (0,13)
101      CONTINUE
C        END BLOCK
      ENDDO
C (0,14)
C     BEGIN UNSTRUCTURED
C (1,1)
CX20748 CALL DOOUTX( 748 )
CY20748 CALL DOOUTY( 748 )
      IF (IDO.EQ.1) RETURN
C (3,1)
C     BEGIN BLOCK
C (3,2)
      IDP2 = IDO+2
C (3,3)
CX10749 CALL DOINX( 749 )
CY10749 CALL DOINY( 749 )
!     INITIALLY: DO 103
      DO K = 1, L1
C (3,4)
C        BEGIN BLOCK
C (3,5)
!     INITIALLY: DO 102
         DO I = 3, IDO, 2
C (3,6)
C           BEGIN BLOCK
C (3,7)
            IC = IDP2-I
C (3,8)
            DR2 = WA1(I-2)*CC(I-1,K,2)+WA1(I-1)*CC(I,K,2)
C (3,9)
            DI2 = WA1(I-2)*CC(I,K,2)-WA1(I-1)*CC(I-1,K,2)
C (3,10)
            DR3 = WA2(I-2)*CC(I-1,K,3)+WA2(I-1)*CC(I,K,3)
C (3,11)
            DI3 = WA2(I-2)*CC(I,K,3)-WA2(I-1)*CC(I-1,K,3)
C (3,12)
            DR4 = WA3(I-2)*CC(I-1,K,4)+WA3(I-1)*CC(I,K,4)
C (3,13)
            DI4 = WA3(I-2)*CC(I,K,4)-WA3(I-1)*CC(I-1,K,4)
C (3,14)
            DR5 = WA4(I-2)*CC(I-1,K,5)+WA4(I-1)*CC(I,K,5)
C (3,15)
            DI5 = WA4(I-2)*CC(I,K,5)-WA4(I-1)*CC(I-1,K,5)
C (3,16)
            CR2 = DR2+DR5
C (3,17)
            CI5 = DR5-DR2
C (3,18)
            CR5 = DI2-DI5
C (3,19)
            CI2 = DI2+DI5
C (3,20)
            CR3 = DR3+DR4
C (3,21)
            CI4 = DR4-DR3
C (3,22)
            CR4 = DI3-DI4
C (3,23)
            CI3 = DI3+DI4
C (3,24)
            CH(I-1,1,K) = CC(I-1,K,1)+CR2+CR3
C (3,25)
            CH(I,1,K) = CC(I,K,1)+CI2+CI3
C (3,26)
            TR2 = CC(I-1,K,1)+TR11*CR2+TR12*CR3
C (3,27)
            TI2 = CC(I,K,1)+TR11*CI2+TR12*CI3
C (3,28)
            TR3 = CC(I-1,K,1)+TR12*CR2+TR11*CR3
C (3,29)
            TI3 = CC(I,K,1)+TR12*CI2+TR11*CI3
C (3,30)
            TR5 = TI11*CR5+TI12*CR4
C (3,31)
            TI5 = TI11*CI5+TI12*CI4
C (3,32)
            TR4 = TI12*CR5-TI11*CR4
C (3,33)
            TI4 = TI12*CI5-TI11*CI4
C (3,34)
            CH(I-1,3,K) = TR2+TR5
C (3,35)
            CH(IC-1,2,K) = TR2-TR5
C (3,36)
            CH(I,3,K) = TI2+TI5
C (3,37)
            CH(IC,2,K) = TI5-TI2
C (3,38)
            CH(I-1,5,K) = TR3+TR4
C (3,39)
            CH(IC-1,4,K) = TR3-TR4
C (3,40)
            CH(I,5,K) = TI3+TI4
C (3,41)
            CH(IC,4,K) = TI4-TI3
C (3,42)
102         CONTINUE
C           END BLOCK
         ENDDO
C (3,43)
103      CONTINUE
C        END BLOCK
      ENDDO
CX20750 CALL DOOUTX( 750 )
CY20750 CALL DOOUTY( 750 )
CX40160 CALL SBOUTX (160)
CY40160 CALL SBOUTY (160)
C     END BLOCK
C (2,1)
CX40160 CALL SBOUTX (160)
CY40160 CALL SBOUTY (160)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
      SUBROUTINE RADFG (IDO,IP,L1,IDL1,CC,C1,C2,CH,CH2,WA)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION       CH(IDO,L1,IP)          ,CC(IDO,IP,L1)          ,
     1                C1(IDO,L1,IP)          ,C2(IDL1,IP),
     2                CH2(IDL1,IP)           ,WA(I_PIPS_RADFG_WA)
      PARAMETER (TPI = 6.28318530717959)
C (0,1)
      INTEGER*8 I_PIPS_RFFTF_WSAVE
      COMMON /PIPS_RFFTF_WSAVE/ I_PIPS_RFFTF_WSAVE
      INTEGER*8 I_PIPS_RADFG_WA
      COMMON /PIPS_RADFG_WA/ I_PIPS_RADFG_WA
C     BEGIN BLOCK
C (0,2)
CX30161 CALL SBINX (161)
CY30161 CALL SBINY (161)
      ARG = TPI/FLOAT(IP)
C (0,3)
      DCP = DCOS(ARG)
C (0,4)
      DSP = DSIN(ARG)
C (0,5)
      IPPH = (IP+1)/2
C (0,6)
      IPP2 = IP+2
C (0,7)
      IDP2 = IDO+2
C (0,8)
      NBD = (IDO-1)/2
C (0,9)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (IDO.EQ.1) GOTO 119
C (19,1)
C     BEGIN BLOCK
C (19,2)
CX10751 CALL DOINX( 751 )
CY10751 CALL DOINY( 751 )
!     INITIALLY: DO 101
      DO IK = 1, IDL1
C (19,3)
C        BEGIN BLOCK
C (19,4)
         CH2(IK,1) = C2(IK,1)
C (19,5)
101      CONTINUE
C        END BLOCK
      ENDDO
C (19,6)
CX20752 CALL DOOUTX( 752 )
CY20752 CALL DOOUTY( 752 )
CX10753 CALL DOINX( 753 )
CY10753 CALL DOINY( 753 )
!     INITIALLY: DO 103
      DO J = 2, IP
C (19,7)
C        BEGIN BLOCK
C (19,8)
!     INITIALLY: DO 102
         DO K = 1, L1
C (19,9)
C           BEGIN BLOCK
C (19,10)
            CH(1,K,J) = C1(1,K,J)
C (19,11)
102         CONTINUE
C           END BLOCK
         ENDDO
C (19,12)
103      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (17,1)
CX20754 CALL DOOUTX( 754 )
CY20754 CALL DOOUTY( 754 )
      IF (NBD.GT.L1) GOTO 107
C (18,1)
C     BEGIN BLOCK
C (18,2)
      IS = -IDO
C (18,3)
CX10755 CALL DOINX( 755 )
CY10755 CALL DOINY( 755 )
!     INITIALLY: DO 106
      DO J = 2, IP
C (18,4)
C        BEGIN BLOCK
C (18,5)
         IS = IS+IDO
C (18,6)
         IDIJ = IS
C (18,7)
!     INITIALLY: DO 105
         DO I = 3, IDO, 2
C (18,8)
C           BEGIN BLOCK
C (18,9)
            IDIJ = IDIJ+2
C (18,10)
!     INITIALLY: DO 104
            DO K = 1, L1
C (18,11)
C              BEGIN BLOCK
C (18,12)
               CH(I-1,K,J) = WA(IDIJ-1)*C1(I-1,K,J)+WA(IDIJ)*C1(I,K,J
     &         )
C (18,13)
               CH(I,K,J) = WA(IDIJ-1)*C1(I,K,J)-WA(IDIJ)*C1(I-1,K,J)
C (18,14)
104            CONTINUE
C              END BLOCK
            ENDDO
C (18,15)
105         CONTINUE
C           END BLOCK
         ENDDO
C (18,16)
106      CONTINUE
C        END BLOCK
      ENDDO
CX20756 CALL DOOUTX( 756 )
CY20756 CALL DOOUTY( 756 )
C     END BLOCK
C (14,1)
CX20758 CALL DOOUTX( 758 )
CY20758 CALL DOOUTY( 758 )
111   IF (NBD.LT.L1) GOTO 115
C (15,1)
C     BEGIN BLOCK
C (15,2)
CX10759 CALL DOINX( 759 )
CY10759 CALL DOINY( 759 )
!     INITIALLY: DO 114
      DO J = 2, IPPH
C (15,3)
C        BEGIN BLOCK
C (15,4)
         JC = IPP2-J
C (15,5)
!     INITIALLY: DO 113
         DO K = 1, L1
C (15,6)
C           BEGIN BLOCK
C (15,7)
!     INITIALLY: DO 112
            DO I = 3, IDO, 2
C (15,8)
C              BEGIN BLOCK
C (15,9)
               C1(I-1,K,J) = CH(I-1,K,J)+CH(I-1,K,JC)
C (15,10)
               C1(I-1,K,JC) = CH(I,K,J)-CH(I,K,JC)
C (15,11)
               C1(I,K,J) = CH(I,K,J)+CH(I,K,JC)
C (15,12)
               C1(I,K,JC) = CH(I-1,K,JC)-CH(I-1,K,J)
C (15,13)
112            CONTINUE
C              END BLOCK
            ENDDO
C (15,14)
113         CONTINUE
C           END BLOCK
         ENDDO
C (15,15)
114      CONTINUE
C        END BLOCK
      ENDDO
CX20760 CALL DOOUTX( 760 )
CY20760 CALL DOOUTY( 760 )
C     END BLOCK
C (3,1)
C     BEGIN BLOCK
C (3,2)
CX20764 CALL DOOUTX( 764 )
CY20764 CALL DOOUTY( 764 )
121   CONTINUE
C (3,3)
CX10765 CALL DOINX( 765 )
CY10765 CALL DOINY( 765 )
!     INITIALLY: DO 123
      DO J = 2, IPPH
C (3,4)
C        BEGIN BLOCK
C (3,5)
         JC = IPP2-J
C (3,6)
!     INITIALLY: DO 122
         DO K = 1, L1
C (3,7)
C           BEGIN BLOCK
C (3,8)
            C1(1,K,J) = CH(1,K,J)+CH(1,K,JC)
C (3,9)
            C1(1,K,JC) = CH(1,K,JC)-CH(1,K,J)
C (3,10)
122         CONTINUE
C           END BLOCK
         ENDDO
C (3,11)
123      CONTINUE
C        END BLOCK
      ENDDO
C (3,12)
CX20766 CALL DOOUTX( 766 )
CY20766 CALL DOOUTY( 766 )
C
      AR1 = 1.
C (3,13)
      AI1 = 0.
C (3,14)
CX10767 CALL DOINX( 767 )
CY10767 CALL DOINY( 767 )
!     INITIALLY: DO 127
      DO L = 2, IPPH
C (3,15)
C        BEGIN BLOCK
C (3,16)
         LC = IPP2-L
C (3,17)
         AR1H = DCP*AR1-DSP*AI1
C (3,18)
         AI1 = DCP*AI1+DSP*AR1
C (3,19)
         AR1 = AR1H
C (3,20)
!     INITIALLY: DO 124
         DO IK = 1, IDL1
C (3,21)
C           BEGIN BLOCK
C (3,22)
            CH2(IK,L) = C2(IK,1)+AR1*C2(IK,2)
C (3,23)
            CH2(IK,LC) = AI1*C2(IK,IP)
C (3,24)
124         CONTINUE
C           END BLOCK
         ENDDO
C (3,25)
         DC2 = AR1
C (3,26)
         DS2 = AI1
C (3,27)
         AR2 = AR1
C (3,28)
         AI2 = AI1
C (3,29)
!     INITIALLY: DO 126
         DO J = 3, IPPH
C (3,30)
C           BEGIN BLOCK
C (3,31)
            JC = IPP2-J
C (3,32)
            AR2H = DC2*AR2-DS2*AI2
C (3,33)
            AI2 = DC2*AI2+DS2*AR2
C (3,34)
            AR2 = AR2H
C (3,35)
!     INITIALLY: DO 125
            DO IK = 1, IDL1
C (3,36)
C              BEGIN BLOCK
C (3,37)
               CH2(IK,L) = CH2(IK,L)+AR2*C2(IK,J)
C (3,38)
               CH2(IK,LC) = CH2(IK,LC)+AI2*C2(IK,JC)
C (3,39)
125            CONTINUE
C              END BLOCK
            ENDDO
C (3,40)
126         CONTINUE
C           END BLOCK
         ENDDO
C (3,41)
127      CONTINUE
C        END BLOCK
      ENDDO
C (3,42)
CX20768 CALL DOOUTX( 768 )
CY20768 CALL DOOUTY( 768 )
CX10769 CALL DOINX( 769 )
CY10769 CALL DOINY( 769 )
!     INITIALLY: DO 129
      DO J = 2, IPPH
C (3,43)
C        BEGIN BLOCK
C (3,44)
!     INITIALLY: DO 128
         DO IK = 1, IDL1
C (3,45)
C           BEGIN BLOCK
C (3,46)
            CH2(IK,1) = CH2(IK,1)+C2(IK,J)
C (3,47)
128         CONTINUE
C           END BLOCK
         ENDDO
C (3,48)
129      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (4,1)
CX20770 CALL DOOUTX( 770 )
CY20770 CALL DOOUTY( 770 )
C
      IF (IDO.LT.L1) GOTO 132
C (12,1)
C     BEGIN BLOCK
C (12,2)
CX10771 CALL DOINX( 771 )
CY10771 CALL DOINY( 771 )
!     INITIALLY: DO 131
      DO K = 1, L1
C (12,3)
C        BEGIN BLOCK
C (12,4)
!     INITIALLY: DO 130
         DO I = 1, IDO
C (12,5)
C           BEGIN BLOCK
C (12,6)
            CC(I,1,K) = CH(I,K,1)
C (12,7)
130         CONTINUE
C           END BLOCK
         ENDDO
C (12,8)
131      CONTINUE
C        END BLOCK
      ENDDO
CX20772 CALL DOOUTX( 772 )
CY20772 CALL DOOUTY( 772 )
C     END BLOCK
C (6,1)
C     BEGIN BLOCK
C (6,2)
CX20774 CALL DOOUTX( 774 )
CY20774 CALL DOOUTY( 774 )
135   CONTINUE
C (6,3)
CX10775 CALL DOINX( 775 )
CY10775 CALL DOINY( 775 )
!     INITIALLY: DO 137
      DO J = 2, IPPH
C (6,4)
C        BEGIN BLOCK
C (6,5)
         JC = IPP2-J
C (6,6)
         J2 = J+J
C (6,7)
!     INITIALLY: DO 136
         DO K = 1, L1
C (6,8)
C           BEGIN BLOCK
C (6,9)
            CC(IDO,J2-2,K) = CH(1,K,J)
C (6,10)
            CC(1,J2-1,K) = CH(1,K,JC)
C (6,11)
136         CONTINUE
C           END BLOCK
         ENDDO
C (6,12)
137      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
C (7,1)
CX20776 CALL DOOUTX( 776 )
CY20776 CALL DOOUTY( 776 )
      IF (IDO.EQ.1) RETURN
C (10,1)
      IF (NBD.LT.L1) GOTO 141
C (9,1)
C     BEGIN BLOCK
C (9,2)
CX10777 CALL DOINX( 777 )
CY10777 CALL DOINY( 777 )
!     INITIALLY: DO 140
      DO J = 2, IPPH
C (9,3)
C        BEGIN BLOCK
C (9,4)
         JC = IPP2-J
C (9,5)
         J2 = J+J
C (9,6)
!     INITIALLY: DO 139
         DO K = 1, L1
C (9,7)
C           BEGIN BLOCK
C (9,8)
!     INITIALLY: DO 138
            DO I = 3, IDO, 2
C (9,9)
C              BEGIN BLOCK
C (9,10)
               IC = IDP2-I
C (9,11)
               CC(I-1,J2-1,K) = CH(I-1,K,J)+CH(I-1,K,JC)
C (9,12)
               CC(IC-1,J2-2,K) = CH(I-1,K,J)-CH(I-1,K,JC)
C (9,13)
               CC(I,J2-1,K) = CH(I,K,J)+CH(I,K,JC)
C (9,14)
               CC(IC,J2-2,K) = CH(I,K,JC)-CH(I,K,J)
C (9,15)
138            CONTINUE
C              END BLOCK
            ENDDO
C (9,16)
139         CONTINUE
C           END BLOCK
         ENDDO
C (9,17)
140      CONTINUE
C        END BLOCK
      ENDDO
CX20778 CALL DOOUTX( 778 )
CY20778 CALL DOOUTY( 778 )
CX40162 CALL SBOUTX (162)
CY40162 CALL SBOUTY (162)
C     END BLOCK
      RETURN
C (11,1)
C     BEGIN BLOCK
C (11,2)
141   CONTINUE
C (11,3)
CX10779 CALL DOINX( 779 )
CY10779 CALL DOINY( 779 )
!     INITIALLY: DO 144
      DO J = 2, IPPH
C (11,4)
C        BEGIN BLOCK
C (11,5)
         JC = IPP2-J
C (11,6)
         J2 = J+J
C (11,7)
!     INITIALLY: DO 143
         DO I = 3, IDO, 2
C (11,8)
C           BEGIN BLOCK
C (11,9)
            IC = IDP2-I
C (11,10)
!     INITIALLY: DO 142
            DO K = 1, L1
C (11,11)
C              BEGIN BLOCK
C (11,12)
               CC(I-1,J2-1,K) = CH(I-1,K,J)+CH(I-1,K,JC)
C (11,13)
               CC(IC-1,J2-2,K) = CH(I-1,K,J)-CH(I-1,K,JC)
C (11,14)
               CC(I,J2-1,K) = CH(I,K,J)+CH(I,K,JC)
C (11,15)
               CC(IC,J2-2,K) = CH(I,K,JC)-CH(I,K,J)
C (11,16)
142            CONTINUE
C              END BLOCK
            ENDDO
C (11,17)
143         CONTINUE
C           END BLOCK
         ENDDO
C (11,18)
144      CONTINUE
C        END BLOCK
      ENDDO
CX20780 CALL DOOUTX( 780 )
CY20780 CALL DOOUTY( 780 )
CX40162 CALL SBOUTX (162)
CY40162 CALL SBOUTY (162)
C     END BLOCK
      RETURN
C (5,1)
C     BEGIN BLOCK
C (5,2)
132   CONTINUE
C (5,3)
CX10773 CALL DOINX( 773 )
CY10773 CALL DOINY( 773 )
!     INITIALLY: DO 134
      DO I = 1, IDO
C (5,4)
C        BEGIN BLOCK
C (5,5)
!     INITIALLY: DO 133
         DO K = 1, L1
C (5,6)
C           BEGIN BLOCK
C (5,7)
            CC(I,1,K) = CH(I,K,1)
C (5,8)
133         CONTINUE
C           END BLOCK
         ENDDO
C (5,9)
134      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 135
C (13,1)
C     BEGIN BLOCK
C (13,2)
115   CONTINUE
C (13,3)
CX10761 CALL DOINX( 761 )
CY10761 CALL DOINY( 761 )
!     INITIALLY: DO 118
      DO J = 2, IPPH
C (13,4)
C        BEGIN BLOCK
C (13,5)
         JC = IPP2-J
C (13,6)
!     INITIALLY: DO 117
         DO I = 3, IDO, 2
C (13,7)
C           BEGIN BLOCK
C (13,8)
!     INITIALLY: DO 116
            DO K = 1, L1
C (13,9)
C              BEGIN BLOCK
C (13,10)
               C1(I-1,K,J) = CH(I-1,K,J)+CH(I-1,K,JC)
C (13,11)
               C1(I-1,K,JC) = CH(I,K,J)-CH(I,K,JC)
C (13,12)
               C1(I,K,J) = CH(I,K,J)+CH(I,K,JC)
C (13,13)
               C1(I,K,JC) = CH(I-1,K,JC)-CH(I-1,K,J)
C (13,14)
116            CONTINUE
C              END BLOCK
            ENDDO
C (13,15)
117         CONTINUE
C           END BLOCK
         ENDDO
C (13,16)
118      CONTINUE
C        END BLOCK
      ENDDO
CX20762 CALL DOOUTX( 762 )
CY20762 CALL DOOUTY( 762 )
C     END BLOCK
      GOTO 121
C (16,1)
C     BEGIN BLOCK
C (16,2)
107   IS = -IDO
C (16,3)
CX10757 CALL DOINX( 757 )
CY10757 CALL DOINY( 757 )
!     INITIALLY: DO 110
      DO J = 2, IP
C (16,4)
C        BEGIN BLOCK
C (16,5)
         IS = IS+IDO
C (16,6)
!     INITIALLY: DO 109
         DO K = 1, L1
C (16,7)
C           BEGIN BLOCK
C (16,8)
            IDIJ = IS
C (16,9)
!     INITIALLY: DO 108
            DO I = 3, IDO, 2
C (16,10)
C              BEGIN BLOCK
C (16,11)
               IDIJ = IDIJ+2
C (16,12)
               CH(I-1,K,J) = WA(IDIJ-1)*C1(I-1,K,J)+WA(IDIJ)*C1(I,K,J
     &         )
C (16,13)
               CH(I,K,J) = WA(IDIJ-1)*C1(I,K,J)-WA(IDIJ)*C1(I-1,K,J)
C (16,14)
108            CONTINUE
C              END BLOCK
            ENDDO
C (16,15)
109         CONTINUE
C           END BLOCK
         ENDDO
C (16,16)
110      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 111
C (2,1)
C     BEGIN BLOCK
C (2,2)
119   CONTINUE
C (2,3)
CX10763 CALL DOINX( 763 )
CY10763 CALL DOINY( 763 )
!     INITIALLY: DO 120
      DO IK = 1, IDL1
C (2,4)
C        BEGIN BLOCK
C (2,5)
         C2(IK,1) = CH2(IK,1)
C (2,6)
120      CONTINUE
C        END BLOCK
      ENDDO
C     END BLOCK
      GOTO 121
C (8,1)
CX40162 CALL SBOUTX (162)
CY40162 CALL SBOUTY (162)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C *   B O U N D A R Y    L A Y E R    S O L V E R   F O R     KM  KH   *
C *====================================================================*
C *  BOUNDARY LAYER SOLVER FOR THE MESO+SYNOPTIC WIND AND TEMPERATURE. *
C *  U,T ARE UTILITY VECTORS FOR DATA MANIPULATIONS. (HELP,HELPA)      *
C *  POTT,UX,VY ARE THE PERTURBATION TEMPERATURE AND WINDS, ZET IS     *
C *  THE GEOMETRIC HEIGHT, DKZM AND SKZH ARE THE  EDDY DIFFUSIVITIES   *
C *  DZMIN IS THE MINIMUM DIFFUSIVITY SPECIFIED IN THE DATA, Z0 IS THE *
C *  TERRAIN ROUGHNESS, ELEV IS THE TOPOGRAPHY, NX,NY,NZ ARE THE       *
C *  DOMAIN GRID POINTS, HMIX IS THE MIXING HEIGHT OR  THE HEIGHT      *
C *  OF THE BOUNDARY LAYER, STEPH IS THE BOUNDARY LAYER HEIGHT AT THE  *
C *  PREVIOUS TIME STEP, OBUK IS THE MONIN OBUKOV LENGTH, USTR IS      *
C *  FRICTIONAL VELOCITY, VDEP IS THE DRY DEPOSITIONAL VELOCITY, WZ IS *
C *  THE VERTICAL VELOCITY, UM, VM AND TM ARE THE SYNOPTIC WIND AND    *
C *  TEMPERATURE COMPONENTS RESPECTIVELY, TSTR IS THE TURBULENT        *
C *  POTENTIAL TEMPERATURE, FXC+FYC THE SPECTRAL DIFFUSSIVITIES IN X,Y *
C *  AND TAVR IS THE AVERAGE TEMPERATURE IN THE SURFACE LAYER          *
C **********************************************************************
C
      SUBROUTINE DKZMH(U,T,TM,UM,VM,POTT,UX,VY,WZ,ZET,DKZM,DKZH,DZMIN,
     *Z0,ELEV,NX,NX1,NY,NY1,NZ,HMIX,STEPH,TAVR,OBUK,USTR,TSTR,VDEP,NSMT,
     x 
     *F,NFILT,ISTEP,DELTAT,SAVEX,SAVEY,FX,FY,FXC,FYC,DCDX,DCDY,TSL,DLF)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION UX(NX,NY,NZ),VY(NX,NY,NZ),POTT(NX,NY,NZ),DKZM(NX,NY,NZ),
     x 
     *DKZH(NX,NY,NZ),WZ(NX,NY,NZ),OBUK(NX,NY),USTR(NX,NY),
     *VDEP(NX,NY),TAVR(NX,NY),TSTR(NX,NY),STEPH(NX,NY),Z0(NX,NY),
     *ELEV(NX,NY),HMIX(NX,NY),U(I_PIPS_RUN_HELP),T(I_PIPS_RUN_HELPA),TM(
     x I_PIPS_RUN_TM),VM(I_PIPS_RUN_VM),UM(I_PIPS_RUN_UM),ZET(I_PIPS_RUN
     x _ZET),
     *SAVEX(I_PIPS_RUN_SAVEX),SAVEY(I_PIPS_RUN_SAVEY),FX(I_PIPS_RUN_FX),
     x FY(I_PIPS_RUN_FY),FXC(I_PIPS_RUN_FXC),FYC(I_PIPS_RUN_FYC),DCDX(I_
     x PIPS_RUN_DCDX),DCDY(I_PIPS_RUN_DCDY)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
C     BEGIN BLOCK
C (0,2)
CX30163 CALL SBINX (163)
CY30163 CALL SBINY (163)
CX10781 CALL DOINX( 781 )
CY10781 CALL DOINY( 781 )
C
!     INITIALLY: DO 30
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 20
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
C
C           CALCULATE ROUGHNES LENGTH BY USING THE FRICTIONAL
C           VELOCITY USTAR ONLY FOR LAKE (ELEV<0.) (PIERSON 1978)
C
            ZMH = HMIX(I,J)
C (0,7)
            ZNOT = Z0(I,J)
C (0,8)
            IF (ELEV(I,J).LT.0) THEN
C (0,9)
C              BEGIN BLOCK
C (0,10)
               USTAR = MAX(USTR(I,J), 0.001D0)
C (0,11)
               ZNOT = 3.905D-5/USTAR+1.6046D-3*USTAR**2-1.747D-4
C (0,12)
               Z0(I,J) = ZNOT
C              END BLOCK
            ELSE
C (0,13)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,14)
C
C           FILL VECTORS WITH PERTURBATION WIND AND TEMPERATURE
C
C *****   REMEMBER  K(MESO)=K(MESO+SYNOP)-K(SYNOP)  ********************
C
!     INITIALLY: DO 10
            DO K = 1, NZ
C (0,15)
C              BEGIN BLOCK
C (0,16)
               IF (I.EQ.1.OR.I.EQ.NX) THEN
C (0,17)
C                 BEGIN BLOCK
C (0,18)
                  TX = 0.5D0*POTT(I,J,K)
C (0,19)
                  WUX = 0.5D0*UX(I,J,K)
C (0,20)
                  WVX = 0.5D0*VY(I,J,K)
C                 END BLOCK
               ELSE
C (0,21)
C                 BEGIN BLOCK
C (0,22)
                  TX = 0.25D0*(POTT(I-1,J,K)+POTT(I+1,J,K))
C (0,23)
                  WUX = 0.25D0*(UX(I-1,J,K)+UX(I+1,J,K))
C (0,24)
                  WVX = 0.25D0*(VY(I-1,J,K)+VY(I+1,J,K))
C                 END BLOCK
               ENDIF
C (0,25)
               IF (J.EQ.1.OR.J.EQ.NY) THEN
C (0,26)
C                 BEGIN BLOCK
C (0,27)
                  TY = 0.5D0*POTT(I,J,K)
C (0,28)
                  WUY = 0.5D0*UX(I,J,K)
C (0,29)
                  WVY = 0.5D0*VY(I,J,K)
C                 END BLOCK
               ELSE
C (0,30)
C                 BEGIN BLOCK
C (0,31)
                  TY = 0.25D0*(POTT(I,J-1,K)+POTT(I,J+1,K))
C (0,32)
                  WUY = 0.25D0*(UX(I,J-1,K)+UX(I,J+1,K))
C (0,33)
                  WVY = 0.25D0*(VY(I,J-1,K)+VY(I,J+1,K))
C                 END BLOCK
               ENDIF
C (0,34)
C
C              ADD THE SYNOPTIC VARIABLES TO THE MESOSCALE, AND
C              CALCULATE THE TOTAL WIND EFFECT (U+V)**1/2
C
               XW = (UX(I,J,K)+WUX+WUY)/2.D0+UM(K)
C (0,35)
               YW = (VY(I,J,K)+WVX+WVY)/2.D0+VM(K)
C (0,36)
               U(K) = SQRT(XW*XW+YW*YW)
C (0,37)
               T(K) = (POTT(I,J,K)+TX+TY)/2.D0+TM(K)
C (0,38)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,39)
C
C       CALCULATE SURFACE LAYER PARAMETERS
C
            CALL SFCPAR(U, T, ZET, NZ, ZNOT, USTAR, TSTAR, DL, ZMH, 
     &      TSL, TMES)
C (0,40)
C
C           DUMP ALL HORIZONTAL BOUNDARY LAYER PARAMETERS BACK
C
            OBUK(I,J) = DL
C (0,41)
            USTR(I,J) = USTAR
C (0,42)
            TSTR(I,J) = TSTAR
C (0,43)
            TAVR(I,J) = TMES
C (0,44)
20          CONTINUE
C           END BLOCK
         ENDDO
C (0,45)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,46)
CX20782 CALL DOOUTX( 782 )
CY20782 CALL DOOUTY( 782 )
C
C      SMOOTH THE BOUNDARY LAYER PARAMETERS TO GET RID OF THE
C      TWO-GRID NOISE IN THE SURFACE LAYER.
C
      CALL HORSMT(NX, NY, USTR)
C (0,47)
      CALL HORSMT(NX, NY, TSTR)
C (0,48)
C
C     CALCULATE A NEW MONIN OBUKHOV LENGTH FROM THE SURFACE LAYER
C     RELATION TO HAVE A BALANCE BETWEEN U*,T* AND L
C     FIND THE TOP OF THE BOUNDARY LAYER BY USING DEARDORFFS AND
C     SMEDAS PROGNOSTIC RELATION VIA PSEUDOSPECTRAL METHODS.
C
      CALL TOPBL(NX, NX1, NY, NY1, NZ, USTR, TSTR, OBUK, TAVR, HMIX, 
     &STEPH, UX, UM, VY, VM, WZ, POTT, TM, ZET, U, T, NFILT, ISTEP, F
     &, DELTAT, SAVEX, SAVEY, FX, FY, FXC, FYC, DCDX, DCDY)
C (0,49)
CX10783 CALL DOINX( 783 )
CY10783 CALL DOINY( 783 )
C
C     IMPOSE RESTRICTIONS ON THE BOUNDARY LAYER HEIGHT, AND CALCULATE
C     THE DRY DEPOSITIONAL VELOCITIES ACCORDING TO WALCHEK
C
!     INITIALLY: DO 60
      DO J = 1, NY
C (0,50)
C        BEGIN BLOCK
C (0,51)
!     INITIALLY: DO 50
         DO I = 1, NX
C (0,52)
C           BEGIN BLOCK
C (0,53)
            DL = OBUK(I,J)
C (0,54)
            TMES = TAVR(I,J)
C (0,55)
            USTAR = USTR(I,J)
C (0,56)
            ZMH = MAX(40.D0, HMIX(I,J))
C (0,57)
            ZMH = MIN(ZMH, 2000.D0)
C (0,58)
            HMIX(I,J) = ZMH
C (0,59)
            ZNOT = Z0(I,J)
C (0,60)
            DEPFAC = USTAR/500.D0
C (0,61)
C
C           STORE DRY DEPOSITION VELOCITIES IN STABLE AND
C           UNSTABLE CONDITIONS.
C
            IF (DL.GE.0) THEN
C (0,62)
               VDEP(I,J) = DEPFAC
            ELSE
C (0,63)
C              BEGIN BLOCK
C (0,64)
               ZC = ZMH/DL
C (0,65)
               IF (ZC.LT.-30.D0) THEN
C (0,66)
                  VDEP(I,J) = 0.5D0*DEPFAC*(-ZC)**0.6666667D0
               ELSE
C (0,67)
                  VDEP(I,J) = DEPFAC*(1.D0+((-300)/DL)**0.6666667D0)
               ENDIF
C              END BLOCK
            ENDIF
C (0,68)
            VDEP(I,J) = MIN(0.004D0, VDEP(I,J))
C (0,69)
C
C       CALCULATE THE EDDY DIFFUSIVITY COEFFICIENTS FOR HEAT AND
C       MOMENTUM IN THE BOUNDARY LAYER FOR EVERY VERTICAL COLUMN
C
            CALL BLSOLV(ZET, NZ, ZNOT, USTAR, DL, DZMIN, U, T, ZMH, 
     &      TSL)
C (0,70)
C
C      DUMP THE EDDY DIFFUSIVITIES ON A 3-D GRID AND SMOOTH
C      HORIZONTALLY FOR AVOIDING HIGH LOCAL FORCING IN ADVECTION TERMS
C
!     INITIALLY: DO 40
            DO K = 1, NZ
C (0,71)
C              BEGIN BLOCK
C (0,72)
               DKZM(I,J,K) = U(K)
C (0,73)
               DKZH(I,J,K) = T(K)
C (0,74)
40             CONTINUE
C              END BLOCK
            ENDDO
C (0,75)
50          CONTINUE
C           END BLOCK
         ENDDO
C (0,76)
60       CONTINUE
C        END BLOCK
      ENDDO
C (0,77)
CX20784 CALL DOOUTX( 784 )
CY20784 CALL DOOUTY( 784 )
C
      CALL HORSMT(NX, NY, VDEP)
C (0,78)
      CALL SMOOTH(DKZM, NX, NY, NZ)
C (0,79)
      CALL SMOOTH(DKZH, NX, NY, NZ)
C (0,80)
CX40164 CALL SBOUTX (164)
CY40164 CALL SBOUTY (164)

      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *  ROUTINE TO CALCULATE THE TIME DEPENDENT MIXING HEIGHT H WHICH IS  *
C *            THE TOP OF THE PLANETARY BOUNDARY LAYER                 *
C **********************************************************************
C
      SUBROUTINE TOPBL(NX,NX1,NY,NY1,NZ,USTR,TSTR,OBUK,TAVR,
     *HMIX,STEPH,UX,UM,VY,VM,WZ,POTT,TM,ZET,HELP,HELPA,NFILT,
     *ISTEP,F,DELTAT,SAVEX,SAVEY,FX,FY,FXC,FYC,DCDX,DCDY)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION UX(NX,NY,NZ),VY(NX,NY,NZ),POTT(NX,NY,NZ),WZ(NX,NY,NZ),
     *DCDX(I_PIPS_RUN_DCDX),DCDY(I_PIPS_RUN_DCDY),HMIX(NX,NY),STEPH(NX,N
     x Y),TAVR(NX,NY),
     *USTR(NX,NY),TSTR(NX,NY),OBUK(NX,NY),UM(I_PIPS_RUN_UM),VM(I_PIPS_RU
     x N_VM),TM(I_PIPS_RUN_TM),ZET(I_PIPS_RUN_ZET),
     *HELP(I_PIPS_RUN_HELP),HELPA(I_PIPS_RUN_HELPA),SAVEX(I_PIPS_RUN_SAV
     x EX),SAVEY(I_PIPS_RUN_SAVEY),FX(I_PIPS_RUN_FX),FY(I_PIPS_RUN_FY),F
     x XC(I_PIPS_RUN_FXC),FYC(I_PIPS_RUN_FYC)
C (0,1)
      INTEGER*8 I_PIPS_RUN_UM
      COMMON /PIPS_RUN_UM/ I_PIPS_RUN_UM
      INTEGER*8 I_PIPS_RUN_VM
      COMMON /PIPS_RUN_VM/ I_PIPS_RUN_VM
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_SAVEX
      COMMON /PIPS_RUN_SAVEX/ I_PIPS_RUN_SAVEX
      INTEGER*8 I_PIPS_RUN_SAVEY
      COMMON /PIPS_RUN_SAVEY/ I_PIPS_RUN_SAVEY
      INTEGER*8 I_PIPS_RUN_FX
      COMMON /PIPS_RUN_FX/ I_PIPS_RUN_FX
      INTEGER*8 I_PIPS_RUN_FY
      COMMON /PIPS_RUN_FY/ I_PIPS_RUN_FY
      INTEGER*8 I_PIPS_RUN_FXC
      COMMON /PIPS_RUN_FXC/ I_PIPS_RUN_FXC
      INTEGER*8 I_PIPS_RUN_FYC
      COMMON /PIPS_RUN_FYC/ I_PIPS_RUN_FYC
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_RUN_DCDY
      COMMON /PIPS_RUN_DCDY/ I_PIPS_RUN_DCDY
      INTEGER*8 I_PIPS_DCTDX_FX
      COMMON /PIPS_DCTDX_FX/ I_PIPS_DCTDX_FX
      INTEGER*8 I_PIPS_DCTDX_FXX
      COMMON /PIPS_DCTDX_FXX/ I_PIPS_DCTDX_FXX
      INTEGER*8 I_PIPS_DCTDX_SAVEX
      COMMON /PIPS_DCTDX_SAVEX/ I_PIPS_DCTDX_SAVEX
      INTEGER*8 I_PIPS_LEAPFR_F2
      COMMON /PIPS_LEAPFR_F2/ I_PIPS_LEAPFR_F2
      INTEGER*8 I_PIPS_LEAPFR_F0
      COMMON /PIPS_LEAPFR_F0/ I_PIPS_LEAPFR_F0
C     BEGIN BLOCK
C (0,2)
      I_PIPS_DCTDX_FX = I_PIPS_RUN_FX
      I_PIPS_DCTDX_FXX = I_PIPS_RUN_FXC
      I_PIPS_DCTDX_SAVEX = I_PIPS_RUN_SAVEX
CX30165 CALL SBINX (165)
CY30165 CALL SBINY (165)
C
C     CALCULATE THE DERIVATIVES DH/DX,DH/DY  VIA FFT
C
      CALL DCTDX(NX, NY, NX1, NFILT, HMIX, DCDX, HELP, HELPA, FX, FXC
     &, SAVEX)
C (0,3)
      IF (NY.GT.1) THEN
C (0,4)
      I_PIPS_DCTDX_FX = I_PIPS_RUN_FY
      I_PIPS_DCTDX_FXX = I_PIPS_RUN_FYC
      I_PIPS_DCTDX_SAVEX = I_PIPS_RUN_SAVEY
         CALL DCTDX(NX, NY, NY1, NFILT, HMIX, DCDY, HELP, HELPA, FY, 
     &   FYC, SAVEY)
      ELSE
C (0,5)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,6)
C
C     RUN THE TIME LOOP
C
      LOOP = NX*NY
C (0,7)
C
C     FIND  ADVECTION, CONVECTION AND HEATING RATES
C     K=0.35, G=9.81 THEIR PRODUCT IS 3.4335
C
      L = 0
C (0,8)
CX10785 CALL DOINX( 785 )
CY10785 CALL DOINY( 785 )
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,9)
C        BEGIN BLOCK
C (0,10)
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,11)
C           BEGIN BLOCK
C (0,12)
            ZMH = HMIX(I,J)
C (0,13)
            USTAR = USTR(I,J)
C (0,14)
            TSTAR = TSTR(I,J)
C (0,15)
            TSTAB = ABS(TSTAR)
C (0,16)
C
C       CORRECT THE MONIN-OBUKHOV LENGTH
C
CGAO            OB=OBUK(I,J)
            DL = MAX(USTAR*USTAR*TAVR(I,J)/(3.4335D0*TSTAB), 5.D0)
C (0,17)
            OBUK(I,J) = DL*TSTAR/TSTAB
C (0,18)
            L = L+1
C (0,19)
            K = 1
C (0,20)
C           BEGIN UNSTRUCTURED
99981       CONTINUE
C (1,1)
C
C     FIND THE MIXING HEIGHT LEVEL K
C
C     DO loop 10 with exit had to be desugared
            IF (K.GT.NZ) GOTO 20
C (5,1)
            KLEV = K-1
C (3,1)
            IF (ZET(K).GT.ZMH) GOTO 20
C (4,1)
C           BEGIN BLOCK
C (4,2)
10          CONTINUE
C (4,3)
            K = K+1
C           END BLOCK
            GOTO 99981
C (2,1)
C
C     INTERPOLATE  WIND AND TEMPERATURES AT THE MIXING HEIGHT LEVEL
C
20          CONTINUE
C           END UNSTRUCTURED
C (0,21)
            DRATIO = (ZMH-ZET(KLEV))/(ZET(KLEV+1)-ZET(KLEV))
C (0,22)
C  ** U COMPONENT **
            U2 = UX(I,J,KLEV+1)+UM(KLEV+1)
C (0,23)
            U1 = UX(I,J,KLEV)+UM(KLEV)
C (0,24)
            U = U1+(U2-U1)*DRATIO
C (0,25)
C  ** V COMPONENT **
            V2 = VY(I,J,KLEV+1)+VM(KLEV+1)
C (0,26)
            V1 = VY(I,J,KLEV)+VM(KLEV)
C (0,27)
            V = V1+(V2-V1)*DRATIO
C (0,28)
            IF (NY.EQ.1) THEN
C (0,29)
               V = 0.0D0
            ELSE
C (0,30)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,31)
C  ** W COMPONENT **
            W2 = WZ(I,J,KLEV+1)
C (0,32)
            W1 = WZ(I,J,KLEV)
C (0,33)
            W = W1+(W2-W1)*DRATIO
C (0,34)
C  ** POTENTIAL TEMPERATURE **
            T2 = POTT(I,J,KLEV+1)+TM(KLEV+1)
C (0,35)
            T1 = POTT(I,J,KLEV)+TM(KLEV)
C (0,36)
            T = T1+(T2-T1)*DRATIO
C (0,37)
C  ** LAPSE RATE ABOVE THE INVERSION DT+/DZ **
            DTPL = (TM(NZ)-T)/(ZET(NZ)-ZMH)
C (0,38)
C  ** SURFACE TEMPERATURE  **
            TS = TM(1)+POTT(I,J,1)
C (0,39)
C
C           CALCULATE FORCING TERMS FOR THE BOUNDARY LAYER HEIGHT
C           FOR STABLE (SMEDA) AND UNSTABLE (DEARDORFF) CONDITIONS
C
            IF (DL.LT.0.) THEN
C (0,40)
C              BEGIN BLOCK
C (0,41)
               WSTAR = (-9.8D0*USTAR*TSTAR*ZMH/TS)**0.333333D0
C (0,42)
               DNUM = 2.2D0*(WSTAR**3+1.1D0*USTAR**3-3.3D0*USTAR**2*F
     &         *ZMH)
C (0,43)
               DENO = 9.8D0*ZMH*ZMH*DTPL/TS+9.D0*WSTAR*WSTAR+7.2D0*
     &         USTAR*USTAR
C (0,44)
               ENT = DNUM/DENO
C              END BLOCK
            ELSE
C (0,45)
C              BEGIN BLOCK
C (0,46)
               WSTAR = 0.0D0
C (0,47)
               ENT = 0.06D0*USTAR*USTAR*(1.D0-(3.3D0*ZMH*F/USTAR)**3)
     &         /(ZMH*F)
C              END BLOCK
            ENDIF
C (0,48)
C
C           CALCULATE THE RIGHT HAND SIDE IN DEARDORFFS RELATION
C
            DCDX(L) = -U*DCDX(L)-V*DCDY(L)+W+ENT
C (0,49)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,50)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,51)
      I_PIPS_LEAPFR_F2 = NX*NY
      I_PIPS_LEAPFR_F0 = NX*NY
CX20786 CALL DOOUTX( 786 )
CY20786 CALL DOOUTY( 786 )
C
C    MARCH IN TIME WITH LEAPFROG
C
      CALL LEAPFR(ISTEP, LOOP, DELTAT, HMIX, DCDX, STEPH)
C (0,52)
CX40166 CALL SBOUTX (166)
CY40166 CALL SBOUTY (166)
C     CALL HORSMT(NX,NY,HMIX)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *       SUBROUTINE TO INITIALIZE THE BOUNDARY LAYER HEIGHT           *
C **********************************************************************
C
      SUBROUTINE INITBL(NX,NY,ELEV,HMIX,H0)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 HMIX(NX,NY),ELEV(NX,NY)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30167 CALL SBINX (167)
CY30167 CALL SBINY (167)
CX10787 CALL DOINX( 787 )
CY10787 CALL DOINY( 787 )
!     INITIALLY: DO 20
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 10
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
            HMIX(I,J) = H0
C (0,7)
10          CONTINUE
C           END BLOCK
         ENDDO
C (0,8)
20       CONTINUE
C        END BLOCK
      ENDDO
C (0,9)
CX20788 CALL DOOUTX( 788 )
CY20788 CALL DOOUTY( 788 )
CX40168 CALL SBOUTX (168)
CY40168 CALL SBOUTY (168)
      RETURN
C     END BLOCK
      END
C
C   ********************************************************************
C   *  SUBROUTINE TO CALCULATE THE SURFACE LAYER HEIGHT AND GENERALLY  *
C   *  ALL SURFACE LAYER PARAMETERS SMOOTH THEM AND USE THEM AS INPUT  *
C   *  TO PRODUCE THE DIFFUSIVITY PROFILES FOR HEAT AND MOMENTUM (KZ)  *
C   ********************************************************************
C
      SUBROUTINE SFCPAR(U,T,ZET,NZ,Z0,USTAR,TSTAR,DL,ZMH,TSL,TMES)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 U(I_PIPS_RUN_HELP),T(I_PIPS_RUN_HELPA),ZET(I_PIPS_RUN_ZET)
C (0,1)
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
C     BEGIN BLOCK
C (0,2)
CX30169 CALL SBINX (169)
CY30169 CALL SBINY (169)
C
C     ZS IS THE SURFACE LAYER, A FRACTION OF THE BOUNDARY LAYER
C
      ZMH = MAX(ZMH, 50.D0)
C (0,3)
      ZS = MAX(TSL*ZMH, ZET(2))
C (0,4)
      Z0 = MAX(Z0, 0.00001D0)
C (0,5)
      K = 2
C (0,6)
C     BEGIN UNSTRUCTURED
99983 CONTINUE
C (1,1)
CX10789 CALL DOINX( 789 )
CY10789 CALL DOINY( 789 )
C
C     FIND THE SURFACE LAYER HEIGHT
C
C     DO loop 10 with exit had to be desugared
      IF (K.GT.NZ) GOTO 20
C (5,1)
      KLEV = K-1
C (3,1)
      IF (ZS.LE.ZET(K)) GOTO 20
C (4,1)
C     BEGIN BLOCK
C (4,2)
10    CONTINUE
C (4,3)
      K = K+1
C     END BLOCK
      GOTO 99983
C (2,1)
CX20790 CALL DOOUTX( 790 )
CY20790 CALL DOOUTY( 790 )
20    CONTINUE
C     END UNSTRUCTURED
C (0,7)
C
C     FIND MEAN QUANTITIES IN THE SURFACE LAYER ACCORDING TO DEARDORFF
C
      DZET = ZS-Z0
C (0,8)
      RATIO = (ZS/2.D0-Z0)/(ZET(KLEV+1)-Z0)
C (0,9)
      UMES = MAX(U(KLEV+1)*RATIO, 0.005D0)
C (0,10)
      TMES = T(1)+(T(KLEV+1)-T(1))*RATIO
C (0,11)
C
C     THE ANEMOMETER HEIGHT IS ZH OR IN THIS CASE THE FIRST VERTICAL
C     LEVEL ABOVE THE GROUND. IF EVEN VERTICAL LAYERS ARE USED, ZH
C     MUST NOT EXCEED 30 METERS. IN THIS CASE ASSIGN ZH=20.
C
      ZH = ZET(2)
C (0,12)
C
C     CALCULATE WIND AND TEMPERATURE AT ANEMOMETER HEIGHT
C
      UZH = MAX(ZH*U(2)/ZET(2), 0.0001D0)
C (0,13)
      TZH = ZH*T(2)/ZET(2)
C (0,14)
C   ** SURFACE TEMPERATURE **
      TS = T(1)
C (0,15)
C
C        CALCULATE THE MODEL'S LAPSE RATE AND SHEAR IN THE
C        SURFACE LAYER. THE -0.0098 IS THE DRY ADIABAT.
C        CONVERT TO DEGREES K PER 100 METERS, AND CALCULATE THE
C        STABILITY PARAMETER BETA FROM FORMULA (LLOYD)
C
      DUDZ = UMES/DZET
C (0,16)
      DTDZ = (TMES-TS)/DZET
C (0,17)
C
      DTHDZ = 100.D0*(DTDZ-0.0098D0)
C (0,18)
      IF (DTHDZ.LT.-5.D0) THEN
C (0,19)
         DTHDZ = -5.D0
      ELSE
C (0,20)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,21)
      BETA = 1.D0/((10.D0+DTHDZ)**2)+.0025D0*DUDZ
C (0,22)
      BETA = 1.D0/DSQRT(BETA)
C (0,23)
C
C     THERE IS A CORRESPONDANCE BETWEEN BETA AND THE PASQUILL
C     STABILITY CLASS (FUNCTION CLASS). THUS FROM BETA
C     CALCULATE THE MONIN-OBUKOV LENGTH THROUGH GOLDERS STABILITY
C     DIAGRAM AS A FUNCTION OF ROUGHNESS LENGTH
C
      DL = 1.D0/OVL(BETA, Z0)
C (0,24)
C
C        SURFACE LAYER CALCULATIONS FOR THE ESTIMATION OF THE
C        FRICTIONAL VELOCITY AND TURBULENT POTENTIAL TEMPERATURE
C        UNDER DIFFERENT STABILITY CONDITIONS
C
      CALL SURFAC(UZH, TZH, TS, ZH, Z0, DL, USTAR, TSTAR)
C (0,25)
CX40170 CALL SBOUTX (170)
CY40170 CALL SBOUTY (170)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *  ROUTINE THAT CALCULATES U*, AND T* IN THE  SURFACE LAYER.         *
C **********************************************************************
C
      SUBROUTINE  SURFAC(UZH,TZH,TS,ZH,Z0,DL,USTAR,TSTAR)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30171 CALL SBINX (171)
CY30171 CALL SBINY (171)
C
C        IMPORTANT ROLE PLAY THE NONDIMENSIONAL LENGTH Z/L = ZOL
C        AND THE SURFACE LAYER PARAMETERS ACCORDING TO STABILITY
C        IF (DL) L<0 UNSTABLE,  L>0 STABLE  CONDITIONS.
C
      IF (DL.LT.0.) THEN
C (0,3)
C        BEGIN BLOCK
C (0,4)
C * * *    U N S T A B L E   C A S E   * * *
         ZHMPHI = (1.D0-15.D0*ZH/DL)**.25D0
C (0,5)
         Z0MPHI = (1.D0-15.D0*Z0/DL)**.25D0
C (0,6)
         Z0TPHI = (1.D0-9.D0*Z0/DL)**0.5D0
C (0,7)
         ZHTPHI = (1.D0-9.D0*ZH/DL)**0.5D0
C (0,8)
         P0 = MAX(0.00001D0, (ZHMPHI+1.D0)*(Z0MPHI-1.D0))
C (0,9)
         Q0 = MAX(0.00001D0, (ZHTPHI+1.D0)*(Z0TPHI-1.D0))
C (0,10)
         P = (ZHMPHI-1.D0)*(Z0MPHI+1.D0)/P0
C (0,11)
         Q = (ZHTPHI-1.D0)*(Z0TPHI+1.D0)/Q0
C (0,12)
         USTAR = 0.35D0*UZH/(DLOG(P)+2.D0*(DATAN(ZHMPHI)-DATAN(Z0MPHI
     &   )))
C (0,13)
         TSTAR = 0.35D0*(TZH-TS)/(0.74D0*DLOG(Q))
C
C * * *   S T A B L E    O R   N E U T R A L   C A S E       * * *
C
C        END BLOCK
      ELSE
C (0,15)
C        BEGIN BLOCK
C (0,16)
         USTAR = 0.35D0*UZH/(DLOG(ZH/Z0)+4.7D0*(ZH-Z0)/DL)
C (0,17)
         TSTAR = 0.35D0*(TZH-TS)/(0.74D0*DLOG(ZH/Z0)+4.7D0*(ZH-Z0)/DL
     &   )
C        END BLOCK
      ENDIF
C (0,18)
CX40172 CALL SBOUTX (172)
CY40172 CALL SBOUTY (172)
C
      RETURN
C     END BLOCK
      END
C
C  *********************************************************************
C  *  THIS ROUTINE CALCULATES THE EDDY DIFFUSIVITY COEFFICIENTS        *
C  *  FOR HEAT AND MOMENTUM IN THE SURFACE LAYER AND THE TOP OF THE    *
C  *  SURFACE LAYERS, AND MATCHES THE DIFFUSIVITIES FROM THE TOP OF    *
C  *  SURFACE LAYERS TO THE TOP OF THE BOUNDARY LAYER (EKMAN LAYER)    *
C  *********************************************************************
C
      SUBROUTINE BLSOLV(ZET,NZ,Z0,USTAR,DL,DZ,DKZM,DKZH,ZMH,TSL)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 ZET(I_PIPS_RUN_ZET),DKZM(I_PIPS_RUN_HELP),DKZH(I_PIPS_RUN_H
     x ELPA)
C (0,1)
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_HELP
      COMMON /PIPS_RUN_HELP/ I_PIPS_RUN_HELP
      INTEGER*8 I_PIPS_RUN_HELPA
      COMMON /PIPS_RUN_HELPA/ I_PIPS_RUN_HELPA
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
C     BEGIN BLOCK
C (0,2)
CX30173 CALL SBINX (173)
CY30173 CALL SBINY (173)
C
C     MINIMUM VALUES FOR THE DIFFUSIVITIES AT THE MODEL SURFACE
C
      DKZM(1) = DZ
C (0,3)
      DKZH(1) = DZ
C (0,4)
      K = 2
C (0,5)
C     BEGIN UNSTRUCTURED
99993 CONTINUE
C (1,1)
CX10791 CALL DOINX( 791 )
CY10791 CALL DOINY( 791 )
C
C     DO loop 10 with exit had to be desugared
      IF (K.GT.NZ) GOTO 20
C (5,1)
C     BEGIN BLOCK
C (5,2)
C
C        SURFACE LAYER KM AND KH CALCULATIONS
C
      KE = K
C (5,3)
      CALL SRFLAY(ZET, DKZM(K), DKZH(K), NZ, K, ZMH, DL, Z0, USTAR, 
     &DZ, TSL, ZS, DKSM, DKZSM, DKSH, DKZSH, KLEV)
C     END BLOCK
C (3,1)
      IF (DKSM.GT.0.) GOTO 20
C (4,1)
C     BEGIN BLOCK
C (4,2)
10    CONTINUE
C (4,3)
      K = K+1
C     END BLOCK
      GOTO 99993
C (2,1)
CX20792 CALL DOOUTX( 792 )
CY20792 CALL DOOUTY( 792 )
C
C        EKMAN LAYER KM AND KH CALCULATIONS
C
20    CONTINUE
C     END UNSTRUCTURED
C (0,6)
      KE = KE+KLEV
C (0,7)
CX10793 CALL DOINX( 793 )
CY10793 CALL DOINY( 793 )
!     INITIALLY: DO 30
      DO K = KE, NZ
C (0,8)
C        BEGIN BLOCK
C (0,9)
         CALL EKMLAY(ZET(K), DKZM(K), DKZH(K), ZMH, DZ, ZS, DKSM, 
     &   DKZSM, DKSH, DKZSH)
C (0,10)
30       CONTINUE
C        END BLOCK
      ENDDO
C (0,11)
      I_PIPS_SMTH_F = I_PIPS_RUN_HELP
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
CX20794 CALL DOOUTX( 794 )
CY20794 CALL DOOUTY( 794 )
C
C      SMOOTH THE DIFFUSIVITIES VERTICALLY
C
      CALL SMTH(DKZM, ZET, NZ)
C (0,12)
      I_PIPS_SMTH_F = I_PIPS_RUN_HELPA
      I_PIPS_SMTH_Z = I_PIPS_RUN_ZET
      CALL SMTH(DKZH, ZET, NZ)
C (0,13)
CX40174 CALL SBOUTX (174)
CY40174 CALL SBOUTY (174)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *  ROUTINE THAT CALCULATES DIFFUSIVITIES IN THE SURFACE LAYER.       *
C *  ALSO THE ROUTINE CALCULATES THE TOP OF THE SURFACE LAYER AND IF   *
C *  ZS>ZET IT CALCULATES K AND DK/DZ AT ZET=ZS FOR THE MATCHING COND. *
C **********************************************************************
C
      SUBROUTINE  SRFLAY(ZET,DKZM,DKZH,NZ,K,ZMH,DL,Z0,USTAR,DZ,
     *TSL,ZS,DKSM,DKZSM,DKSH,DKZSH,KL)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 ZET(I_PIPS_RUN_ZET)
C (0,1)
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
C     BEGIN BLOCK
C (0,2)
CX30175 CALL SBINX (175)
CY30175 CALL SBINY (175)
C
C        IMPORTANT ROLE PLAY THE NONDIMENSIONAL LENGTH Z/L = ZOL
C        AND THE SURFACE LAYER PARAMETERS ACCORDING TO STABILITY
C        IF (DL) L<0 UNSTABLE,  L>0 STABLE  PROFILES.
C
      DKSM = -1.0D0
C (0,3)
      KL = 1
C (0,4)
      DKZSM = 0.0D0
C (0,5)
      ZOL = ZET(K)/DL
C (0,6)
      ZS = MAX(TSL*ZMH, ZET(2))
C (0,7)
      IF (DL.LT.0.D0) THEN
C (0,8)
C
C * * *    U N S T A B L E   P R O F I L E   * * *
C
C     IF THE TOP ZS OF THE SURFACE LAYER > Z THEN CALCULATE
C     THE MATCHING CONDITIONS AND SET FLAG DKSM><0
C
         IF (ZOL.LT.-5.D0) THEN
C (0,9)
C           BEGIN BLOCK
C (0,10)
C
C * * *   W E A K L Y  U N S T A B L E  * * *
C
C         K=0.35, 0.078 AN EMPIRICAL CONSTANT, THE QUBIC ROOT
C         OF THEIR PRODUCT=0.6064, 2.162 ANOTHER CONSTANT,PROD3=1.835
C         BOTH PRODUCTS MULTIPLIED BU 4/3 TO YIELD THE DERIVATIVES
C
            DKZM = 0.6064D0*USTAR*ZET(K)*ABS(ZOL)**0.3333D0
C (0,11)
            DKZH = 1.835D0*USTAR*ZET(K)*ABS(ZOL)**0.3333D0
C (0,12)
            IF (ZS.LT.ZET(K)) THEN
C (0,13)
C              BEGIN BLOCK
C (0,14)
               DKSM = 0.6064D0*USTAR*ZS*ABS(ZS/DL)**0.3333D0
C (0,15)
               DKSH = 1.835D0*USTAR*ZS*ABS(ZS/DL)**0.3333D0
C (0,16)
               DKZSM = 0.8085D0*USTAR*ABS(-ZS/DL)**0.3333D0
C (0,17)
               DKZSH = 2.446D0*USTAR*ABS(-ZS/DL)**0.3333D0
C (0,18)
               IF (ABS(ZS-ZET(K)).GT.ABS(ZS-ZET(K-1))) THEN
C (0,19)
                  KL = 0
               ELSE
C (0,20)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C              END BLOCK
            ELSE
C (0,21)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
         ELSE
C (0,22)
C           BEGIN BLOCK
C (0,23)
C
C * * *   S T R O N G L Y  U N S T A B L E * * *
C
C         0.35 IS THE VON KARMAN CONST AND 0.74 A CONSTANT
C         DETERMINED BY BUSINGER. 0.473 IS THEIR RATIO.
C
            DKZM = .35D0*USTAR*ZET(K)*(1.D0-15.D0*ZOL)**0.25D0
C (0,24)
            DKZH = .473D0*USTAR*ZET(K)*(1.D0-9.D0*ZOL)**0.5D0
C (0,25)
            IF (ZS.LT.ZET(K)) THEN
C (0,26)
C              BEGIN BLOCK
C (0,27)
               DKSM = .35D0*USTAR*ZS*(1.D0-15.D0*ZS/DL)**.25D0
C (0,28)
               DKSH = .473D0*USTAR*ZS*(1.D0-9.D0*ZS/DL)**.5D0
C (0,29)
               DKZSM = .35D0*USTAR*(1.D0-18.75D0*ZS/DL)/((1.D0-15.D0*
     &         ZS/DL)**.75D0)
C (0,30)
               DKZSH = .473D0*USTAR*(1.D0-13.5D0*ZS/DL)/((1.D0-9.D0*
     &         ZS/DL)**.5D0)
C (0,31)
               IF (ABS(ZS-ZET(K)).GT.ABS(ZS-ZET(K-1))) THEN
C (0,32)
                  KL = 0
               ELSE
C (0,33)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C              END BLOCK
            ELSE
C (0,34)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
         ENDIF
      ELSE
C (0,35)
C        BEGIN BLOCK
C (0,36)
C
C * * *   S T A B L E    P R O F I L E     * * *
C
         DKZM = .35D0*USTAR*ZET(K)/(1.D0+4.7D0*ZOL)
C (0,37)
         DKZH = .35D0*USTAR*ZET(K)/(0.74D0+4.7D0*ZOL)
C (0,38)
         IF (ZS.LT.ZET(K)) THEN
C (0,39)
C           BEGIN BLOCK
C (0,40)
            DKSM = .35D0*USTAR*ZS/(1.D0+4.7D0*ZS/DL)
C (0,41)
            DKSH = .35D0*USTAR*ZS/(0.74D0+4.7D0*ZS/DL)
C (0,42)
            DKZSM = .35D0*USTAR/((1.D0+4.7D0*ZS/DL)**2)
C (0,43)
            DKZSH = .35D0*USTAR/((0.74D0+4.7D0*ZS/DL)**2)
C (0,44)
            IF (ABS(ZS-ZET(K)).GT.ABS(ZS-ZET(K-1))) THEN
C (0,45)
               KL = 0
            ELSE
C (0,46)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
         ELSE
C (0,47)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C        END BLOCK
      ENDIF
C (0,48)
      DKZM = MAX(DKZM, DZ)
C (0,49)
      DKZH = MAX(DKZH, DZ)
C (0,50)
CX40176 CALL SBOUTX (176)
CY40176 CALL SBOUTY (176)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *  THIS SUBROUTINE DETERMINES THE VALUES OF KZM AND KZH IN THE EKMAN *
C *  LAYER    IN THE MANNER SUGGESTED BY O'BRIEN(1970).                *
C **********************************************************************
C
      SUBROUTINE EKMLAY(ZET,DKZM,DKZH,ZMH,DZ,ZS,DKSM,DKZSM,DKSH,DKZSH)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30177 CALL SBINX (177)
CY30177 CALL SBINY (177)
C
      DKE = DZ
C (0,3)
      ZE = ZMH
C (0,4)
      DELZ = ZET-ZE
C (0,5)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (DELZ.GT.0.D0) GOTO 99992
C (4,1)
C     BEGIN BLOCK
C (4,2)
      DELZ = DELZ*DELZ
C (4,3)
      DZES = ZE-ZS
C (4,4)
      DKSMKE = DKSM-DKE
C (4,5)
      DKSHKE = DKSH-DKE
C (4,6)
C
C        O'BRIEN'S FORMULATION
C
      DKZM = DKE+DELZ/(DZES**2.D0)*(DKSMKE+(ZET-ZS)*(DKZSM+2.D0*
     &DKSMKE/DZES))
C (4,7)
      DKZM = MAX(DKZM, DZ)
C (4,8)
      DKZH = DKE+DELZ/(DZES**2.D0)*(DKSHKE+(ZET-ZS)*(DKZSH+2.D0*
     &DKSHKE/DZES))
C (4,9)
      DKZH = MAX(DKZH, DZ)
CX40178 CALL SBOUTX (178)
CY40178 CALL SBOUTY (178)
C
C     END BLOCK
      RETURN
99992 CONTINUE
C (2,1)
C     BEGIN BLOCK
C (2,2)
      DKZM = DZ
C (2,3)
      DKZH = DZ
CX40178 CALL SBOUTX (178)
CY40178 CALL SBOUTY (178)
C     END BLOCK
C (3,1)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C **********************************************************************
C *        BOUNDARY LAYER SET FOR THE MEAN WIND AND TEMPERATURE        *
C **********************************************************************
C
      SUBROUTINE DKZMN(POTT,WM,ZET,DKZ,DZMIN,Z0,USTAR,DL,KLAS,ZMH,F,NZ)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION DKZ(I_PIPS_RUN_DKM),POTT(I_PIPS_RUN_TM),ZET(I_PIPS_RUN_Z
     x ET)
      COMPLEX*16 WM(I_PIPS_DKZMN_WM)
C (0,1)
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_RUN_DCDX
      COMMON /PIPS_RUN_DCDX/ I_PIPS_RUN_DCDX
      INTEGER*8 I_PIPS_DKZMN_WM
      COMMON /PIPS_DKZMN_WM/ I_PIPS_DKZMN_WM
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_BLM_POTT
      COMMON /PIPS_BLM_POTT/ I_PIPS_BLM_POTT
      INTEGER*8 I_PIPS_BLM_ZET
      COMMON /PIPS_BLM_ZET/ I_PIPS_BLM_ZET
      INTEGER*8 I_PIPS_BLM_DKZ
      COMMON /PIPS_BLM_DKZ/ I_PIPS_BLM_DKZ
C     BEGIN BLOCK
C (0,2)
CX30179 CALL SBINX (179)
CY30179 CALL SBINY (179)
      U = ABS(WM(2))
C (0,3)
      I_PIPS_BLM_POTT = I_PIPS_RUN_TM
      I_PIPS_BLM_ZET = I_PIPS_RUN_ZET
      I_PIPS_BLM_DKZ = I_PIPS_RUN_DKM
      CALL BLM(U, POTT, ZET, NZ, Z0, USTAR, DL, DZMIN, DKZ, KLAS, ZMH
     &, F)
C (0,4)
CX40180 CALL SBOUTX (180)
CY40180 CALL SBOUTY (180)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *    ANOTHER BOUNDARY LAYER SOLVER FOR THE   WIND AND TEMPERATURE    *
C *    U,T ARE UTILITY VECTORS FOR DATA MANIPULATIONS. (HELP,HELPA)    *
C *    POTT,UX,VY ARE THE PRTURBATION TEMPERATURE AND WINDS, ZET IS    *
C *    THE GEOMETRIC HEIGHT, DKZ IS THE PERTURBATION EDDY DIFFUSIVITY  *
C *    DZMIN THE MINIMUM DIFFUSIVITY SPECIFIED IN THE DATA, Z0 IS THE  *
C *    TERRAIN ROUGHNESS, ELEV IS THE TOPOGRAPHY, NX,NY,NZ ARE THE     *
C *    DOMAIN GRID POINTS HMIX IS THE MIXING HEIGHT HBL IS THE HEIGHT  *
C *    OF THE BOUNDARY LAYER, OBUK IS THE MONIN OBUKOV LENGTH, USTR IS *
C *    FRICTIONAL VELOCITY AND  TAVR IS THE GOLDER STABILITY REGIME    *
C *    THE MIXING HEIGHTS HERE ARE CALCULATED DIAGNOSTICALLY           *
C **********************************************************************
C
      SUBROUTINE DKZP(U,T,TM,UM,VM,POTT,UX,VY,ZET,DKZ,DZMIN,
     *Z0,ELEV,NX,NY,NZ,HMIX,TAVR,OBUK,USTR,VDEP,NSMT,F,DLM,AN,BN,CN)
C
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      DIMENSION ZET(I_PIPS_DKZP_ZET),U(I_PIPS_DKZP_U),Z0(NX,NY),ELEV(NX,
     x NY),HMIX(NX,NY),TM(I_PIPS_DKZP_TM),
     *OBUK(NX,NY),USTR(NX,NY),VDEP(NX,NY),TAVR(NX,NY),VM(I_PIPS_DKZP_VM)
     x ,UM(I_PIPS_DKZP_UM),
     *UX(NX,NY,NZ),VY(NX,NY,NZ),POTT(NX,NY,NZ),DKZ(NX,NY,NZ),T(I_PIPS_DK
     x ZP_T),
     *AN(I_PIPS_DKZP_AN),BN(I_PIPS_DKZP_BN),CN(I_PIPS_DKZP_CN)
C (0,1)
      INTEGER*8 I_PIPS_DKZP_U
      COMMON /PIPS_DKZP_U/ I_PIPS_DKZP_U
      INTEGER*8 I_PIPS_DKZP_T
      COMMON /PIPS_DKZP_T/ I_PIPS_DKZP_T
      INTEGER*8 I_PIPS_DKZP_TM
      COMMON /PIPS_DKZP_TM/ I_PIPS_DKZP_TM
      INTEGER*8 I_PIPS_DKZP_UM
      COMMON /PIPS_DKZP_UM/ I_PIPS_DKZP_UM
      INTEGER*8 I_PIPS_DKZP_VM
      COMMON /PIPS_DKZP_VM/ I_PIPS_DKZP_VM
      INTEGER*8 I_PIPS_DKZP_ZET
      COMMON /PIPS_DKZP_ZET/ I_PIPS_DKZP_ZET
      INTEGER*8 I_PIPS_DKZP_AN
      COMMON /PIPS_DKZP_AN/ I_PIPS_DKZP_AN
      INTEGER*8 I_PIPS_DKZP_BN
      COMMON /PIPS_DKZP_BN/ I_PIPS_DKZP_BN
      INTEGER*8 I_PIPS_DKZP_CN
      COMMON /PIPS_DKZP_CN/ I_PIPS_DKZP_CN
      INTEGER*8 I_PIPS_BLM_POTT
      COMMON /PIPS_BLM_POTT/ I_PIPS_BLM_POTT
      INTEGER*8 I_PIPS_BLM_ZET
      COMMON /PIPS_BLM_ZET/ I_PIPS_BLM_ZET
      INTEGER*8 I_PIPS_BLM_DKZ
      COMMON /PIPS_BLM_DKZ/ I_PIPS_BLM_DKZ
      INTEGER*8 I_PIPS_HORIMS_HELP
      COMMON /PIPS_HORIMS_HELP/ I_PIPS_HORIMS_HELP
      INTEGER*8 I_PIPS_HORIMS_HELPA
      COMMON /PIPS_HORIMS_HELPA/ I_PIPS_HORIMS_HELPA
      INTEGER*8 I_PIPS_HORIMS_AN
      COMMON /PIPS_HORIMS_AN/ I_PIPS_HORIMS_AN
      INTEGER*8 I_PIPS_HORIMS_BN
      COMMON /PIPS_HORIMS_BN/ I_PIPS_HORIMS_BN
      INTEGER*8 I_PIPS_HORIMS_CN
      COMMON /PIPS_HORIMS_CN/ I_PIPS_HORIMS_CN
C     BEGIN BLOCK
C (0,2)
CX30181 CALL SBINX (181)
CY30181 CALL SBINY (181)
CX10795 CALL DOINX( 795 )
CY10795 CALL DOINY( 795 )
!     INITIALLY: DO 40
      DO J = 1, NY
C (0,3)
C        BEGIN BLOCK
C (0,4)
!     INITIALLY: DO 30
         DO I = 1, NX
C (0,5)
C           BEGIN BLOCK
C (0,6)
C
C           CALCULATE ROUGHNES LENGTH BY USING THE  FRICTION
C           VELOCITY ONLY FOR LAKE (ELEV<0.)
C
            ZNOT = Z0(I,J)
C (0,7)
            IF (ELEV(I,J).LT.0) THEN
C (0,8)
C              BEGIN BLOCK
C (0,9)
               USTAR = MAX(USTR(I,J), 0.005D0)
C (0,10)
               ZNOT = 3.905D-5/USTAR+1.6046D-3*USTAR**2-1.747D-4
C (0,11)
               Z0(I,J) = ZNOT
C              END BLOCK
            ELSE
C (0,12)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,13)
C
C           FILL VECTORS WITH PERTURBATION WIND AND TEMPERATURE
C
C *****   REMEMBER  K(MESO)=K(MESO+SYNOP)-K(SYNOP)
C
!     INITIALLY: DO 10
            DO K = 1, NZ
C (0,14)
C              BEGIN BLOCK
C (0,15)
               IF (I.EQ.1.OR.I.EQ.NX) THEN
C (0,16)
C                 BEGIN BLOCK
C (0,17)
                  TX = 0.5D0*POTT(I,J,K)
C (0,18)
                  WUX = 0.5D0*UX(I,J,K)
C (0,19)
                  WVX = 0.5D0*VY(I,J,K)
C                 END BLOCK
               ELSE
C (0,20)
C                 BEGIN BLOCK
C (0,21)
                  TX = 0.25D0*(POTT(I-1,J,K)+POTT(I+1,J,K))
C (0,22)
                  WUX = 0.25D0*(UX(I-1,J,K)+UX(I+1,J,K))
C (0,23)
                  WVX = 0.25D0*(VY(I-1,J,K)+VY(I+1,J,K))
C                 END BLOCK
               ENDIF
C (0,24)
               IF (J.EQ.1.OR.J.EQ.NY) THEN
C (0,25)
C                 BEGIN BLOCK
C (0,26)
                  TY = 0.5D0*POTT(I,J,K)
C (0,27)
                  WUY = 0.5D0*UX(I,J,K)
C (0,28)
                  WVY = 0.5D0*VY(I,J,K)
C                 END BLOCK
               ELSE
C (0,29)
C                 BEGIN BLOCK
C (0,30)
                  TY = 0.25D0*(POTT(I,J-1,K)+POTT(I,J+1,K))
C (0,31)
                  WUY = 0.25D0*(UX(I,J-1,K)+UX(I,J+1,K))
C (0,32)
                  WVY = 0.25D0*(VY(I,J-1,K)+VY(I,J+1,K))
C                 END BLOCK
               ENDIF
C (0,33)
C
C    ADD MEAN FIELDS AND CALCULATE TOTAL WIND
C
               XW = (UX(I,J,K)+WUX+WUY)/2.D0+UM(K)
C (0,34)
               YW = (VY(I,J,K)+WVX+WVY)/2.D0+VM(K)
C (0,35)
               U(K) = SQRT(XW*XW+YW*YW)
C (0,36)
               T(K) = (POTT(I,J,K)+TX+TY)/2.D0+TM(K)
C (0,37)
10             CONTINUE
C              END BLOCK
            ENDDO
C (0,38)
            WIND = U(2)
C (0,39)
      I_PIPS_BLM_POTT = I_PIPS_DKZP_T
      I_PIPS_BLM_ZET = I_PIPS_DKZP_ZET
      I_PIPS_BLM_DKZ = I_PIPS_DKZP_U
C
C     CALL THE BOUNDARY LAYER SOLVER
C
            CALL BLM(WIND, T, ZET, NZ, ZNOT, USTAR, DL, DZMIN, U, 
     &      KLAS, ZMH, F)
C (0,40)
C
C     DUMP VERTICAL DISTRIBUTION OF KZ
C
!     INITIALLY: DO 20
            DO K = 1, NZ
C (0,41)
C              BEGIN BLOCK
C (0,42)
               DKZ(I,J,K) = U(K)
C (0,43)
20             CONTINUE
C              END BLOCK
            ENDDO
C (0,44)
C
C           STORE DRY DEPOSITION VELOCITIES IN STABLE CONDITIONS
C
            IF (KLAS.GE.4) THEN
C (0,45)
               VDEP(I,J) = USTAR/500.D0
            ELSE
C (0,46)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,47)
            IF (KLAS.LT.4) THEN
C (0,48)
C
C           STORE DRY DEPOSITION VELOCITIES IN UNSTABLE CONDITIONS
C
               IF (KLAS.EQ.3) THEN
C (0,49)
                  VDEP(I,J) = USTAR*(1.D0+((-300)/DL)**0.6666667D0)/
     &            500.D0
               ELSE
C (0,50)
C                 VERY UNSTABLE CONDITIONS
                  VDEP(I,J) = USTAR*0.0009D0*((-ZMH)/DL)**0.6666667D0
               ENDIF
            ELSE
C (0,51)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C (0,52)
C
C           DUMP ALL HORIZONTAL BOUNDARY LAYER PERAMETERS BACK
C
            OBUK(I,J) = DL
C (0,53)
            HMIX(I,J) = ZMH
C (0,54)
            USTR(I,J) = USTAR
C (0,55)
            TAVR(I,J) = FLOAT(KLAS)
C (0,56)
30          CONTINUE
C           END BLOCK
         ENDDO
C (0,57)
40       CONTINUE
C        END BLOCK
      ENDDO
C (0,58)
CX20796 CALL DOOUTX( 796 )
CY20796 CALL DOOUTY( 796 )
      CALL SMOOTH(DKZ, NX, NY, NZ)
C (0,59)
      I_PIPS_HORIMS_HELP = I_PIPS_DKZP_U
      I_PIPS_HORIMS_HELPA = I_PIPS_DKZP_T
      I_PIPS_HORIMS_AN = I_PIPS_DKZP_AN
      I_PIPS_HORIMS_BN = I_PIPS_DKZP_BN
      I_PIPS_HORIMS_CN = I_PIPS_DKZP_CN
      CALL HORIMS(NX, NY, VDEP, DLM, U, T, AN, BN, CN)
C (0,60)
CX40182 CALL SBOUTX (182)
CY40182 CALL SBOUTY (182)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *         B O U N D A R Y    L A Y E R    S O L V E R                *
C *    THIS ROUTINE IS A BOUNDARY LAYER SOLVER USING THE K-DIFFUSIVITY *
C *    THEORY.  GIVEN THE VERTICAL WIND AND TEMPERATURE DISTRIBUTION   *
C *    AND SURFACE CHARACTERISTICS, IT CALCULATES  VERTICAL            *
C *    DISTRIBUTION OF THE EDDY  DIFFUSSIVITY COEFFICIENTS   KZ (DKZ)  *
C *    DZ=MINIMUM OF EDDY DIFFUSIVITY (INPUT) , KLAS=STABILITY CLASS   *
C *    (OUTPUT), Z0=ROUGHNESS LENGTH (INPUT/OUTPUT), ZET U AND POTT    *
C *    (INPUTS) HEIGHT Z(M), WIND (M/S) AND  TEMPERATURE PROFILES      *
C *    RESPECTIVELY, H=MIXING HEIGHT(M), USTAR= FRICTION VELOCITY      *
C *    AND MONIN-OBUKHOV LENGTH DL (M) (OUTPUTS) (F=CORIOLIS=10E-4)    *
C **********************************************************************
C
      SUBROUTINE BLM(U,POTT,ZET,NZ,Z0,USTAR,DL,DZ,DKZ,KLAS,ZMH,F)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 POTT(I_PIPS_BLM_POTT),ZET(I_PIPS_BLM_ZET),DKZ(I_PIPS_BLM_DK
     x Z)
C (0,1)
      INTEGER*8 I_PIPS_RUN_TM
      COMMON /PIPS_RUN_TM/ I_PIPS_RUN_TM
      INTEGER*8 I_PIPS_DKZP_T
      COMMON /PIPS_DKZP_T/ I_PIPS_DKZP_T
      INTEGER*8 I_PIPS_BLM_POTT
      COMMON /PIPS_BLM_POTT/ I_PIPS_BLM_POTT
      INTEGER*8 I_PIPS_RUN_ZET
      COMMON /PIPS_RUN_ZET/ I_PIPS_RUN_ZET
      INTEGER*8 I_PIPS_DKZP_ZET
      COMMON /PIPS_DKZP_ZET/ I_PIPS_DKZP_ZET
      INTEGER*8 I_PIPS_BLM_ZET
      COMMON /PIPS_BLM_ZET/ I_PIPS_BLM_ZET
      INTEGER*8 I_PIPS_RUN_DKM
      COMMON /PIPS_RUN_DKM/ I_PIPS_RUN_DKM
      INTEGER*8 I_PIPS_DKZP_U
      COMMON /PIPS_DKZP_U/ I_PIPS_DKZP_U
      INTEGER*8 I_PIPS_BLM_DKZ
      COMMON /PIPS_BLM_DKZ/ I_PIPS_BLM_DKZ
      INTEGER*8 I_PIPS_SMTH_F
      COMMON /PIPS_SMTH_F/ I_PIPS_SMTH_F
      INTEGER*8 I_PIPS_SMTH_Z
      COMMON /PIPS_SMTH_Z/ I_PIPS_SMTH_Z
C     BEGIN BLOCK
C (0,2)
CX30183 CALL SBINX (183)
CY30183 CALL SBINY (183)
C
C      THE NEUTRAL CASE IS ACCOMONDATED BY DEFINING DL=-1.E5
C
      DL = -1.D5
C (0,3)
      Z0 = MAX(Z0, 0.00001D0)
C (0,4)
C
C    WIND AT ANEMOMETER HEIGHT ZH, (10 M  FROM THE GROUND.)
C
      H = 0.D0
C (0,5)
      ZH = 10.D0
C (0,6)
      UZ0 = 0.D0
C (0,7)
      UZ1 = 0.D0
C (0,8)
      UMES = ZH*U/ZET(2)
C (0,9)
      UMES = MAX(UMES, 0.05D0)
C (0,10)
      DKZ(1) = DZ
C (0,11)
      K = 2
C (0,12)
C     BEGIN UNSTRUCTURED
99994 CONTINUE
C (1,1)
CX10797 CALL DOINX( 797 )
CY10797 CALL DOINY( 797 )
C
C     DO loop 30 with exit had to be desugared
      IF (K.GT.NZ) GOTO 40
C (12,1)
C     BEGIN BLOCK
C (12,2)
      IF (K.EQ.2) THEN
C (12,3)
C        BEGIN BLOCK
C (12,4)
         DZET = ZET(K)-Z0
C (12,5)
         DUDZ = U/DZET
C        END BLOCK
      ELSE
C (12,6)
C        BEGIN BLOCK
C (12,7)
         DZET = ZET(K)-ZET(K-1)
C (12,8)
         UZ1 = UMES*DLOG(ZET(K)/Z0)/DLOG(ZH/Z0)
C (12,9)
         DUDZ = ABS(UZ1-UZ0)/DZET
C        END BLOCK
      ENDIF
C (12,10)
C
C        CALCULATE THE MODEL'S LAPSE RATE AND SHEAR IN THE
C        SURFACE LAYER. THE -0.0098 IS THE DRY ADIABAT.
C        CONVERT TO K/100M
C        UZZ IS A NEUTRAL ESTIMATE OF THE WIND SPEED WITH HEIGHT
C
      DTDZ = 100.D0*((POTT(K)-POTT(K-1))/DZET-0.0098D0)
C (12,11)
      IF (DTDZ.LT.-5.D0) THEN
C (12,12)
         DTDZ = -5.D0
      ELSE
C (12,13)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (12,14)
C
C        SINCE DUDZ IS THE SHEAR IN UNKOWN STABILITY CONDITIONS USE
C        SUCESSIVE CORECTIONS (LCOR<10) TO OBTAIN THE CORRECT
C        MONIN-OBUKHOV LENGTH WHICH CORRESPONDS TO A STABILITY
C        CORRECTED SHEAR DUDZ.
C        DL IS THEN CALCULATED FROM THE STABILITY PARAMETER BETA
C
      DUMB = DUDZ
C (12,15)
      LCOR = 1
C     END BLOCK
99995 CONTINUE
C (6,1)
C     DO loop 10 with exit had to be desugared
      IF (LCOR.GT.10) GOTO 20
C (7,1)
C     BEGIN BLOCK
C (7,2)
      DLN = DL
C (7,3)
      BETA = 1.D0/((10.D0+DTDZ)**2)+.0025D0*DUDZ
C (7,4)
      BETA = 1.D0/DSQRT(BETA)
C (7,5)
      DL = 1.D0/OVL(BETA, Z0)
C (7,6)
      ZOL = ZET(K)/DL
C     END BLOCK
C (8,1)
C
C        IF IN FIRST LAYER THEN NO NEED TO CORRECT SHEAR PHI(Z/L)
C
      IF (K.EQ.2) GOTO 20
C (9,1)
C
C        MONIN-OBUKHOV LENGTH CONVERGENCE CRITERION
C
      TOL = ABS((DLN-DL)/DL)
C (10,1)
      IF (TOL.LE.0.01) GOTO 20
C (11,1)
C     BEGIN BLOCK
C (11,2)
      IF (DL.LT.0.D0) THEN
C (11,3)
         DUDZ = DUMB/((1.D0-15.D0*ZOL)**0.25D0)
      ELSE
C (11,4)
         DUDZ = DUMB*(1.D0+4.7D0*ZOL)
      ENDIF
C (11,5)
10    CONTINUE
C (11,6)
      LCOR = LCOR+1
C     END BLOCK
      GOTO 99995
C (5,1)
C     BEGIN BLOCK
C (5,2)
CX20798 CALL DOOUTX( 798 )
CY20798 CALL DOOUTY( 798 )
C
C        FIND STABILITY CLASS IN THE GOLDER DIAGRAM
C
20    CONTINUE
C (5,3)
      UZ0 = UZ1
C (5,4)
      KLAS = KLASS(BETA)
C (5,5)
C
C        SURFACE LAYER CALCULATIONS
C
      KE = K
C (5,6)
      CALL SRFCLR(POTT, ZET, DKZ(K), NZ, K, ZMH, DL, ZH, Z0, USTAR, 
     &UMES, DZ, ZS, DKS, DKZS, KLEV, H, F)
C     END BLOCK
C (3,1)
      IF (DKS.GT.0.) GOTO 40
C (4,1)
C     BEGIN BLOCK
C (4,2)
30    CONTINUE
C (4,3)
      K = K+1
C     END BLOCK
      GOTO 99994
C (2,1)
C
C        EKMAN LAYER CALCULATIONS
C
40    CONTINUE
C     END UNSTRUCTURED
C (0,13)
      KE = KE+KLEV
C (0,14)
CX10799 CALL DOINX( 799 )
CY10799 CALL DOINY( 799 )
!     INITIALLY: DO 50
      DO K = KE, NZ
C (0,15)
C        BEGIN BLOCK
C (0,16)
         CALL EKMNLR(ZET(K), DKZ(K), ZMH, DZ, ZS, DKS, DKZS)
C (0,17)
50       CONTINUE
C        END BLOCK
      ENDDO
C (0,18)
      I_PIPS_SMTH_F = I_PIPS_BLM_DKZ
      I_PIPS_SMTH_Z = I_PIPS_BLM_ZET
CX20800 CALL DOOUTX( 800 )
CY20800 CALL DOOUTY( 800 )
C
C      SMOOTH THE DIFFUSIVITIES
C
      CALL SMTH(DKZ, ZET, NZ)
C (0,19)
CX40184 CALL SBOUTX (184)
CY40184 CALL SBOUTY (184)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *     ROUTINE TO CALCULATE THE TURBOULENT MIXING HEIGHT FROM THE     *
C *     VERTICAL DISTRIBUTION OF THE POTENTIAL TEMPERATURE             *
C *     H, CONVECTIVELY INDUCED MIXING HEIGHT, (OUTPUT)                *
C *     ZHTMIX , MECHANICALLY INDUCED MIXING HEIGHT (INPUT)            *
C *     POTT(*) IS POTENTIAL TEMPERATURE, ZET(*) IS, HEIGHT (INPUTS)   *
C **********************************************************************
C
      SUBROUTINE MIXHGT(POTT,ZET,NZ,ZMH,H)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)

      REAL*8 POTT(I_PIPS_BLM_POTT),ZET(I_PIPS_BLM_ZET)
C (0,1)
      INTEGER*8 I_PIPS_BLM_POTT
      COMMON /PIPS_BLM_POTT/ I_PIPS_BLM_POTT
      INTEGER*8 I_PIPS_BLM_ZET
      COMMON /PIPS_BLM_ZET/ I_PIPS_BLM_ZET
C     BEGIN BLOCK
C (0,2)
CX30185 CALL SBINX (185)
CY30185 CALL SBINY (185)
C
C     COMPUTE THE COVECTIVE MIXING HEIGHT IF THERE IS ANY
C     FIRST FIND THE SURFACE BASED INVERSION
C
      KTOP = 1
C (0,3)
      K = 2
C (0,4)
C     BEGIN UNSTRUCTURED
99989 CONTINUE
C (1,1)
CX10801 CALL DOINX( 801 )
CY10801 CALL DOINY( 801 )
C     DO loop 20 with exit had to be desugared
      IF (K.GT.NZ) GOTO 30
C (15,1)
      DT = POTT(K)-POTT(K-1)
C (13,1)
      IF (DT.LE.0) GOTO 30
C (14,1)
C     BEGIN BLOCK
C (14,2)
10    KTOP = K
C (14,3)
20    CONTINUE
C (14,4)
      K = K+1
C     END BLOCK
      GOTO 99989
C (2,1)
CX20802 CALL DOOUTX( 802 )
CY20802 CALL DOOUTY( 802 )
C
30    IF (ZET(KTOP).GT.ZMH) GOTO 99988
C (12,1)
C     BEGIN BLOCK
C (12,2)
C
C    FIND THE HEIGHT AT WHICH A DRY ADIABAT FROM THE HEIGHT ZET(KTOP)
C    CROSSES  THE MODEL'S LAPSE RATE. ASSIGN THIS HEIGHT AS THE
C    MIXING HEIGHT H IF IT IS GREATER THAN ZMH.
C
      ITS = 0
C (12,3)
      IF (KTOP.EQ.NZ) THEN
C (12,4)
         ITS = NZ
      ELSE
C (12,5)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (12,6)
      KK = KTOP+1
C (12,7)
      K = KK
C     END BLOCK
99986 CONTINUE
C (8,1)
CX10803 CALL DOINX( 803 )
CY10803 CALL DOINY( 803 )
C     DO loop 50 with exit had to be desugared
      IF (K.GT.NZ) GOTO 60
C (9,1)
C     BEGIN BLOCK
C (9,2)
      KKTOP = K
C (9,3)
      DT = POTT(K)-POTT(KTOP)
C     END BLOCK
C (10,1)
      IF (DT.LE.0) GOTO 40
C (6,1)
CX20804 CALL DOOUTX( 804 )
CY20804 CALL DOOUTY( 804 )
C
60    IF (ITS.EQ.NZ) GOTO 99987
C (5,1)
C     BEGIN BLOCK
C (5,2)
C
C     INVERSION HEIGHT
C
      H = (ZET(KKTOP)-ZET(KKTOP-1))*(POTT(KTOP)-POTT(KKTOP-1))/(POTT(
     &KKTOP)-POTT(KKTOP-1))+ZET(KKTOP-1)
CX40186 CALL SBOUTX (186)
CY40186 CALL SBOUTY (186)
C     END BLOCK
      RETURN
99987 CONTINUE
C (7,1)
C     BEGIN BLOCK
C (7,2)
      H = 1600.D0
CX40186 CALL SBOUTX (186)
CY40186 CALL SBOUTY (186)
C     END BLOCK
      RETURN
C (11,1)
C     BEGIN BLOCK
C (11,2)
40    IF (K.EQ.NZ) THEN
C (11,3)
         ITS = NZ
      ELSE
C (11,4)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (11,5)
50    CONTINUE
C (11,6)
      K = K+1
C     END BLOCK
      GOTO 99986
99988 CONTINUE
C (3,1)
C     BEGIN BLOCK
C (3,2)
      H = MIN(ZMH, 2000.D0)
CX40186 CALL SBOUTX (186)
CY40186 CALL SBOUTY (186)
C     END BLOCK
C (4,1)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
C
C  *********************************************************************
C  *  FUNCTION THAT DETERMINES THE ATMOSPHERIC STABILLITY CLASS        *
C  *  (PASQUILL-GIFFORD) FROM THE STABILITY PARAMETER (BETA).          *
C  *********************************************************************
C
      FUNCTION KLASS(BETA)
CX30187 CALL SBINX (187)
CY30187 CALL SBINY (187)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C (0,1)
C     BEGIN BLOCK
C (0,2)
      KLASS = 6
C (0,3)
      IF (BETA.LE.11.25D0) THEN
C (0,4)
         KLASS = 5
      ELSE
C (0,5)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,6)
      IF (BETA.LE.9.50D0) THEN
C (0,7)
         KLASS = 4
      ELSE
C (0,8)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,9)
      IF (BETA.LE.8.75D0) THEN
C (0,10)
         KLASS = 3
      ELSE
C (0,11)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,12)
      IF (BETA.LE.8.00D0) THEN
C (0,13)
         KLASS = 2
      ELSE
C (0,14)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,15)
      IF (BETA.LE.7.00D0) THEN
C (0,16)
         KLASS = 1
      ELSE
C (0,17)
C        BEGIN BLOCK
C        END BLOCK
      ENDIF
C (0,18)
CX40188 CALL SBOUTX (188)
CY40188 CALL SBOUTY (188)
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *    THIS FUNCTION COMPUTES THE INVERSE OF THE MONIN-OBUKHOV LENGTH  *
C *    USING GOLDER'S TABLES OF ROUGHNESS LENGTH VERSUS THE PARAMETER  *
C *    BETA WHICH IS STABILITY DEPENDENT (DT/DZ AND DU/DZ)             *
C **********************************************************************
C
      FUNCTION OVL(BETA,Z0)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C (0,1)
C     BEGIN UNSTRUCTURED
C (1,1)
CX30189 CALL SBINX (189)
CY30189 CALL SBINY (189)
C
      IF (BETA.GT.8.0) GOTO 1
C (14,1)
C     BEGIN BLOCK
C (14,2)
      SLOPE = 0.0156D0-0.0072D0*(BETA-7.D0)
C (14,3)
      XL = 0.0540D0*(BETA-8.33D0)+SLOPE*DLOG(2.D0*Z0)
C (14,4)
      OVL = MIN(XL, -0.003D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
      RETURN
C (2,1)
1     IF (BETA.GT.8.75D0) GOTO 2
C (13,1)
C     BEGIN BLOCK
C (13,2)
      SLOPE = 0.0084D0-0.0085D0*(BETA-8.D0)
C (13,3)
      XL = 0.0213D0*(BETA-8.84D0)+SLOPE*DLOG(2.D0*Z0)
C (13,4)
      OVL = MIN(XL, -0.0001D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
      RETURN
C (3,1)
2     IF (BETA.GT.9.02D0) GOTO 3
C (12,1)
C     BEGIN BLOCK
C (12,2)
      SLOPE = 0.0019D0-0.0070D0*(BETA-8.75D0)
C (12,3)
      XL = 0.0074D0*(BETA-9.02D0)+SLOPE*DLOG(2.D0*Z0)
C (12,4)
      OVL = MIN(XL, -0.00001D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
      RETURN
C (4,1)
3     IF (BETA.GT.9.5D0) GOTO 4
C (11,1)
C     BEGIN BLOCK
C (11,2)
      SLOPE = -0.0029D0*(BETA-9.02D0)
C (11,3)
      XL = 0.0031D0*(BETA-9.02D0)+SLOPE*DLOG(2.D0*Z0)
C (11,4)
      OVL = MAX(XL, 0.00001D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
      RETURN
C (5,1)
4     IF (BETA.GT.11.25D0) GOTO 5
C (10,1)
C     BEGIN BLOCK
C (10,2)
      SLOPE = -0.0014D0-0.0040D0*(BETA-9.5D0)
C (10,3)
      XL = 0.0083D0*(BETA-9.32D0)+SLOPE*DLOG(2.D0*Z0)
C (10,4)
      OVL = MAX(XL, 0.0001D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
      RETURN
C (6,1)
5     IF (BETA.GT.12.375D0) GOTO 6
C (9,1)
C     BEGIN BLOCK
C (9,2)
      SLOPE = -0.0084D0-0.0069D0*(BETA-11.25D0)
C (9,3)
      XL = 0.0083D0*(BETA-9.32D0)+SLOPE*DLOG(2.D0*Z0)
C (9,4)
      OVL = MAX(XL, 0.004D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
      RETURN
C (7,1)
C     BEGIN BLOCK
C (7,2)
6     SLOPE = -0.0162D0-0.0069D0*(BETA-12.375D0)
C (7,3)
      XL = 0.0083D0*(BETA-9.32D0)+SLOPE*DLOG(2.D0*Z0)
C (7,4)
      OVL = MAX(XL, 0.00667D0)
CX40190 CALL SBOUTX (190)
CY40190 CALL SBOUTY (190)
C     END BLOCK
C (8,1)
      RETURN
C     END UNSTRUCTURED
      END
C
C **********************************************************************
C *  ROUTINE THAT CALCULATES DIFFUSIVITIES IN THE SURFACE LAYER.       *
C *  ALSO THE ROUTINE CALCULATES THE TOP OF THE SURFACE LAYER AND IF   *
C *  ZS>ZET IT CALCULATES K AND DK/DZ AT ZET=ZS FOR THE MATCHING COND. *
C **********************************************************************
C
      SUBROUTINE  SRFCLR(POTT,ZET,DKZ,NZ,K,ZMH,DL,ZH,Z0,USTAR,
     *UMES,DZ,ZS,DKS,DKZS,KLEV,H,F)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      REAL*8 POTT(I_PIPS_BLM_POTT),ZET(I_PIPS_BLM_ZET)
C (0,1)
      INTEGER*8 I_PIPS_BLM_POTT
      COMMON /PIPS_BLM_POTT/ I_PIPS_BLM_POTT
      INTEGER*8 I_PIPS_BLM_ZET
      COMMON /PIPS_BLM_ZET/ I_PIPS_BLM_ZET
C     BEGIN BLOCK
C (0,2)
CX30191 CALL SBINX (191)
CY30191 CALL SBINY (191)
C
C        IMPORTANT ROLE PLAY THE NONDIMENSIONAL LENGTH Z/L = ZOL
C        AND THE SURFACE LAYER PARAMETERS ACCORDING TO STABILITY
C        IF (DL) L<0 UNSTABLE,  L>0 STABLE  PROFILES.
C
      DKS = -1.0D0
C (0,3)
      KLEV = 1
C (0,4)
      DKZS = 0.0D0
C (0,5)
      ZOL = ZET(K)/DL
C (0,6)
      IF (DL.LT.0.D0) THEN
C (0,7)
C        BEGIN BLOCK
C (0,8)
C
C * * *    U N S T A B L E   P R O F I L E   * * *
C
         ZHPHI = (1.D0-15.D0*ZH/DL)**.25D0
C (0,9)
         Z0PHI = (1.D0-15.D0*Z0/DL)**.25D0
C (0,10)
         USTAR = 0.35D0*UMES/(DLOG(ZH/Z0)+DLOG((Z0PHI**2+1.D0)*(Z0PHI
     &   +1.D0)**2/((ZHPHI**2+1.D0)*(ZHPHI+1.D0)**2))+2.D0*(DATAN(
     &   ZHPHI)-DATAN(Z0PHI)))
C (0,11)
         IF (K.EQ.2) THEN
C (0,12)
C           BEGIN BLOCK
C (0,13)
            ZMH = 0.4D0*(USTAR/F)**1.5D0/DSQRT(-DL)
C (0,14)
            CALL MIXHGT(POTT, ZET, NZ, ZMH, H)
C           END BLOCK
         ELSE
C (0,15)
            ZMH = 0.4D0*USTAR/F
         ENDIF
C (0,16)
         IF (H.LT.50) THEN
C (0,17)
            CALL MIXHGT(POTT, ZET, NZ, ZMH, H)
         ELSE
C (0,18)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C (0,19)
         IF (H.LT.2000.0D0.AND.H.GT.50.0D0) THEN
C (0,20)
            ZMH = H+100.D0
         ELSE
C (0,21)
            ZMH = MIN(2000.D0, ZMH)+100.D0
         ENDIF
C (0,22)
         ZS = 0.1D0*ZMH
C (0,23)
C
C     IF THE TOP ZS OF THE SURFACE LAYER > Z THEN CALCULATE
C     THE MATCHING CONDITIONS AND SET FLAG DKS><0
C
         IF (ZOL.LT.-5.D0) THEN
C (0,24)
C           BEGIN BLOCK
C (0,25)
C
C * * *   W E A K L Y  U N S T A B L E  * * *
C
CFACTOR=1.143
            DKZ = 0.6064D0*USTAR*ZET(K)*ABS(ZOL)**0.3333D0
C (0,26)
            IF (ZS.LT.ZET(K)) THEN
C (0,27)
C              BEGIN BLOCK
C (0,28)
               DKS = 0.6064D0*USTAR*ZS*ABS(ZS/DL)**0.3333D0
C (0,29)
               DKZS = 0.8085D0*USTAR*ABS(-ZS/DL)**0.3333D0
C (0,30)
               IF (ABS(ZS-ZET(K)).GT.ABS(ZS-ZET(K-1))) THEN
C (0,31)
                  KLEV = 0
               ELSE
C (0,32)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C              END BLOCK
            ELSE
C (0,33)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
         ELSE
C (0,34)
C           BEGIN BLOCK
C (0,35)
C
C * * *   S T R O N G L Y  U N S T A B L E * * *
C
            DKZ = .35D0*USTAR*ZET(K)*(1.D0-15.D0*ZOL)**0.25D0
C (0,36)
            IF (ZS.LT.ZET(K)) THEN
C (0,37)
C              BEGIN BLOCK
C (0,38)
               DKS = .35D0*USTAR*ZS*(1.D0-15.D0*ZS/DL)**.25D0
C (0,39)
               DKZS = .35D0*USTAR*(1.D0-18.75D0*ZS/DL)/((1.D0-15.D0*
     &         ZS/DL)**.75D0)
C (0,40)
               IF (ABS(ZS-ZET(K)).GT.ABS(ZS-ZET(K-1))) THEN
C (0,41)
                  KLEV = 0
               ELSE
C (0,42)
C                 BEGIN BLOCK
C                 END BLOCK
               ENDIF
C              END BLOCK
            ELSE
C (0,43)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
         ENDIF
C        END BLOCK
      ELSE
C (0,44)
C        BEGIN BLOCK
C (0,45)
C
C * * *   S T A B L E    P R O F I L E     * * *
C
         USTAR = 0.35D0*UMES/(DLOG(ZH/Z0)+4.7D0*(ZH-Z0)/DL)
C (0,46)
         ZMH = 0.4D0*DSQRT(USTAR*DL/F)
C (0,47)
         ZHTMAX = 0.4D0*USTAR/F
C (0,48)
         ZMH = MAX(ZHTMAX, ZMH)
C (0,49)
         ZMH = MIN(2000.D0, ZMH)
C (0,50)
         DKZ = .4D0*USTAR*ZET(K)/(1.D0+4.7D0*ZOL)
C (0,51)
         ZS = 0.1D0*ZMH
C (0,52)
         IF (ZS.LT.ZET(K)) THEN
C (0,53)
C           BEGIN BLOCK
C (0,54)
            DKS = .35D0*USTAR*ZS/(1.D0+4.7D0*ZS/DL)
C (0,55)
            DKZS = .35D0*USTAR/((1.D0+4.7D0*ZS/DL)**2.D0)
C (0,56)
            IF (ABS(ZS-ZET(K)).GT.ABS(ZS-ZET(K-1))) THEN
C (0,57)
               KLEV = 0
            ELSE
C (0,58)
C              BEGIN BLOCK
C              END BLOCK
            ENDIF
C           END BLOCK
         ELSE
C (0,59)
C           BEGIN BLOCK
C           END BLOCK
         ENDIF
C        END BLOCK
      ENDIF
C (0,60)
      DKZ = MAX(DKZ, DZ)
C (0,61)
CX40192 CALL SBOUTX (192)
CY40192 CALL SBOUTY (192)
C
      RETURN
C     END BLOCK
      END
C
C **********************************************************************
C *  THIS SUBROUTINE DETERMINES THE VALUES OF KZ IN THE EKMAN LAYER    *
C *    IN THE MANNER SUGGESTED BY O'BRIEN(1970).                       *
C **********************************************************************
C
      SUBROUTINE EKMNLR(ZET,DKZ,ZMH,DZ,ZS,DKS,DKZS)
      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
C (0,1)
C     BEGIN BLOCK
C (0,2)
CX30193 CALL SBINX (193)
CY30193 CALL SBINY (193)
C
      DKE = DZ
C (0,3)
      ZE = ZMH
C (0,4)
CGAO      AKD=DKS-DKE
      DELZ = ZET-ZE
C (0,5)
C     BEGIN UNSTRUCTURED
C (1,1)
      IF (DELZ.GT.0.D0) GOTO 99991
C (4,1)
C     BEGIN BLOCK
C (4,2)
      DELZ = DELZ*DELZ
C (4,3)
      DZES = ZE-ZS
C (4,4)
      DKSKE = DKS-DKE
C (4,5)
C
C        O'BRIEN'S FORMULATION
C
      DKZ = DKE+DELZ/(DZES**2.D0)*(DKSKE+(ZET-ZS)*(DKZS+2.D0*DKSKE/
     &DZES))
C (4,6)
      DKZ = MAX(DKZ, DZ)
CX40194 CALL SBOUTX (194)
CY40194 CALL SBOUTY (194)
C
C     END BLOCK
      RETURN
99991 CONTINUE
C (2,1)
C     BEGIN BLOCK
C (2,2)
      DKZ = DZ
CX40194 CALL SBOUTX (194)
CY40194 CALL SBOUTY (194)
C     END BLOCK
C (3,1)
      RETURN
C     END UNSTRUCTURED
C     END BLOCK
      END
