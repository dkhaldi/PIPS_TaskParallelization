// Yet another rewrite of Regions/linked_regions01.c
//
// Goal: integrate references before you perform the convex hulls and
// observe all intermediate results using if(1)
//
// No overflows (MAY or MUST regions), but two simple constraints, phi1 <=99 and
// phi1+ph2<=198, are replaced by a unique constraints, 20299 phi1 + 99
// phi2 <= 2019402

// The effective vertices in (phi1,phi2) are (99,-101), (99,99) and
// (98,100). The new constraint is generated by (100,-102) and
// (98,100). This new constraint is correct as far as integer points are
// concerned. However, it is not correct for rational numbers.

// So my guess is that integer redundancy is used and that two nice
// exact integer constraints are replaced by one ugly constraint in the name of
// constraint number minimization.

// Note 1: when handling these cases by hand, it is much easier to
// integrate each reference with respect to the enclosing loops first and
// then to perform the convex hull because the integration/summation is
// trivial and because it reduces the number of dimensions. This could
// be implemented easily if region lists/sets could hold several
// occurences of each array.

// Note 2: one affine reference, i.e. a reference whose subscript
// expressions are all affine expressions of the loop indices and
// constant parameters, generate the image of the iteration polytope
// (or polyhedron if parameters are used). Thus the vertices of the
// array region are images of the vertices of the iteration polyhedron
// because of convexity. So we could get directly the generating
// system of each reference, easily when no parameters are
// involved. More thinking is needed for the parametric case.

// The vertices are (-1,100), (-1,199), (98,1) and (98, 10o) for the first reference.
// The vertices are (0,-2), (0,97), (99,-2) and (99, -101) for the second reference.
// The vertices are (1,1) and (99, 99) for the third reference.

// The vertices for the union of the three references are (0,-2),
// (-1,100), (-1,199) on one hand, (98,100), (99,99), (99,-2) amd
// (99,-101) on the other.

// The lower constraints on phi1 is 102 phi1 + phi2 >= -2 and
// phi1>=-1. they are not unified by a super rational constraint with
// large coefficient.

// The side constraints are phi1+phi2>=-2 and phi1+phi2<=198.

// The upper constraints on phi1 is phi1<=99 but it is probably
// eliminated as redundant for integer points with
// 20299phi1+99phi2<=2019402

// The union of the first two references require the constraint
// 102phi1+phi2<=10096. It is based on vertices (99,-2) and
// (98,100). It is simplified when the point (99,99) is added by the
// third reference.

// OK, a figure would make it much easier!

// This test case is the same as Regions/linked_regions01, but the
// variables used in the main loop are declared at the
// beginning of the function

#include <stdio.h>

int main()
{
  int ii, jj, x0;
  double x1;

  int N = 100;
  double A[100][100];

  if(1) {
    if(1) {
      for(ii = 1; ii <= N; ii += 1)
	for(jj = 1; jj <= N; jj += 1) {
	  if(1) {
	    x0 = ii*jj;
	    x1 = (double) N/2;
	    if (x0<x1) 
	      A[N-ii-1][ii+jj-1] = 1.0;
	  }
	}

      for(ii = 1; ii <= N; ii += 1)
	for(jj = 1; jj <= N; jj += 1) {
	  if(1) {
	    x0 = ii*jj;
	    x1 = (double) N/2;
	    if (x0<x1) 
	      A[ii-1][N-ii-jj-1] = 1.0;
	  }
	}
    }

    for(ii = 1; ii <= N; ii += 1)
      for(jj = 1; jj <= N; jj += 1) {
	if (ii==jj)
	  A[ii-1][jj-1] = 1.0;
      }
  }
  for (int i=0; i<N; i++)
    for (int j=0; j<N; j++)
      printf("%f\n", A[i][j]);
  return 0;
}
