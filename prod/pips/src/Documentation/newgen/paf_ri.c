/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * Pvecteur;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "paf_ri.h"


/* BDT
 */
bdt copy_bdt(bdt p) {
  return (bdt) gen_copy_tree((gen_chunk*) p);
}
void free_bdt(bdt p) {
  gen_free((gen_chunk*) p);
}
bdt check_bdt(bdt p) {
  return (bdt) gen_check((gen_chunk*) p, bdt_domain);
}
bool bdt_consistent_p(bdt p) {
  check_bdt(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool bdt_defined_p(bdt p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_bdt_cons(bdt p, list l) {
  return gen_typed_cons(BDT_NEWGEN_DOMAIN, p, l);
}
void bdt_assign_contents(bdt r, bdt v) {
  check_bdt(r);
  check_bdt(v);
  message_assert("defined references to domain bdt",
                 bdt_defined_p(r) && bdt_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_bdt_));
}
void bdt_non_recursive_free(bdt p) {
  // should clear up contents...
  free(p);
}
void write_bdt(FILE* f, bdt p) {
  gen_write(f, (gen_chunk*) p);
}
bdt read_bdt(FILE* f) {
  return (bdt) gen_read(f);
}
bdt make_bdt(list a) {
  return (bdt) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, bdt_domain, a);
}

/* COMMUNICATION
 */
communication copy_communication(communication p) {
  return (communication) gen_copy_tree((gen_chunk*) p);
}
void free_communication(communication p) {
  gen_free((gen_chunk*) p);
}
communication check_communication(communication p) {
  return (communication) gen_check((gen_chunk*) p, communication_domain);
}
bool communication_consistent_p(communication p) {
  check_communication(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool communication_defined_p(communication p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_communication_cons(communication p, list l) {
  return gen_typed_cons(COMMUNICATION_NEWGEN_DOMAIN, p, l);
}
void communication_assign_contents(communication r, communication v) {
  check_communication(r);
  check_communication(v);
  message_assert("defined references to domain communication",
                 communication_defined_p(r) && communication_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_communication_));
}
void communication_non_recursive_free(communication p) {
  // should clear up contents...
  free(p);
}
void write_communication(FILE* f, communication p) {
  gen_write(f, (gen_chunk*) p);
}
communication read_communication(FILE* f) {
  return (communication) gen_read(f);
}
communication make_communication(predicate a1, predicate a2, predicate a3) {
  return (communication) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, communication_domain, a1, a2, a3);
}

/* CONDITIONAL
 */
conditional copy_conditional(conditional p) {
  return (conditional) gen_copy_tree((gen_chunk*) p);
}
void free_conditional(conditional p) {
  gen_free((gen_chunk*) p);
}
conditional check_conditional(conditional p) {
  return (conditional) gen_check((gen_chunk*) p, conditional_domain);
}
bool conditional_consistent_p(conditional p) {
  check_conditional(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool conditional_defined_p(conditional p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_conditional_cons(conditional p, list l) {
  return gen_typed_cons(CONDITIONAL_NEWGEN_DOMAIN, p, l);
}
void conditional_assign_contents(conditional r, conditional v) {
  check_conditional(r);
  check_conditional(v);
  message_assert("defined references to domain conditional",
                 conditional_defined_p(r) && conditional_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_conditional_));
}
void conditional_non_recursive_free(conditional p) {
  // should clear up contents...
  free(p);
}
void write_conditional(FILE* f, conditional p) {
  gen_write(f, (gen_chunk*) p);
}
conditional read_conditional(FILE* f) {
  return (conditional) gen_read(f);
}
conditional make_conditional(predicate a1, quast a2, quast a3) {
  return (conditional) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, conditional_domain, a1, a2, a3);
}

/* DATAFLOW
 */
dataflow copy_dataflow(dataflow p) {
  return (dataflow) gen_copy_tree((gen_chunk*) p);
}
void free_dataflow(dataflow p) {
  gen_free((gen_chunk*) p);
}
dataflow check_dataflow(dataflow p) {
  return (dataflow) gen_check((gen_chunk*) p, dataflow_domain);
}
bool dataflow_consistent_p(dataflow p) {
  check_dataflow(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dataflow_defined_p(dataflow p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dataflow_cons(dataflow p, list l) {
  return gen_typed_cons(DATAFLOW_NEWGEN_DOMAIN, p, l);
}
void dataflow_assign_contents(dataflow r, dataflow v) {
  check_dataflow(r);
  check_dataflow(v);
  message_assert("defined references to domain dataflow",
                 dataflow_defined_p(r) && dataflow_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dataflow_));
}
void dataflow_non_recursive_free(dataflow p) {
  // should clear up contents...
  free(p);
}
void write_dataflow(FILE* f, dataflow p) {
  gen_write(f, (gen_chunk*) p);
}
dataflow read_dataflow(FILE* f) {
  return (dataflow) gen_read(f);
}
dataflow make_dataflow(reference a1, list a2, predicate a3, communication a4) {
  return (dataflow) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, dataflow_domain, a1, a2, a3, a4);
}

/* DFG_ARC_LABEL
 */
dfg_arc_label copy_dfg_arc_label(dfg_arc_label p) {
  return (dfg_arc_label) gen_copy_tree((gen_chunk*) p);
}
void free_dfg_arc_label(dfg_arc_label p) {
  gen_free((gen_chunk*) p);
}
dfg_arc_label check_dfg_arc_label(dfg_arc_label p) {
  return (dfg_arc_label) gen_check((gen_chunk*) p, dfg_arc_label_domain);
}
bool dfg_arc_label_consistent_p(dfg_arc_label p) {
  check_dfg_arc_label(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dfg_arc_label_defined_p(dfg_arc_label p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dfg_arc_label_cons(dfg_arc_label p, list l) {
  return gen_typed_cons(DFG_ARC_LABEL_NEWGEN_DOMAIN, p, l);
}
void dfg_arc_label_assign_contents(dfg_arc_label r, dfg_arc_label v) {
  check_dfg_arc_label(r);
  check_dfg_arc_label(v);
  message_assert("defined references to domain dfg_arc_label",
                 dfg_arc_label_defined_p(r) && dfg_arc_label_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dfg_arc_label_));
}
void dfg_arc_label_non_recursive_free(dfg_arc_label p) {
  // should clear up contents...
  free(p);
}
void write_dfg_arc_label(FILE* f, dfg_arc_label p) {
  gen_write(f, (gen_chunk*) p);
}
dfg_arc_label read_dfg_arc_label(FILE* f) {
  return (dfg_arc_label) gen_read(f);
}
dfg_arc_label make_dfg_arc_label(list a) {
  return (dfg_arc_label) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, dfg_arc_label_domain, a);
}

/* DFG_VERTEX_LABEL
 */
dfg_vertex_label copy_dfg_vertex_label(dfg_vertex_label p) {
  return (dfg_vertex_label) gen_copy_tree((gen_chunk*) p);
}
void free_dfg_vertex_label(dfg_vertex_label p) {
  gen_free((gen_chunk*) p);
}
dfg_vertex_label check_dfg_vertex_label(dfg_vertex_label p) {
  return (dfg_vertex_label) gen_check((gen_chunk*) p, dfg_vertex_label_domain);
}
bool dfg_vertex_label_consistent_p(dfg_vertex_label p) {
  check_dfg_vertex_label(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dfg_vertex_label_defined_p(dfg_vertex_label p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dfg_vertex_label_cons(dfg_vertex_label p, list l) {
  return gen_typed_cons(DFG_VERTEX_LABEL_NEWGEN_DOMAIN, p, l);
}
void dfg_vertex_label_assign_contents(dfg_vertex_label r, dfg_vertex_label v) {
  check_dfg_vertex_label(r);
  check_dfg_vertex_label(v);
  message_assert("defined references to domain dfg_vertex_label",
                 dfg_vertex_label_defined_p(r) && dfg_vertex_label_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dfg_vertex_label_));
}
void dfg_vertex_label_non_recursive_free(dfg_vertex_label p) {
  // should clear up contents...
  free(p);
}
void write_dfg_vertex_label(FILE* f, dfg_vertex_label p) {
  gen_write(f, (gen_chunk*) p);
}
dfg_vertex_label read_dfg_vertex_label(FILE* f) {
  return (dfg_vertex_label) gen_read(f);
}
dfg_vertex_label make_dfg_vertex_label(intptr_t a1, predicate a2, sccflags a3) {
  return (dfg_vertex_label) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, dfg_vertex_label_domain, a1, a2, a3);
}

/* LEAF_LABEL
 */
leaf_label copy_leaf_label(leaf_label p) {
  return (leaf_label) gen_copy_tree((gen_chunk*) p);
}
void free_leaf_label(leaf_label p) {
  gen_free((gen_chunk*) p);
}
leaf_label check_leaf_label(leaf_label p) {
  return (leaf_label) gen_check((gen_chunk*) p, leaf_label_domain);
}
bool leaf_label_consistent_p(leaf_label p) {
  check_leaf_label(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool leaf_label_defined_p(leaf_label p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_leaf_label_cons(leaf_label p, list l) {
  return gen_typed_cons(LEAF_LABEL_NEWGEN_DOMAIN, p, l);
}
void leaf_label_assign_contents(leaf_label r, leaf_label v) {
  check_leaf_label(r);
  check_leaf_label(v);
  message_assert("defined references to domain leaf_label",
                 leaf_label_defined_p(r) && leaf_label_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_leaf_label_));
}
void leaf_label_non_recursive_free(leaf_label p) {
  // should clear up contents...
  free(p);
}
void write_leaf_label(FILE* f, leaf_label p) {
  gen_write(f, (gen_chunk*) p);
}
leaf_label read_leaf_label(FILE* f) {
  return (leaf_label) gen_read(f);
}
leaf_label make_leaf_label(intptr_t a1, intptr_t a2) {
  return (leaf_label) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, leaf_label_domain, a1, a2);
}

/* LISP_EXPRESSION
 */
lisp_expression copy_lisp_expression(lisp_expression p) {
  return (lisp_expression) gen_copy_tree((gen_chunk*) p);
}
void free_lisp_expression(lisp_expression p) {
  gen_free((gen_chunk*) p);
}
lisp_expression check_lisp_expression(lisp_expression p) {
  return (lisp_expression) gen_check((gen_chunk*) p, lisp_expression_domain);
}
bool lisp_expression_consistent_p(lisp_expression p) {
  check_lisp_expression(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool lisp_expression_defined_p(lisp_expression p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_lisp_expression_cons(lisp_expression p, list l) {
  return gen_typed_cons(LISP_EXPRESSION_NEWGEN_DOMAIN, p, l);
}
void lisp_expression_assign_contents(lisp_expression r, lisp_expression v) {
  check_lisp_expression(r);
  check_lisp_expression(v);
  message_assert("defined references to domain lisp_expression",
                 lisp_expression_defined_p(r) && lisp_expression_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_lisp_expression_));
}
void lisp_expression_non_recursive_free(lisp_expression p) {
  // should clear up contents...
  free(p);
}
void write_lisp_expression(FILE* f, lisp_expression p) {
  gen_write(f, (gen_chunk*) p);
}
lisp_expression read_lisp_expression(FILE* f) {
  return (lisp_expression) gen_read(f);
}
lisp_expression make_lisp_expression(string a1, list a2) {
  return (lisp_expression) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, lisp_expression_domain, a1, a2);
}

/* PLACEMENT
 */
placement copy_placement(placement p) {
  return (placement) gen_copy_tree((gen_chunk*) p);
}
void free_placement(placement p) {
  gen_free((gen_chunk*) p);
}
placement check_placement(placement p) {
  return (placement) gen_check((gen_chunk*) p, placement_domain);
}
bool placement_consistent_p(placement p) {
  check_placement(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool placement_defined_p(placement p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_placement_cons(placement p, list l) {
  return gen_typed_cons(PLACEMENT_NEWGEN_DOMAIN, p, l);
}
void placement_assign_contents(placement r, placement v) {
  check_placement(r);
  check_placement(v);
  message_assert("defined references to domain placement",
                 placement_defined_p(r) && placement_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_placement_));
}
void placement_non_recursive_free(placement p) {
  // should clear up contents...
  free(p);
}
void write_placement(FILE* f, placement p) {
  gen_write(f, (gen_chunk*) p);
}
placement read_placement(FILE* f) {
  return (placement) gen_read(f);
}
placement make_placement(intptr_t a1, list a2) {
  return (placement) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, placement_domain, a1, a2);
}

/* PLC
 */
plc copy_plc(plc p) {
  return (plc) gen_copy_tree((gen_chunk*) p);
}
void free_plc(plc p) {
  gen_free((gen_chunk*) p);
}
plc check_plc(plc p) {
  return (plc) gen_check((gen_chunk*) p, plc_domain);
}
bool plc_consistent_p(plc p) {
  check_plc(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool plc_defined_p(plc p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_plc_cons(plc p, list l) {
  return gen_typed_cons(PLC_NEWGEN_DOMAIN, p, l);
}
void plc_assign_contents(plc r, plc v) {
  check_plc(r);
  check_plc(v);
  message_assert("defined references to domain plc",
                 plc_defined_p(r) && plc_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_plc_));
}
void plc_non_recursive_free(plc p) {
  // should clear up contents...
  free(p);
}
void write_plc(FILE* f, plc p) {
  gen_write(f, (gen_chunk*) p);
}
plc read_plc(FILE* f) {
  return (plc) gen_read(f);
}
plc make_plc(list a) {
  return (plc) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, plc_domain, a);
}

/* QUAST_LEAF
 */
quast_leaf copy_quast_leaf(quast_leaf p) {
  return (quast_leaf) gen_copy_tree((gen_chunk*) p);
}
void free_quast_leaf(quast_leaf p) {
  gen_free((gen_chunk*) p);
}
quast_leaf check_quast_leaf(quast_leaf p) {
  return (quast_leaf) gen_check((gen_chunk*) p, quast_leaf_domain);
}
bool quast_leaf_consistent_p(quast_leaf p) {
  check_quast_leaf(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool quast_leaf_defined_p(quast_leaf p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_quast_leaf_cons(quast_leaf p, list l) {
  return gen_typed_cons(QUAST_LEAF_NEWGEN_DOMAIN, p, l);
}
void quast_leaf_assign_contents(quast_leaf r, quast_leaf v) {
  check_quast_leaf(r);
  check_quast_leaf(v);
  message_assert("defined references to domain quast_leaf",
                 quast_leaf_defined_p(r) && quast_leaf_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_quast_leaf_));
}
void quast_leaf_non_recursive_free(quast_leaf p) {
  // should clear up contents...
  free(p);
}
void write_quast_leaf(FILE* f, quast_leaf p) {
  gen_write(f, (gen_chunk*) p);
}
quast_leaf read_quast_leaf(FILE* f) {
  return (quast_leaf) gen_read(f);
}
quast_leaf make_quast_leaf(list a1, leaf_label a2) {
  return (quast_leaf) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, quast_leaf_domain, a1, a2);
}

/* QUAST
 */
quast copy_quast(quast p) {
  return (quast) gen_copy_tree((gen_chunk*) p);
}
void free_quast(quast p) {
  gen_free((gen_chunk*) p);
}
quast check_quast(quast p) {
  return (quast) gen_check((gen_chunk*) p, quast_domain);
}
bool quast_consistent_p(quast p) {
  check_quast(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool quast_defined_p(quast p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_quast_cons(quast p, list l) {
  return gen_typed_cons(QUAST_NEWGEN_DOMAIN, p, l);
}
void quast_assign_contents(quast r, quast v) {
  check_quast(r);
  check_quast(v);
  message_assert("defined references to domain quast",
                 quast_defined_p(r) && quast_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_quast_));
}
void quast_non_recursive_free(quast p) {
  // should clear up contents...
  free(p);
}
void write_quast(FILE* f, quast p) {
  gen_write(f, (gen_chunk*) p);
}
quast read_quast(FILE* f) {
  return (quast) gen_read(f);
}
quast make_quast(quast_value a1, list a2) {
  return (quast) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, quast_domain, a1, a2);
}

/* QUAST_VALUE
 */
quast_value copy_quast_value(quast_value p) {
  return (quast_value) gen_copy_tree((gen_chunk*) p);
}
void free_quast_value(quast_value p) {
  gen_free((gen_chunk*) p);
}
quast_value check_quast_value(quast_value p) {
  return (quast_value) gen_check((gen_chunk*) p, quast_value_domain);
}
bool quast_value_consistent_p(quast_value p) {
  check_quast_value(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool quast_value_defined_p(quast_value p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_quast_value_cons(quast_value p, list l) {
  return gen_typed_cons(QUAST_VALUE_NEWGEN_DOMAIN, p, l);
}
void quast_value_assign_contents(quast_value r, quast_value v) {
  check_quast_value(r);
  check_quast_value(v);
  message_assert("defined references to domain quast_value",
                 quast_value_defined_p(r) && quast_value_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_quast_value_));
}
void quast_value_non_recursive_free(quast_value p) {
  // should clear up contents...
  free(p);
}
void write_quast_value(FILE* f, quast_value p) {
  gen_write(f, (gen_chunk*) p);
}
quast_value read_quast_value(FILE* f) {
  return (quast_value) gen_read(f);
}
string quast_value_tag_as_string(enum quast_value_utype tag) {
  switch (tag) {
  case is_quast_value_quast_leaf: return "quast_leaf";
  case is_quast_value_conditional: return "conditional";
  default: return string_undefined;
  }
}
quast_value make_quast_value(enum quast_value_utype tag, void * val) {
  return (quast_value) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, quast_value_domain, tag, val);
}
quast_value make_quast_value_quast_leaf(quast_leaf _field_) {
  return make_quast_value(is_quast_value_quast_leaf, (void*)(intptr_t) _field_);
}
quast_value make_quast_value_conditional(conditional _field_) {
  return make_quast_value(is_quast_value_conditional, (void*)(intptr_t) _field_);
}

/* SCHEDULE
 */
schedule copy_schedule(schedule p) {
  return (schedule) gen_copy_tree((gen_chunk*) p);
}
void free_schedule(schedule p) {
  gen_free((gen_chunk*) p);
}
schedule check_schedule(schedule p) {
  return (schedule) gen_check((gen_chunk*) p, schedule_domain);
}
bool schedule_consistent_p(schedule p) {
  check_schedule(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool schedule_defined_p(schedule p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_schedule_cons(schedule p, list l) {
  return gen_typed_cons(SCHEDULE_NEWGEN_DOMAIN, p, l);
}
void schedule_assign_contents(schedule r, schedule v) {
  check_schedule(r);
  check_schedule(v);
  message_assert("defined references to domain schedule",
                 schedule_defined_p(r) && schedule_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_schedule_));
}
void schedule_non_recursive_free(schedule p) {
  // should clear up contents...
  free(p);
}
void write_schedule(FILE* f, schedule p) {
  gen_write(f, (gen_chunk*) p);
}
schedule read_schedule(FILE* f) {
  return (schedule) gen_read(f);
}
schedule make_schedule(intptr_t a1, predicate a2, list a3) {
  return (schedule) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, schedule_domain, a1, a2, a3);
}

/* STATIC_CONTROL
 */
static_control copy_static_control(static_control p) {
  return (static_control) gen_copy_tree((gen_chunk*) p);
}
void free_static_control(static_control p) {
  gen_free((gen_chunk*) p);
}
static_control check_static_control(static_control p) {
  return (static_control) gen_check((gen_chunk*) p, static_control_domain);
}
bool static_control_consistent_p(static_control p) {
  check_static_control(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool static_control_defined_p(static_control p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_static_control_cons(static_control p, list l) {
  return gen_typed_cons(STATIC_CONTROL_NEWGEN_DOMAIN, p, l);
}
void static_control_assign_contents(static_control r, static_control v) {
  check_static_control(r);
  check_static_control(v);
  message_assert("defined references to domain static_control",
                 static_control_defined_p(r) && static_control_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_static_control_));
}
void static_control_non_recursive_free(static_control p) {
  // should clear up contents...
  free(p);
}
void write_static_control(FILE* f, static_control p) {
  gen_write(f, (gen_chunk*) p);
}
static_control read_static_control(FILE* f) {
  return (static_control) gen_read(f);
}
static_control make_static_control(bool a1, list a2, list a3, list a4) {
  return (static_control) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, static_control_domain, a1, a2, a3, a4);
}

/* VAR_VAL
 */
var_val copy_var_val(var_val p) {
  return (var_val) gen_copy_tree((gen_chunk*) p);
}
void free_var_val(var_val p) {
  gen_free((gen_chunk*) p);
}
var_val check_var_val(var_val p) {
  return (var_val) gen_check((gen_chunk*) p, var_val_domain);
}
bool var_val_consistent_p(var_val p) {
  check_var_val(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool var_val_defined_p(var_val p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_var_val_cons(var_val p, list l) {
  return gen_typed_cons(VAR_VAL_NEWGEN_DOMAIN, p, l);
}
void var_val_assign_contents(var_val r, var_val v) {
  check_var_val(r);
  check_var_val(v);
  message_assert("defined references to domain var_val",
                 var_val_defined_p(r) && var_val_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_var_val_));
}
void var_val_non_recursive_free(var_val p) {
  // should clear up contents...
  free(p);
}
void write_var_val(FILE* f, var_val p) {
  gen_write(f, (gen_chunk*) p);
}
var_val read_var_val(FILE* f) {
  return (var_val) gen_read(f);
}
var_val make_var_val(entity a1, expression a2) {
  return (var_val) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, var_val_domain, a1, a2);
}

