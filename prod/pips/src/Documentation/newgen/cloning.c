/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "cloning.h"

/* CLONE_CONTEXT
 */
clone_context copy_clone_context(clone_context p) {
  return (clone_context) gen_copy_tree((gen_chunk*) p);
}
void free_clone_context(clone_context p) {
  gen_free((gen_chunk*) p);
}
clone_context check_clone_context(clone_context p) {
  return (clone_context) gen_check((gen_chunk*) p, clone_context_domain);
}
bool clone_context_consistent_p(clone_context p) {
  check_clone_context(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool clone_context_defined_p(clone_context p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_clone_context_cons(clone_context p, list l) {
  return gen_typed_cons(CLONE_CONTEXT_NEWGEN_DOMAIN, p, l);
}
void clone_context_assign_contents(clone_context r, clone_context v) {
  check_clone_context(r);
  check_clone_context(v);
  message_assert("defined references to domain clone_context",
                 clone_context_defined_p(r) && clone_context_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_clone_context_));
}
void clone_context_non_recursive_free(clone_context p) {
  // should clear up contents...
  free(p);
}
void write_clone_context(FILE* f, clone_context p) {
  gen_write(f, (gen_chunk*) p);
}
clone_context read_clone_context(FILE* f) {
  return (clone_context) gen_read(f);
}
clone_context make_clone_context(entity a1, entity a2, list a3, statement a4) {
  return (clone_context) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, clone_context_domain, a1, a2, a3, a4);
}

