/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "property.h"

/* PROPERTY
 */
property copy_property(property p) {
  return (property) gen_copy_tree((gen_chunk*) p);
}
void free_property(property p) {
  gen_free((gen_chunk*) p);
}
property check_property(property p) {
  return (property) gen_check((gen_chunk*) p, property_domain);
}
bool property_consistent_p(property p) {
  check_property(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool property_defined_p(property p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_property_cons(property p, list l) {
  return gen_typed_cons(PROPERTY_NEWGEN_DOMAIN, p, l);
}
void property_assign_contents(property r, property v) {
  check_property(r);
  check_property(v);
  message_assert("defined references to domain property",
                 property_defined_p(r) && property_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_property_));
}
void property_non_recursive_free(property p) {
  // should clear up contents...
  free(p);
}
void write_property(FILE* f, property p) {
  gen_write(f, (gen_chunk*) p);
}
property read_property(FILE* f) {
  return (property) gen_read(f);
}
string property_tag_as_string(enum property_utype tag) {
  switch (tag) {
  case is_property_int: return "int";
  case is_property_bool: return "bool";
  case is_property_string: return "string";
  default: return string_undefined;
  }
}
property make_property(enum property_utype tag, void * val) {
  return (property) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, property_domain, tag, val);
}
property make_property_int(intptr_t _field_) {
  return make_property(is_property_int, (void*)(intptr_t) _field_);
}
property make_property_bool(bool _field_) {
  return make_property(is_property_bool, (void*)(intptr_t) _field_);
}
property make_property_string(string _field_) {
  return make_property(is_property_string, (void*)(intptr_t) _field_);
}

