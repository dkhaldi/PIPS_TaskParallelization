/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * Pvecteur;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "compsec.h"


/* BOUND_PAIR
 */
bound_pair copy_bound_pair(bound_pair p) {
  return (bound_pair) gen_copy_tree((gen_chunk*) p);
}
void free_bound_pair(bound_pair p) {
  gen_free((gen_chunk*) p);
}
bound_pair check_bound_pair(bound_pair p) {
  return (bound_pair) gen_check((gen_chunk*) p, bound_pair_domain);
}
bool bound_pair_consistent_p(bound_pair p) {
  check_bound_pair(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool bound_pair_defined_p(bound_pair p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_bound_pair_cons(bound_pair p, list l) {
  return gen_typed_cons(BOUND_PAIR_NEWGEN_DOMAIN, p, l);
}
void bound_pair_assign_contents(bound_pair r, bound_pair v) {
  check_bound_pair(r);
  check_bound_pair(v);
  message_assert("defined references to domain bound_pair",
                 bound_pair_defined_p(r) && bound_pair_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_bound_pair_));
}
void bound_pair_non_recursive_free(bound_pair p) {
  // should clear up contents...
  free(p);
}
void write_bound_pair(FILE* f, bound_pair p) {
  gen_write(f, (gen_chunk*) p);
}
bound_pair read_bound_pair(FILE* f) {
  return (bound_pair) gen_read(f);
}
bound_pair make_bound_pair(intptr_t a1, Pvecteur a2, Pvecteur a3) {
  return (bound_pair) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, bound_pair_domain, a1, a2, a3);
}

/* COMP_DESC
 */
comp_desc copy_comp_desc(comp_desc p) {
  return (comp_desc) gen_copy_tree((gen_chunk*) p);
}
void free_comp_desc(comp_desc p) {
  gen_free((gen_chunk*) p);
}
comp_desc check_comp_desc(comp_desc p) {
  return (comp_desc) gen_check((gen_chunk*) p, comp_desc_domain);
}
bool comp_desc_consistent_p(comp_desc p) {
  check_comp_desc(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool comp_desc_defined_p(comp_desc p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_comp_desc_cons(comp_desc p, list l) {
  return gen_typed_cons(COMP_DESC_NEWGEN_DOMAIN, p, l);
}
void comp_desc_assign_contents(comp_desc r, comp_desc v) {
  check_comp_desc(r);
  check_comp_desc(v);
  message_assert("defined references to domain comp_desc",
                 comp_desc_defined_p(r) && comp_desc_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_comp_desc_));
}
void comp_desc_non_recursive_free(comp_desc p) {
  // should clear up contents...
  free(p);
}
void write_comp_desc(FILE* f, comp_desc p) {
  gen_write(f, (gen_chunk*) p);
}
comp_desc read_comp_desc(FILE* f) {
  return (comp_desc) gen_read(f);
}
comp_desc make_comp_desc(reference a1, action a2, comp_sec a3) {
  return (comp_desc) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, comp_desc_domain, a1, a2, a3);
}

/* COMP_DESC_SET
 */
comp_desc_set copy_comp_desc_set(comp_desc_set p) {
  return (comp_desc_set) gen_copy_tree((gen_chunk*) p);
}
void free_comp_desc_set(comp_desc_set p) {
  gen_free((gen_chunk*) p);
}
comp_desc_set check_comp_desc_set(comp_desc_set p) {
  return (comp_desc_set) gen_check((gen_chunk*) p, comp_desc_set_domain);
}
bool comp_desc_set_consistent_p(comp_desc_set p) {
  check_comp_desc_set(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool comp_desc_set_defined_p(comp_desc_set p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_comp_desc_set_cons(comp_desc_set p, list l) {
  return gen_typed_cons(COMP_DESC_SET_NEWGEN_DOMAIN, p, l);
}
void comp_desc_set_assign_contents(comp_desc_set r, comp_desc_set v) {
  check_comp_desc_set(r);
  check_comp_desc_set(v);
  message_assert("defined references to domain comp_desc_set",
                 comp_desc_set_defined_p(r) && comp_desc_set_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_comp_desc_set_));
}
void comp_desc_set_non_recursive_free(comp_desc_set p) {
  // should clear up contents...
  free(p);
}
void write_comp_desc_set(FILE* f, comp_desc_set p) {
  gen_write(f, (gen_chunk*) p);
}
comp_desc_set read_comp_desc_set(FILE* f) {
  return (comp_desc_set) gen_read(f);
}
comp_desc_set make_comp_desc_set(list a) {
  return (comp_desc_set) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, comp_desc_set_domain, a);
}

/* COMP_SEC
 */
comp_sec copy_comp_sec(comp_sec p) {
  return (comp_sec) gen_copy_tree((gen_chunk*) p);
}
void free_comp_sec(comp_sec p) {
  gen_free((gen_chunk*) p);
}
comp_sec check_comp_sec(comp_sec p) {
  return (comp_sec) gen_check((gen_chunk*) p, comp_sec_domain);
}
bool comp_sec_consistent_p(comp_sec p) {
  check_comp_sec(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool comp_sec_defined_p(comp_sec p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_comp_sec_cons(comp_sec p, list l) {
  return gen_typed_cons(COMP_SEC_NEWGEN_DOMAIN, p, l);
}
void comp_sec_assign_contents(comp_sec r, comp_sec v) {
  check_comp_sec(r);
  check_comp_sec(v);
  message_assert("defined references to domain comp_sec",
                 comp_sec_defined_p(r) && comp_sec_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_comp_sec_));
}
void comp_sec_non_recursive_free(comp_sec p) {
  // should clear up contents...
  free(p);
}
void write_comp_sec(FILE* f, comp_sec p) {
  gen_write(f, (gen_chunk*) p);
}
comp_sec read_comp_sec(FILE* f) {
  return (comp_sec) gen_read(f);
}
comp_sec make_comp_sec(simple_section a1, list a2) {
  return (comp_sec) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, comp_sec_domain, a1, a2);
}

/* CONTEXT_INFO
 */
context_info copy_context_info(context_info p) {
  return (context_info) gen_copy_tree((gen_chunk*) p);
}
void free_context_info(context_info p) {
  gen_free((gen_chunk*) p);
}
context_info check_context_info(context_info p) {
  return (context_info) gen_check((gen_chunk*) p, context_info_domain);
}
bool context_info_consistent_p(context_info p) {
  check_context_info(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool context_info_defined_p(context_info p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_context_info_cons(context_info p, list l) {
  return gen_typed_cons(CONTEXT_INFO_NEWGEN_DOMAIN, p, l);
}
void context_info_assign_contents(context_info r, context_info v) {
  check_context_info(r);
  check_context_info(v);
  message_assert("defined references to domain context_info",
                 context_info_defined_p(r) && context_info_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_context_info_));
}
void context_info_non_recursive_free(context_info p) {
  // should clear up contents...
  free(p);
}
void write_context_info(FILE* f, context_info p) {
  gen_write(f, (gen_chunk*) p);
}
context_info read_context_info(FILE* f) {
  return (context_info) gen_read(f);
}
context_info make_context_info(intptr_t a1, intptr_t a2, intptr_t a3) {
  return (context_info) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, context_info_domain, a1, a2, a3);
}

/* DAD_STRUCT
 */
dad_struct copy_dad_struct(dad_struct p) {
  return (dad_struct) gen_copy_tree((gen_chunk*) p);
}
void free_dad_struct(dad_struct p) {
  gen_free((gen_chunk*) p);
}
dad_struct check_dad_struct(dad_struct p) {
  return (dad_struct) gen_check((gen_chunk*) p, dad_struct_domain);
}
bool dad_struct_consistent_p(dad_struct p) {
  check_dad_struct(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dad_struct_defined_p(dad_struct p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dad_struct_cons(dad_struct p, list l) {
  return gen_typed_cons(DAD_STRUCT_NEWGEN_DOMAIN, p, l);
}
void dad_struct_assign_contents(dad_struct r, dad_struct v) {
  check_dad_struct(r);
  check_dad_struct(v);
  message_assert("defined references to domain dad_struct",
                 dad_struct_defined_p(r) && dad_struct_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dad_struct_));
}
void dad_struct_non_recursive_free(dad_struct p) {
  // should clear up contents...
  free(p);
}
void write_dad_struct(FILE* f, dad_struct p) {
  gen_write(f, (gen_chunk*) p);
}
dad_struct read_dad_struct(FILE* f) {
  return (dad_struct) gen_read(f);
}
dad_struct make_dad_struct(list a1, list a2) {
  return (dad_struct) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, dad_struct_domain, a1, a2);
}

/* REF_TEMP
 */
ref_temp copy_ref_temp(ref_temp p) {
  return (ref_temp) gen_copy_tree((gen_chunk*) p);
}
void free_ref_temp(ref_temp p) {
  gen_free((gen_chunk*) p);
}
ref_temp check_ref_temp(ref_temp p) {
  return (ref_temp) gen_check((gen_chunk*) p, ref_temp_domain);
}
bool ref_temp_consistent_p(ref_temp p) {
  check_ref_temp(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool ref_temp_defined_p(ref_temp p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_ref_temp_cons(ref_temp p, list l) {
  return gen_typed_cons(REF_TEMP_NEWGEN_DOMAIN, p, l);
}
void ref_temp_assign_contents(ref_temp r, ref_temp v) {
  check_ref_temp(r);
  check_ref_temp(v);
  message_assert("defined references to domain ref_temp",
                 ref_temp_defined_p(r) && ref_temp_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_ref_temp_));
}
void ref_temp_non_recursive_free(ref_temp p) {
  // should clear up contents...
  free(p);
}
void write_ref_temp(FILE* f, ref_temp p) {
  gen_write(f, (gen_chunk*) p);
}
ref_temp read_ref_temp(FILE* f) {
  return (ref_temp) gen_read(f);
}
ref_temp make_ref_temp(intptr_t a1, rtype a2) {
  return (ref_temp) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, ref_temp_domain, a1, a2);
}

/* RTYPE
 */
rtype copy_rtype(rtype p) {
  return (rtype) gen_copy_tree((gen_chunk*) p);
}
void free_rtype(rtype p) {
  gen_free((gen_chunk*) p);
}
rtype check_rtype(rtype p) {
  return (rtype) gen_check((gen_chunk*) p, rtype_domain);
}
bool rtype_consistent_p(rtype p) {
  check_rtype(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool rtype_defined_p(rtype p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_rtype_cons(rtype p, list l) {
  return gen_typed_cons(RTYPE_NEWGEN_DOMAIN, p, l);
}
void rtype_assign_contents(rtype r, rtype v) {
  check_rtype(r);
  check_rtype(v);
  message_assert("defined references to domain rtype",
                 rtype_defined_p(r) && rtype_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_rtype_));
}
void rtype_non_recursive_free(rtype p) {
  // should clear up contents...
  free(p);
}
void write_rtype(FILE* f, rtype p) {
  gen_write(f, (gen_chunk*) p);
}
rtype read_rtype(FILE* f) {
  return (rtype) gen_read(f);
}
string rtype_tag_as_string(enum rtype_utype tag) {
  switch (tag) {
  case is_rtype_nonlinear: return "nonlinear";
  case is_rtype_linvariant: return "linvariant";
  case is_rtype_lininvariant: return "lininvariant";
  default: return string_undefined;
  }
}
rtype make_rtype(enum rtype_utype tag, void * val) {
  return (rtype) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, rtype_domain, tag, val);
}
rtype make_rtype_nonlinear(void) {
  return make_rtype(is_rtype_nonlinear, UU);
}
rtype make_rtype_linvariant(void) {
  return make_rtype(is_rtype_linvariant, UU);
}
rtype make_rtype_lininvariant(void) {
  return make_rtype(is_rtype_lininvariant, UU);
}

/* SIMPLE_SECTION
 */
simple_section copy_simple_section(simple_section p) {
  return (simple_section) gen_copy_tree((gen_chunk*) p);
}
void free_simple_section(simple_section p) {
  gen_free((gen_chunk*) p);
}
simple_section check_simple_section(simple_section p) {
  return (simple_section) gen_check((gen_chunk*) p, simple_section_domain);
}
bool simple_section_consistent_p(simple_section p) {
  check_simple_section(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool simple_section_defined_p(simple_section p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_simple_section_cons(simple_section p, list l) {
  return gen_typed_cons(SIMPLE_SECTION_NEWGEN_DOMAIN, p, l);
}
void simple_section_assign_contents(simple_section r, simple_section v) {
  check_simple_section(r);
  check_simple_section(v);
  message_assert("defined references to domain simple_section",
                 simple_section_defined_p(r) && simple_section_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_simple_section_));
}
void simple_section_non_recursive_free(simple_section p) {
  // should clear up contents...
  free(p);
}
void write_simple_section(FILE* f, simple_section p) {
  gen_write(f, (gen_chunk*) p);
}
simple_section read_simple_section(FILE* f) {
  return (simple_section) gen_read(f);
}
simple_section make_simple_section(context_info a1, dad_struct a2) {
  return (simple_section) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, simple_section_domain, a1, a2);
}

