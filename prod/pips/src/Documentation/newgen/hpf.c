/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "hpf.h"

/* ALIGN
 */
align copy_align(align p) {
  return (align) gen_copy_tree((gen_chunk*) p);
}
void free_align(align p) {
  gen_free((gen_chunk*) p);
}
align check_align(align p) {
  return (align) gen_check((gen_chunk*) p, align_domain);
}
bool align_consistent_p(align p) {
  check_align(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool align_defined_p(align p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_align_cons(align p, list l) {
  return gen_typed_cons(ALIGN_NEWGEN_DOMAIN, p, l);
}
void align_assign_contents(align r, align v) {
  check_align(r);
  check_align(v);
  message_assert("defined references to domain align",
                 align_defined_p(r) && align_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_align_));
}
void align_non_recursive_free(align p) {
  // should clear up contents...
  free(p);
}
void write_align(FILE* f, align p) {
  gen_write(f, (gen_chunk*) p);
}
align read_align(FILE* f) {
  return (align) gen_read(f);
}
align make_align(list a1, entity a2) {
  return (align) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, align_domain, a1, a2);
}

/* ALIGNMENT
 */
alignment copy_alignment(alignment p) {
  return (alignment) gen_copy_tree((gen_chunk*) p);
}
void free_alignment(alignment p) {
  gen_free((gen_chunk*) p);
}
alignment check_alignment(alignment p) {
  return (alignment) gen_check((gen_chunk*) p, alignment_domain);
}
bool alignment_consistent_p(alignment p) {
  check_alignment(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool alignment_defined_p(alignment p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_alignment_cons(alignment p, list l) {
  return gen_typed_cons(ALIGNMENT_NEWGEN_DOMAIN, p, l);
}
void alignment_assign_contents(alignment r, alignment v) {
  check_alignment(r);
  check_alignment(v);
  message_assert("defined references to domain alignment",
                 alignment_defined_p(r) && alignment_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_alignment_));
}
void alignment_non_recursive_free(alignment p) {
  // should clear up contents...
  free(p);
}
void write_alignment(FILE* f, alignment p) {
  gen_write(f, (gen_chunk*) p);
}
alignment read_alignment(FILE* f) {
  return (alignment) gen_read(f);
}
alignment make_alignment(intptr_t a1, intptr_t a2, expression a3, expression a4) {
  return (alignment) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, alignment_domain, a1, a2, a3, a4);
}

/* DISTRIBUTE
 */
distribute copy_distribute(distribute p) {
  return (distribute) gen_copy_tree((gen_chunk*) p);
}
void free_distribute(distribute p) {
  gen_free((gen_chunk*) p);
}
distribute check_distribute(distribute p) {
  return (distribute) gen_check((gen_chunk*) p, distribute_domain);
}
bool distribute_consistent_p(distribute p) {
  check_distribute(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool distribute_defined_p(distribute p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_distribute_cons(distribute p, list l) {
  return gen_typed_cons(DISTRIBUTE_NEWGEN_DOMAIN, p, l);
}
void distribute_assign_contents(distribute r, distribute v) {
  check_distribute(r);
  check_distribute(v);
  message_assert("defined references to domain distribute",
                 distribute_defined_p(r) && distribute_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_distribute_));
}
void distribute_non_recursive_free(distribute p) {
  // should clear up contents...
  free(p);
}
void write_distribute(FILE* f, distribute p) {
  gen_write(f, (gen_chunk*) p);
}
distribute read_distribute(FILE* f) {
  return (distribute) gen_read(f);
}
distribute make_distribute(list a1, entity a2) {
  return (distribute) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, distribute_domain, a1, a2);
}

/* DISTRIBUTION
 */
distribution copy_distribution(distribution p) {
  return (distribution) gen_copy_tree((gen_chunk*) p);
}
void free_distribution(distribution p) {
  gen_free((gen_chunk*) p);
}
distribution check_distribution(distribution p) {
  return (distribution) gen_check((gen_chunk*) p, distribution_domain);
}
bool distribution_consistent_p(distribution p) {
  check_distribution(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool distribution_defined_p(distribution p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_distribution_cons(distribution p, list l) {
  return gen_typed_cons(DISTRIBUTION_NEWGEN_DOMAIN, p, l);
}
void distribution_assign_contents(distribution r, distribution v) {
  check_distribution(r);
  check_distribution(v);
  message_assert("defined references to domain distribution",
                 distribution_defined_p(r) && distribution_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_distribution_));
}
void distribution_non_recursive_free(distribution p) {
  // should clear up contents...
  free(p);
}
void write_distribution(FILE* f, distribution p) {
  gen_write(f, (gen_chunk*) p);
}
distribution read_distribution(FILE* f) {
  return (distribution) gen_read(f);
}
distribution make_distribution(style a1, expression a2) {
  return (distribution) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, distribution_domain, a1, a2);
}

/* STYLE
 */
style copy_style(style p) {
  return (style) gen_copy_tree((gen_chunk*) p);
}
void free_style(style p) {
  gen_free((gen_chunk*) p);
}
style check_style(style p) {
  return (style) gen_check((gen_chunk*) p, style_domain);
}
bool style_consistent_p(style p) {
  check_style(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool style_defined_p(style p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_style_cons(style p, list l) {
  return gen_typed_cons(STYLE_NEWGEN_DOMAIN, p, l);
}
void style_assign_contents(style r, style v) {
  check_style(r);
  check_style(v);
  message_assert("defined references to domain style",
                 style_defined_p(r) && style_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_style_));
}
void style_non_recursive_free(style p) {
  // should clear up contents...
  free(p);
}
void write_style(FILE* f, style p) {
  gen_write(f, (gen_chunk*) p);
}
style read_style(FILE* f) {
  return (style) gen_read(f);
}
string style_tag_as_string(enum style_utype tag) {
  switch (tag) {
  case is_style_none: return "none";
  case is_style_block: return "block";
  case is_style_cyclic: return "cyclic";
  default: return string_undefined;
  }
}
style make_style(enum style_utype tag, void * val) {
  return (style) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, style_domain, tag, val);
}
style make_style_none(void) {
  return make_style(is_style_none, UU);
}
style make_style_block(void) {
  return make_style(is_style_block, UU);
}
style make_style_cyclic(void) {
  return make_style(is_style_cyclic, UU);
}

