/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "eole_private.h"

/* ASSIGNMENT
 */
assignment copy_assignment(assignment p) {
  return (assignment) gen_copy_tree((gen_chunk*) p);
}
void free_assignment(assignment p) {
  gen_free((gen_chunk*) p);
}
assignment check_assignment(assignment p) {
  return (assignment) gen_check((gen_chunk*) p, assignment_domain);
}
bool assignment_consistent_p(assignment p) {
  check_assignment(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool assignment_defined_p(assignment p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_assignment_cons(assignment p, list l) {
  return gen_typed_cons(ASSIGNMENT_NEWGEN_DOMAIN, p, l);
}
void assignment_assign_contents(assignment r, assignment v) {
  check_assignment(r);
  check_assignment(v);
  message_assert("defined references to domain assignment",
                 assignment_defined_p(r) && assignment_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_assignment_));
}
void assignment_non_recursive_free(assignment p) {
  // should clear up contents...
  free(p);
}
void write_assignment(FILE* f, assignment p) {
  gen_write(f, (gen_chunk*) p);
}
assignment read_assignment(FILE* f) {
  return (assignment) gen_read(f);
}
assignment make_assignment(function a1, function a2, list a3) {
  return (assignment) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, assignment_domain, a1, a2, a3);
}

/* EXPRESSIONWITHLEVEL
 */
expressionwithlevel copy_expressionwithlevel(expressionwithlevel p) {
  return (expressionwithlevel) gen_copy_tree((gen_chunk*) p);
}
void free_expressionwithlevel(expressionwithlevel p) {
  gen_free((gen_chunk*) p);
}
expressionwithlevel check_expressionwithlevel(expressionwithlevel p) {
  return (expressionwithlevel) gen_check((gen_chunk*) p, expressionwithlevel_domain);
}
bool expressionwithlevel_consistent_p(expressionwithlevel p) {
  check_expressionwithlevel(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool expressionwithlevel_defined_p(expressionwithlevel p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_expressionwithlevel_cons(expressionwithlevel p, list l) {
  return gen_typed_cons(EXPRESSIONWITHLEVEL_NEWGEN_DOMAIN, p, l);
}
void expressionwithlevel_assign_contents(expressionwithlevel r, expressionwithlevel v) {
  check_expressionwithlevel(r);
  check_expressionwithlevel(v);
  message_assert("defined references to domain expressionwithlevel",
                 expressionwithlevel_defined_p(r) && expressionwithlevel_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_expressionwithlevel_));
}
void expressionwithlevel_non_recursive_free(expressionwithlevel p) {
  // should clear up contents...
  free(p);
}
void write_expressionwithlevel(FILE* f, expressionwithlevel p) {
  gen_write(f, (gen_chunk*) p);
}
expressionwithlevel read_expressionwithlevel(FILE* f) {
  return (expressionwithlevel) gen_read(f);
}
expressionwithlevel make_expressionwithlevel(list a1, expression a2) {
  return (expressionwithlevel) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, expressionwithlevel_domain, a1, a2);
}

/* FUNCTION
 */
function copy_function(function p) {
  return (function) gen_copy_tree((gen_chunk*) p);
}
void free_function(function p) {
  gen_free((gen_chunk*) p);
}
function check_function(function p) {
  return (function) gen_check((gen_chunk*) p, function_domain);
}
bool function_consistent_p(function p) {
  check_function(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool function_defined_p(function p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_function_cons(function p, list l) {
  return gen_typed_cons(FUNCTION_NEWGEN_DOMAIN, p, l);
}
void function_assign_contents(function r, function v) {
  check_function(r);
  check_function(v);
  message_assert("defined references to domain function",
                 function_defined_p(r) && function_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_function_));
}
void function_non_recursive_free(function p) {
  // should clear up contents...
  free(p);
}
void write_function(FILE* f, function p) {
  gen_write(f, (gen_chunk*) p);
}
function read_function(FILE* f) {
  return (function) gen_read(f);
}
function make_function(entity a1, list a2) {
  return (function) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, function_domain, a1, a2);
}

/* LEXPRESSIONWITHLEVEL
 */
lexpressionwithlevel copy_lexpressionwithlevel(lexpressionwithlevel p) {
  return (lexpressionwithlevel) gen_copy_tree((gen_chunk*) p);
}
void free_lexpressionwithlevel(lexpressionwithlevel p) {
  gen_free((gen_chunk*) p);
}
lexpressionwithlevel check_lexpressionwithlevel(lexpressionwithlevel p) {
  return (lexpressionwithlevel) gen_check((gen_chunk*) p, lexpressionwithlevel_domain);
}
bool lexpressionwithlevel_consistent_p(lexpressionwithlevel p) {
  check_lexpressionwithlevel(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool lexpressionwithlevel_defined_p(lexpressionwithlevel p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_lexpressionwithlevel_cons(lexpressionwithlevel p, list l) {
  return gen_typed_cons(LEXPRESSIONWITHLEVEL_NEWGEN_DOMAIN, p, l);
}
void lexpressionwithlevel_assign_contents(lexpressionwithlevel r, lexpressionwithlevel v) {
  check_lexpressionwithlevel(r);
  check_lexpressionwithlevel(v);
  message_assert("defined references to domain lexpressionwithlevel",
                 lexpressionwithlevel_defined_p(r) && lexpressionwithlevel_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_lexpressionwithlevel_));
}
void lexpressionwithlevel_non_recursive_free(lexpressionwithlevel p) {
  // should clear up contents...
  free(p);
}
void write_lexpressionwithlevel(FILE* f, lexpressionwithlevel p) {
  gen_write(f, (gen_chunk*) p);
}
lexpressionwithlevel read_lexpressionwithlevel(FILE* f) {
  return (lexpressionwithlevel) gen_read(f);
}
lexpressionwithlevel make_lexpressionwithlevel(list a) {
  return (lexpressionwithlevel) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, lexpressionwithlevel_domain, a);
}

/* PERSISTANT_EXPRESSION_TO_ENTITY
 */
persistant_expression_to_entity copy_persistant_expression_to_entity(persistant_expression_to_entity p) {
  return (persistant_expression_to_entity) gen_copy_tree((gen_chunk*) p);
}
void free_persistant_expression_to_entity(persistant_expression_to_entity p) {
  gen_free((gen_chunk*) p);
}
persistant_expression_to_entity check_persistant_expression_to_entity(persistant_expression_to_entity p) {
  return (persistant_expression_to_entity) gen_check((gen_chunk*) p, persistant_expression_to_entity_domain);
}
bool persistant_expression_to_entity_consistent_p(persistant_expression_to_entity p) {
  check_persistant_expression_to_entity(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool persistant_expression_to_entity_defined_p(persistant_expression_to_entity p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_persistant_expression_to_entity_cons(persistant_expression_to_entity p, list l) {
  return gen_typed_cons(PERSISTANT_EXPRESSION_TO_ENTITY_NEWGEN_DOMAIN, p, l);
}
void persistant_expression_to_entity_assign_contents(persistant_expression_to_entity r, persistant_expression_to_entity v) {
  check_persistant_expression_to_entity(r);
  check_persistant_expression_to_entity(v);
  message_assert("defined references to domain persistant_expression_to_entity",
                 persistant_expression_to_entity_defined_p(r) && persistant_expression_to_entity_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_persistant_expression_to_entity_));
}
void persistant_expression_to_entity_non_recursive_free(persistant_expression_to_entity p) {
  // should clear up contents...
  free(p);
}
void write_persistant_expression_to_entity(FILE* f, persistant_expression_to_entity p) {
  gen_write(f, (gen_chunk*) p);
}
persistant_expression_to_entity read_persistant_expression_to_entity(FILE* f) {
  return (persistant_expression_to_entity) gen_read(f);
}
persistant_expression_to_entity make_persistant_expression_to_entity(void) {
  return (persistant_expression_to_entity) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, persistant_expression_to_entity_domain);
}
entity apply_persistant_expression_to_entity(persistant_expression_to_entity f, expression k) {
  return (entity) (intptr_t)HASH_GET(p, p, persistant_expression_to_entity_hash_table(f), k);
}
void update_persistant_expression_to_entity(persistant_expression_to_entity f, expression k, entity v) {
  HASH_UPDATE(p, p, persistant_expression_to_entity_hash_table(f), k, (intptr_t)v);
}
void extend_persistant_expression_to_entity(persistant_expression_to_entity f, expression k, entity v) {
  HASH_EXTEND(p, p, persistant_expression_to_entity_hash_table(f), k, (intptr_t)v);
}
entity delete_persistant_expression_to_entity(persistant_expression_to_entity f, expression k) {
  return (entity)(intptr_t) HASH_DELETE(p, p, persistant_expression_to_entity_hash_table(f), k);
}
bool bound_persistant_expression_to_entity_p(persistant_expression_to_entity f, expression k) {
  return (intptr_t)HASH_BOUND_P(p, p, persistant_expression_to_entity_hash_table(f), k);
}

