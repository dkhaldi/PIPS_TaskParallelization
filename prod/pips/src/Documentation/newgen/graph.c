/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * vertex_label;
typedef void * arc_label;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "graph.h"



/* GRAPH
 */
graph copy_graph(graph p) {
  return (graph) gen_copy_tree((gen_chunk*) p);
}
void free_graph(graph p) {
  gen_free((gen_chunk*) p);
}
graph check_graph(graph p) {
  return (graph) gen_check((gen_chunk*) p, graph_domain);
}
bool graph_consistent_p(graph p) {
  check_graph(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool graph_defined_p(graph p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_graph_cons(graph p, list l) {
  return gen_typed_cons(GRAPH_NEWGEN_DOMAIN, p, l);
}
void graph_assign_contents(graph r, graph v) {
  check_graph(r);
  check_graph(v);
  message_assert("defined references to domain graph",
                 graph_defined_p(r) && graph_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_graph_));
}
void graph_non_recursive_free(graph p) {
  // should clear up contents...
  free(p);
}
void write_graph(FILE* f, graph p) {
  gen_write(f, (gen_chunk*) p);
}
graph read_graph(FILE* f) {
  return (graph) gen_read(f);
}
graph make_graph(list a) {
  return (graph) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, graph_domain, a);
}

/* SUCCESSOR
 */
successor copy_successor(successor p) {
  return (successor) gen_copy_tree((gen_chunk*) p);
}
void free_successor(successor p) {
  gen_free((gen_chunk*) p);
}
successor check_successor(successor p) {
  return (successor) gen_check((gen_chunk*) p, successor_domain);
}
bool successor_consistent_p(successor p) {
  check_successor(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool successor_defined_p(successor p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_successor_cons(successor p, list l) {
  return gen_typed_cons(SUCCESSOR_NEWGEN_DOMAIN, p, l);
}
void successor_assign_contents(successor r, successor v) {
  check_successor(r);
  check_successor(v);
  message_assert("defined references to domain successor",
                 successor_defined_p(r) && successor_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_successor_));
}
void successor_non_recursive_free(successor p) {
  // should clear up contents...
  free(p);
}
void write_successor(FILE* f, successor p) {
  gen_write(f, (gen_chunk*) p);
}
successor read_successor(FILE* f) {
  return (successor) gen_read(f);
}
successor make_successor(arc_label a1, vertex a2) {
  return (successor) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, successor_domain, a1, a2);
}

/* VERTEX
 */
vertex copy_vertex(vertex p) {
  return (vertex) gen_copy_tree((gen_chunk*) p);
}
void free_vertex(vertex p) {
  gen_free((gen_chunk*) p);
}
vertex check_vertex(vertex p) {
  return (vertex) gen_check((gen_chunk*) p, vertex_domain);
}
bool vertex_consistent_p(vertex p) {
  check_vertex(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool vertex_defined_p(vertex p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_vertex_cons(vertex p, list l) {
  return gen_typed_cons(VERTEX_NEWGEN_DOMAIN, p, l);
}
void vertex_assign_contents(vertex r, vertex v) {
  check_vertex(r);
  check_vertex(v);
  message_assert("defined references to domain vertex",
                 vertex_defined_p(r) && vertex_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_vertex_));
}
void vertex_non_recursive_free(vertex p) {
  // should clear up contents...
  free(p);
}
void write_vertex(FILE* f, vertex p) {
  gen_write(f, (gen_chunk*) p);
}
vertex read_vertex(FILE* f) {
  return (vertex) gen_read(f);
}
vertex make_vertex(vertex_label a1, list a2) {
  return (vertex) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, vertex_domain, a1, a2);
}

