/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * Ppolynome;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "complexity_ri.h"


/* COMPLEXITY
 */
complexity copy_complexity(complexity p) {
  return (complexity) gen_copy_tree((gen_chunk*) p);
}
void free_complexity(complexity p) {
  gen_free((gen_chunk*) p);
}
complexity check_complexity(complexity p) {
  return (complexity) gen_check((gen_chunk*) p, complexity_domain);
}
bool complexity_consistent_p(complexity p) {
  check_complexity(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool complexity_defined_p(complexity p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_complexity_cons(complexity p, list l) {
  return gen_typed_cons(COMPLEXITY_NEWGEN_DOMAIN, p, l);
}
void complexity_assign_contents(complexity r, complexity v) {
  check_complexity(r);
  check_complexity(v);
  message_assert("defined references to domain complexity",
                 complexity_defined_p(r) && complexity_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_complexity_));
}
void complexity_non_recursive_free(complexity p) {
  // should clear up contents...
  free(p);
}
void write_complexity(FILE* f, complexity p) {
  gen_write(f, (gen_chunk*) p);
}
complexity read_complexity(FILE* f) {
  return (complexity) gen_read(f);
}
complexity make_complexity(Ppolynome a1, varcount a2, rangecount a3, ifcount a4) {
  return (complexity) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, complexity_domain, a1, a2, a3, a4);
}

/* IFCOUNT
 */
ifcount copy_ifcount(ifcount p) {
  return (ifcount) gen_copy_tree((gen_chunk*) p);
}
void free_ifcount(ifcount p) {
  gen_free((gen_chunk*) p);
}
ifcount check_ifcount(ifcount p) {
  return (ifcount) gen_check((gen_chunk*) p, ifcount_domain);
}
bool ifcount_consistent_p(ifcount p) {
  check_ifcount(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool ifcount_defined_p(ifcount p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_ifcount_cons(ifcount p, list l) {
  return gen_typed_cons(IFCOUNT_NEWGEN_DOMAIN, p, l);
}
void ifcount_assign_contents(ifcount r, ifcount v) {
  check_ifcount(r);
  check_ifcount(v);
  message_assert("defined references to domain ifcount",
                 ifcount_defined_p(r) && ifcount_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_ifcount_));
}
void ifcount_non_recursive_free(ifcount p) {
  // should clear up contents...
  free(p);
}
void write_ifcount(FILE* f, ifcount p) {
  gen_write(f, (gen_chunk*) p);
}
ifcount read_ifcount(FILE* f) {
  return (ifcount) gen_read(f);
}
ifcount make_ifcount(intptr_t a1, intptr_t a2, intptr_t a3) {
  return (ifcount) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, ifcount_domain, a1, a2, a3);
}

/* RANGECOUNT
 */
rangecount copy_rangecount(rangecount p) {
  return (rangecount) gen_copy_tree((gen_chunk*) p);
}
void free_rangecount(rangecount p) {
  gen_free((gen_chunk*) p);
}
rangecount check_rangecount(rangecount p) {
  return (rangecount) gen_check((gen_chunk*) p, rangecount_domain);
}
bool rangecount_consistent_p(rangecount p) {
  check_rangecount(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool rangecount_defined_p(rangecount p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_rangecount_cons(rangecount p, list l) {
  return gen_typed_cons(RANGECOUNT_NEWGEN_DOMAIN, p, l);
}
void rangecount_assign_contents(rangecount r, rangecount v) {
  check_rangecount(r);
  check_rangecount(v);
  message_assert("defined references to domain rangecount",
                 rangecount_defined_p(r) && rangecount_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_rangecount_));
}
void rangecount_non_recursive_free(rangecount p) {
  // should clear up contents...
  free(p);
}
void write_rangecount(FILE* f, rangecount p) {
  gen_write(f, (gen_chunk*) p);
}
rangecount read_rangecount(FILE* f) {
  return (rangecount) gen_read(f);
}
rangecount make_rangecount(intptr_t a1, intptr_t a2, intptr_t a3, intptr_t a4) {
  return (rangecount) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, rangecount_domain, a1, a2, a3, a4);
}

/* VARCOUNT
 */
varcount copy_varcount(varcount p) {
  return (varcount) gen_copy_tree((gen_chunk*) p);
}
void free_varcount(varcount p) {
  gen_free((gen_chunk*) p);
}
varcount check_varcount(varcount p) {
  return (varcount) gen_check((gen_chunk*) p, varcount_domain);
}
bool varcount_consistent_p(varcount p) {
  check_varcount(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool varcount_defined_p(varcount p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_varcount_cons(varcount p, list l) {
  return gen_typed_cons(VARCOUNT_NEWGEN_DOMAIN, p, l);
}
void varcount_assign_contents(varcount r, varcount v) {
  check_varcount(r);
  check_varcount(v);
  message_assert("defined references to domain varcount",
                 varcount_defined_p(r) && varcount_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_varcount_));
}
void varcount_non_recursive_free(varcount p) {
  // should clear up contents...
  free(p);
}
void write_varcount(FILE* f, varcount p) {
  gen_write(f, (gen_chunk*) p);
}
varcount read_varcount(FILE* f) {
  return (varcount) gen_read(f);
}
varcount make_varcount(intptr_t a1, intptr_t a2, intptr_t a3, intptr_t a4) {
  return (varcount) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, varcount_domain, a1, a2, a3, a4);
}

