/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * Pvecteur;
typedef void * Psysteme;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "ri.h"



/* APPLICATION
 */
application copy_application(application p) {
  return (application) gen_copy_tree((gen_chunk*) p);
}
void free_application(application p) {
  gen_free((gen_chunk*) p);
}
application check_application(application p) {
  return (application) gen_check((gen_chunk*) p, application_domain);
}
bool application_consistent_p(application p) {
  check_application(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool application_defined_p(application p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_application_cons(application p, list l) {
  return gen_typed_cons(APPLICATION_NEWGEN_DOMAIN, p, l);
}
void application_assign_contents(application r, application v) {
  check_application(r);
  check_application(v);
  message_assert("defined references to domain application",
                 application_defined_p(r) && application_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_application_));
}
void application_non_recursive_free(application p) {
  // should clear up contents...
  free(p);
}
void write_application(FILE* f, application p) {
  gen_write(f, (gen_chunk*) p);
}
application read_application(FILE* f) {
  return (application) gen_read(f);
}
application make_application(expression a1, list a2) {
  return (application) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, application_domain, a1, a2);
}

/* AREA
 */
area copy_area(area p) {
  return (area) gen_copy_tree((gen_chunk*) p);
}
void free_area(area p) {
  gen_free((gen_chunk*) p);
}
area check_area(area p) {
  return (area) gen_check((gen_chunk*) p, area_domain);
}
bool area_consistent_p(area p) {
  check_area(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool area_defined_p(area p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_area_cons(area p, list l) {
  return gen_typed_cons(AREA_NEWGEN_DOMAIN, p, l);
}
void area_assign_contents(area r, area v) {
  check_area(r);
  check_area(v);
  message_assert("defined references to domain area",
                 area_defined_p(r) && area_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_area_));
}
void area_non_recursive_free(area p) {
  // should clear up contents...
  free(p);
}
void write_area(FILE* f, area p) {
  gen_write(f, (gen_chunk*) p);
}
area read_area(FILE* f) {
  return (area) gen_read(f);
}
area make_area(intptr_t a1, list a2) {
  return (area) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, area_domain, a1, a2);
}

/* BASIC
 */
basic copy_basic(basic p) {
  return (basic) gen_copy_tree((gen_chunk*) p);
}
void free_basic(basic p) {
  gen_free((gen_chunk*) p);
}
basic check_basic(basic p) {
  return (basic) gen_check((gen_chunk*) p, basic_domain);
}
bool basic_consistent_p(basic p) {
  check_basic(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool basic_defined_p(basic p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_basic_cons(basic p, list l) {
  return gen_typed_cons(BASIC_NEWGEN_DOMAIN, p, l);
}
void basic_assign_contents(basic r, basic v) {
  check_basic(r);
  check_basic(v);
  message_assert("defined references to domain basic",
                 basic_defined_p(r) && basic_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_basic_));
}
void basic_non_recursive_free(basic p) {
  // should clear up contents...
  free(p);
}
void write_basic(FILE* f, basic p) {
  gen_write(f, (gen_chunk*) p);
}
basic read_basic(FILE* f) {
  return (basic) gen_read(f);
}
string basic_tag_as_string(enum basic_utype tag) {
  switch (tag) {
  case is_basic_int: return "int";
  case is_basic_float: return "float";
  case is_basic_logical: return "logical";
  case is_basic_overloaded: return "overloaded";
  case is_basic_complex: return "complex";
  case is_basic_string: return "string";
  case is_basic_bit: return "bit";
  case is_basic_pointer: return "pointer";
  case is_basic_derived: return "derived";
  case is_basic_typedef: return "typedef";
  default: return string_undefined;
  }
}
basic make_basic(enum basic_utype tag, void * val) {
  return (basic) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, basic_domain, tag, val);
}
basic make_basic_int(intptr_t _field_) {
  return make_basic(is_basic_int, (void*)(intptr_t) _field_);
}
basic make_basic_float(intptr_t _field_) {
  return make_basic(is_basic_float, (void*)(intptr_t) _field_);
}
basic make_basic_logical(intptr_t _field_) {
  return make_basic(is_basic_logical, (void*)(intptr_t) _field_);
}
basic make_basic_overloaded(void) {
  return make_basic(is_basic_overloaded, UU);
}
basic make_basic_complex(intptr_t _field_) {
  return make_basic(is_basic_complex, (void*)(intptr_t) _field_);
}
basic make_basic_string(value _field_) {
  return make_basic(is_basic_string, (void*)(intptr_t) _field_);
}
basic make_basic_bit(symbolic _field_) {
  return make_basic(is_basic_bit, (void*)(intptr_t) _field_);
}
basic make_basic_pointer(type _field_) {
  return make_basic(is_basic_pointer, (void*)(intptr_t) _field_);
}
basic make_basic_derived(entity _field_) {
  return make_basic(is_basic_derived, (void*)(intptr_t) _field_);
}
basic make_basic_typedef(entity _field_) {
  return make_basic(is_basic_typedef, (void*)(intptr_t) _field_);
}

/* CALLEES
 */
callees copy_callees(callees p) {
  return (callees) gen_copy_tree((gen_chunk*) p);
}
void free_callees(callees p) {
  gen_free((gen_chunk*) p);
}
callees check_callees(callees p) {
  return (callees) gen_check((gen_chunk*) p, callees_domain);
}
bool callees_consistent_p(callees p) {
  check_callees(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool callees_defined_p(callees p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_callees_cons(callees p, list l) {
  return gen_typed_cons(CALLEES_NEWGEN_DOMAIN, p, l);
}
void callees_assign_contents(callees r, callees v) {
  check_callees(r);
  check_callees(v);
  message_assert("defined references to domain callees",
                 callees_defined_p(r) && callees_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_callees_));
}
void callees_non_recursive_free(callees p) {
  // should clear up contents...
  free(p);
}
void write_callees(FILE* f, callees p) {
  gen_write(f, (gen_chunk*) p);
}
callees read_callees(FILE* f) {
  return (callees) gen_read(f);
}
callees make_callees(list a) {
  return (callees) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, callees_domain, a);
}

/* CALL
 */
call copy_call(call p) {
  return (call) gen_copy_tree((gen_chunk*) p);
}
void free_call(call p) {
  gen_free((gen_chunk*) p);
}
call check_call(call p) {
  return (call) gen_check((gen_chunk*) p, call_domain);
}
bool call_consistent_p(call p) {
  check_call(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool call_defined_p(call p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_call_cons(call p, list l) {
  return gen_typed_cons(CALL_NEWGEN_DOMAIN, p, l);
}
void call_assign_contents(call r, call v) {
  check_call(r);
  check_call(v);
  message_assert("defined references to domain call",
                 call_defined_p(r) && call_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_call_));
}
void call_non_recursive_free(call p) {
  // should clear up contents...
  free(p);
}
void write_call(FILE* f, call p) {
  gen_write(f, (gen_chunk*) p);
}
call read_call(FILE* f) {
  return (call) gen_read(f);
}
call make_call(entity a1, list a2) {
  return (call) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, call_domain, a1, a2);
}

/* CAST
 */
cast copy_cast(cast p) {
  return (cast) gen_copy_tree((gen_chunk*) p);
}
void free_cast(cast p) {
  gen_free((gen_chunk*) p);
}
cast check_cast(cast p) {
  return (cast) gen_check((gen_chunk*) p, cast_domain);
}
bool cast_consistent_p(cast p) {
  check_cast(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool cast_defined_p(cast p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_cast_cons(cast p, list l) {
  return gen_typed_cons(CAST_NEWGEN_DOMAIN, p, l);
}
void cast_assign_contents(cast r, cast v) {
  check_cast(r);
  check_cast(v);
  message_assert("defined references to domain cast",
                 cast_defined_p(r) && cast_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_cast_));
}
void cast_non_recursive_free(cast p) {
  // should clear up contents...
  free(p);
}
void write_cast(FILE* f, cast p) {
  gen_write(f, (gen_chunk*) p);
}
cast read_cast(FILE* f) {
  return (cast) gen_read(f);
}
cast make_cast(type a1, expression a2) {
  return (cast) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, cast_domain, a1, a2);
}

/* CODE
 */
code copy_code(code p) {
  return (code) gen_copy_tree((gen_chunk*) p);
}
void free_code(code p) {
  gen_free((gen_chunk*) p);
}
code check_code(code p) {
  return (code) gen_check((gen_chunk*) p, code_domain);
}
bool code_consistent_p(code p) {
  check_code(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool code_defined_p(code p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_code_cons(code p, list l) {
  return gen_typed_cons(CODE_NEWGEN_DOMAIN, p, l);
}
void code_assign_contents(code r, code v) {
  check_code(r);
  check_code(v);
  message_assert("defined references to domain code",
                 code_defined_p(r) && code_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_code_));
}
void code_non_recursive_free(code p) {
  // should clear up contents...
  free(p);
}
void write_code(FILE* f, code p) {
  gen_write(f, (gen_chunk*) p);
}
code read_code(FILE* f) {
  return (code) gen_read(f);
}
code make_code(list a1, string a2, sequence a3, list a4, language a5) {
  return (code) gen_alloc(6*sizeof(gen_chunk), GEN_CHECK_ALLOC, code_domain, a1, a2, a3, a4, a5);
}

/* CONSTANT
 */
constant copy_constant(constant p) {
  return (constant) gen_copy_tree((gen_chunk*) p);
}
void free_constant(constant p) {
  gen_free((gen_chunk*) p);
}
constant check_constant(constant p) {
  return (constant) gen_check((gen_chunk*) p, constant_domain);
}
bool constant_consistent_p(constant p) {
  check_constant(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool constant_defined_p(constant p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_constant_cons(constant p, list l) {
  return gen_typed_cons(CONSTANT_NEWGEN_DOMAIN, p, l);
}
void constant_assign_contents(constant r, constant v) {
  check_constant(r);
  check_constant(v);
  message_assert("defined references to domain constant",
                 constant_defined_p(r) && constant_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_constant_));
}
void constant_non_recursive_free(constant p) {
  // should clear up contents...
  free(p);
}
void write_constant(FILE* f, constant p) {
  gen_write(f, (gen_chunk*) p);
}
constant read_constant(FILE* f) {
  return (constant) gen_read(f);
}
string constant_tag_as_string(enum constant_utype tag) {
  switch (tag) {
  case is_constant_int: return "int";
  case is_constant_float: return "float";
  case is_constant_logical: return "logical";
  case is_constant_litteral: return "litteral";
  case is_constant_call: return "call";
  case is_constant_unknown: return "unknown";
  default: return string_undefined;
  }
}
constant make_constant(enum constant_utype tag, void * val) {
  return (constant) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, constant_domain, tag, val);
}
constant make_constant_int(intptr_t _field_) {
  return make_constant(is_constant_int, (void*)(intptr_t) _field_);
}
constant make_constant_float(float _field_) {
  return make_constant(is_constant_float, (void*)(intptr_t) _field_);
}
constant make_constant_logical(intptr_t _field_) {
  return make_constant(is_constant_logical, (void*)(intptr_t) _field_);
}
constant make_constant_litteral(void) {
  return make_constant(is_constant_litteral, UU);
}
constant make_constant_call(entity _field_) {
  return make_constant(is_constant_call, (void*)(intptr_t) _field_);
}
constant make_constant_unknown(void) {
  return make_constant(is_constant_unknown, UU);
}

/* CONTROLMAP
 */
controlmap copy_controlmap(controlmap p) {
  return (controlmap) gen_copy_tree((gen_chunk*) p);
}
void free_controlmap(controlmap p) {
  gen_free((gen_chunk*) p);
}
controlmap check_controlmap(controlmap p) {
  return (controlmap) gen_check((gen_chunk*) p, controlmap_domain);
}
bool controlmap_consistent_p(controlmap p) {
  check_controlmap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool controlmap_defined_p(controlmap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_controlmap_cons(controlmap p, list l) {
  return gen_typed_cons(CONTROLMAP_NEWGEN_DOMAIN, p, l);
}
void controlmap_assign_contents(controlmap r, controlmap v) {
  check_controlmap(r);
  check_controlmap(v);
  message_assert("defined references to domain controlmap",
                 controlmap_defined_p(r) && controlmap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_controlmap_));
}
void controlmap_non_recursive_free(controlmap p) {
  // should clear up contents...
  free(p);
}
void write_controlmap(FILE* f, controlmap p) {
  gen_write(f, (gen_chunk*) p);
}
controlmap read_controlmap(FILE* f) {
  return (controlmap) gen_read(f);
}
controlmap make_controlmap(void) {
  return (controlmap) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, controlmap_domain);
}
control apply_controlmap(controlmap f, statement k) {
  return (control) (intptr_t)HASH_GET(p, p, controlmap_hash_table(f), k);
}
void update_controlmap(controlmap f, statement k, control v) {
  HASH_UPDATE(p, p, controlmap_hash_table(f), k, (intptr_t)v);
}
void extend_controlmap(controlmap f, statement k, control v) {
  HASH_EXTEND(p, p, controlmap_hash_table(f), k, (intptr_t)v);
}
control delete_controlmap(controlmap f, statement k) {
  return (control)(intptr_t) HASH_DELETE(p, p, controlmap_hash_table(f), k);
}
bool bound_controlmap_p(controlmap f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, controlmap_hash_table(f), k);
}

/* CONTROL
 */
control copy_control(control p) {
  return (control) gen_copy_tree((gen_chunk*) p);
}
void free_control(control p) {
  gen_free((gen_chunk*) p);
}
control check_control(control p) {
  return (control) gen_check((gen_chunk*) p, control_domain);
}
bool control_consistent_p(control p) {
  check_control(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool control_defined_p(control p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_control_cons(control p, list l) {
  return gen_typed_cons(CONTROL_NEWGEN_DOMAIN, p, l);
}
void control_assign_contents(control r, control v) {
  check_control(r);
  check_control(v);
  message_assert("defined references to domain control",
                 control_defined_p(r) && control_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_control_));
}
void control_non_recursive_free(control p) {
  // should clear up contents...
  free(p);
}
void write_control(FILE* f, control p) {
  gen_write(f, (gen_chunk*) p);
}
control read_control(FILE* f) {
  return (control) gen_read(f);
}
control make_control(statement a1, list a2, list a3) {
  return (control) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, control_domain, a1, a2, a3);
}

/* DIMENSION
 */
dimension copy_dimension(dimension p) {
  return (dimension) gen_copy_tree((gen_chunk*) p);
}
void free_dimension(dimension p) {
  gen_free((gen_chunk*) p);
}
dimension check_dimension(dimension p) {
  return (dimension) gen_check((gen_chunk*) p, dimension_domain);
}
bool dimension_consistent_p(dimension p) {
  check_dimension(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dimension_defined_p(dimension p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dimension_cons(dimension p, list l) {
  return gen_typed_cons(DIMENSION_NEWGEN_DOMAIN, p, l);
}
void dimension_assign_contents(dimension r, dimension v) {
  check_dimension(r);
  check_dimension(v);
  message_assert("defined references to domain dimension",
                 dimension_defined_p(r) && dimension_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dimension_));
}
void dimension_non_recursive_free(dimension p) {
  // should clear up contents...
  free(p);
}
void write_dimension(FILE* f, dimension p) {
  gen_write(f, (gen_chunk*) p);
}
dimension read_dimension(FILE* f) {
  return (dimension) gen_read(f);
}
dimension make_dimension(expression a1, expression a2, list a3) {
  return (dimension) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, dimension_domain, a1, a2, a3);
}

/* DUMMY
 */
dummy copy_dummy(dummy p) {
  return (dummy) gen_copy_tree((gen_chunk*) p);
}
void free_dummy(dummy p) {
  gen_free((gen_chunk*) p);
}
dummy check_dummy(dummy p) {
  return (dummy) gen_check((gen_chunk*) p, dummy_domain);
}
bool dummy_consistent_p(dummy p) {
  check_dummy(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dummy_defined_p(dummy p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dummy_cons(dummy p, list l) {
  return gen_typed_cons(DUMMY_NEWGEN_DOMAIN, p, l);
}
void dummy_assign_contents(dummy r, dummy v) {
  check_dummy(r);
  check_dummy(v);
  message_assert("defined references to domain dummy",
                 dummy_defined_p(r) && dummy_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dummy_));
}
void dummy_non_recursive_free(dummy p) {
  // should clear up contents...
  free(p);
}
void write_dummy(FILE* f, dummy p) {
  gen_write(f, (gen_chunk*) p);
}
dummy read_dummy(FILE* f) {
  return (dummy) gen_read(f);
}
string dummy_tag_as_string(enum dummy_utype tag) {
  switch (tag) {
  case is_dummy_unknown: return "unknown";
  case is_dummy_identifier: return "identifier";
  default: return string_undefined;
  }
}
dummy make_dummy(enum dummy_utype tag, void * val) {
  return (dummy) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, dummy_domain, tag, val);
}
dummy make_dummy_unknown(void) {
  return make_dummy(is_dummy_unknown, UU);
}
dummy make_dummy_identifier(entity _field_) {
  return make_dummy(is_dummy_identifier, (void*)(intptr_t) _field_);
}

/* ENTITY_INT
 */
entity_int copy_entity_int(entity_int p) {
  return (entity_int) gen_copy_tree((gen_chunk*) p);
}
void free_entity_int(entity_int p) {
  gen_free((gen_chunk*) p);
}
entity_int check_entity_int(entity_int p) {
  return (entity_int) gen_check((gen_chunk*) p, entity_int_domain);
}
bool entity_int_consistent_p(entity_int p) {
  check_entity_int(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entity_int_defined_p(entity_int p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entity_int_cons(entity_int p, list l) {
  return gen_typed_cons(ENTITY_INT_NEWGEN_DOMAIN, p, l);
}
void entity_int_assign_contents(entity_int r, entity_int v) {
  check_entity_int(r);
  check_entity_int(v);
  message_assert("defined references to domain entity_int",
                 entity_int_defined_p(r) && entity_int_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entity_int_));
}
void entity_int_non_recursive_free(entity_int p) {
  // should clear up contents...
  free(p);
}
void write_entity_int(FILE* f, entity_int p) {
  gen_write(f, (gen_chunk*) p);
}
entity_int read_entity_int(FILE* f) {
  return (entity_int) gen_read(f);
}
entity_int make_entity_int(void) {
  return (entity_int) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, entity_int_domain);
}
intptr_t apply_entity_int(entity_int f, entity k) {
  return (intptr_t) (intptr_t)HASH_GET(p, i, entity_int_hash_table(f), k);
}
void update_entity_int(entity_int f, entity k, intptr_t v) {
  HASH_UPDATE(p, i, entity_int_hash_table(f), k, (intptr_t)v);
}
void extend_entity_int(entity_int f, entity k, intptr_t v) {
  HASH_EXTEND(p, i, entity_int_hash_table(f), k, (intptr_t)v);
}
intptr_t delete_entity_int(entity_int f, entity k) {
  return (intptr_t)(intptr_t) HASH_DELETE(p, i, entity_int_hash_table(f), k);
}
bool bound_entity_int_p(entity_int f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, i, entity_int_hash_table(f), k);
}

/* EVALUATION
 */
evaluation copy_evaluation(evaluation p) {
  return (evaluation) gen_copy_tree((gen_chunk*) p);
}
void free_evaluation(evaluation p) {
  gen_free((gen_chunk*) p);
}
evaluation check_evaluation(evaluation p) {
  return (evaluation) gen_check((gen_chunk*) p, evaluation_domain);
}
bool evaluation_consistent_p(evaluation p) {
  check_evaluation(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool evaluation_defined_p(evaluation p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_evaluation_cons(evaluation p, list l) {
  return gen_typed_cons(EVALUATION_NEWGEN_DOMAIN, p, l);
}
void evaluation_assign_contents(evaluation r, evaluation v) {
  check_evaluation(r);
  check_evaluation(v);
  message_assert("defined references to domain evaluation",
                 evaluation_defined_p(r) && evaluation_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_evaluation_));
}
void evaluation_non_recursive_free(evaluation p) {
  // should clear up contents...
  free(p);
}
void write_evaluation(FILE* f, evaluation p) {
  gen_write(f, (gen_chunk*) p);
}
evaluation read_evaluation(FILE* f) {
  return (evaluation) gen_read(f);
}
string evaluation_tag_as_string(enum evaluation_utype tag) {
  switch (tag) {
  case is_evaluation_before: return "before";
  case is_evaluation_after: return "after";
  default: return string_undefined;
  }
}
evaluation make_evaluation(enum evaluation_utype tag, void * val) {
  return (evaluation) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, evaluation_domain, tag, val);
}
evaluation make_evaluation_before(void) {
  return make_evaluation(is_evaluation_before, UU);
}
evaluation make_evaluation_after(void) {
  return make_evaluation(is_evaluation_after, UU);
}

/* EXECUTION
 */
execution copy_execution(execution p) {
  return (execution) gen_copy_tree((gen_chunk*) p);
}
void free_execution(execution p) {
  gen_free((gen_chunk*) p);
}
execution check_execution(execution p) {
  return (execution) gen_check((gen_chunk*) p, execution_domain);
}
bool execution_consistent_p(execution p) {
  check_execution(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool execution_defined_p(execution p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_execution_cons(execution p, list l) {
  return gen_typed_cons(EXECUTION_NEWGEN_DOMAIN, p, l);
}
void execution_assign_contents(execution r, execution v) {
  check_execution(r);
  check_execution(v);
  message_assert("defined references to domain execution",
                 execution_defined_p(r) && execution_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_execution_));
}
void execution_non_recursive_free(execution p) {
  // should clear up contents...
  free(p);
}
void write_execution(FILE* f, execution p) {
  gen_write(f, (gen_chunk*) p);
}
execution read_execution(FILE* f) {
  return (execution) gen_read(f);
}
string execution_tag_as_string(enum execution_utype tag) {
  switch (tag) {
  case is_execution_sequential: return "sequential";
  case is_execution_parallel: return "parallel";
  default: return string_undefined;
  }
}
execution make_execution(enum execution_utype tag, void * val) {
  return (execution) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, execution_domain, tag, val);
}
execution make_execution_sequential(void) {
  return make_execution(is_execution_sequential, UU);
}
execution make_execution_parallel(void) {
  return make_execution(is_execution_parallel, UU);
}

/* EXPRESSION
 */
expression copy_expression(expression p) {
  return (expression) gen_copy_tree((gen_chunk*) p);
}
void free_expression(expression p) {
  gen_free((gen_chunk*) p);
}
expression check_expression(expression p) {
  return (expression) gen_check((gen_chunk*) p, expression_domain);
}
bool expression_consistent_p(expression p) {
  check_expression(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool expression_defined_p(expression p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_expression_cons(expression p, list l) {
  return gen_typed_cons(EXPRESSION_NEWGEN_DOMAIN, p, l);
}
void expression_assign_contents(expression r, expression v) {
  check_expression(r);
  check_expression(v);
  message_assert("defined references to domain expression",
                 expression_defined_p(r) && expression_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_expression_));
}
void expression_non_recursive_free(expression p) {
  // should clear up contents...
  free(p);
}
void write_expression(FILE* f, expression p) {
  gen_write(f, (gen_chunk*) p);
}
expression read_expression(FILE* f) {
  return (expression) gen_read(f);
}
expression make_expression(syntax a1, normalized a2) {
  return (expression) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, expression_domain, a1, a2);
}

/* EXTENSION
 */
extension copy_extension(extension p) {
  return (extension) gen_copy_tree((gen_chunk*) p);
}
void free_extension(extension p) {
  gen_free((gen_chunk*) p);
}
extension check_extension(extension p) {
  return (extension) gen_check((gen_chunk*) p, extension_domain);
}
bool extension_consistent_p(extension p) {
  check_extension(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool extension_defined_p(extension p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_extension_cons(extension p, list l) {
  return gen_typed_cons(EXTENSION_NEWGEN_DOMAIN, p, l);
}
void extension_assign_contents(extension r, extension v) {
  check_extension(r);
  check_extension(v);
  message_assert("defined references to domain extension",
                 extension_defined_p(r) && extension_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_extension_));
}
void extension_non_recursive_free(extension p) {
  // should clear up contents...
  free(p);
}
void write_extension(FILE* f, extension p) {
  gen_write(f, (gen_chunk*) p);
}
extension read_extension(FILE* f) {
  return (extension) gen_read(f);
}
string extension_tag_as_string(enum extension_utype tag) {
  switch (tag) {
  case is_extension_pragma: return "pragma";
  case is_extension_unknown: return "unknown";
  default: return string_undefined;
  }
}
extension make_extension(enum extension_utype tag, void * val) {
  return (extension) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, extension_domain, tag, val);
}
extension make_extension_pragma(pragma _field_) {
  return make_extension(is_extension_pragma, (void*)(intptr_t) _field_);
}
extension make_extension_unknown(void) {
  return make_extension(is_extension_unknown, UU);
}

/* EXTENSIONS
 */
extensions copy_extensions(extensions p) {
  return (extensions) gen_copy_tree((gen_chunk*) p);
}
void free_extensions(extensions p) {
  gen_free((gen_chunk*) p);
}
extensions check_extensions(extensions p) {
  return (extensions) gen_check((gen_chunk*) p, extensions_domain);
}
bool extensions_consistent_p(extensions p) {
  check_extensions(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool extensions_defined_p(extensions p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_extensions_cons(extensions p, list l) {
  return gen_typed_cons(EXTENSIONS_NEWGEN_DOMAIN, p, l);
}
void extensions_assign_contents(extensions r, extensions v) {
  check_extensions(r);
  check_extensions(v);
  message_assert("defined references to domain extensions",
                 extensions_defined_p(r) && extensions_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_extensions_));
}
void extensions_non_recursive_free(extensions p) {
  // should clear up contents...
  free(p);
}
void write_extensions(FILE* f, extensions p) {
  gen_write(f, (gen_chunk*) p);
}
extensions read_extensions(FILE* f) {
  return (extensions) gen_read(f);
}
extensions make_extensions(list a) {
  return (extensions) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, extensions_domain, a);
}

/* FORLOOP
 */
forloop copy_forloop(forloop p) {
  return (forloop) gen_copy_tree((gen_chunk*) p);
}
void free_forloop(forloop p) {
  gen_free((gen_chunk*) p);
}
forloop check_forloop(forloop p) {
  return (forloop) gen_check((gen_chunk*) p, forloop_domain);
}
bool forloop_consistent_p(forloop p) {
  check_forloop(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool forloop_defined_p(forloop p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_forloop_cons(forloop p, list l) {
  return gen_typed_cons(FORLOOP_NEWGEN_DOMAIN, p, l);
}
void forloop_assign_contents(forloop r, forloop v) {
  check_forloop(r);
  check_forloop(v);
  message_assert("defined references to domain forloop",
                 forloop_defined_p(r) && forloop_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_forloop_));
}
void forloop_non_recursive_free(forloop p) {
  // should clear up contents...
  free(p);
}
void write_forloop(FILE* f, forloop p) {
  gen_write(f, (gen_chunk*) p);
}
forloop read_forloop(FILE* f) {
  return (forloop) gen_read(f);
}
forloop make_forloop(expression a1, expression a2, expression a3, statement a4) {
  return (forloop) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, forloop_domain, a1, a2, a3, a4);
}

/* FORMAL
 */
formal copy_formal(formal p) {
  return (formal) gen_copy_tree((gen_chunk*) p);
}
void free_formal(formal p) {
  gen_free((gen_chunk*) p);
}
formal check_formal(formal p) {
  return (formal) gen_check((gen_chunk*) p, formal_domain);
}
bool formal_consistent_p(formal p) {
  check_formal(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool formal_defined_p(formal p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_formal_cons(formal p, list l) {
  return gen_typed_cons(FORMAL_NEWGEN_DOMAIN, p, l);
}
void formal_assign_contents(formal r, formal v) {
  check_formal(r);
  check_formal(v);
  message_assert("defined references to domain formal",
                 formal_defined_p(r) && formal_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_formal_));
}
void formal_non_recursive_free(formal p) {
  // should clear up contents...
  free(p);
}
void write_formal(FILE* f, formal p) {
  gen_write(f, (gen_chunk*) p);
}
formal read_formal(FILE* f) {
  return (formal) gen_read(f);
}
formal make_formal(entity a1, intptr_t a2) {
  return (formal) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, formal_domain, a1, a2);
}

/* FUNCTIONAL
 */
functional copy_functional(functional p) {
  return (functional) gen_copy_tree((gen_chunk*) p);
}
void free_functional(functional p) {
  gen_free((gen_chunk*) p);
}
functional check_functional(functional p) {
  return (functional) gen_check((gen_chunk*) p, functional_domain);
}
bool functional_consistent_p(functional p) {
  check_functional(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool functional_defined_p(functional p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_functional_cons(functional p, list l) {
  return gen_typed_cons(FUNCTIONAL_NEWGEN_DOMAIN, p, l);
}
void functional_assign_contents(functional r, functional v) {
  check_functional(r);
  check_functional(v);
  message_assert("defined references to domain functional",
                 functional_defined_p(r) && functional_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_functional_));
}
void functional_non_recursive_free(functional p) {
  // should clear up contents...
  free(p);
}
void write_functional(FILE* f, functional p) {
  gen_write(f, (gen_chunk*) p);
}
functional read_functional(FILE* f) {
  return (functional) gen_read(f);
}
functional make_functional(list a1, type a2) {
  return (functional) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, functional_domain, a1, a2);
}

/* INSTRUCTION
 */
instruction copy_instruction(instruction p) {
  return (instruction) gen_copy_tree((gen_chunk*) p);
}
void free_instruction(instruction p) {
  gen_free((gen_chunk*) p);
}
instruction check_instruction(instruction p) {
  return (instruction) gen_check((gen_chunk*) p, instruction_domain);
}
bool instruction_consistent_p(instruction p) {
  check_instruction(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool instruction_defined_p(instruction p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_instruction_cons(instruction p, list l) {
  return gen_typed_cons(INSTRUCTION_NEWGEN_DOMAIN, p, l);
}
void instruction_assign_contents(instruction r, instruction v) {
  check_instruction(r);
  check_instruction(v);
  message_assert("defined references to domain instruction",
                 instruction_defined_p(r) && instruction_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_instruction_));
}
void instruction_non_recursive_free(instruction p) {
  // should clear up contents...
  free(p);
}
void write_instruction(FILE* f, instruction p) {
  gen_write(f, (gen_chunk*) p);
}
instruction read_instruction(FILE* f) {
  return (instruction) gen_read(f);
}
string instruction_tag_as_string(enum instruction_utype tag) {
  switch (tag) {
  case is_instruction_sequence: return "sequence";
  case is_instruction_test: return "test";
  case is_instruction_loop: return "loop";
  case is_instruction_whileloop: return "whileloop";
  case is_instruction_goto: return "goto";
  case is_instruction_call: return "call";
  case is_instruction_unstructured: return "unstructured";
  case is_instruction_multitest: return "multitest";
  case is_instruction_forloop: return "forloop";
  case is_instruction_expression: return "expression";
  default: return string_undefined;
  }
}
instruction make_instruction(enum instruction_utype tag, void * val) {
  return (instruction) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, instruction_domain, tag, val);
}
instruction make_instruction_sequence(sequence _field_) {
  return make_instruction(is_instruction_sequence, (void*)(intptr_t) _field_);
}
instruction make_instruction_test(test _field_) {
  return make_instruction(is_instruction_test, (void*)(intptr_t) _field_);
}
instruction make_instruction_loop(loop _field_) {
  return make_instruction(is_instruction_loop, (void*)(intptr_t) _field_);
}
instruction make_instruction_whileloop(whileloop _field_) {
  return make_instruction(is_instruction_whileloop, (void*)(intptr_t) _field_);
}
instruction make_instruction_goto(statement _field_) {
  return make_instruction(is_instruction_goto, (void*)(intptr_t) _field_);
}
instruction make_instruction_call(call _field_) {
  return make_instruction(is_instruction_call, (void*)(intptr_t) _field_);
}
instruction make_instruction_unstructured(unstructured _field_) {
  return make_instruction(is_instruction_unstructured, (void*)(intptr_t) _field_);
}
instruction make_instruction_multitest(multitest _field_) {
  return make_instruction(is_instruction_multitest, (void*)(intptr_t) _field_);
}
instruction make_instruction_forloop(forloop _field_) {
  return make_instruction(is_instruction_forloop, (void*)(intptr_t) _field_);
}
instruction make_instruction_expression(expression _field_) {
  return make_instruction(is_instruction_expression, (void*)(intptr_t) _field_);
}

/* LANGUAGE
 */
language copy_language(language p) {
  return (language) gen_copy_tree((gen_chunk*) p);
}
void free_language(language p) {
  gen_free((gen_chunk*) p);
}
language check_language(language p) {
  return (language) gen_check((gen_chunk*) p, language_domain);
}
bool language_consistent_p(language p) {
  check_language(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool language_defined_p(language p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_language_cons(language p, list l) {
  return gen_typed_cons(LANGUAGE_NEWGEN_DOMAIN, p, l);
}
void language_assign_contents(language r, language v) {
  check_language(r);
  check_language(v);
  message_assert("defined references to domain language",
                 language_defined_p(r) && language_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_language_));
}
void language_non_recursive_free(language p) {
  // should clear up contents...
  free(p);
}
void write_language(FILE* f, language p) {
  gen_write(f, (gen_chunk*) p);
}
language read_language(FILE* f) {
  return (language) gen_read(f);
}
string language_tag_as_string(enum language_utype tag) {
  switch (tag) {
  case is_language_fortran: return "fortran";
  case is_language_c: return "c";
  case is_language_fortran95: return "fortran95";
  case is_language_unknown: return "unknown";
  default: return string_undefined;
  }
}
language make_language(enum language_utype tag, void * val) {
  return (language) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, language_domain, tag, val);
}
language make_language_fortran(void) {
  return make_language(is_language_fortran, UU);
}
language make_language_c(void) {
  return make_language(is_language_c, UU);
}
language make_language_fortran95(void) {
  return make_language(is_language_fortran95, UU);
}
language make_language_unknown(void) {
  return make_language(is_language_unknown, UU);
}

/* LOOP
 */
loop copy_loop(loop p) {
  return (loop) gen_copy_tree((gen_chunk*) p);
}
void free_loop(loop p) {
  gen_free((gen_chunk*) p);
}
loop check_loop(loop p) {
  return (loop) gen_check((gen_chunk*) p, loop_domain);
}
bool loop_consistent_p(loop p) {
  check_loop(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool loop_defined_p(loop p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_loop_cons(loop p, list l) {
  return gen_typed_cons(LOOP_NEWGEN_DOMAIN, p, l);
}
void loop_assign_contents(loop r, loop v) {
  check_loop(r);
  check_loop(v);
  message_assert("defined references to domain loop",
                 loop_defined_p(r) && loop_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_loop_));
}
void loop_non_recursive_free(loop p) {
  // should clear up contents...
  free(p);
}
void write_loop(FILE* f, loop p) {
  gen_write(f, (gen_chunk*) p);
}
loop read_loop(FILE* f) {
  return (loop) gen_read(f);
}
loop make_loop(entity a1, range a2, statement a3, entity a4, execution a5, list a6) {
  return (loop) gen_alloc(7*sizeof(gen_chunk), GEN_CHECK_ALLOC, loop_domain, a1, a2, a3, a4, a5, a6);
}

/* MODE
 */
mode copy_mode(mode p) {
  return (mode) gen_copy_tree((gen_chunk*) p);
}
void free_mode(mode p) {
  gen_free((gen_chunk*) p);
}
mode check_mode(mode p) {
  return (mode) gen_check((gen_chunk*) p, mode_domain);
}
bool mode_consistent_p(mode p) {
  check_mode(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool mode_defined_p(mode p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_mode_cons(mode p, list l) {
  return gen_typed_cons(MODE_NEWGEN_DOMAIN, p, l);
}
void mode_assign_contents(mode r, mode v) {
  check_mode(r);
  check_mode(v);
  message_assert("defined references to domain mode",
                 mode_defined_p(r) && mode_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_mode_));
}
void mode_non_recursive_free(mode p) {
  // should clear up contents...
  free(p);
}
void write_mode(FILE* f, mode p) {
  gen_write(f, (gen_chunk*) p);
}
mode read_mode(FILE* f) {
  return (mode) gen_read(f);
}
string mode_tag_as_string(enum mode_utype tag) {
  switch (tag) {
  case is_mode_value: return "value";
  case is_mode_reference: return "reference";
  default: return string_undefined;
  }
}
mode make_mode(enum mode_utype tag, void * val) {
  return (mode) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, mode_domain, tag, val);
}
mode make_mode_value(void) {
  return make_mode(is_mode_value, UU);
}
mode make_mode_reference(void) {
  return make_mode(is_mode_reference, UU);
}

/* MULTITEST
 */
multitest copy_multitest(multitest p) {
  return (multitest) gen_copy_tree((gen_chunk*) p);
}
void free_multitest(multitest p) {
  gen_free((gen_chunk*) p);
}
multitest check_multitest(multitest p) {
  return (multitest) gen_check((gen_chunk*) p, multitest_domain);
}
bool multitest_consistent_p(multitest p) {
  check_multitest(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool multitest_defined_p(multitest p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_multitest_cons(multitest p, list l) {
  return gen_typed_cons(MULTITEST_NEWGEN_DOMAIN, p, l);
}
void multitest_assign_contents(multitest r, multitest v) {
  check_multitest(r);
  check_multitest(v);
  message_assert("defined references to domain multitest",
                 multitest_defined_p(r) && multitest_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_multitest_));
}
void multitest_non_recursive_free(multitest p) {
  // should clear up contents...
  free(p);
}
void write_multitest(FILE* f, multitest p) {
  gen_write(f, (gen_chunk*) p);
}
multitest read_multitest(FILE* f) {
  return (multitest) gen_read(f);
}
multitest make_multitest(expression a1, statement a2) {
  return (multitest) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, multitest_domain, a1, a2);
}

/* NORMALIZED
 */
normalized copy_normalized(normalized p) {
  return (normalized) gen_copy_tree((gen_chunk*) p);
}
void free_normalized(normalized p) {
  gen_free((gen_chunk*) p);
}
normalized check_normalized(normalized p) {
  return (normalized) gen_check((gen_chunk*) p, normalized_domain);
}
bool normalized_consistent_p(normalized p) {
  check_normalized(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool normalized_defined_p(normalized p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_normalized_cons(normalized p, list l) {
  return gen_typed_cons(NORMALIZED_NEWGEN_DOMAIN, p, l);
}
void normalized_assign_contents(normalized r, normalized v) {
  check_normalized(r);
  check_normalized(v);
  message_assert("defined references to domain normalized",
                 normalized_defined_p(r) && normalized_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_normalized_));
}
void normalized_non_recursive_free(normalized p) {
  // should clear up contents...
  free(p);
}
void write_normalized(FILE* f, normalized p) {
  gen_write(f, (gen_chunk*) p);
}
normalized read_normalized(FILE* f) {
  return (normalized) gen_read(f);
}
string normalized_tag_as_string(enum normalized_utype tag) {
  switch (tag) {
  case is_normalized_linear: return "linear";
  case is_normalized_complex: return "complex";
  default: return string_undefined;
  }
}
normalized make_normalized(enum normalized_utype tag, void * val) {
  return (normalized) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, normalized_domain, tag, val);
}
normalized make_normalized_linear(Pvecteur _field_) {
  return make_normalized(is_normalized_linear, (void*)(intptr_t) _field_);
}
normalized make_normalized_complex(void) {
  return make_normalized(is_normalized_complex, UU);
}

/* PARAMETER
 */
parameter copy_parameter(parameter p) {
  return (parameter) gen_copy_tree((gen_chunk*) p);
}
void free_parameter(parameter p) {
  gen_free((gen_chunk*) p);
}
parameter check_parameter(parameter p) {
  return (parameter) gen_check((gen_chunk*) p, parameter_domain);
}
bool parameter_consistent_p(parameter p) {
  check_parameter(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool parameter_defined_p(parameter p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_parameter_cons(parameter p, list l) {
  return gen_typed_cons(PARAMETER_NEWGEN_DOMAIN, p, l);
}
void parameter_assign_contents(parameter r, parameter v) {
  check_parameter(r);
  check_parameter(v);
  message_assert("defined references to domain parameter",
                 parameter_defined_p(r) && parameter_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_parameter_));
}
void parameter_non_recursive_free(parameter p) {
  // should clear up contents...
  free(p);
}
void write_parameter(FILE* f, parameter p) {
  gen_write(f, (gen_chunk*) p);
}
parameter read_parameter(FILE* f) {
  return (parameter) gen_read(f);
}
parameter make_parameter(type a1, mode a2, dummy a3) {
  return (parameter) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, parameter_domain, a1, a2, a3);
}

/* PERSISTANT_STATEMENT_TO_CLUSTER
 */
persistant_statement_to_cluster copy_persistant_statement_to_cluster(persistant_statement_to_cluster p) {
  return (persistant_statement_to_cluster) gen_copy_tree((gen_chunk*) p);
}
void free_persistant_statement_to_cluster(persistant_statement_to_cluster p) {
  gen_free((gen_chunk*) p);
}
persistant_statement_to_cluster check_persistant_statement_to_cluster(persistant_statement_to_cluster p) {
  return (persistant_statement_to_cluster) gen_check((gen_chunk*) p, persistant_statement_to_cluster_domain);
}
bool persistant_statement_to_cluster_consistent_p(persistant_statement_to_cluster p) {
  check_persistant_statement_to_cluster(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool persistant_statement_to_cluster_defined_p(persistant_statement_to_cluster p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_persistant_statement_to_cluster_cons(persistant_statement_to_cluster p, list l) {
  return gen_typed_cons(PERSISTANT_STATEMENT_TO_CLUSTER_NEWGEN_DOMAIN, p, l);
}
void persistant_statement_to_cluster_assign_contents(persistant_statement_to_cluster r, persistant_statement_to_cluster v) {
  check_persistant_statement_to_cluster(r);
  check_persistant_statement_to_cluster(v);
  message_assert("defined references to domain persistant_statement_to_cluster",
                 persistant_statement_to_cluster_defined_p(r) && persistant_statement_to_cluster_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_persistant_statement_to_cluster_));
}
void persistant_statement_to_cluster_non_recursive_free(persistant_statement_to_cluster p) {
  // should clear up contents...
  free(p);
}
void write_persistant_statement_to_cluster(FILE* f, persistant_statement_to_cluster p) {
  gen_write(f, (gen_chunk*) p);
}
persistant_statement_to_cluster read_persistant_statement_to_cluster(FILE* f) {
  return (persistant_statement_to_cluster) gen_read(f);
}
persistant_statement_to_cluster make_persistant_statement_to_cluster(void) {
  return (persistant_statement_to_cluster) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, persistant_statement_to_cluster_domain);
}
intptr_t apply_persistant_statement_to_cluster(persistant_statement_to_cluster f, intptr_t k) {
  return (intptr_t) (intptr_t)HASH_GET(i, i, persistant_statement_to_cluster_hash_table(f), k);
}
void update_persistant_statement_to_cluster(persistant_statement_to_cluster f, intptr_t k, intptr_t v) {
  HASH_UPDATE(i, i, persistant_statement_to_cluster_hash_table(f), k, (intptr_t)v);
}
void extend_persistant_statement_to_cluster(persistant_statement_to_cluster f, intptr_t k, intptr_t v) {
  HASH_EXTEND(i, i, persistant_statement_to_cluster_hash_table(f), k, (intptr_t)v);
}
intptr_t delete_persistant_statement_to_cluster(persistant_statement_to_cluster f, intptr_t k) {
  return (intptr_t)(intptr_t) HASH_DELETE(i, i, persistant_statement_to_cluster_hash_table(f), k);
}
bool bound_persistant_statement_to_cluster_p(persistant_statement_to_cluster f, intptr_t k) {
  return (intptr_t)HASH_BOUND_P(i, i, persistant_statement_to_cluster_hash_table(f), k);
}

/* PERSISTANT_STATEMENT_TO_CONTROL
 */
persistant_statement_to_control copy_persistant_statement_to_control(persistant_statement_to_control p) {
  return (persistant_statement_to_control) gen_copy_tree((gen_chunk*) p);
}
void free_persistant_statement_to_control(persistant_statement_to_control p) {
  gen_free((gen_chunk*) p);
}
persistant_statement_to_control check_persistant_statement_to_control(persistant_statement_to_control p) {
  return (persistant_statement_to_control) gen_check((gen_chunk*) p, persistant_statement_to_control_domain);
}
bool persistant_statement_to_control_consistent_p(persistant_statement_to_control p) {
  check_persistant_statement_to_control(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool persistant_statement_to_control_defined_p(persistant_statement_to_control p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_persistant_statement_to_control_cons(persistant_statement_to_control p, list l) {
  return gen_typed_cons(PERSISTANT_STATEMENT_TO_CONTROL_NEWGEN_DOMAIN, p, l);
}
void persistant_statement_to_control_assign_contents(persistant_statement_to_control r, persistant_statement_to_control v) {
  check_persistant_statement_to_control(r);
  check_persistant_statement_to_control(v);
  message_assert("defined references to domain persistant_statement_to_control",
                 persistant_statement_to_control_defined_p(r) && persistant_statement_to_control_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_persistant_statement_to_control_));
}
void persistant_statement_to_control_non_recursive_free(persistant_statement_to_control p) {
  // should clear up contents...
  free(p);
}
void write_persistant_statement_to_control(FILE* f, persistant_statement_to_control p) {
  gen_write(f, (gen_chunk*) p);
}
persistant_statement_to_control read_persistant_statement_to_control(FILE* f) {
  return (persistant_statement_to_control) gen_read(f);
}
persistant_statement_to_control make_persistant_statement_to_control(void) {
  return (persistant_statement_to_control) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, persistant_statement_to_control_domain);
}
control apply_persistant_statement_to_control(persistant_statement_to_control f, statement k) {
  return (control) (intptr_t)HASH_GET(p, p, persistant_statement_to_control_hash_table(f), k);
}
void update_persistant_statement_to_control(persistant_statement_to_control f, statement k, control v) {
  HASH_UPDATE(p, p, persistant_statement_to_control_hash_table(f), k, (intptr_t)v);
}
void extend_persistant_statement_to_control(persistant_statement_to_control f, statement k, control v) {
  HASH_EXTEND(p, p, persistant_statement_to_control_hash_table(f), k, (intptr_t)v);
}
control delete_persistant_statement_to_control(persistant_statement_to_control f, statement k) {
  return (control)(intptr_t) HASH_DELETE(p, p, persistant_statement_to_control_hash_table(f), k);
}
bool bound_persistant_statement_to_control_p(persistant_statement_to_control f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, persistant_statement_to_control_hash_table(f), k);
}

/* PERSISTANT_STATEMENT_TO_INT
 */
persistant_statement_to_int copy_persistant_statement_to_int(persistant_statement_to_int p) {
  return (persistant_statement_to_int) gen_copy_tree((gen_chunk*) p);
}
void free_persistant_statement_to_int(persistant_statement_to_int p) {
  gen_free((gen_chunk*) p);
}
persistant_statement_to_int check_persistant_statement_to_int(persistant_statement_to_int p) {
  return (persistant_statement_to_int) gen_check((gen_chunk*) p, persistant_statement_to_int_domain);
}
bool persistant_statement_to_int_consistent_p(persistant_statement_to_int p) {
  check_persistant_statement_to_int(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool persistant_statement_to_int_defined_p(persistant_statement_to_int p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_persistant_statement_to_int_cons(persistant_statement_to_int p, list l) {
  return gen_typed_cons(PERSISTANT_STATEMENT_TO_INT_NEWGEN_DOMAIN, p, l);
}
void persistant_statement_to_int_assign_contents(persistant_statement_to_int r, persistant_statement_to_int v) {
  check_persistant_statement_to_int(r);
  check_persistant_statement_to_int(v);
  message_assert("defined references to domain persistant_statement_to_int",
                 persistant_statement_to_int_defined_p(r) && persistant_statement_to_int_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_persistant_statement_to_int_));
}
void persistant_statement_to_int_non_recursive_free(persistant_statement_to_int p) {
  // should clear up contents...
  free(p);
}
void write_persistant_statement_to_int(FILE* f, persistant_statement_to_int p) {
  gen_write(f, (gen_chunk*) p);
}
persistant_statement_to_int read_persistant_statement_to_int(FILE* f) {
  return (persistant_statement_to_int) gen_read(f);
}
persistant_statement_to_int make_persistant_statement_to_int(void) {
  return (persistant_statement_to_int) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, persistant_statement_to_int_domain);
}
intptr_t apply_persistant_statement_to_int(persistant_statement_to_int f, statement k) {
  return (intptr_t) (intptr_t)HASH_GET(p, i, persistant_statement_to_int_hash_table(f), k);
}
void update_persistant_statement_to_int(persistant_statement_to_int f, statement k, intptr_t v) {
  HASH_UPDATE(p, i, persistant_statement_to_int_hash_table(f), k, (intptr_t)v);
}
void extend_persistant_statement_to_int(persistant_statement_to_int f, statement k, intptr_t v) {
  HASH_EXTEND(p, i, persistant_statement_to_int_hash_table(f), k, (intptr_t)v);
}
intptr_t delete_persistant_statement_to_int(persistant_statement_to_int f, statement k) {
  return (intptr_t)(intptr_t) HASH_DELETE(p, i, persistant_statement_to_int_hash_table(f), k);
}
bool bound_persistant_statement_to_int_p(persistant_statement_to_int f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, i, persistant_statement_to_int_hash_table(f), k);
}

/* PERSISTANT_STATEMENT_TO_STATEMENT
 */
persistant_statement_to_statement copy_persistant_statement_to_statement(persistant_statement_to_statement p) {
  return (persistant_statement_to_statement) gen_copy_tree((gen_chunk*) p);
}
void free_persistant_statement_to_statement(persistant_statement_to_statement p) {
  gen_free((gen_chunk*) p);
}
persistant_statement_to_statement check_persistant_statement_to_statement(persistant_statement_to_statement p) {
  return (persistant_statement_to_statement) gen_check((gen_chunk*) p, persistant_statement_to_statement_domain);
}
bool persistant_statement_to_statement_consistent_p(persistant_statement_to_statement p) {
  check_persistant_statement_to_statement(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool persistant_statement_to_statement_defined_p(persistant_statement_to_statement p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_persistant_statement_to_statement_cons(persistant_statement_to_statement p, list l) {
  return gen_typed_cons(PERSISTANT_STATEMENT_TO_STATEMENT_NEWGEN_DOMAIN, p, l);
}
void persistant_statement_to_statement_assign_contents(persistant_statement_to_statement r, persistant_statement_to_statement v) {
  check_persistant_statement_to_statement(r);
  check_persistant_statement_to_statement(v);
  message_assert("defined references to domain persistant_statement_to_statement",
                 persistant_statement_to_statement_defined_p(r) && persistant_statement_to_statement_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_persistant_statement_to_statement_));
}
void persistant_statement_to_statement_non_recursive_free(persistant_statement_to_statement p) {
  // should clear up contents...
  free(p);
}
void write_persistant_statement_to_statement(FILE* f, persistant_statement_to_statement p) {
  gen_write(f, (gen_chunk*) p);
}
persistant_statement_to_statement read_persistant_statement_to_statement(FILE* f) {
  return (persistant_statement_to_statement) gen_read(f);
}
persistant_statement_to_statement make_persistant_statement_to_statement(void) {
  return (persistant_statement_to_statement) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, persistant_statement_to_statement_domain);
}
statement apply_persistant_statement_to_statement(persistant_statement_to_statement f, statement k) {
  return (statement) (intptr_t)HASH_GET(p, p, persistant_statement_to_statement_hash_table(f), k);
}
void update_persistant_statement_to_statement(persistant_statement_to_statement f, statement k, statement v) {
  HASH_UPDATE(p, p, persistant_statement_to_statement_hash_table(f), k, (intptr_t)v);
}
void extend_persistant_statement_to_statement(persistant_statement_to_statement f, statement k, statement v) {
  HASH_EXTEND(p, p, persistant_statement_to_statement_hash_table(f), k, (intptr_t)v);
}
statement delete_persistant_statement_to_statement(persistant_statement_to_statement f, statement k) {
  return (statement)(intptr_t) HASH_DELETE(p, p, persistant_statement_to_statement_hash_table(f), k);
}
bool bound_persistant_statement_to_statement_p(persistant_statement_to_statement f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, persistant_statement_to_statement_hash_table(f), k);
}

/* PRAGMA
 */
pragma copy_pragma(pragma p) {
  return (pragma) gen_copy_tree((gen_chunk*) p);
}
void free_pragma(pragma p) {
  gen_free((gen_chunk*) p);
}
pragma check_pragma(pragma p) {
  return (pragma) gen_check((gen_chunk*) p, pragma_domain);
}
bool pragma_consistent_p(pragma p) {
  check_pragma(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool pragma_defined_p(pragma p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_pragma_cons(pragma p, list l) {
  return gen_typed_cons(PRAGMA_NEWGEN_DOMAIN, p, l);
}
void pragma_assign_contents(pragma r, pragma v) {
  check_pragma(r);
  check_pragma(v);
  message_assert("defined references to domain pragma",
                 pragma_defined_p(r) && pragma_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_pragma_));
}
void pragma_non_recursive_free(pragma p) {
  // should clear up contents...
  free(p);
}
void write_pragma(FILE* f, pragma p) {
  gen_write(f, (gen_chunk*) p);
}
pragma read_pragma(FILE* f) {
  return (pragma) gen_read(f);
}
string pragma_tag_as_string(enum pragma_utype tag) {
  switch (tag) {
  case is_pragma_string: return "string";
  case is_pragma_expression: return "expression";
  default: return string_undefined;
  }
}
pragma make_pragma(enum pragma_utype tag, void * val) {
  return (pragma) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, pragma_domain, tag, val);
}
pragma make_pragma_string(string _field_) {
  return make_pragma(is_pragma_string, (void*)(intptr_t) _field_);
}
pragma make_pragma_expression(list _field_) {
  return make_pragma(is_pragma_expression, (void*)(intptr_t) _field_);
}

/* PREDICATE
 */
predicate copy_predicate(predicate p) {
  return (predicate) gen_copy_tree((gen_chunk*) p);
}
void free_predicate(predicate p) {
  gen_free((gen_chunk*) p);
}
predicate check_predicate(predicate p) {
  return (predicate) gen_check((gen_chunk*) p, predicate_domain);
}
bool predicate_consistent_p(predicate p) {
  check_predicate(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool predicate_defined_p(predicate p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_predicate_cons(predicate p, list l) {
  return gen_typed_cons(PREDICATE_NEWGEN_DOMAIN, p, l);
}
void predicate_assign_contents(predicate r, predicate v) {
  check_predicate(r);
  check_predicate(v);
  message_assert("defined references to domain predicate",
                 predicate_defined_p(r) && predicate_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_predicate_));
}
void predicate_non_recursive_free(predicate p) {
  // should clear up contents...
  free(p);
}
void write_predicate(FILE* f, predicate p) {
  gen_write(f, (gen_chunk*) p);
}
predicate read_predicate(FILE* f) {
  return (predicate) gen_read(f);
}
predicate make_predicate(Psysteme a1) {
  return (predicate) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, predicate_domain, a1);
}

/* PREFERENCE
 */
preference copy_preference(preference p) {
  return (preference) gen_copy_tree((gen_chunk*) p);
}
void free_preference(preference p) {
  gen_free((gen_chunk*) p);
}
preference check_preference(preference p) {
  return (preference) gen_check((gen_chunk*) p, preference_domain);
}
bool preference_consistent_p(preference p) {
  check_preference(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool preference_defined_p(preference p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_preference_cons(preference p, list l) {
  return gen_typed_cons(PREFERENCE_NEWGEN_DOMAIN, p, l);
}
void preference_assign_contents(preference r, preference v) {
  check_preference(r);
  check_preference(v);
  message_assert("defined references to domain preference",
                 preference_defined_p(r) && preference_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_preference_));
}
void preference_non_recursive_free(preference p) {
  // should clear up contents...
  free(p);
}
void write_preference(FILE* f, preference p) {
  gen_write(f, (gen_chunk*) p);
}
preference read_preference(FILE* f) {
  return (preference) gen_read(f);
}
preference make_preference(reference a1) {
  return (preference) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, preference_domain, a1);
}

/* QUALIFIER
 */
qualifier copy_qualifier(qualifier p) {
  return (qualifier) gen_copy_tree((gen_chunk*) p);
}
void free_qualifier(qualifier p) {
  gen_free((gen_chunk*) p);
}
qualifier check_qualifier(qualifier p) {
  return (qualifier) gen_check((gen_chunk*) p, qualifier_domain);
}
bool qualifier_consistent_p(qualifier p) {
  check_qualifier(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool qualifier_defined_p(qualifier p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_qualifier_cons(qualifier p, list l) {
  return gen_typed_cons(QUALIFIER_NEWGEN_DOMAIN, p, l);
}
void qualifier_assign_contents(qualifier r, qualifier v) {
  check_qualifier(r);
  check_qualifier(v);
  message_assert("defined references to domain qualifier",
                 qualifier_defined_p(r) && qualifier_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_qualifier_));
}
void qualifier_non_recursive_free(qualifier p) {
  // should clear up contents...
  free(p);
}
void write_qualifier(FILE* f, qualifier p) {
  gen_write(f, (gen_chunk*) p);
}
qualifier read_qualifier(FILE* f) {
  return (qualifier) gen_read(f);
}
string qualifier_tag_as_string(enum qualifier_utype tag) {
  switch (tag) {
  case is_qualifier_const: return "const";
  case is_qualifier_restrict: return "restrict";
  case is_qualifier_volatile: return "volatile";
  case is_qualifier_register: return "register";
  case is_qualifier_auto: return "auto";
  case is_qualifier_thread: return "thread";
  case is_qualifier_asm: return "asm";
  case is_qualifier_static_dimension: return "static_dimension";
  case is_qualifier_local: return "local";
  case is_qualifier_global: return "global";
  case is_qualifier_constant: return "constant";
  case is_qualifier_private: return "private";
  default: return string_undefined;
  }
}
qualifier make_qualifier(enum qualifier_utype tag, void * val) {
  return (qualifier) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, qualifier_domain, tag, val);
}
qualifier make_qualifier_const(void) {
  return make_qualifier(is_qualifier_const, UU);
}
qualifier make_qualifier_restrict(void) {
  return make_qualifier(is_qualifier_restrict, UU);
}
qualifier make_qualifier_volatile(void) {
  return make_qualifier(is_qualifier_volatile, UU);
}
qualifier make_qualifier_register(void) {
  return make_qualifier(is_qualifier_register, UU);
}
qualifier make_qualifier_auto(void) {
  return make_qualifier(is_qualifier_auto, UU);
}
qualifier make_qualifier_thread(void) {
  return make_qualifier(is_qualifier_thread, UU);
}
qualifier make_qualifier_asm(string _field_) {
  return make_qualifier(is_qualifier_asm, (void*)(intptr_t) _field_);
}
qualifier make_qualifier_static_dimension(void) {
  return make_qualifier(is_qualifier_static_dimension, UU);
}
qualifier make_qualifier_local(void) {
  return make_qualifier(is_qualifier_local, UU);
}
qualifier make_qualifier_global(void) {
  return make_qualifier(is_qualifier_global, UU);
}
qualifier make_qualifier_constant(void) {
  return make_qualifier(is_qualifier_constant, UU);
}
qualifier make_qualifier_private(void) {
  return make_qualifier(is_qualifier_private, UU);
}

/* RAM
 */
ram copy_ram(ram p) {
  return (ram) gen_copy_tree((gen_chunk*) p);
}
void free_ram(ram p) {
  gen_free((gen_chunk*) p);
}
ram check_ram(ram p) {
  return (ram) gen_check((gen_chunk*) p, ram_domain);
}
bool ram_consistent_p(ram p) {
  check_ram(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool ram_defined_p(ram p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_ram_cons(ram p, list l) {
  return gen_typed_cons(RAM_NEWGEN_DOMAIN, p, l);
}
void ram_assign_contents(ram r, ram v) {
  check_ram(r);
  check_ram(v);
  message_assert("defined references to domain ram",
                 ram_defined_p(r) && ram_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_ram_));
}
void ram_non_recursive_free(ram p) {
  // should clear up contents...
  free(p);
}
void write_ram(FILE* f, ram p) {
  gen_write(f, (gen_chunk*) p);
}
ram read_ram(FILE* f) {
  return (ram) gen_read(f);
}
ram make_ram(entity a1, entity a2, intptr_t a3, list a4) {
  return (ram) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, ram_domain, a1, a2, a3, a4);
}

/* RANGE
 */
range copy_range(range p) {
  return (range) gen_copy_tree((gen_chunk*) p);
}
void free_range(range p) {
  gen_free((gen_chunk*) p);
}
range check_range(range p) {
  return (range) gen_check((gen_chunk*) p, range_domain);
}
bool range_consistent_p(range p) {
  check_range(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool range_defined_p(range p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_range_cons(range p, list l) {
  return gen_typed_cons(RANGE_NEWGEN_DOMAIN, p, l);
}
void range_assign_contents(range r, range v) {
  check_range(r);
  check_range(v);
  message_assert("defined references to domain range",
                 range_defined_p(r) && range_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_range_));
}
void range_non_recursive_free(range p) {
  // should clear up contents...
  free(p);
}
void write_range(FILE* f, range p) {
  gen_write(f, (gen_chunk*) p);
}
range read_range(FILE* f) {
  return (range) gen_read(f);
}
range make_range(expression a1, expression a2, expression a3) {
  return (range) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, range_domain, a1, a2, a3);
}

/* REFERENCE
 */
reference copy_reference(reference p) {
  return (reference) gen_copy_tree((gen_chunk*) p);
}
void free_reference(reference p) {
  gen_free((gen_chunk*) p);
}
reference check_reference(reference p) {
  return (reference) gen_check((gen_chunk*) p, reference_domain);
}
bool reference_consistent_p(reference p) {
  check_reference(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool reference_defined_p(reference p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_reference_cons(reference p, list l) {
  return gen_typed_cons(REFERENCE_NEWGEN_DOMAIN, p, l);
}
void reference_assign_contents(reference r, reference v) {
  check_reference(r);
  check_reference(v);
  message_assert("defined references to domain reference",
                 reference_defined_p(r) && reference_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_reference_));
}
void reference_non_recursive_free(reference p) {
  // should clear up contents...
  free(p);
}
void write_reference(FILE* f, reference p) {
  gen_write(f, (gen_chunk*) p);
}
reference read_reference(FILE* f) {
  return (reference) gen_read(f);
}
reference make_reference(entity a1, list a2) {
  return (reference) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, reference_domain, a1, a2);
}

/* SEQUENCE
 */
sequence copy_sequence(sequence p) {
  return (sequence) gen_copy_tree((gen_chunk*) p);
}
void free_sequence(sequence p) {
  gen_free((gen_chunk*) p);
}
sequence check_sequence(sequence p) {
  return (sequence) gen_check((gen_chunk*) p, sequence_domain);
}
bool sequence_consistent_p(sequence p) {
  check_sequence(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool sequence_defined_p(sequence p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_sequence_cons(sequence p, list l) {
  return gen_typed_cons(SEQUENCE_NEWGEN_DOMAIN, p, l);
}
void sequence_assign_contents(sequence r, sequence v) {
  check_sequence(r);
  check_sequence(v);
  message_assert("defined references to domain sequence",
                 sequence_defined_p(r) && sequence_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_sequence_));
}
void sequence_non_recursive_free(sequence p) {
  // should clear up contents...
  free(p);
}
void write_sequence(FILE* f, sequence p) {
  gen_write(f, (gen_chunk*) p);
}
sequence read_sequence(FILE* f) {
  return (sequence) gen_read(f);
}
sequence make_sequence(list a) {
  return (sequence) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, sequence_domain, a);
}

/* SIZEOFEXPRESSION
 */
sizeofexpression copy_sizeofexpression(sizeofexpression p) {
  return (sizeofexpression) gen_copy_tree((gen_chunk*) p);
}
void free_sizeofexpression(sizeofexpression p) {
  gen_free((gen_chunk*) p);
}
sizeofexpression check_sizeofexpression(sizeofexpression p) {
  return (sizeofexpression) gen_check((gen_chunk*) p, sizeofexpression_domain);
}
bool sizeofexpression_consistent_p(sizeofexpression p) {
  check_sizeofexpression(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool sizeofexpression_defined_p(sizeofexpression p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_sizeofexpression_cons(sizeofexpression p, list l) {
  return gen_typed_cons(SIZEOFEXPRESSION_NEWGEN_DOMAIN, p, l);
}
void sizeofexpression_assign_contents(sizeofexpression r, sizeofexpression v) {
  check_sizeofexpression(r);
  check_sizeofexpression(v);
  message_assert("defined references to domain sizeofexpression",
                 sizeofexpression_defined_p(r) && sizeofexpression_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_sizeofexpression_));
}
void sizeofexpression_non_recursive_free(sizeofexpression p) {
  // should clear up contents...
  free(p);
}
void write_sizeofexpression(FILE* f, sizeofexpression p) {
  gen_write(f, (gen_chunk*) p);
}
sizeofexpression read_sizeofexpression(FILE* f) {
  return (sizeofexpression) gen_read(f);
}
string sizeofexpression_tag_as_string(enum sizeofexpression_utype tag) {
  switch (tag) {
  case is_sizeofexpression_type: return "type";
  case is_sizeofexpression_expression: return "expression";
  default: return string_undefined;
  }
}
sizeofexpression make_sizeofexpression(enum sizeofexpression_utype tag, void * val) {
  return (sizeofexpression) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, sizeofexpression_domain, tag, val);
}
sizeofexpression make_sizeofexpression_type(type _field_) {
  return make_sizeofexpression(is_sizeofexpression_type, (void*)(intptr_t) _field_);
}
sizeofexpression make_sizeofexpression_expression(expression _field_) {
  return make_sizeofexpression(is_sizeofexpression_expression, (void*)(intptr_t) _field_);
}

/* STATEMENT
 */
statement copy_statement(statement p) {
  return (statement) gen_copy_tree((gen_chunk*) p);
}
void free_statement(statement p) {
  gen_free((gen_chunk*) p);
}
statement check_statement(statement p) {
  return (statement) gen_check((gen_chunk*) p, statement_domain);
}
bool statement_consistent_p(statement p) {
  check_statement(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool statement_defined_p(statement p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_statement_cons(statement p, list l) {
  return gen_typed_cons(STATEMENT_NEWGEN_DOMAIN, p, l);
}
void statement_assign_contents(statement r, statement v) {
  check_statement(r);
  check_statement(v);
  message_assert("defined references to domain statement",
                 statement_defined_p(r) && statement_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_statement_));
}
void statement_non_recursive_free(statement p) {
  // should clear up contents...
  free(p);
}
void write_statement(FILE* f, statement p) {
  gen_write(f, (gen_chunk*) p);
}
statement read_statement(FILE* f) {
  return (statement) gen_read(f);
}
statement make_statement(entity a1, intptr_t a2, intptr_t a3, string a4, instruction a5, list a6, string a7, extensions a8, synchronization a9) {
  return (statement) gen_alloc(10*sizeof(gen_chunk), GEN_CHECK_ALLOC, statement_domain, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

/* STORAGE
 */
storage copy_storage(storage p) {
  return (storage) gen_copy_tree((gen_chunk*) p);
}
void free_storage(storage p) {
  gen_free((gen_chunk*) p);
}
storage check_storage(storage p) {
  return (storage) gen_check((gen_chunk*) p, storage_domain);
}
bool storage_consistent_p(storage p) {
  check_storage(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool storage_defined_p(storage p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_storage_cons(storage p, list l) {
  return gen_typed_cons(STORAGE_NEWGEN_DOMAIN, p, l);
}
void storage_assign_contents(storage r, storage v) {
  check_storage(r);
  check_storage(v);
  message_assert("defined references to domain storage",
                 storage_defined_p(r) && storage_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_storage_));
}
void storage_non_recursive_free(storage p) {
  // should clear up contents...
  free(p);
}
void write_storage(FILE* f, storage p) {
  gen_write(f, (gen_chunk*) p);
}
storage read_storage(FILE* f) {
  return (storage) gen_read(f);
}
string storage_tag_as_string(enum storage_utype tag) {
  switch (tag) {
  case is_storage_return: return "return";
  case is_storage_ram: return "ram";
  case is_storage_formal: return "formal";
  case is_storage_rom: return "rom";
  default: return string_undefined;
  }
}
storage make_storage(enum storage_utype tag, void * val) {
  return (storage) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, storage_domain, tag, val);
}
storage make_storage_return(entity _field_) {
  return make_storage(is_storage_return, (void*)(intptr_t) _field_);
}
storage make_storage_ram(ram _field_) {
  return make_storage(is_storage_ram, (void*)(intptr_t) _field_);
}
storage make_storage_formal(formal _field_) {
  return make_storage(is_storage_formal, (void*)(intptr_t) _field_);
}
storage make_storage_rom(void) {
  return make_storage(is_storage_rom, UU);
}

/* SUBSCRIPT
 */
subscript copy_subscript(subscript p) {
  return (subscript) gen_copy_tree((gen_chunk*) p);
}
void free_subscript(subscript p) {
  gen_free((gen_chunk*) p);
}
subscript check_subscript(subscript p) {
  return (subscript) gen_check((gen_chunk*) p, subscript_domain);
}
bool subscript_consistent_p(subscript p) {
  check_subscript(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool subscript_defined_p(subscript p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_subscript_cons(subscript p, list l) {
  return gen_typed_cons(SUBSCRIPT_NEWGEN_DOMAIN, p, l);
}
void subscript_assign_contents(subscript r, subscript v) {
  check_subscript(r);
  check_subscript(v);
  message_assert("defined references to domain subscript",
                 subscript_defined_p(r) && subscript_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_subscript_));
}
void subscript_non_recursive_free(subscript p) {
  // should clear up contents...
  free(p);
}
void write_subscript(FILE* f, subscript p) {
  gen_write(f, (gen_chunk*) p);
}
subscript read_subscript(FILE* f) {
  return (subscript) gen_read(f);
}
subscript make_subscript(expression a1, list a2) {
  return (subscript) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, subscript_domain, a1, a2);
}

/* SYMBOLIC
 */
symbolic copy_symbolic(symbolic p) {
  return (symbolic) gen_copy_tree((gen_chunk*) p);
}
void free_symbolic(symbolic p) {
  gen_free((gen_chunk*) p);
}
symbolic check_symbolic(symbolic p) {
  return (symbolic) gen_check((gen_chunk*) p, symbolic_domain);
}
bool symbolic_consistent_p(symbolic p) {
  check_symbolic(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool symbolic_defined_p(symbolic p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_symbolic_cons(symbolic p, list l) {
  return gen_typed_cons(SYMBOLIC_NEWGEN_DOMAIN, p, l);
}
void symbolic_assign_contents(symbolic r, symbolic v) {
  check_symbolic(r);
  check_symbolic(v);
  message_assert("defined references to domain symbolic",
                 symbolic_defined_p(r) && symbolic_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_symbolic_));
}
void symbolic_non_recursive_free(symbolic p) {
  // should clear up contents...
  free(p);
}
void write_symbolic(FILE* f, symbolic p) {
  gen_write(f, (gen_chunk*) p);
}
symbolic read_symbolic(FILE* f) {
  return (symbolic) gen_read(f);
}
symbolic make_symbolic(expression a1, constant a2) {
  return (symbolic) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, symbolic_domain, a1, a2);
}

/* SYNCHRONIZATION
 */
synchronization copy_synchronization(synchronization p) {
  return (synchronization) gen_copy_tree((gen_chunk*) p);
}
void free_synchronization(synchronization p) {
  gen_free((gen_chunk*) p);
}
synchronization check_synchronization(synchronization p) {
  return (synchronization) gen_check((gen_chunk*) p, synchronization_domain);
}
bool synchronization_consistent_p(synchronization p) {
  check_synchronization(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool synchronization_defined_p(synchronization p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_synchronization_cons(synchronization p, list l) {
  return gen_typed_cons(SYNCHRONIZATION_NEWGEN_DOMAIN, p, l);
}
void synchronization_assign_contents(synchronization r, synchronization v) {
  check_synchronization(r);
  check_synchronization(v);
  message_assert("defined references to domain synchronization",
                 synchronization_defined_p(r) && synchronization_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_synchronization_));
}
void synchronization_non_recursive_free(synchronization p) {
  // should clear up contents...
  free(p);
}
void write_synchronization(FILE* f, synchronization p) {
  gen_write(f, (gen_chunk*) p);
}
synchronization read_synchronization(FILE* f) {
  return (synchronization) gen_read(f);
}
string synchronization_tag_as_string(enum synchronization_utype tag) {
  switch (tag) {
  case is_synchronization_none: return "none";
  case is_synchronization_spawn: return "spawn";
  case is_synchronization_barrier: return "barrier";
  case is_synchronization_single: return "single";
  case is_synchronization_critical: return "critical";
  default: return string_undefined;
  }
}
synchronization make_synchronization(enum synchronization_utype tag, void * val) {
  return (synchronization) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, synchronization_domain, tag, val);
}
synchronization make_synchronization_none(void) {
  return make_synchronization(is_synchronization_none, UU);
}
synchronization make_synchronization_spawn(entity _field_) {
  return make_synchronization(is_synchronization_spawn, (void*)(intptr_t) _field_);
}
synchronization make_synchronization_barrier(void) {
  return make_synchronization(is_synchronization_barrier, UU);
}
synchronization make_synchronization_single(bool _field_) {
  return make_synchronization(is_synchronization_single, (void*)(intptr_t) _field_);
}
synchronization make_synchronization_critical(reference _field_) {
  return make_synchronization(is_synchronization_critical, (void*)(intptr_t) _field_);
}

/* SYNTAX
 */
syntax copy_syntax(syntax p) {
  return (syntax) gen_copy_tree((gen_chunk*) p);
}
void free_syntax(syntax p) {
  gen_free((gen_chunk*) p);
}
syntax check_syntax(syntax p) {
  return (syntax) gen_check((gen_chunk*) p, syntax_domain);
}
bool syntax_consistent_p(syntax p) {
  check_syntax(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool syntax_defined_p(syntax p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_syntax_cons(syntax p, list l) {
  return gen_typed_cons(SYNTAX_NEWGEN_DOMAIN, p, l);
}
void syntax_assign_contents(syntax r, syntax v) {
  check_syntax(r);
  check_syntax(v);
  message_assert("defined references to domain syntax",
                 syntax_defined_p(r) && syntax_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_syntax_));
}
void syntax_non_recursive_free(syntax p) {
  // should clear up contents...
  free(p);
}
void write_syntax(FILE* f, syntax p) {
  gen_write(f, (gen_chunk*) p);
}
syntax read_syntax(FILE* f) {
  return (syntax) gen_read(f);
}
string syntax_tag_as_string(enum syntax_utype tag) {
  switch (tag) {
  case is_syntax_reference: return "reference";
  case is_syntax_range: return "range";
  case is_syntax_call: return "call";
  case is_syntax_cast: return "cast";
  case is_syntax_sizeofexpression: return "sizeofexpression";
  case is_syntax_subscript: return "subscript";
  case is_syntax_application: return "application";
  case is_syntax_va_arg: return "va_arg";
  default: return string_undefined;
  }
}
syntax make_syntax(enum syntax_utype tag, void * val) {
  return (syntax) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, syntax_domain, tag, val);
}
syntax make_syntax_reference(reference _field_) {
  return make_syntax(is_syntax_reference, (void*)(intptr_t) _field_);
}
syntax make_syntax_range(range _field_) {
  return make_syntax(is_syntax_range, (void*)(intptr_t) _field_);
}
syntax make_syntax_call(call _field_) {
  return make_syntax(is_syntax_call, (void*)(intptr_t) _field_);
}
syntax make_syntax_cast(cast _field_) {
  return make_syntax(is_syntax_cast, (void*)(intptr_t) _field_);
}
syntax make_syntax_sizeofexpression(sizeofexpression _field_) {
  return make_syntax(is_syntax_sizeofexpression, (void*)(intptr_t) _field_);
}
syntax make_syntax_subscript(subscript _field_) {
  return make_syntax(is_syntax_subscript, (void*)(intptr_t) _field_);
}
syntax make_syntax_application(application _field_) {
  return make_syntax(is_syntax_application, (void*)(intptr_t) _field_);
}
syntax make_syntax_va_arg(list _field_) {
  return make_syntax(is_syntax_va_arg, (void*)(intptr_t) _field_);
}

/* ENTITY
 */
entity copy_entity(entity p) {
  return (entity) gen_copy_tree((gen_chunk*) p);
}
void free_entity(entity p) {
  gen_free((gen_chunk*) p);
}
entity check_entity(entity p) {
  return (entity) gen_check((gen_chunk*) p, entity_domain);
}
bool entity_consistent_p(entity p) {
  check_entity(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entity_defined_p(entity p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entity_cons(entity p, list l) {
  return gen_typed_cons(ENTITY_NEWGEN_DOMAIN, p, l);
}
void entity_assign_contents(entity r, entity v) {
  check_entity(r);
  check_entity(v);
  message_assert("defined references to domain entity",
                 entity_defined_p(r) && entity_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entity_));
}
void entity_non_recursive_free(entity p) {
  // should clear up contents...
  free(p);
}
entity gen_find_entity(char* s) {
  return (entity) gen_find_tabulated(s, entity_domain);
}
void write_tabulated_entity(FILE* f) {
  (void) gen_write_tabulated(f, entity_domain);
}
void read_tabulated_entity(FILE* f) {
  int domain = gen_read_tabulated(f, 0);
  if (domain!=entity_domain) {
    fprintf(stderr, "[newgen internal error]""inconsistent domain number for entity: %d (expecting %d)\n",
            domain, entity_domain);
    abort();
  }
}
entity make_entity(string a1, type a2, storage a3, value a4, intptr_t a5) {
  return (entity) gen_alloc(7*sizeof(gen_chunk), GEN_CHECK_ALLOC, entity_domain, a1, a2, a3, a4, a5);
}

/* TEST
 */
test copy_test(test p) {
  return (test) gen_copy_tree((gen_chunk*) p);
}
void free_test(test p) {
  gen_free((gen_chunk*) p);
}
test check_test(test p) {
  return (test) gen_check((gen_chunk*) p, test_domain);
}
bool test_consistent_p(test p) {
  check_test(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool test_defined_p(test p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_test_cons(test p, list l) {
  return gen_typed_cons(TEST_NEWGEN_DOMAIN, p, l);
}
void test_assign_contents(test r, test v) {
  check_test(r);
  check_test(v);
  message_assert("defined references to domain test",
                 test_defined_p(r) && test_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_test_));
}
void test_non_recursive_free(test p) {
  // should clear up contents...
  free(p);
}
void write_test(FILE* f, test p) {
  gen_write(f, (gen_chunk*) p);
}
test read_test(FILE* f) {
  return (test) gen_read(f);
}
test make_test(expression a1, statement a2, statement a3) {
  return (test) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, test_domain, a1, a2, a3);
}

/* TRANSFORMER
 */
transformer copy_transformer(transformer p) {
  return (transformer) gen_copy_tree((gen_chunk*) p);
}
void free_transformer(transformer p) {
  gen_free((gen_chunk*) p);
}
transformer check_transformer(transformer p) {
  return (transformer) gen_check((gen_chunk*) p, transformer_domain);
}
bool transformer_consistent_p(transformer p) {
  check_transformer(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool transformer_defined_p(transformer p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_transformer_cons(transformer p, list l) {
  return gen_typed_cons(TRANSFORMER_NEWGEN_DOMAIN, p, l);
}
void transformer_assign_contents(transformer r, transformer v) {
  check_transformer(r);
  check_transformer(v);
  message_assert("defined references to domain transformer",
                 transformer_defined_p(r) && transformer_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_transformer_));
}
void transformer_non_recursive_free(transformer p) {
  // should clear up contents...
  free(p);
}
void write_transformer(FILE* f, transformer p) {
  gen_write(f, (gen_chunk*) p);
}
transformer read_transformer(FILE* f) {
  return (transformer) gen_read(f);
}
transformer make_transformer(list a1, predicate a2) {
  return (transformer) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, transformer_domain, a1, a2);
}

/* TYPE
 */
type copy_type(type p) {
  return (type) gen_copy_tree((gen_chunk*) p);
}
void free_type(type p) {
  gen_free((gen_chunk*) p);
}
type check_type(type p) {
  return (type) gen_check((gen_chunk*) p, type_domain);
}
bool type_consistent_p(type p) {
  check_type(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool type_defined_p(type p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_type_cons(type p, list l) {
  return gen_typed_cons(TYPE_NEWGEN_DOMAIN, p, l);
}
void type_assign_contents(type r, type v) {
  check_type(r);
  check_type(v);
  message_assert("defined references to domain type",
                 type_defined_p(r) && type_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_type_));
}
void type_non_recursive_free(type p) {
  // should clear up contents...
  free(p);
}
void write_type(FILE* f, type p) {
  gen_write(f, (gen_chunk*) p);
}
type read_type(FILE* f) {
  return (type) gen_read(f);
}
string type_tag_as_string(enum type_utype tag) {
  switch (tag) {
  case is_type_statement: return "statement";
  case is_type_area: return "area";
  case is_type_variable: return "variable";
  case is_type_functional: return "functional";
  case is_type_varargs: return "varargs";
  case is_type_unknown: return "unknown";
  case is_type_void: return "void";
  case is_type_struct: return "struct";
  case is_type_union: return "union";
  case is_type_enum: return "enum";
  default: return string_undefined;
  }
}
type make_type(enum type_utype tag, void * val) {
  return (type) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, type_domain, tag, val);
}
type make_type_statement(void) {
  return make_type(is_type_statement, UU);
}
type make_type_area(area _field_) {
  return make_type(is_type_area, (void*)(intptr_t) _field_);
}
type make_type_variable(variable _field_) {
  return make_type(is_type_variable, (void*)(intptr_t) _field_);
}
type make_type_functional(functional _field_) {
  return make_type(is_type_functional, (void*)(intptr_t) _field_);
}
type make_type_varargs(type _field_) {
  return make_type(is_type_varargs, (void*)(intptr_t) _field_);
}
type make_type_unknown(void) {
  return make_type(is_type_unknown, UU);
}
type make_type_void(list _field_) {
  return make_type(is_type_void, (void*)(intptr_t) _field_);
}
type make_type_struct(list _field_) {
  return make_type(is_type_struct, (void*)(intptr_t) _field_);
}
type make_type_union(list _field_) {
  return make_type(is_type_union, (void*)(intptr_t) _field_);
}
type make_type_enum(list _field_) {
  return make_type(is_type_enum, (void*)(intptr_t) _field_);
}

/* UNSTRUCTURED
 */
unstructured copy_unstructured(unstructured p) {
  return (unstructured) gen_copy_tree((gen_chunk*) p);
}
void free_unstructured(unstructured p) {
  gen_free((gen_chunk*) p);
}
unstructured check_unstructured(unstructured p) {
  return (unstructured) gen_check((gen_chunk*) p, unstructured_domain);
}
bool unstructured_consistent_p(unstructured p) {
  check_unstructured(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool unstructured_defined_p(unstructured p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_unstructured_cons(unstructured p, list l) {
  return gen_typed_cons(UNSTRUCTURED_NEWGEN_DOMAIN, p, l);
}
void unstructured_assign_contents(unstructured r, unstructured v) {
  check_unstructured(r);
  check_unstructured(v);
  message_assert("defined references to domain unstructured",
                 unstructured_defined_p(r) && unstructured_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_unstructured_));
}
void unstructured_non_recursive_free(unstructured p) {
  // should clear up contents...
  free(p);
}
void write_unstructured(FILE* f, unstructured p) {
  gen_write(f, (gen_chunk*) p);
}
unstructured read_unstructured(FILE* f) {
  return (unstructured) gen_read(f);
}
unstructured make_unstructured(control a1, control a2) {
  return (unstructured) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, unstructured_domain, a1, a2);
}

/* VALUE
 */
value copy_value(value p) {
  return (value) gen_copy_tree((gen_chunk*) p);
}
void free_value(value p) {
  gen_free((gen_chunk*) p);
}
value check_value(value p) {
  return (value) gen_check((gen_chunk*) p, value_domain);
}
bool value_consistent_p(value p) {
  check_value(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool value_defined_p(value p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_value_cons(value p, list l) {
  return gen_typed_cons(VALUE_NEWGEN_DOMAIN, p, l);
}
void value_assign_contents(value r, value v) {
  check_value(r);
  check_value(v);
  message_assert("defined references to domain value",
                 value_defined_p(r) && value_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_value_));
}
void value_non_recursive_free(value p) {
  // should clear up contents...
  free(p);
}
void write_value(FILE* f, value p) {
  gen_write(f, (gen_chunk*) p);
}
value read_value(FILE* f) {
  return (value) gen_read(f);
}
string value_tag_as_string(enum value_utype tag) {
  switch (tag) {
  case is_value_code: return "code";
  case is_value_symbolic: return "symbolic";
  case is_value_constant: return "constant";
  case is_value_intrinsic: return "intrinsic";
  case is_value_unknown: return "unknown";
  case is_value_expression: return "expression";
  default: return string_undefined;
  }
}
value make_value(enum value_utype tag, void * val) {
  return (value) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, value_domain, tag, val);
}
value make_value_code(code _field_) {
  return make_value(is_value_code, (void*)(intptr_t) _field_);
}
value make_value_symbolic(symbolic _field_) {
  return make_value(is_value_symbolic, (void*)(intptr_t) _field_);
}
value make_value_constant(constant _field_) {
  return make_value(is_value_constant, (void*)(intptr_t) _field_);
}
value make_value_intrinsic(void) {
  return make_value(is_value_intrinsic, UU);
}
value make_value_unknown(void) {
  return make_value(is_value_unknown, UU);
}
value make_value_expression(expression _field_) {
  return make_value(is_value_expression, (void*)(intptr_t) _field_);
}

/* VARIABLE
 */
variable copy_variable(variable p) {
  return (variable) gen_copy_tree((gen_chunk*) p);
}
void free_variable(variable p) {
  gen_free((gen_chunk*) p);
}
variable check_variable(variable p) {
  return (variable) gen_check((gen_chunk*) p, variable_domain);
}
bool variable_consistent_p(variable p) {
  check_variable(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool variable_defined_p(variable p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_variable_cons(variable p, list l) {
  return gen_typed_cons(VARIABLE_NEWGEN_DOMAIN, p, l);
}
void variable_assign_contents(variable r, variable v) {
  check_variable(r);
  check_variable(v);
  message_assert("defined references to domain variable",
                 variable_defined_p(r) && variable_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_variable_));
}
void variable_non_recursive_free(variable p) {
  // should clear up contents...
  free(p);
}
void write_variable(FILE* f, variable p) {
  gen_write(f, (gen_chunk*) p);
}
variable read_variable(FILE* f) {
  return (variable) gen_read(f);
}
variable make_variable(basic a1, list a2, list a3) {
  return (variable) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, variable_domain, a1, a2, a3);
}

/* WHILELOOP
 */
whileloop copy_whileloop(whileloop p) {
  return (whileloop) gen_copy_tree((gen_chunk*) p);
}
void free_whileloop(whileloop p) {
  gen_free((gen_chunk*) p);
}
whileloop check_whileloop(whileloop p) {
  return (whileloop) gen_check((gen_chunk*) p, whileloop_domain);
}
bool whileloop_consistent_p(whileloop p) {
  check_whileloop(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool whileloop_defined_p(whileloop p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_whileloop_cons(whileloop p, list l) {
  return gen_typed_cons(WHILELOOP_NEWGEN_DOMAIN, p, l);
}
void whileloop_assign_contents(whileloop r, whileloop v) {
  check_whileloop(r);
  check_whileloop(v);
  message_assert("defined references to domain whileloop",
                 whileloop_defined_p(r) && whileloop_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_whileloop_));
}
void whileloop_non_recursive_free(whileloop p) {
  // should clear up contents...
  free(p);
}
void write_whileloop(FILE* f, whileloop p) {
  gen_write(f, (gen_chunk*) p);
}
whileloop read_whileloop(FILE* f) {
  return (whileloop) gen_read(f);
}
whileloop make_whileloop(expression a1, statement a2, entity a3, evaluation a4) {
  return (whileloop) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, whileloop_domain, a1, a2, a3, a4);
}

