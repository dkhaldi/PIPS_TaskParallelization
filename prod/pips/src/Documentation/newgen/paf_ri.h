#ifndef _newgen_paf_ri_included
#define _newgen_paf_ri_included
#define _gen_paf_ri_start 229
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_reference_domain_defined_)
#define _newgen_reference_domain_defined_
#define REFERENCE_NEWGEN_DOMAIN (reference_domain)
#define reference_NEWGEN_DOMAIN (reference_domain)
typedef struct _newgen_struct_reference_ * reference;
#endif /* _newgen_reference_domain_defined_ */

#if !defined(_newgen_predicate_domain_defined_)
#define _newgen_predicate_domain_defined_
#define PREDICATE_NEWGEN_DOMAIN (predicate_domain)
#define predicate_NEWGEN_DOMAIN (predicate_domain)
typedef struct _newgen_struct_predicate_ * predicate;
#endif /* _newgen_predicate_domain_defined_ */

#if !defined(_newgen_expression_domain_defined_)
#define _newgen_expression_domain_defined_
#define EXPRESSION_NEWGEN_DOMAIN (expression_domain)
#define expression_NEWGEN_DOMAIN (expression_domain)
typedef struct _newgen_struct_expression_ * expression;
#endif /* _newgen_expression_domain_defined_ */

#if !defined(_newgen_loop_domain_defined_)
#define _newgen_loop_domain_defined_
#define LOOP_NEWGEN_DOMAIN (loop_domain)
#define loop_NEWGEN_DOMAIN (loop_domain)
typedef struct _newgen_struct_loop_ * loop;
#endif /* _newgen_loop_domain_defined_ */

#if !defined(_newgen_statement_domain_defined_)
#define _newgen_statement_domain_defined_
#define STATEMENT_NEWGEN_DOMAIN (statement_domain)
#define statement_NEWGEN_DOMAIN (statement_domain)
typedef struct _newgen_struct_statement_ * statement;
#endif /* _newgen_statement_domain_defined_ */

#if !defined(_newgen_entity_domain_defined_)
#define _newgen_entity_domain_defined_
#define ENTITY_NEWGEN_DOMAIN (entity_domain)
#define entity_NEWGEN_DOMAIN (entity_domain)
typedef struct _newgen_struct_entity_ * entity;
#endif /* _newgen_entity_domain_defined_ */

#if !defined(_newgen_sccflags_domain_defined_)
#define _newgen_sccflags_domain_defined_
#define SCCFLAGS_NEWGEN_DOMAIN (sccflags_domain)
#define sccflags_NEWGEN_DOMAIN (sccflags_domain)
typedef struct _newgen_struct_sccflags_ * sccflags;
#endif /* _newgen_sccflags_domain_defined_ */

#if !defined(_newgen_Pvecteur_domain_defined_)
#define _newgen_Pvecteur_domain_defined_
#define newgen_Pvecteur(p) (p) /* old hack compatible */
#define PVECTEUR_NEWGEN_EXTERNAL (_gen_paf_ri_start+0)
#define PVECTEUR_NEWGEN_DOMAIN (PVECTEUR_NEWGEN_EXTERNAL)
#define Pvecteur_NEWGEN_DOMAIN (PVECTEUR_NEWGEN_EXTERNAL)
#endif /* _newgen_Pvecteur_domain_defined_ */

#define bdt_domain (_gen_paf_ri_start+1)
#if !defined(_newgen_bdt_domain_defined_)
#define _newgen_bdt_domain_defined_
#define BDT_NEWGEN_DOMAIN (bdt_domain)
#define bdt_NEWGEN_DOMAIN (bdt_domain)
typedef struct _newgen_struct_bdt_ * bdt;
#endif /* _newgen_bdt_domain_defined_ */

#define communication_domain (_gen_paf_ri_start+2)
#if !defined(_newgen_communication_domain_defined_)
#define _newgen_communication_domain_defined_
#define COMMUNICATION_NEWGEN_DOMAIN (communication_domain)
#define communication_NEWGEN_DOMAIN (communication_domain)
typedef struct _newgen_struct_communication_ * communication;
#endif /* _newgen_communication_domain_defined_ */

#define conditional_domain (_gen_paf_ri_start+3)
#if !defined(_newgen_conditional_domain_defined_)
#define _newgen_conditional_domain_defined_
#define CONDITIONAL_NEWGEN_DOMAIN (conditional_domain)
#define conditional_NEWGEN_DOMAIN (conditional_domain)
typedef struct _newgen_struct_conditional_ * conditional;
#endif /* _newgen_conditional_domain_defined_ */

#define dataflow_domain (_gen_paf_ri_start+4)
#if !defined(_newgen_dataflow_domain_defined_)
#define _newgen_dataflow_domain_defined_
#define DATAFLOW_NEWGEN_DOMAIN (dataflow_domain)
#define dataflow_NEWGEN_DOMAIN (dataflow_domain)
typedef struct _newgen_struct_dataflow_ * dataflow;
#endif /* _newgen_dataflow_domain_defined_ */

#define dfg_arc_label_domain (_gen_paf_ri_start+5)
#if !defined(_newgen_dfg_arc_label_domain_defined_)
#define _newgen_dfg_arc_label_domain_defined_
#define DFG_ARC_LABEL_NEWGEN_DOMAIN (dfg_arc_label_domain)
#define dfg_arc_label_NEWGEN_DOMAIN (dfg_arc_label_domain)
typedef struct _newgen_struct_dfg_arc_label_ * dfg_arc_label;
#endif /* _newgen_dfg_arc_label_domain_defined_ */

#define dfg_vertex_label_domain (_gen_paf_ri_start+6)
#if !defined(_newgen_dfg_vertex_label_domain_defined_)
#define _newgen_dfg_vertex_label_domain_defined_
#define DFG_VERTEX_LABEL_NEWGEN_DOMAIN (dfg_vertex_label_domain)
#define dfg_vertex_label_NEWGEN_DOMAIN (dfg_vertex_label_domain)
typedef struct _newgen_struct_dfg_vertex_label_ * dfg_vertex_label;
#endif /* _newgen_dfg_vertex_label_domain_defined_ */

#define leaf_label_domain (_gen_paf_ri_start+7)
#if !defined(_newgen_leaf_label_domain_defined_)
#define _newgen_leaf_label_domain_defined_
#define LEAF_LABEL_NEWGEN_DOMAIN (leaf_label_domain)
#define leaf_label_NEWGEN_DOMAIN (leaf_label_domain)
typedef struct _newgen_struct_leaf_label_ * leaf_label;
#endif /* _newgen_leaf_label_domain_defined_ */

#define lisp_expression_domain (_gen_paf_ri_start+8)
#if !defined(_newgen_lisp_expression_domain_defined_)
#define _newgen_lisp_expression_domain_defined_
#define LISP_EXPRESSION_NEWGEN_DOMAIN (lisp_expression_domain)
#define lisp_expression_NEWGEN_DOMAIN (lisp_expression_domain)
typedef struct _newgen_struct_lisp_expression_ * lisp_expression;
#endif /* _newgen_lisp_expression_domain_defined_ */

#define placement_domain (_gen_paf_ri_start+9)
#if !defined(_newgen_placement_domain_defined_)
#define _newgen_placement_domain_defined_
#define PLACEMENT_NEWGEN_DOMAIN (placement_domain)
#define placement_NEWGEN_DOMAIN (placement_domain)
typedef struct _newgen_struct_placement_ * placement;
#endif /* _newgen_placement_domain_defined_ */

#define plc_domain (_gen_paf_ri_start+10)
#if !defined(_newgen_plc_domain_defined_)
#define _newgen_plc_domain_defined_
#define PLC_NEWGEN_DOMAIN (plc_domain)
#define plc_NEWGEN_DOMAIN (plc_domain)
typedef struct _newgen_struct_plc_ * plc;
#endif /* _newgen_plc_domain_defined_ */

#define quast_leaf_domain (_gen_paf_ri_start+11)
#if !defined(_newgen_quast_leaf_domain_defined_)
#define _newgen_quast_leaf_domain_defined_
#define QUAST_LEAF_NEWGEN_DOMAIN (quast_leaf_domain)
#define quast_leaf_NEWGEN_DOMAIN (quast_leaf_domain)
typedef struct _newgen_struct_quast_leaf_ * quast_leaf;
#endif /* _newgen_quast_leaf_domain_defined_ */

#define quast_domain (_gen_paf_ri_start+12)
#if !defined(_newgen_quast_domain_defined_)
#define _newgen_quast_domain_defined_
#define QUAST_NEWGEN_DOMAIN (quast_domain)
#define quast_NEWGEN_DOMAIN (quast_domain)
typedef struct _newgen_struct_quast_ * quast;
#endif /* _newgen_quast_domain_defined_ */

#define quast_value_domain (_gen_paf_ri_start+13)
#if !defined(_newgen_quast_value_domain_defined_)
#define _newgen_quast_value_domain_defined_
#define QUAST_VALUE_NEWGEN_DOMAIN (quast_value_domain)
#define quast_value_NEWGEN_DOMAIN (quast_value_domain)
typedef struct _newgen_struct_quast_value_ * quast_value;
#endif /* _newgen_quast_value_domain_defined_ */

#define schedule_domain (_gen_paf_ri_start+14)
#if !defined(_newgen_schedule_domain_defined_)
#define _newgen_schedule_domain_defined_
#define SCHEDULE_NEWGEN_DOMAIN (schedule_domain)
#define schedule_NEWGEN_DOMAIN (schedule_domain)
typedef struct _newgen_struct_schedule_ * schedule;
#endif /* _newgen_schedule_domain_defined_ */

#define static_control_domain (_gen_paf_ri_start+15)
#if !defined(_newgen_static_control_domain_defined_)
#define _newgen_static_control_domain_defined_
#define STATIC_CONTROL_NEWGEN_DOMAIN (static_control_domain)
#define static_control_NEWGEN_DOMAIN (static_control_domain)
typedef struct _newgen_struct_static_control_ * static_control;
#endif /* _newgen_static_control_domain_defined_ */

#define var_val_domain (_gen_paf_ri_start+16)
#if !defined(_newgen_var_val_domain_defined_)
#define _newgen_var_val_domain_defined_
#define VAR_VAL_NEWGEN_DOMAIN (var_val_domain)
#define var_val_NEWGEN_DOMAIN (var_val_domain)
typedef struct _newgen_struct_var_val_ * var_val;
#endif /* _newgen_var_val_domain_defined_ */


/* BDT
 */
#define BDT(x) ((bdt)((x).p))
#define bdt_CAST(x) BDT(x)
#define BDT_CAST(x) BDT(x)
#define BDT_(x) ((x).e)
#define BDT_TYPE bdt
#define bdt_TYPE bdt
#define bdt_undefined ((bdt)gen_chunk_undefined)
#define bdt_undefined_p(x) ((x)==bdt_undefined)

extern bdt copy_bdt(bdt);
extern void free_bdt(bdt);
extern bdt check_bdt(bdt);
extern bool bdt_consistent_p(bdt);
extern bool bdt_defined_p(bdt);
#define gen_BDT_cons gen_bdt_cons
extern list gen_bdt_cons(bdt, list);
extern void bdt_assign_contents(bdt, bdt);
extern void bdt_non_recursive_free(bdt);
extern void write_bdt(FILE*, bdt);
extern bdt read_bdt(FILE*);
extern bdt make_bdt(list);

struct _newgen_struct_bdt_ {
  intptr_t _type_;
  list _bdt_holder_;
};

#define bdt_domain_number(x) ((x)->_type_)
#define bdt_schedules(x) ((x)->_bdt_holder_)

/* COMMUNICATION
 */
#define COMMUNICATION(x) ((communication)((x).p))
#define communication_CAST(x) COMMUNICATION(x)
#define COMMUNICATION_CAST(x) COMMUNICATION(x)
#define COMMUNICATION_(x) ((x).e)
#define COMMUNICATION_TYPE communication
#define communication_TYPE communication
#define communication_undefined ((communication)gen_chunk_undefined)
#define communication_undefined_p(x) ((x)==communication_undefined)

extern communication copy_communication(communication);
extern void free_communication(communication);
extern communication check_communication(communication);
extern bool communication_consistent_p(communication);
extern bool communication_defined_p(communication);
#define gen_COMMUNICATION_cons gen_communication_cons
extern list gen_communication_cons(communication, list);
extern void communication_assign_contents(communication, communication);
extern void communication_non_recursive_free(communication);
extern void write_communication(FILE*, communication);
extern communication read_communication(FILE*);
extern communication make_communication(predicate, predicate, predicate);

struct _newgen_struct_communication_ {
  intptr_t _type_;
  predicate _communication_broadcast_; /* broadcast:predicate */
  predicate _communication_reduction_; /* reduction:predicate */
  predicate _communication_shift_; /* shift:predicate */
};

#define communication_domain_number(x) ((x)->_type_)
#define communication_broadcast_(x) communication_broadcast(x) /* old hack compatible */
#define communication_broadcast(x) ((x)->_communication_broadcast_)
#define communication_reduction_(x) communication_reduction(x) /* old hack compatible */
#define communication_reduction(x) ((x)->_communication_reduction_)
#define communication_shift_(x) communication_shift(x) /* old hack compatible */
#define communication_shift(x) ((x)->_communication_shift_)

/* CONDITIONAL
 */
#define CONDITIONAL(x) ((conditional)((x).p))
#define conditional_CAST(x) CONDITIONAL(x)
#define CONDITIONAL_CAST(x) CONDITIONAL(x)
#define CONDITIONAL_(x) ((x).e)
#define CONDITIONAL_TYPE conditional
#define conditional_TYPE conditional
#define conditional_undefined ((conditional)gen_chunk_undefined)
#define conditional_undefined_p(x) ((x)==conditional_undefined)

extern conditional copy_conditional(conditional);
extern void free_conditional(conditional);
extern conditional check_conditional(conditional);
extern bool conditional_consistent_p(conditional);
extern bool conditional_defined_p(conditional);
#define gen_CONDITIONAL_cons gen_conditional_cons
extern list gen_conditional_cons(conditional, list);
extern void conditional_assign_contents(conditional, conditional);
extern void conditional_non_recursive_free(conditional);
extern void write_conditional(FILE*, conditional);
extern conditional read_conditional(FILE*);
extern conditional make_conditional(predicate, quast, quast);

struct _newgen_struct_conditional_ {
  intptr_t _type_;
  predicate _conditional_predicate_; /* predicate:predicate */
  quast _conditional_true_quast_; /* true_quast:quast */
  quast _conditional_false_quast_; /* false_quast:quast */
};

#define conditional_domain_number(x) ((x)->_type_)
#define conditional_predicate_(x) conditional_predicate(x) /* old hack compatible */
#define conditional_predicate(x) ((x)->_conditional_predicate_)
#define conditional_true_quast_(x) conditional_true_quast(x) /* old hack compatible */
#define conditional_true_quast(x) ((x)->_conditional_true_quast_)
#define conditional_false_quast_(x) conditional_false_quast(x) /* old hack compatible */
#define conditional_false_quast(x) ((x)->_conditional_false_quast_)

/* DATAFLOW
 */
#define DATAFLOW(x) ((dataflow)((x).p))
#define dataflow_CAST(x) DATAFLOW(x)
#define DATAFLOW_CAST(x) DATAFLOW(x)
#define DATAFLOW_(x) ((x).e)
#define DATAFLOW_TYPE dataflow
#define dataflow_TYPE dataflow
#define dataflow_undefined ((dataflow)gen_chunk_undefined)
#define dataflow_undefined_p(x) ((x)==dataflow_undefined)

extern dataflow copy_dataflow(dataflow);
extern void free_dataflow(dataflow);
extern dataflow check_dataflow(dataflow);
extern bool dataflow_consistent_p(dataflow);
extern bool dataflow_defined_p(dataflow);
#define gen_DATAFLOW_cons gen_dataflow_cons
extern list gen_dataflow_cons(dataflow, list);
extern void dataflow_assign_contents(dataflow, dataflow);
extern void dataflow_non_recursive_free(dataflow);
extern void write_dataflow(FILE*, dataflow);
extern dataflow read_dataflow(FILE*);
extern dataflow make_dataflow(reference, list, predicate, communication);

struct _newgen_struct_dataflow_ {
  intptr_t _type_;
  reference _dataflow_reference_; /* reference:reference */
  list _dataflow_transformation_; /* transformation:expression* */
  predicate _dataflow_governing_pred_; /* governing_pred:predicate */
  communication _dataflow_communication_; /* communication:communication */
};

#define dataflow_domain_number(x) ((x)->_type_)
#define dataflow_reference_(x) dataflow_reference(x) /* old hack compatible */
#define dataflow_reference(x) ((x)->_dataflow_reference_)
#define dataflow_transformation_(x) dataflow_transformation(x) /* old hack compatible */
#define dataflow_transformation(x) ((x)->_dataflow_transformation_)
#define dataflow_governing_pred_(x) dataflow_governing_pred(x) /* old hack compatible */
#define dataflow_governing_pred(x) ((x)->_dataflow_governing_pred_)
#define dataflow_communication_(x) dataflow_communication(x) /* old hack compatible */
#define dataflow_communication(x) ((x)->_dataflow_communication_)

/* DFG_ARC_LABEL
 */
#define DFG_ARC_LABEL(x) ((dfg_arc_label)((x).p))
#define dfg_arc_label_CAST(x) DFG_ARC_LABEL(x)
#define DFG_ARC_LABEL_CAST(x) DFG_ARC_LABEL(x)
#define DFG_ARC_LABEL_(x) ((x).e)
#define DFG_ARC_LABEL_TYPE dfg_arc_label
#define dfg_arc_label_TYPE dfg_arc_label
#define dfg_arc_label_undefined ((dfg_arc_label)gen_chunk_undefined)
#define dfg_arc_label_undefined_p(x) ((x)==dfg_arc_label_undefined)

extern dfg_arc_label copy_dfg_arc_label(dfg_arc_label);
extern void free_dfg_arc_label(dfg_arc_label);
extern dfg_arc_label check_dfg_arc_label(dfg_arc_label);
extern bool dfg_arc_label_consistent_p(dfg_arc_label);
extern bool dfg_arc_label_defined_p(dfg_arc_label);
#define gen_DFG_ARC_LABEL_cons gen_dfg_arc_label_cons
extern list gen_dfg_arc_label_cons(dfg_arc_label, list);
extern void dfg_arc_label_assign_contents(dfg_arc_label, dfg_arc_label);
extern void dfg_arc_label_non_recursive_free(dfg_arc_label);
extern void write_dfg_arc_label(FILE*, dfg_arc_label);
extern dfg_arc_label read_dfg_arc_label(FILE*);
extern dfg_arc_label make_dfg_arc_label(list);

struct _newgen_struct_dfg_arc_label_ {
  intptr_t _type_;
  list _dfg_arc_label_holder_;
};

#define dfg_arc_label_domain_number(x) ((x)->_type_)
#define dfg_arc_label_dataflows(x) ((x)->_dfg_arc_label_holder_)

/* DFG_VERTEX_LABEL
 */
#define DFG_VERTEX_LABEL(x) ((dfg_vertex_label)((x).p))
#define dfg_vertex_label_CAST(x) DFG_VERTEX_LABEL(x)
#define DFG_VERTEX_LABEL_CAST(x) DFG_VERTEX_LABEL(x)
#define DFG_VERTEX_LABEL_(x) ((x).e)
#define DFG_VERTEX_LABEL_TYPE dfg_vertex_label
#define dfg_vertex_label_TYPE dfg_vertex_label
#define dfg_vertex_label_undefined ((dfg_vertex_label)gen_chunk_undefined)
#define dfg_vertex_label_undefined_p(x) ((x)==dfg_vertex_label_undefined)

extern dfg_vertex_label copy_dfg_vertex_label(dfg_vertex_label);
extern void free_dfg_vertex_label(dfg_vertex_label);
extern dfg_vertex_label check_dfg_vertex_label(dfg_vertex_label);
extern bool dfg_vertex_label_consistent_p(dfg_vertex_label);
extern bool dfg_vertex_label_defined_p(dfg_vertex_label);
#define gen_DFG_VERTEX_LABEL_cons gen_dfg_vertex_label_cons
extern list gen_dfg_vertex_label_cons(dfg_vertex_label, list);
extern void dfg_vertex_label_assign_contents(dfg_vertex_label, dfg_vertex_label);
extern void dfg_vertex_label_non_recursive_free(dfg_vertex_label);
extern void write_dfg_vertex_label(FILE*, dfg_vertex_label);
extern dfg_vertex_label read_dfg_vertex_label(FILE*);
extern dfg_vertex_label make_dfg_vertex_label(intptr_t, predicate, sccflags);

struct _newgen_struct_dfg_vertex_label_ {
  intptr_t _type_;
  intptr_t _dfg_vertex_label_statement_; /* statement:int */
  predicate _dfg_vertex_label_exec_domain_; /* exec_domain:predicate */
  sccflags _dfg_vertex_label_sccflags_; /* sccflags:sccflags */
};

#define dfg_vertex_label_domain_number(x) ((x)->_type_)
#define dfg_vertex_label_statement_(x) dfg_vertex_label_statement(x) /* old hack compatible */
#define dfg_vertex_label_statement(x) ((x)->_dfg_vertex_label_statement_)
#define dfg_vertex_label_exec_domain_(x) dfg_vertex_label_exec_domain(x) /* old hack compatible */
#define dfg_vertex_label_exec_domain(x) ((x)->_dfg_vertex_label_exec_domain_)
#define dfg_vertex_label_sccflags_(x) dfg_vertex_label_sccflags(x) /* old hack compatible */
#define dfg_vertex_label_sccflags(x) ((x)->_dfg_vertex_label_sccflags_)

/* LEAF_LABEL
 */
#define LEAF_LABEL(x) ((leaf_label)((x).p))
#define leaf_label_CAST(x) LEAF_LABEL(x)
#define LEAF_LABEL_CAST(x) LEAF_LABEL(x)
#define LEAF_LABEL_(x) ((x).e)
#define LEAF_LABEL_TYPE leaf_label
#define leaf_label_TYPE leaf_label
#define leaf_label_undefined ((leaf_label)gen_chunk_undefined)
#define leaf_label_undefined_p(x) ((x)==leaf_label_undefined)

extern leaf_label copy_leaf_label(leaf_label);
extern void free_leaf_label(leaf_label);
extern leaf_label check_leaf_label(leaf_label);
extern bool leaf_label_consistent_p(leaf_label);
extern bool leaf_label_defined_p(leaf_label);
#define gen_LEAF_LABEL_cons gen_leaf_label_cons
extern list gen_leaf_label_cons(leaf_label, list);
extern void leaf_label_assign_contents(leaf_label, leaf_label);
extern void leaf_label_non_recursive_free(leaf_label);
extern void write_leaf_label(FILE*, leaf_label);
extern leaf_label read_leaf_label(FILE*);
extern leaf_label make_leaf_label(intptr_t, intptr_t);

struct _newgen_struct_leaf_label_ {
  intptr_t _type_;
  intptr_t _leaf_label_statement_; /* statement:int */
  intptr_t _leaf_label_depth_; /* depth:int */
};

#define leaf_label_domain_number(x) ((x)->_type_)
#define leaf_label_statement_(x) leaf_label_statement(x) /* old hack compatible */
#define leaf_label_statement(x) ((x)->_leaf_label_statement_)
#define leaf_label_depth_(x) leaf_label_depth(x) /* old hack compatible */
#define leaf_label_depth(x) ((x)->_leaf_label_depth_)

/* LISP_EXPRESSION
 */
#define LISP_EXPRESSION(x) ((lisp_expression)((x).p))
#define lisp_expression_CAST(x) LISP_EXPRESSION(x)
#define LISP_EXPRESSION_CAST(x) LISP_EXPRESSION(x)
#define LISP_EXPRESSION_(x) ((x).e)
#define LISP_EXPRESSION_TYPE lisp_expression
#define lisp_expression_TYPE lisp_expression
#define lisp_expression_undefined ((lisp_expression)gen_chunk_undefined)
#define lisp_expression_undefined_p(x) ((x)==lisp_expression_undefined)

extern lisp_expression copy_lisp_expression(lisp_expression);
extern void free_lisp_expression(lisp_expression);
extern lisp_expression check_lisp_expression(lisp_expression);
extern bool lisp_expression_consistent_p(lisp_expression);
extern bool lisp_expression_defined_p(lisp_expression);
#define gen_LISP_EXPRESSION_cons gen_lisp_expression_cons
extern list gen_lisp_expression_cons(lisp_expression, list);
extern void lisp_expression_assign_contents(lisp_expression, lisp_expression);
extern void lisp_expression_non_recursive_free(lisp_expression);
extern void write_lisp_expression(FILE*, lisp_expression);
extern lisp_expression read_lisp_expression(FILE*);
extern lisp_expression make_lisp_expression(string, list);

struct _newgen_struct_lisp_expression_ {
  intptr_t _type_;
  string _lisp_expression_operation_; /* operation:string */
  list _lisp_expression_args_; /* args:expression* */
};

#define lisp_expression_domain_number(x) ((x)->_type_)
#define lisp_expression_operation_(x) lisp_expression_operation(x) /* old hack compatible */
#define lisp_expression_operation(x) ((x)->_lisp_expression_operation_)
#define lisp_expression_args_(x) lisp_expression_args(x) /* old hack compatible */
#define lisp_expression_args(x) ((x)->_lisp_expression_args_)

/* PLACEMENT
 */
#define PLACEMENT(x) ((placement)((x).p))
#define placement_CAST(x) PLACEMENT(x)
#define PLACEMENT_CAST(x) PLACEMENT(x)
#define PLACEMENT_(x) ((x).e)
#define PLACEMENT_TYPE placement
#define placement_TYPE placement
#define placement_undefined ((placement)gen_chunk_undefined)
#define placement_undefined_p(x) ((x)==placement_undefined)

extern placement copy_placement(placement);
extern void free_placement(placement);
extern placement check_placement(placement);
extern bool placement_consistent_p(placement);
extern bool placement_defined_p(placement);
#define gen_PLACEMENT_cons gen_placement_cons
extern list gen_placement_cons(placement, list);
extern void placement_assign_contents(placement, placement);
extern void placement_non_recursive_free(placement);
extern void write_placement(FILE*, placement);
extern placement read_placement(FILE*);
extern placement make_placement(intptr_t, list);

struct _newgen_struct_placement_ {
  intptr_t _type_;
  intptr_t _placement_statement_; /* statement:int */
  list _placement_dims_; /* dims:expression* */
};

#define placement_domain_number(x) ((x)->_type_)
#define placement_statement_(x) placement_statement(x) /* old hack compatible */
#define placement_statement(x) ((x)->_placement_statement_)
#define placement_dims_(x) placement_dims(x) /* old hack compatible */
#define placement_dims(x) ((x)->_placement_dims_)

/* PLC
 */
#define PLC(x) ((plc)((x).p))
#define plc_CAST(x) PLC(x)
#define PLC_CAST(x) PLC(x)
#define PLC_(x) ((x).e)
#define PLC_TYPE plc
#define plc_TYPE plc
#define plc_undefined ((plc)gen_chunk_undefined)
#define plc_undefined_p(x) ((x)==plc_undefined)

extern plc copy_plc(plc);
extern void free_plc(plc);
extern plc check_plc(plc);
extern bool plc_consistent_p(plc);
extern bool plc_defined_p(plc);
#define gen_PLC_cons gen_plc_cons
extern list gen_plc_cons(plc, list);
extern void plc_assign_contents(plc, plc);
extern void plc_non_recursive_free(plc);
extern void write_plc(FILE*, plc);
extern plc read_plc(FILE*);
extern plc make_plc(list);

struct _newgen_struct_plc_ {
  intptr_t _type_;
  list _plc_holder_;
};

#define plc_domain_number(x) ((x)->_type_)
#define plc_placements(x) ((x)->_plc_holder_)

/* QUAST_LEAF
 */
#define QUAST_LEAF(x) ((quast_leaf)((x).p))
#define quast_leaf_CAST(x) QUAST_LEAF(x)
#define QUAST_LEAF_CAST(x) QUAST_LEAF(x)
#define QUAST_LEAF_(x) ((x).e)
#define QUAST_LEAF_TYPE quast_leaf
#define quast_leaf_TYPE quast_leaf
#define quast_leaf_undefined ((quast_leaf)gen_chunk_undefined)
#define quast_leaf_undefined_p(x) ((x)==quast_leaf_undefined)

extern quast_leaf copy_quast_leaf(quast_leaf);
extern void free_quast_leaf(quast_leaf);
extern quast_leaf check_quast_leaf(quast_leaf);
extern bool quast_leaf_consistent_p(quast_leaf);
extern bool quast_leaf_defined_p(quast_leaf);
#define gen_QUAST_LEAF_cons gen_quast_leaf_cons
extern list gen_quast_leaf_cons(quast_leaf, list);
extern void quast_leaf_assign_contents(quast_leaf, quast_leaf);
extern void quast_leaf_non_recursive_free(quast_leaf);
extern void write_quast_leaf(FILE*, quast_leaf);
extern quast_leaf read_quast_leaf(FILE*);
extern quast_leaf make_quast_leaf(list, leaf_label);

struct _newgen_struct_quast_leaf_ {
  intptr_t _type_;
  list _quast_leaf_solution_; /* solution:expression* */
  leaf_label _quast_leaf_leaf_label_; /* leaf_label:leaf_label */
};

#define quast_leaf_domain_number(x) ((x)->_type_)
#define quast_leaf_solution_(x) quast_leaf_solution(x) /* old hack compatible */
#define quast_leaf_solution(x) ((x)->_quast_leaf_solution_)
#define quast_leaf_leaf_label_(x) quast_leaf_leaf_label(x) /* old hack compatible */
#define quast_leaf_leaf_label(x) ((x)->_quast_leaf_leaf_label_)

/* QUAST
 */
#define QUAST(x) ((quast)((x).p))
#define quast_CAST(x) QUAST(x)
#define QUAST_CAST(x) QUAST(x)
#define QUAST_(x) ((x).e)
#define QUAST_TYPE quast
#define quast_TYPE quast
#define quast_undefined ((quast)gen_chunk_undefined)
#define quast_undefined_p(x) ((x)==quast_undefined)

extern quast copy_quast(quast);
extern void free_quast(quast);
extern quast check_quast(quast);
extern bool quast_consistent_p(quast);
extern bool quast_defined_p(quast);
#define gen_QUAST_cons gen_quast_cons
extern list gen_quast_cons(quast, list);
extern void quast_assign_contents(quast, quast);
extern void quast_non_recursive_free(quast);
extern void write_quast(FILE*, quast);
extern quast read_quast(FILE*);
extern quast make_quast(quast_value, list);

struct _newgen_struct_quast_ {
  intptr_t _type_;
  quast_value _quast_quast_value_; /* quast_value:quast_value */
  list _quast_newparms_; /* newparms:var_val* */
};

#define quast_domain_number(x) ((x)->_type_)
#define quast_quast_value_(x) quast_quast_value(x) /* old hack compatible */
#define quast_quast_value(x) ((x)->_quast_quast_value_)
#define quast_newparms_(x) quast_newparms(x) /* old hack compatible */
#define quast_newparms(x) ((x)->_quast_newparms_)

/* QUAST_VALUE
 */
#define QUAST_VALUE(x) ((quast_value)((x).p))
#define quast_value_CAST(x) QUAST_VALUE(x)
#define QUAST_VALUE_CAST(x) QUAST_VALUE(x)
#define QUAST_VALUE_(x) ((x).e)
#define QUAST_VALUE_TYPE quast_value
#define quast_value_TYPE quast_value
#define quast_value_undefined ((quast_value)gen_chunk_undefined)
#define quast_value_undefined_p(x) ((x)==quast_value_undefined)

extern quast_value copy_quast_value(quast_value);
extern void free_quast_value(quast_value);
extern quast_value check_quast_value(quast_value);
extern bool quast_value_consistent_p(quast_value);
extern bool quast_value_defined_p(quast_value);
#define gen_QUAST_VALUE_cons gen_quast_value_cons
extern list gen_quast_value_cons(quast_value, list);
extern void quast_value_assign_contents(quast_value, quast_value);
extern void quast_value_non_recursive_free(quast_value);
extern void write_quast_value(FILE*, quast_value);
extern quast_value read_quast_value(FILE*);
enum quast_value_utype {
  is_quast_value_quast_leaf,
  is_quast_value_conditional
};
extern string quast_value_tag_as_string(enum quast_value_utype);
extern quast_value make_quast_value(enum quast_value_utype, void *);
extern quast_value make_quast_value_quast_leaf(quast_leaf);
extern quast_value make_quast_value_conditional(conditional);

struct _newgen_struct_quast_value_ {
  intptr_t _type_;
  enum quast_value_utype _quast_value_tag__;
  union {
    quast_leaf _quast_value_quast_leaf_; /* quast_leaf:quast_leaf */
    conditional _quast_value_conditional_; /* conditional:conditional */
  } _quast_value_union_;
};

#define quast_value_domain_number(x) ((x)->_type_)
#define quast_value_tag(x) ((x)->_quast_value_tag__)
#define quast_value_quast_leaf_p(x) (quast_value_tag(x)==is_quast_value_quast_leaf)
#define quast_value_quast_leaf_(x) quast_value_quast_leaf(x) /* old hack compatible */
#define quast_value_quast_leaf(x) ((x)->_quast_value_union_._quast_value_quast_leaf_)
#define quast_value_conditional_p(x) (quast_value_tag(x)==is_quast_value_conditional)
#define quast_value_conditional_(x) quast_value_conditional(x) /* old hack compatible */
#define quast_value_conditional(x) ((x)->_quast_value_union_._quast_value_conditional_)

/* SCHEDULE
 */
#define SCHEDULE(x) ((schedule)((x).p))
#define schedule_CAST(x) SCHEDULE(x)
#define SCHEDULE_CAST(x) SCHEDULE(x)
#define SCHEDULE_(x) ((x).e)
#define SCHEDULE_TYPE schedule
#define schedule_TYPE schedule
#define schedule_undefined ((schedule)gen_chunk_undefined)
#define schedule_undefined_p(x) ((x)==schedule_undefined)

extern schedule copy_schedule(schedule);
extern void free_schedule(schedule);
extern schedule check_schedule(schedule);
extern bool schedule_consistent_p(schedule);
extern bool schedule_defined_p(schedule);
#define gen_SCHEDULE_cons gen_schedule_cons
extern list gen_schedule_cons(schedule, list);
extern void schedule_assign_contents(schedule, schedule);
extern void schedule_non_recursive_free(schedule);
extern void write_schedule(FILE*, schedule);
extern schedule read_schedule(FILE*);
extern schedule make_schedule(intptr_t, predicate, list);

struct _newgen_struct_schedule_ {
  intptr_t _type_;
  intptr_t _schedule_statement_; /* statement:int */
  predicate _schedule_predicate_; /* predicate:predicate */
  list _schedule_dims_; /* dims:expression* */
};

#define schedule_domain_number(x) ((x)->_type_)
#define schedule_statement_(x) schedule_statement(x) /* old hack compatible */
#define schedule_statement(x) ((x)->_schedule_statement_)
#define schedule_predicate_(x) schedule_predicate(x) /* old hack compatible */
#define schedule_predicate(x) ((x)->_schedule_predicate_)
#define schedule_dims_(x) schedule_dims(x) /* old hack compatible */
#define schedule_dims(x) ((x)->_schedule_dims_)

/* STATIC_CONTROL
 */
#define STATIC_CONTROL(x) ((static_control)((x).p))
#define static_control_CAST(x) STATIC_CONTROL(x)
#define STATIC_CONTROL_CAST(x) STATIC_CONTROL(x)
#define STATIC_CONTROL_(x) ((x).e)
#define STATIC_CONTROL_TYPE static_control
#define static_control_TYPE static_control
#define static_control_undefined ((static_control)gen_chunk_undefined)
#define static_control_undefined_p(x) ((x)==static_control_undefined)

extern static_control copy_static_control(static_control);
extern void free_static_control(static_control);
extern static_control check_static_control(static_control);
extern bool static_control_consistent_p(static_control);
extern bool static_control_defined_p(static_control);
#define gen_STATIC_CONTROL_cons gen_static_control_cons
extern list gen_static_control_cons(static_control, list);
extern void static_control_assign_contents(static_control, static_control);
extern void static_control_non_recursive_free(static_control);
extern void write_static_control(FILE*, static_control);
extern static_control read_static_control(FILE*);
extern static_control make_static_control(bool, list, list, list);

struct _newgen_struct_static_control_ {
  intptr_t _type_;
  gen_chunk _static_control_yes_; /* yes:bool */
  list _static_control_params_; /* params:entity* */
  list _static_control_loops_; /* loops:loop* */
  list _static_control_tests_; /* tests:expression* */
};

#define static_control_domain_number(x) ((x)->_type_)
#define static_control_yes_(x) static_control_yes(x) /* old hack compatible */
#define static_control_yes(x) ((x)->_static_control_yes_.b)
#define static_control_params_(x) static_control_params(x) /* old hack compatible */
#define static_control_params(x) ((x)->_static_control_params_)
#define static_control_loops_(x) static_control_loops(x) /* old hack compatible */
#define static_control_loops(x) ((x)->_static_control_loops_)
#define static_control_tests_(x) static_control_tests(x) /* old hack compatible */
#define static_control_tests(x) ((x)->_static_control_tests_)

/* VAR_VAL
 */
#define VAR_VAL(x) ((var_val)((x).p))
#define var_val_CAST(x) VAR_VAL(x)
#define VAR_VAL_CAST(x) VAR_VAL(x)
#define VAR_VAL_(x) ((x).e)
#define VAR_VAL_TYPE var_val
#define var_val_TYPE var_val
#define var_val_undefined ((var_val)gen_chunk_undefined)
#define var_val_undefined_p(x) ((x)==var_val_undefined)

extern var_val copy_var_val(var_val);
extern void free_var_val(var_val);
extern var_val check_var_val(var_val);
extern bool var_val_consistent_p(var_val);
extern bool var_val_defined_p(var_val);
#define gen_VAR_VAL_cons gen_var_val_cons
extern list gen_var_val_cons(var_val, list);
extern void var_val_assign_contents(var_val, var_val);
extern void var_val_non_recursive_free(var_val);
extern void write_var_val(FILE*, var_val);
extern var_val read_var_val(FILE*);
extern var_val make_var_val(entity, expression);

struct _newgen_struct_var_val_ {
  intptr_t _type_;
  entity _var_val_variable_; /* variable:entity */
  expression _var_val_value_; /* value:expression */
};

#define var_val_domain_number(x) ((x)->_type_)
#define var_val_variable_(x) var_val_variable(x) /* old hack compatible */
#define var_val_variable(x) ((x)->_var_val_variable_)
#define var_val_value_(x) var_val_value(x) /* old hack compatible */
#define var_val_value(x) ((x)->_var_val_value_)

#define paf_ri_spec "\
--NEWGEN-START 229\n\
import reference from \"ri.newgen\";\n\
import predicate from \"ri.newgen\";\n\
import expression from \"ri.newgen\";\n\
import loop from \"ri.newgen\";\n\
import statement from \"ri.newgen\";\n\
import entity from \"ri.newgen\";\n\
import sccflags from \"dg.newgen\";\n\
external Pvecteur;\n\
bdt = schedules:schedule*;\n\
communication = broadcast:predicate x reduction:predicate x shift:predicate;\n\
conditional = predicate:predicate x true_quast:quast x false_quast:quast;\n\
dataflow = reference:reference x transformation:expression* x governing_pred:predicate x communication:communication;\n\
dfg_arc_label = dataflows:dataflow*;\n\
dfg_vertex_label = statement:int x exec_domain:predicate x sccflags:sccflags;\n\
leaf_label = statement:int x depth:int;\n\
lisp_expression = operation:string x args:expression*;\n\
placement = statement:int x dims:expression*;\n\
plc = placements:placement*;\n\
quast_leaf = solution:expression* x leaf_label:leaf_label;\n\
quast = quast_value:quast_value x newparms:var_val*;\n\
quast_value = quast_leaf:quast_leaf + conditional:conditional;\n\
schedule = statement:int x predicate:predicate x dims:expression*;\n\
static_control = yes:bool x params:entity* x loops:loop* x tests:expression*;\n\
var_val = variable:entity x value:expression;\n\
"
#endif
