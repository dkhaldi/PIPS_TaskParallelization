/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "hpf_private.h"

/* ALIGNMAP
 */
alignmap copy_alignmap(alignmap p) {
  return (alignmap) gen_copy_tree((gen_chunk*) p);
}
void free_alignmap(alignmap p) {
  gen_free((gen_chunk*) p);
}
alignmap check_alignmap(alignmap p) {
  return (alignmap) gen_check((gen_chunk*) p, alignmap_domain);
}
bool alignmap_consistent_p(alignmap p) {
  check_alignmap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool alignmap_defined_p(alignmap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_alignmap_cons(alignmap p, list l) {
  return gen_typed_cons(ALIGNMAP_NEWGEN_DOMAIN, p, l);
}
void alignmap_assign_contents(alignmap r, alignmap v) {
  check_alignmap(r);
  check_alignmap(v);
  message_assert("defined references to domain alignmap",
                 alignmap_defined_p(r) && alignmap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_alignmap_));
}
void alignmap_non_recursive_free(alignmap p) {
  // should clear up contents...
  free(p);
}
void write_alignmap(FILE* f, alignmap p) {
  gen_write(f, (gen_chunk*) p);
}
alignmap read_alignmap(FILE* f) {
  return (alignmap) gen_read(f);
}
alignmap make_alignmap(void) {
  return (alignmap) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, alignmap_domain);
}
align apply_alignmap(alignmap f, entity k) {
  return (align) (intptr_t)HASH_GET(p, p, alignmap_hash_table(f), k);
}
void update_alignmap(alignmap f, entity k, align v) {
  HASH_UPDATE(p, p, alignmap_hash_table(f), k, (intptr_t)v);
}
void extend_alignmap(alignmap f, entity k, align v) {
  HASH_EXTEND(p, p, alignmap_hash_table(f), k, (intptr_t)v);
}
align delete_alignmap(alignmap f, entity k) {
  return (align)(intptr_t) HASH_DELETE(p, p, alignmap_hash_table(f), k);
}
bool bound_alignmap_p(alignmap f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, alignmap_hash_table(f), k);
}

/* DATA_STATUS
 */
data_status copy_data_status(data_status p) {
  return (data_status) gen_copy_tree((gen_chunk*) p);
}
void free_data_status(data_status p) {
  gen_free((gen_chunk*) p);
}
data_status check_data_status(data_status p) {
  return (data_status) gen_check((gen_chunk*) p, data_status_domain);
}
bool data_status_consistent_p(data_status p) {
  check_data_status(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool data_status_defined_p(data_status p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_data_status_cons(data_status p, list l) {
  return gen_typed_cons(DATA_STATUS_NEWGEN_DOMAIN, p, l);
}
void data_status_assign_contents(data_status r, data_status v) {
  check_data_status(r);
  check_data_status(v);
  message_assert("defined references to domain data_status",
                 data_status_defined_p(r) && data_status_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_data_status_));
}
void data_status_non_recursive_free(data_status p) {
  // should clear up contents...
  free(p);
}
void write_data_status(FILE* f, data_status p) {
  gen_write(f, (gen_chunk*) p);
}
data_status read_data_status(FILE* f) {
  return (data_status) gen_read(f);
}
data_status make_data_status(newdeclmap a1, alignmap a2, distributemap a3, list a4, list a5, list a6) {
  return (data_status) gen_alloc(7*sizeof(gen_chunk), GEN_CHECK_ALLOC, data_status_domain, a1, a2, a3, a4, a5, a6);
}

/* DISTRIBUTEMAP
 */
distributemap copy_distributemap(distributemap p) {
  return (distributemap) gen_copy_tree((gen_chunk*) p);
}
void free_distributemap(distributemap p) {
  gen_free((gen_chunk*) p);
}
distributemap check_distributemap(distributemap p) {
  return (distributemap) gen_check((gen_chunk*) p, distributemap_domain);
}
bool distributemap_consistent_p(distributemap p) {
  check_distributemap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool distributemap_defined_p(distributemap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_distributemap_cons(distributemap p, list l) {
  return gen_typed_cons(DISTRIBUTEMAP_NEWGEN_DOMAIN, p, l);
}
void distributemap_assign_contents(distributemap r, distributemap v) {
  check_distributemap(r);
  check_distributemap(v);
  message_assert("defined references to domain distributemap",
                 distributemap_defined_p(r) && distributemap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_distributemap_));
}
void distributemap_non_recursive_free(distributemap p) {
  // should clear up contents...
  free(p);
}
void write_distributemap(FILE* f, distributemap p) {
  gen_write(f, (gen_chunk*) p);
}
distributemap read_distributemap(FILE* f) {
  return (distributemap) gen_read(f);
}
distributemap make_distributemap(void) {
  return (distributemap) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, distributemap_domain);
}
distribute apply_distributemap(distributemap f, entity k) {
  return (distribute) (intptr_t)HASH_GET(p, p, distributemap_hash_table(f), k);
}
void update_distributemap(distributemap f, entity k, distribute v) {
  HASH_UPDATE(p, p, distributemap_hash_table(f), k, (intptr_t)v);
}
void extend_distributemap(distributemap f, entity k, distribute v) {
  HASH_EXTEND(p, p, distributemap_hash_table(f), k, (intptr_t)v);
}
distribute delete_distributemap(distributemap f, entity k) {
  return (distribute)(intptr_t) HASH_DELETE(p, p, distributemap_hash_table(f), k);
}
bool bound_distributemap_p(distributemap f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, distributemap_hash_table(f), k);
}

/* DYNAMIC_STATUS
 */
dynamic_status copy_dynamic_status(dynamic_status p) {
  return (dynamic_status) gen_copy_tree((gen_chunk*) p);
}
void free_dynamic_status(dynamic_status p) {
  gen_free((gen_chunk*) p);
}
dynamic_status check_dynamic_status(dynamic_status p) {
  return (dynamic_status) gen_check((gen_chunk*) p, dynamic_status_domain);
}
bool dynamic_status_consistent_p(dynamic_status p) {
  check_dynamic_status(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dynamic_status_defined_p(dynamic_status p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dynamic_status_cons(dynamic_status p, list l) {
  return gen_typed_cons(DYNAMIC_STATUS_NEWGEN_DOMAIN, p, l);
}
void dynamic_status_assign_contents(dynamic_status r, dynamic_status v) {
  check_dynamic_status(r);
  check_dynamic_status(v);
  message_assert("defined references to domain dynamic_status",
                 dynamic_status_defined_p(r) && dynamic_status_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dynamic_status_));
}
void dynamic_status_non_recursive_free(dynamic_status p) {
  // should clear up contents...
  free(p);
}
void write_dynamic_status(FILE* f, dynamic_status p) {
  gen_write(f, (gen_chunk*) p);
}
dynamic_status read_dynamic_status(FILE* f) {
  return (dynamic_status) gen_read(f);
}
dynamic_status make_dynamic_status(entity_entities a1, entitymap a2, statement_renamings a3, statement_entities a4) {
  return (dynamic_status) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, dynamic_status_domain, a1, a2, a3, a4);
}

/* ENTITIES
 */
entities copy_entities(entities p) {
  return (entities) gen_copy_tree((gen_chunk*) p);
}
void free_entities(entities p) {
  gen_free((gen_chunk*) p);
}
entities check_entities(entities p) {
  return (entities) gen_check((gen_chunk*) p, entities_domain);
}
bool entities_consistent_p(entities p) {
  check_entities(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entities_defined_p(entities p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entities_cons(entities p, list l) {
  return gen_typed_cons(ENTITIES_NEWGEN_DOMAIN, p, l);
}
void entities_assign_contents(entities r, entities v) {
  check_entities(r);
  check_entities(v);
  message_assert("defined references to domain entities",
                 entities_defined_p(r) && entities_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entities_));
}
void entities_non_recursive_free(entities p) {
  // should clear up contents...
  free(p);
}
void write_entities(FILE* f, entities p) {
  gen_write(f, (gen_chunk*) p);
}
entities read_entities(FILE* f) {
  return (entities) gen_read(f);
}
entities make_entities(list a) {
  return (entities) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, entities_domain, a);
}

/* ENTITY_ENTITIES
 */
entity_entities copy_entity_entities(entity_entities p) {
  return (entity_entities) gen_copy_tree((gen_chunk*) p);
}
void free_entity_entities(entity_entities p) {
  gen_free((gen_chunk*) p);
}
entity_entities check_entity_entities(entity_entities p) {
  return (entity_entities) gen_check((gen_chunk*) p, entity_entities_domain);
}
bool entity_entities_consistent_p(entity_entities p) {
  check_entity_entities(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entity_entities_defined_p(entity_entities p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entity_entities_cons(entity_entities p, list l) {
  return gen_typed_cons(ENTITY_ENTITIES_NEWGEN_DOMAIN, p, l);
}
void entity_entities_assign_contents(entity_entities r, entity_entities v) {
  check_entity_entities(r);
  check_entity_entities(v);
  message_assert("defined references to domain entity_entities",
                 entity_entities_defined_p(r) && entity_entities_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entity_entities_));
}
void entity_entities_non_recursive_free(entity_entities p) {
  // should clear up contents...
  free(p);
}
void write_entity_entities(FILE* f, entity_entities p) {
  gen_write(f, (gen_chunk*) p);
}
entity_entities read_entity_entities(FILE* f) {
  return (entity_entities) gen_read(f);
}
entity_entities make_entity_entities(void) {
  return (entity_entities) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, entity_entities_domain);
}
entities apply_entity_entities(entity_entities f, entity k) {
  return (entities) (intptr_t)HASH_GET(p, p, entity_entities_hash_table(f), k);
}
void update_entity_entities(entity_entities f, entity k, entities v) {
  HASH_UPDATE(p, p, entity_entities_hash_table(f), k, (intptr_t)v);
}
void extend_entity_entities(entity_entities f, entity k, entities v) {
  HASH_EXTEND(p, p, entity_entities_hash_table(f), k, (intptr_t)v);
}
entities delete_entity_entities(entity_entities f, entity k) {
  return (entities)(intptr_t) HASH_DELETE(p, p, entity_entities_hash_table(f), k);
}
bool bound_entity_entities_p(entity_entities f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, entity_entities_hash_table(f), k);
}

/* ENTITYMAP
 */
entitymap copy_entitymap(entitymap p) {
  return (entitymap) gen_copy_tree((gen_chunk*) p);
}
void free_entitymap(entitymap p) {
  gen_free((gen_chunk*) p);
}
entitymap check_entitymap(entitymap p) {
  return (entitymap) gen_check((gen_chunk*) p, entitymap_domain);
}
bool entitymap_consistent_p(entitymap p) {
  check_entitymap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entitymap_defined_p(entitymap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entitymap_cons(entitymap p, list l) {
  return gen_typed_cons(ENTITYMAP_NEWGEN_DOMAIN, p, l);
}
void entitymap_assign_contents(entitymap r, entitymap v) {
  check_entitymap(r);
  check_entitymap(v);
  message_assert("defined references to domain entitymap",
                 entitymap_defined_p(r) && entitymap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entitymap_));
}
void entitymap_non_recursive_free(entitymap p) {
  // should clear up contents...
  free(p);
}
void write_entitymap(FILE* f, entitymap p) {
  gen_write(f, (gen_chunk*) p);
}
entitymap read_entitymap(FILE* f) {
  return (entitymap) gen_read(f);
}
entitymap make_entitymap(void) {
  return (entitymap) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, entitymap_domain);
}
entity apply_entitymap(entitymap f, entity k) {
  return (entity) (intptr_t)HASH_GET(p, p, entitymap_hash_table(f), k);
}
void update_entitymap(entitymap f, entity k, entity v) {
  HASH_UPDATE(p, p, entitymap_hash_table(f), k, (intptr_t)v);
}
void extend_entitymap(entitymap f, entity k, entity v) {
  HASH_EXTEND(p, p, entitymap_hash_table(f), k, (intptr_t)v);
}
entity delete_entitymap(entitymap f, entity k) {
  return (entity)(intptr_t) HASH_DELETE(p, p, entitymap_hash_table(f), k);
}
bool bound_entitymap_p(entitymap f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, entitymap_hash_table(f), k);
}

/* ENTITY_STATUS
 */
entity_status copy_entity_status(entity_status p) {
  return (entity_status) gen_copy_tree((gen_chunk*) p);
}
void free_entity_status(entity_status p) {
  gen_free((gen_chunk*) p);
}
entity_status check_entity_status(entity_status p) {
  return (entity_status) gen_check((gen_chunk*) p, entity_status_domain);
}
bool entity_status_consistent_p(entity_status p) {
  check_entity_status(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entity_status_defined_p(entity_status p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entity_status_cons(entity_status p, list l) {
  return gen_typed_cons(ENTITY_STATUS_NEWGEN_DOMAIN, p, l);
}
void entity_status_assign_contents(entity_status r, entity_status v) {
  check_entity_status(r);
  check_entity_status(v);
  message_assert("defined references to domain entity_status",
                 entity_status_defined_p(r) && entity_status_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entity_status_));
}
void entity_status_non_recursive_free(entity_status p) {
  // should clear up contents...
  free(p);
}
void write_entity_status(FILE* f, entity_status p) {
  gen_write(f, (gen_chunk*) p);
}
entity_status read_entity_status(FILE* f) {
  return (entity_status) gen_read(f);
}
entity_status make_entity_status(entitymap a1, entitymap a2, entitymap a3, entitymap a4, entity_int a5) {
  return (entity_status) gen_alloc(6*sizeof(gen_chunk), GEN_CHECK_ALLOC, entity_status_domain, a1, a2, a3, a4, a5);
}

/* HPFC_REDUCTIONS
 */
hpfc_reductions copy_hpfc_reductions(hpfc_reductions p) {
  return (hpfc_reductions) gen_copy_tree((gen_chunk*) p);
}
void free_hpfc_reductions(hpfc_reductions p) {
  gen_free((gen_chunk*) p);
}
hpfc_reductions check_hpfc_reductions(hpfc_reductions p) {
  return (hpfc_reductions) gen_check((gen_chunk*) p, hpfc_reductions_domain);
}
bool hpfc_reductions_consistent_p(hpfc_reductions p) {
  check_hpfc_reductions(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool hpfc_reductions_defined_p(hpfc_reductions p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_hpfc_reductions_cons(hpfc_reductions p, list l) {
  return gen_typed_cons(HPFC_REDUCTIONS_NEWGEN_DOMAIN, p, l);
}
void hpfc_reductions_assign_contents(hpfc_reductions r, hpfc_reductions v) {
  check_hpfc_reductions(r);
  check_hpfc_reductions(v);
  message_assert("defined references to domain hpfc_reductions",
                 hpfc_reductions_defined_p(r) && hpfc_reductions_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_hpfc_reductions_));
}
void hpfc_reductions_non_recursive_free(hpfc_reductions p) {
  // should clear up contents...
  free(p);
}
void write_hpfc_reductions(FILE* f, hpfc_reductions p) {
  gen_write(f, (gen_chunk*) p);
}
hpfc_reductions read_hpfc_reductions(FILE* f) {
  return (hpfc_reductions) gen_read(f);
}
hpfc_reductions make_hpfc_reductions(entity a1, entity a2, reduction_operator a3) {
  return (hpfc_reductions) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, hpfc_reductions_domain, a1, a2, a3);
}

/* HPFC_STATUS
 */
hpfc_status copy_hpfc_status(hpfc_status p) {
  return (hpfc_status) gen_copy_tree((gen_chunk*) p);
}
void free_hpfc_status(hpfc_status p) {
  gen_free((gen_chunk*) p);
}
hpfc_status check_hpfc_status(hpfc_status p) {
  return (hpfc_status) gen_check((gen_chunk*) p, hpfc_status_domain);
}
bool hpfc_status_consistent_p(hpfc_status p) {
  check_hpfc_status(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool hpfc_status_defined_p(hpfc_status p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_hpfc_status_cons(hpfc_status p, list l) {
  return gen_typed_cons(HPFC_STATUS_NEWGEN_DOMAIN, p, l);
}
void hpfc_status_assign_contents(hpfc_status r, hpfc_status v) {
  check_hpfc_status(r);
  check_hpfc_status(v);
  message_assert("defined references to domain hpfc_status",
                 hpfc_status_defined_p(r) && hpfc_status_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_hpfc_status_));
}
void hpfc_status_non_recursive_free(hpfc_status p) {
  // should clear up contents...
  free(p);
}
void write_hpfc_status(FILE* f, hpfc_status p) {
  gen_write(f, (gen_chunk*) p);
}
hpfc_status read_hpfc_status(FILE* f) {
  return (hpfc_status) gen_read(f);
}
hpfc_status make_hpfc_status(overlapsmap a1, data_status a2, numbers_status a3, entity_status a4, list a5, dynamic_status a6, list a7, list a8, list a9, statement_entities a10) {
  return (hpfc_status) gen_alloc(11*sizeof(gen_chunk), GEN_CHECK_ALLOC, hpfc_status_domain, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

/* HPF_NEWDECL
 */
hpf_newdecl copy_hpf_newdecl(hpf_newdecl p) {
  return (hpf_newdecl) gen_copy_tree((gen_chunk*) p);
}
void free_hpf_newdecl(hpf_newdecl p) {
  gen_free((gen_chunk*) p);
}
hpf_newdecl check_hpf_newdecl(hpf_newdecl p) {
  return (hpf_newdecl) gen_check((gen_chunk*) p, hpf_newdecl_domain);
}
bool hpf_newdecl_consistent_p(hpf_newdecl p) {
  check_hpf_newdecl(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool hpf_newdecl_defined_p(hpf_newdecl p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_hpf_newdecl_cons(hpf_newdecl p, list l) {
  return gen_typed_cons(HPF_NEWDECL_NEWGEN_DOMAIN, p, l);
}
void hpf_newdecl_assign_contents(hpf_newdecl r, hpf_newdecl v) {
  check_hpf_newdecl(r);
  check_hpf_newdecl(v);
  message_assert("defined references to domain hpf_newdecl",
                 hpf_newdecl_defined_p(r) && hpf_newdecl_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_hpf_newdecl_));
}
void hpf_newdecl_non_recursive_free(hpf_newdecl p) {
  // should clear up contents...
  free(p);
}
void write_hpf_newdecl(FILE* f, hpf_newdecl p) {
  gen_write(f, (gen_chunk*) p);
}
hpf_newdecl read_hpf_newdecl(FILE* f) {
  return (hpf_newdecl) gen_read(f);
}
string hpf_newdecl_tag_as_string(enum hpf_newdecl_utype tag) {
  switch (tag) {
  case is_hpf_newdecl_none: return "none";
  case is_hpf_newdecl_alpha: return "alpha";
  case is_hpf_newdecl_beta: return "beta";
  case is_hpf_newdecl_gamma: return "gamma";
  case is_hpf_newdecl_delta: return "delta";
  default: return string_undefined;
  }
}
hpf_newdecl make_hpf_newdecl(enum hpf_newdecl_utype tag, void * val) {
  return (hpf_newdecl) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, hpf_newdecl_domain, tag, val);
}
hpf_newdecl make_hpf_newdecl_none(void) {
  return make_hpf_newdecl(is_hpf_newdecl_none, UU);
}
hpf_newdecl make_hpf_newdecl_alpha(void) {
  return make_hpf_newdecl(is_hpf_newdecl_alpha, UU);
}
hpf_newdecl make_hpf_newdecl_beta(void) {
  return make_hpf_newdecl(is_hpf_newdecl_beta, UU);
}
hpf_newdecl make_hpf_newdecl_gamma(void) {
  return make_hpf_newdecl(is_hpf_newdecl_gamma, UU);
}
hpf_newdecl make_hpf_newdecl_delta(void) {
  return make_hpf_newdecl(is_hpf_newdecl_delta, UU);
}

/* HPF_NEWDECLS
 */
hpf_newdecls copy_hpf_newdecls(hpf_newdecls p) {
  return (hpf_newdecls) gen_copy_tree((gen_chunk*) p);
}
void free_hpf_newdecls(hpf_newdecls p) {
  gen_free((gen_chunk*) p);
}
hpf_newdecls check_hpf_newdecls(hpf_newdecls p) {
  return (hpf_newdecls) gen_check((gen_chunk*) p, hpf_newdecls_domain);
}
bool hpf_newdecls_consistent_p(hpf_newdecls p) {
  check_hpf_newdecls(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool hpf_newdecls_defined_p(hpf_newdecls p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_hpf_newdecls_cons(hpf_newdecls p, list l) {
  return gen_typed_cons(HPF_NEWDECLS_NEWGEN_DOMAIN, p, l);
}
void hpf_newdecls_assign_contents(hpf_newdecls r, hpf_newdecls v) {
  check_hpf_newdecls(r);
  check_hpf_newdecls(v);
  message_assert("defined references to domain hpf_newdecls",
                 hpf_newdecls_defined_p(r) && hpf_newdecls_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_hpf_newdecls_));
}
void hpf_newdecls_non_recursive_free(hpf_newdecls p) {
  // should clear up contents...
  free(p);
}
void write_hpf_newdecls(FILE* f, hpf_newdecls p) {
  gen_write(f, (gen_chunk*) p);
}
hpf_newdecls read_hpf_newdecls(FILE* f) {
  return (hpf_newdecls) gen_read(f);
}
hpf_newdecls make_hpf_newdecls(list a) {
  return (hpf_newdecls) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, hpf_newdecls_domain, a);
}

/* NEWDECLMAP
 */
newdeclmap copy_newdeclmap(newdeclmap p) {
  return (newdeclmap) gen_copy_tree((gen_chunk*) p);
}
void free_newdeclmap(newdeclmap p) {
  gen_free((gen_chunk*) p);
}
newdeclmap check_newdeclmap(newdeclmap p) {
  return (newdeclmap) gen_check((gen_chunk*) p, newdeclmap_domain);
}
bool newdeclmap_consistent_p(newdeclmap p) {
  check_newdeclmap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool newdeclmap_defined_p(newdeclmap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_newdeclmap_cons(newdeclmap p, list l) {
  return gen_typed_cons(NEWDECLMAP_NEWGEN_DOMAIN, p, l);
}
void newdeclmap_assign_contents(newdeclmap r, newdeclmap v) {
  check_newdeclmap(r);
  check_newdeclmap(v);
  message_assert("defined references to domain newdeclmap",
                 newdeclmap_defined_p(r) && newdeclmap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_newdeclmap_));
}
void newdeclmap_non_recursive_free(newdeclmap p) {
  // should clear up contents...
  free(p);
}
void write_newdeclmap(FILE* f, newdeclmap p) {
  gen_write(f, (gen_chunk*) p);
}
newdeclmap read_newdeclmap(FILE* f) {
  return (newdeclmap) gen_read(f);
}
newdeclmap make_newdeclmap(void) {
  return (newdeclmap) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, newdeclmap_domain);
}
hpf_newdecls apply_newdeclmap(newdeclmap f, entity k) {
  return (hpf_newdecls) (intptr_t)HASH_GET(p, p, newdeclmap_hash_table(f), k);
}
void update_newdeclmap(newdeclmap f, entity k, hpf_newdecls v) {
  HASH_UPDATE(p, p, newdeclmap_hash_table(f), k, (intptr_t)v);
}
void extend_newdeclmap(newdeclmap f, entity k, hpf_newdecls v) {
  HASH_EXTEND(p, p, newdeclmap_hash_table(f), k, (intptr_t)v);
}
hpf_newdecls delete_newdeclmap(newdeclmap f, entity k) {
  return (hpf_newdecls)(intptr_t) HASH_DELETE(p, p, newdeclmap_hash_table(f), k);
}
bool bound_newdeclmap_p(newdeclmap f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, newdeclmap_hash_table(f), k);
}

/* NUMBERS_STATUS
 */
numbers_status copy_numbers_status(numbers_status p) {
  return (numbers_status) gen_copy_tree((gen_chunk*) p);
}
void free_numbers_status(numbers_status p) {
  gen_free((gen_chunk*) p);
}
numbers_status check_numbers_status(numbers_status p) {
  return (numbers_status) gen_check((gen_chunk*) p, numbers_status_domain);
}
bool numbers_status_consistent_p(numbers_status p) {
  check_numbers_status(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool numbers_status_defined_p(numbers_status p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_numbers_status_cons(numbers_status p, list l) {
  return gen_typed_cons(NUMBERS_STATUS_NEWGEN_DOMAIN, p, l);
}
void numbers_status_assign_contents(numbers_status r, numbers_status v) {
  check_numbers_status(r);
  check_numbers_status(v);
  message_assert("defined references to domain numbers_status",
                 numbers_status_defined_p(r) && numbers_status_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_numbers_status_));
}
void numbers_status_non_recursive_free(numbers_status p) {
  // should clear up contents...
  free(p);
}
void write_numbers_status(FILE* f, numbers_status p) {
  gen_write(f, (gen_chunk*) p);
}
numbers_status read_numbers_status(FILE* f) {
  return (numbers_status) gen_read(f);
}
numbers_status make_numbers_status(entity_int a1, intptr_t a2, intptr_t a3, intptr_t a4) {
  return (numbers_status) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, numbers_status_domain, a1, a2, a3, a4);
}

/* OVERLAP
 */
overlap copy_overlap(overlap p) {
  return (overlap) gen_copy_tree((gen_chunk*) p);
}
void free_overlap(overlap p) {
  gen_free((gen_chunk*) p);
}
overlap check_overlap(overlap p) {
  return (overlap) gen_check((gen_chunk*) p, overlap_domain);
}
bool overlap_consistent_p(overlap p) {
  check_overlap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool overlap_defined_p(overlap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_overlap_cons(overlap p, list l) {
  return gen_typed_cons(OVERLAP_NEWGEN_DOMAIN, p, l);
}
void overlap_assign_contents(overlap r, overlap v) {
  check_overlap(r);
  check_overlap(v);
  message_assert("defined references to domain overlap",
                 overlap_defined_p(r) && overlap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_overlap_));
}
void overlap_non_recursive_free(overlap p) {
  // should clear up contents...
  free(p);
}
void write_overlap(FILE* f, overlap p) {
  gen_write(f, (gen_chunk*) p);
}
overlap read_overlap(FILE* f) {
  return (overlap) gen_read(f);
}
overlap make_overlap(intptr_t a1, intptr_t a2) {
  return (overlap) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, overlap_domain, a1, a2);
}

/* OVERLAPSMAP
 */
overlapsmap copy_overlapsmap(overlapsmap p) {
  return (overlapsmap) gen_copy_tree((gen_chunk*) p);
}
void free_overlapsmap(overlapsmap p) {
  gen_free((gen_chunk*) p);
}
overlapsmap check_overlapsmap(overlapsmap p) {
  return (overlapsmap) gen_check((gen_chunk*) p, overlapsmap_domain);
}
bool overlapsmap_consistent_p(overlapsmap p) {
  check_overlapsmap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool overlapsmap_defined_p(overlapsmap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_overlapsmap_cons(overlapsmap p, list l) {
  return gen_typed_cons(OVERLAPSMAP_NEWGEN_DOMAIN, p, l);
}
void overlapsmap_assign_contents(overlapsmap r, overlapsmap v) {
  check_overlapsmap(r);
  check_overlapsmap(v);
  message_assert("defined references to domain overlapsmap",
                 overlapsmap_defined_p(r) && overlapsmap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_overlapsmap_));
}
void overlapsmap_non_recursive_free(overlapsmap p) {
  // should clear up contents...
  free(p);
}
void write_overlapsmap(FILE* f, overlapsmap p) {
  gen_write(f, (gen_chunk*) p);
}
overlapsmap read_overlapsmap(FILE* f) {
  return (overlapsmap) gen_read(f);
}
overlapsmap make_overlapsmap(void) {
  return (overlapsmap) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, overlapsmap_domain);
}
list apply_overlapsmap(overlapsmap f, entity k) {
  return (list) (intptr_t)HASH_GET(p, p, overlapsmap_hash_table(f), k);
}
void update_overlapsmap(overlapsmap f, entity k, list v) {
  HASH_UPDATE(p, p, overlapsmap_hash_table(f), k, (intptr_t)v);
}
void extend_overlapsmap(overlapsmap f, entity k, list v) {
  HASH_EXTEND(p, p, overlapsmap_hash_table(f), k, (intptr_t)v);
}
list delete_overlapsmap(overlapsmap f, entity k) {
  return (list)(intptr_t) HASH_DELETE(p, p, overlapsmap_hash_table(f), k);
}
bool bound_overlapsmap_p(overlapsmap f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, overlapsmap_hash_table(f), k);
}

/* REMAPPING
 */
remapping copy_remapping(remapping p) {
  return (remapping) gen_copy_tree((gen_chunk*) p);
}
void free_remapping(remapping p) {
  gen_free((gen_chunk*) p);
}
remapping check_remapping(remapping p) {
  return (remapping) gen_check((gen_chunk*) p, remapping_domain);
}
bool remapping_consistent_p(remapping p) {
  check_remapping(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool remapping_defined_p(remapping p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_remapping_cons(remapping p, list l) {
  return gen_typed_cons(REMAPPING_NEWGEN_DOMAIN, p, l);
}
void remapping_assign_contents(remapping r, remapping v) {
  check_remapping(r);
  check_remapping(v);
  message_assert("defined references to domain remapping",
                 remapping_defined_p(r) && remapping_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_remapping_));
}
void remapping_non_recursive_free(remapping p) {
  // should clear up contents...
  free(p);
}
void write_remapping(FILE* f, remapping p) {
  gen_write(f, (gen_chunk*) p);
}
remapping read_remapping(FILE* f) {
  return (remapping) gen_read(f);
}
remapping make_remapping(renaming a1, list a2) {
  return (remapping) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, remapping_domain, a1, a2);
}

/* RENAMING
 */
renaming copy_renaming(renaming p) {
  return (renaming) gen_copy_tree((gen_chunk*) p);
}
void free_renaming(renaming p) {
  gen_free((gen_chunk*) p);
}
renaming check_renaming(renaming p) {
  return (renaming) gen_check((gen_chunk*) p, renaming_domain);
}
bool renaming_consistent_p(renaming p) {
  check_renaming(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool renaming_defined_p(renaming p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_renaming_cons(renaming p, list l) {
  return gen_typed_cons(RENAMING_NEWGEN_DOMAIN, p, l);
}
void renaming_assign_contents(renaming r, renaming v) {
  check_renaming(r);
  check_renaming(v);
  message_assert("defined references to domain renaming",
                 renaming_defined_p(r) && renaming_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_renaming_));
}
void renaming_non_recursive_free(renaming p) {
  // should clear up contents...
  free(p);
}
void write_renaming(FILE* f, renaming p) {
  gen_write(f, (gen_chunk*) p);
}
renaming read_renaming(FILE* f) {
  return (renaming) gen_read(f);
}
renaming make_renaming(entity a1, entity a2) {
  return (renaming) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, renaming_domain, a1, a2);
}

/* STATEMENT_ENTITIES
 */
statement_entities copy_statement_entities(statement_entities p) {
  return (statement_entities) gen_copy_tree((gen_chunk*) p);
}
void free_statement_entities(statement_entities p) {
  gen_free((gen_chunk*) p);
}
statement_entities check_statement_entities(statement_entities p) {
  return (statement_entities) gen_check((gen_chunk*) p, statement_entities_domain);
}
bool statement_entities_consistent_p(statement_entities p) {
  check_statement_entities(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool statement_entities_defined_p(statement_entities p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_statement_entities_cons(statement_entities p, list l) {
  return gen_typed_cons(STATEMENT_ENTITIES_NEWGEN_DOMAIN, p, l);
}
void statement_entities_assign_contents(statement_entities r, statement_entities v) {
  check_statement_entities(r);
  check_statement_entities(v);
  message_assert("defined references to domain statement_entities",
                 statement_entities_defined_p(r) && statement_entities_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_statement_entities_));
}
void statement_entities_non_recursive_free(statement_entities p) {
  // should clear up contents...
  free(p);
}
void write_statement_entities(FILE* f, statement_entities p) {
  gen_write(f, (gen_chunk*) p);
}
statement_entities read_statement_entities(FILE* f) {
  return (statement_entities) gen_read(f);
}
statement_entities make_statement_entities(void) {
  return (statement_entities) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, statement_entities_domain);
}
entities apply_statement_entities(statement_entities f, statement k) {
  return (entities) (intptr_t)HASH_GET(p, p, statement_entities_hash_table(f), k);
}
void update_statement_entities(statement_entities f, statement k, entities v) {
  HASH_UPDATE(p, p, statement_entities_hash_table(f), k, (intptr_t)v);
}
void extend_statement_entities(statement_entities f, statement k, entities v) {
  HASH_EXTEND(p, p, statement_entities_hash_table(f), k, (intptr_t)v);
}
entities delete_statement_entities(statement_entities f, statement k) {
  return (entities)(intptr_t) HASH_DELETE(p, p, statement_entities_hash_table(f), k);
}
bool bound_statement_entities_p(statement_entities f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, statement_entities_hash_table(f), k);
}

/* STATEMENT_RENAMINGS
 */
statement_renamings copy_statement_renamings(statement_renamings p) {
  return (statement_renamings) gen_copy_tree((gen_chunk*) p);
}
void free_statement_renamings(statement_renamings p) {
  gen_free((gen_chunk*) p);
}
statement_renamings check_statement_renamings(statement_renamings p) {
  return (statement_renamings) gen_check((gen_chunk*) p, statement_renamings_domain);
}
bool statement_renamings_consistent_p(statement_renamings p) {
  check_statement_renamings(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool statement_renamings_defined_p(statement_renamings p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_statement_renamings_cons(statement_renamings p, list l) {
  return gen_typed_cons(STATEMENT_RENAMINGS_NEWGEN_DOMAIN, p, l);
}
void statement_renamings_assign_contents(statement_renamings r, statement_renamings v) {
  check_statement_renamings(r);
  check_statement_renamings(v);
  message_assert("defined references to domain statement_renamings",
                 statement_renamings_defined_p(r) && statement_renamings_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_statement_renamings_));
}
void statement_renamings_non_recursive_free(statement_renamings p) {
  // should clear up contents...
  free(p);
}
void write_statement_renamings(FILE* f, statement_renamings p) {
  gen_write(f, (gen_chunk*) p);
}
statement_renamings read_statement_renamings(FILE* f) {
  return (statement_renamings) gen_read(f);
}
statement_renamings make_statement_renamings(void) {
  return (statement_renamings) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, statement_renamings_domain);
}
list apply_statement_renamings(statement_renamings f, statement k) {
  return (list) (intptr_t)HASH_GET(p, p, statement_renamings_hash_table(f), k);
}
void update_statement_renamings(statement_renamings f, statement k, list v) {
  HASH_UPDATE(p, p, statement_renamings_hash_table(f), k, (intptr_t)v);
}
void extend_statement_renamings(statement_renamings f, statement k, list v) {
  HASH_EXTEND(p, p, statement_renamings_hash_table(f), k, (intptr_t)v);
}
list delete_statement_renamings(statement_renamings f, statement k) {
  return (list)(intptr_t) HASH_DELETE(p, p, statement_renamings_hash_table(f), k);
}
bool bound_statement_renamings_p(statement_renamings f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, statement_renamings_hash_table(f), k);
}

