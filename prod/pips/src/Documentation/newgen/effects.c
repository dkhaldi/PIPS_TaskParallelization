/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * Psysteme;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "effects.h"


/* ACTION_KIND
 */
action_kind copy_action_kind(action_kind p) {
  return (action_kind) gen_copy_tree((gen_chunk*) p);
}
void free_action_kind(action_kind p) {
  gen_free((gen_chunk*) p);
}
action_kind check_action_kind(action_kind p) {
  return (action_kind) gen_check((gen_chunk*) p, action_kind_domain);
}
bool action_kind_consistent_p(action_kind p) {
  check_action_kind(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool action_kind_defined_p(action_kind p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_action_kind_cons(action_kind p, list l) {
  return gen_typed_cons(ACTION_KIND_NEWGEN_DOMAIN, p, l);
}
void action_kind_assign_contents(action_kind r, action_kind v) {
  check_action_kind(r);
  check_action_kind(v);
  message_assert("defined references to domain action_kind",
                 action_kind_defined_p(r) && action_kind_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_action_kind_));
}
void action_kind_non_recursive_free(action_kind p) {
  // should clear up contents...
  free(p);
}
void write_action_kind(FILE* f, action_kind p) {
  gen_write(f, (gen_chunk*) p);
}
action_kind read_action_kind(FILE* f) {
  return (action_kind) gen_read(f);
}
string action_kind_tag_as_string(enum action_kind_utype tag) {
  switch (tag) {
  case is_action_kind_store: return "store";
  case is_action_kind_environment: return "environment";
  case is_action_kind_type_declaration: return "type_declaration";
  default: return string_undefined;
  }
}
action_kind make_action_kind(enum action_kind_utype tag, void * val) {
  return (action_kind) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, action_kind_domain, tag, val);
}
action_kind make_action_kind_store(void) {
  return make_action_kind(is_action_kind_store, UU);
}
action_kind make_action_kind_environment(void) {
  return make_action_kind(is_action_kind_environment, UU);
}
action_kind make_action_kind_type_declaration(void) {
  return make_action_kind(is_action_kind_type_declaration, UU);
}

/* ACTION
 */
action copy_action(action p) {
  return (action) gen_copy_tree((gen_chunk*) p);
}
void free_action(action p) {
  gen_free((gen_chunk*) p);
}
action check_action(action p) {
  return (action) gen_check((gen_chunk*) p, action_domain);
}
bool action_consistent_p(action p) {
  check_action(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool action_defined_p(action p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_action_cons(action p, list l) {
  return gen_typed_cons(ACTION_NEWGEN_DOMAIN, p, l);
}
void action_assign_contents(action r, action v) {
  check_action(r);
  check_action(v);
  message_assert("defined references to domain action",
                 action_defined_p(r) && action_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_action_));
}
void action_non_recursive_free(action p) {
  // should clear up contents...
  free(p);
}
void write_action(FILE* f, action p) {
  gen_write(f, (gen_chunk*) p);
}
action read_action(FILE* f) {
  return (action) gen_read(f);
}
string action_tag_as_string(enum action_utype tag) {
  switch (tag) {
  case is_action_read: return "read";
  case is_action_write: return "write";
  default: return string_undefined;
  }
}
action make_action(enum action_utype tag, void * val) {
  return (action) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, action_domain, tag, val);
}
action make_action_read(action_kind _field_) {
  return make_action(is_action_read, (void*)(intptr_t) _field_);
}
action make_action_write(action_kind _field_) {
  return make_action(is_action_write, (void*)(intptr_t) _field_);
}

/* APPROXIMATION
 */
approximation copy_approximation(approximation p) {
  return (approximation) gen_copy_tree((gen_chunk*) p);
}
void free_approximation(approximation p) {
  gen_free((gen_chunk*) p);
}
approximation check_approximation(approximation p) {
  return (approximation) gen_check((gen_chunk*) p, approximation_domain);
}
bool approximation_consistent_p(approximation p) {
  check_approximation(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool approximation_defined_p(approximation p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_approximation_cons(approximation p, list l) {
  return gen_typed_cons(APPROXIMATION_NEWGEN_DOMAIN, p, l);
}
void approximation_assign_contents(approximation r, approximation v) {
  check_approximation(r);
  check_approximation(v);
  message_assert("defined references to domain approximation",
                 approximation_defined_p(r) && approximation_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_approximation_));
}
void approximation_non_recursive_free(approximation p) {
  // should clear up contents...
  free(p);
}
void write_approximation(FILE* f, approximation p) {
  gen_write(f, (gen_chunk*) p);
}
approximation read_approximation(FILE* f) {
  return (approximation) gen_read(f);
}
string approximation_tag_as_string(enum approximation_utype tag) {
  switch (tag) {
  case is_approximation_may: return "may";
  case is_approximation_must: return "must";
  case is_approximation_exact: return "exact";
  default: return string_undefined;
  }
}
approximation make_approximation(enum approximation_utype tag, void * val) {
  return (approximation) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, approximation_domain, tag, val);
}
approximation make_approximation_may(void) {
  return make_approximation(is_approximation_may, UU);
}
approximation make_approximation_must(void) {
  return make_approximation(is_approximation_must, UU);
}
approximation make_approximation_exact(void) {
  return make_approximation(is_approximation_exact, UU);
}

/* CELL_INTERPRETATION
 */
cell_interpretation copy_cell_interpretation(cell_interpretation p) {
  return (cell_interpretation) gen_copy_tree((gen_chunk*) p);
}
void free_cell_interpretation(cell_interpretation p) {
  gen_free((gen_chunk*) p);
}
cell_interpretation check_cell_interpretation(cell_interpretation p) {
  return (cell_interpretation) gen_check((gen_chunk*) p, cell_interpretation_domain);
}
bool cell_interpretation_consistent_p(cell_interpretation p) {
  check_cell_interpretation(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool cell_interpretation_defined_p(cell_interpretation p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_cell_interpretation_cons(cell_interpretation p, list l) {
  return gen_typed_cons(CELL_INTERPRETATION_NEWGEN_DOMAIN, p, l);
}
void cell_interpretation_assign_contents(cell_interpretation r, cell_interpretation v) {
  check_cell_interpretation(r);
  check_cell_interpretation(v);
  message_assert("defined references to domain cell_interpretation",
                 cell_interpretation_defined_p(r) && cell_interpretation_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_cell_interpretation_));
}
void cell_interpretation_non_recursive_free(cell_interpretation p) {
  // should clear up contents...
  free(p);
}
void write_cell_interpretation(FILE* f, cell_interpretation p) {
  gen_write(f, (gen_chunk*) p);
}
cell_interpretation read_cell_interpretation(FILE* f) {
  return (cell_interpretation) gen_read(f);
}
string cell_interpretation_tag_as_string(enum cell_interpretation_utype tag) {
  switch (tag) {
  case is_cell_interpretation_value_of: return "value_of";
  case is_cell_interpretation_address_of: return "address_of";
  default: return string_undefined;
  }
}
cell_interpretation make_cell_interpretation(enum cell_interpretation_utype tag, void * val) {
  return (cell_interpretation) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, cell_interpretation_domain, tag, val);
}
cell_interpretation make_cell_interpretation_value_of(void) {
  return make_cell_interpretation(is_cell_interpretation_value_of, UU);
}
cell_interpretation make_cell_interpretation_address_of(void) {
  return make_cell_interpretation(is_cell_interpretation_address_of, UU);
}

/* CELL
 */
cell copy_cell(cell p) {
  return (cell) gen_copy_tree((gen_chunk*) p);
}
void free_cell(cell p) {
  gen_free((gen_chunk*) p);
}
cell check_cell(cell p) {
  return (cell) gen_check((gen_chunk*) p, cell_domain);
}
bool cell_consistent_p(cell p) {
  check_cell(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool cell_defined_p(cell p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_cell_cons(cell p, list l) {
  return gen_typed_cons(CELL_NEWGEN_DOMAIN, p, l);
}
void cell_assign_contents(cell r, cell v) {
  check_cell(r);
  check_cell(v);
  message_assert("defined references to domain cell",
                 cell_defined_p(r) && cell_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_cell_));
}
void cell_non_recursive_free(cell p) {
  // should clear up contents...
  free(p);
}
void write_cell(FILE* f, cell p) {
  gen_write(f, (gen_chunk*) p);
}
cell read_cell(FILE* f) {
  return (cell) gen_read(f);
}
string cell_tag_as_string(enum cell_utype tag) {
  switch (tag) {
  case is_cell_reference: return "reference";
  case is_cell_preference: return "preference";
  case is_cell_gap: return "gap";
  default: return string_undefined;
  }
}
cell make_cell(enum cell_utype tag, void * val) {
  return (cell) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, cell_domain, tag, val);
}
cell make_cell_reference(reference _field_) {
  return make_cell(is_cell_reference, (void*)(intptr_t) _field_);
}
cell make_cell_preference(preference _field_) {
  return make_cell(is_cell_preference, (void*)(intptr_t) _field_);
}
cell make_cell_gap(gap _field_) {
  return make_cell(is_cell_gap, (void*)(intptr_t) _field_);
}

/* CELL_RELATION
 */
cell_relation copy_cell_relation(cell_relation p) {
  return (cell_relation) gen_copy_tree((gen_chunk*) p);
}
void free_cell_relation(cell_relation p) {
  gen_free((gen_chunk*) p);
}
cell_relation check_cell_relation(cell_relation p) {
  return (cell_relation) gen_check((gen_chunk*) p, cell_relation_domain);
}
bool cell_relation_consistent_p(cell_relation p) {
  check_cell_relation(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool cell_relation_defined_p(cell_relation p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_cell_relation_cons(cell_relation p, list l) {
  return gen_typed_cons(CELL_RELATION_NEWGEN_DOMAIN, p, l);
}
void cell_relation_assign_contents(cell_relation r, cell_relation v) {
  check_cell_relation(r);
  check_cell_relation(v);
  message_assert("defined references to domain cell_relation",
                 cell_relation_defined_p(r) && cell_relation_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_cell_relation_));
}
void cell_relation_non_recursive_free(cell_relation p) {
  // should clear up contents...
  free(p);
}
void write_cell_relation(FILE* f, cell_relation p) {
  gen_write(f, (gen_chunk*) p);
}
cell_relation read_cell_relation(FILE* f) {
  return (cell_relation) gen_read(f);
}
cell_relation make_cell_relation(interpreted_cell a1, interpreted_cell a2, approximation a3, descriptor a4) {
  return (cell_relation) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, cell_relation_domain, a1, a2, a3, a4);
}

/* CELL_RELATIONS
 */
cell_relations copy_cell_relations(cell_relations p) {
  return (cell_relations) gen_copy_tree((gen_chunk*) p);
}
void free_cell_relations(cell_relations p) {
  gen_free((gen_chunk*) p);
}
cell_relations check_cell_relations(cell_relations p) {
  return (cell_relations) gen_check((gen_chunk*) p, cell_relations_domain);
}
bool cell_relations_consistent_p(cell_relations p) {
  check_cell_relations(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool cell_relations_defined_p(cell_relations p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_cell_relations_cons(cell_relations p, list l) {
  return gen_typed_cons(CELL_RELATIONS_NEWGEN_DOMAIN, p, l);
}
void cell_relations_assign_contents(cell_relations r, cell_relations v) {
  check_cell_relations(r);
  check_cell_relations(v);
  message_assert("defined references to domain cell_relations",
                 cell_relations_defined_p(r) && cell_relations_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_cell_relations_));
}
void cell_relations_non_recursive_free(cell_relations p) {
  // should clear up contents...
  free(p);
}
void write_cell_relations(FILE* f, cell_relations p) {
  gen_write(f, (gen_chunk*) p);
}
cell_relations read_cell_relations(FILE* f) {
  return (cell_relations) gen_read(f);
}
cell_relations make_cell_relations(list a) {
  return (cell_relations) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, cell_relations_domain, a);
}

/* DESCRIPTOR
 */
descriptor copy_descriptor(descriptor p) {
  return (descriptor) gen_copy_tree((gen_chunk*) p);
}
void free_descriptor(descriptor p) {
  gen_free((gen_chunk*) p);
}
descriptor check_descriptor(descriptor p) {
  return (descriptor) gen_check((gen_chunk*) p, descriptor_domain);
}
bool descriptor_consistent_p(descriptor p) {
  check_descriptor(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool descriptor_defined_p(descriptor p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_descriptor_cons(descriptor p, list l) {
  return gen_typed_cons(DESCRIPTOR_NEWGEN_DOMAIN, p, l);
}
void descriptor_assign_contents(descriptor r, descriptor v) {
  check_descriptor(r);
  check_descriptor(v);
  message_assert("defined references to domain descriptor",
                 descriptor_defined_p(r) && descriptor_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_descriptor_));
}
void descriptor_non_recursive_free(descriptor p) {
  // should clear up contents...
  free(p);
}
void write_descriptor(FILE* f, descriptor p) {
  gen_write(f, (gen_chunk*) p);
}
descriptor read_descriptor(FILE* f) {
  return (descriptor) gen_read(f);
}
string descriptor_tag_as_string(enum descriptor_utype tag) {
  switch (tag) {
  case is_descriptor_convexunion: return "convexunion";
  case is_descriptor_convex: return "convex";
  case is_descriptor_none: return "none";
  default: return string_undefined;
  }
}
descriptor make_descriptor(enum descriptor_utype tag, void * val) {
  return (descriptor) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, descriptor_domain, tag, val);
}
descriptor make_descriptor_convexunion(list _field_) {
  return make_descriptor(is_descriptor_convexunion, (void*)(intptr_t) _field_);
}
descriptor make_descriptor_convex(Psysteme _field_) {
  return make_descriptor(is_descriptor_convex, (void*)(intptr_t) _field_);
}
descriptor make_descriptor_none(void) {
  return make_descriptor(is_descriptor_none, UU);
}

/* EFFECT
 */
effect copy_effect(effect p) {
  return (effect) gen_copy_tree((gen_chunk*) p);
}
void free_effect(effect p) {
  gen_free((gen_chunk*) p);
}
effect check_effect(effect p) {
  return (effect) gen_check((gen_chunk*) p, effect_domain);
}
bool effect_consistent_p(effect p) {
  check_effect(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool effect_defined_p(effect p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_effect_cons(effect p, list l) {
  return gen_typed_cons(EFFECT_NEWGEN_DOMAIN, p, l);
}
void effect_assign_contents(effect r, effect v) {
  check_effect(r);
  check_effect(v);
  message_assert("defined references to domain effect",
                 effect_defined_p(r) && effect_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_effect_));
}
void effect_non_recursive_free(effect p) {
  // should clear up contents...
  free(p);
}
void write_effect(FILE* f, effect p) {
  gen_write(f, (gen_chunk*) p);
}
effect read_effect(FILE* f) {
  return (effect) gen_read(f);
}
effect make_effect(cell a1, action a2, approximation a3, descriptor a4) {
  return (effect) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, effect_domain, a1, a2, a3, a4);
}

/* EFFECTS_CLASSES
 */
effects_classes copy_effects_classes(effects_classes p) {
  return (effects_classes) gen_copy_tree((gen_chunk*) p);
}
void free_effects_classes(effects_classes p) {
  gen_free((gen_chunk*) p);
}
effects_classes check_effects_classes(effects_classes p) {
  return (effects_classes) gen_check((gen_chunk*) p, effects_classes_domain);
}
bool effects_classes_consistent_p(effects_classes p) {
  check_effects_classes(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool effects_classes_defined_p(effects_classes p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_effects_classes_cons(effects_classes p, list l) {
  return gen_typed_cons(EFFECTS_CLASSES_NEWGEN_DOMAIN, p, l);
}
void effects_classes_assign_contents(effects_classes r, effects_classes v) {
  check_effects_classes(r);
  check_effects_classes(v);
  message_assert("defined references to domain effects_classes",
                 effects_classes_defined_p(r) && effects_classes_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_effects_classes_));
}
void effects_classes_non_recursive_free(effects_classes p) {
  // should clear up contents...
  free(p);
}
void write_effects_classes(FILE* f, effects_classes p) {
  gen_write(f, (gen_chunk*) p);
}
effects_classes read_effects_classes(FILE* f) {
  return (effects_classes) gen_read(f);
}
effects_classes make_effects_classes(list a) {
  return (effects_classes) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, effects_classes_domain, a);
}

/* EFFECTS
 */
effects copy_effects(effects p) {
  return (effects) gen_copy_tree((gen_chunk*) p);
}
void free_effects(effects p) {
  gen_free((gen_chunk*) p);
}
effects check_effects(effects p) {
  return (effects) gen_check((gen_chunk*) p, effects_domain);
}
bool effects_consistent_p(effects p) {
  check_effects(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool effects_defined_p(effects p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_effects_cons(effects p, list l) {
  return gen_typed_cons(EFFECTS_NEWGEN_DOMAIN, p, l);
}
void effects_assign_contents(effects r, effects v) {
  check_effects(r);
  check_effects(v);
  message_assert("defined references to domain effects",
                 effects_defined_p(r) && effects_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_effects_));
}
void effects_non_recursive_free(effects p) {
  // should clear up contents...
  free(p);
}
void write_effects(FILE* f, effects p) {
  gen_write(f, (gen_chunk*) p);
}
effects read_effects(FILE* f) {
  return (effects) gen_read(f);
}
effects make_effects(list a) {
  return (effects) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, effects_domain, a);
}

/* ENTITY_EFFECTS
 */
entity_effects copy_entity_effects(entity_effects p) {
  return (entity_effects) gen_copy_tree((gen_chunk*) p);
}
void free_entity_effects(entity_effects p) {
  gen_free((gen_chunk*) p);
}
entity_effects check_entity_effects(entity_effects p) {
  return (entity_effects) gen_check((gen_chunk*) p, entity_effects_domain);
}
bool entity_effects_consistent_p(entity_effects p) {
  check_entity_effects(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool entity_effects_defined_p(entity_effects p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_entity_effects_cons(entity_effects p, list l) {
  return gen_typed_cons(ENTITY_EFFECTS_NEWGEN_DOMAIN, p, l);
}
void entity_effects_assign_contents(entity_effects r, entity_effects v) {
  check_entity_effects(r);
  check_entity_effects(v);
  message_assert("defined references to domain entity_effects",
                 entity_effects_defined_p(r) && entity_effects_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_entity_effects_));
}
void entity_effects_non_recursive_free(entity_effects p) {
  // should clear up contents...
  free(p);
}
void write_entity_effects(FILE* f, entity_effects p) {
  gen_write(f, (gen_chunk*) p);
}
entity_effects read_entity_effects(FILE* f) {
  return (entity_effects) gen_read(f);
}
entity_effects make_entity_effects(void) {
  return (entity_effects) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, entity_effects_domain);
}
effects apply_entity_effects(entity_effects f, entity k) {
  return (effects) (intptr_t)HASH_GET(p, p, entity_effects_hash_table(f), k);
}
void update_entity_effects(entity_effects f, entity k, effects v) {
  HASH_UPDATE(p, p, entity_effects_hash_table(f), k, (intptr_t)v);
}
void extend_entity_effects(entity_effects f, entity k, effects v) {
  HASH_EXTEND(p, p, entity_effects_hash_table(f), k, (intptr_t)v);
}
effects delete_entity_effects(entity_effects f, entity k) {
  return (effects)(intptr_t) HASH_DELETE(p, p, entity_effects_hash_table(f), k);
}
bool bound_entity_effects_p(entity_effects f, entity k) {
  return (intptr_t)HASH_BOUND_P(p, p, entity_effects_hash_table(f), k);
}

/* GAP
 */
gap copy_gap(gap p) {
  return (gap) gen_copy_tree((gen_chunk*) p);
}
void free_gap(gap p) {
  gen_free((gen_chunk*) p);
}
gap check_gap(gap p) {
  return (gap) gen_check((gen_chunk*) p, gap_domain);
}
bool gap_consistent_p(gap p) {
  check_gap(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool gap_defined_p(gap p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_gap_cons(gap p, list l) {
  return gen_typed_cons(GAP_NEWGEN_DOMAIN, p, l);
}
void gap_assign_contents(gap r, gap v) {
  check_gap(r);
  check_gap(v);
  message_assert("defined references to domain gap",
                 gap_defined_p(r) && gap_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_gap_));
}
void gap_non_recursive_free(gap p) {
  // should clear up contents...
  free(p);
}
void write_gap(FILE* f, gap p) {
  gen_write(f, (gen_chunk*) p);
}
gap read_gap(FILE* f) {
  return (gap) gen_read(f);
}
gap make_gap(entity a1, path_selectors a2) {
  return (gap) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, gap_domain, a1, a2);
}

/* INTERPRETED_CELL
 */
interpreted_cell copy_interpreted_cell(interpreted_cell p) {
  return (interpreted_cell) gen_copy_tree((gen_chunk*) p);
}
void free_interpreted_cell(interpreted_cell p) {
  gen_free((gen_chunk*) p);
}
interpreted_cell check_interpreted_cell(interpreted_cell p) {
  return (interpreted_cell) gen_check((gen_chunk*) p, interpreted_cell_domain);
}
bool interpreted_cell_consistent_p(interpreted_cell p) {
  check_interpreted_cell(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool interpreted_cell_defined_p(interpreted_cell p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_interpreted_cell_cons(interpreted_cell p, list l) {
  return gen_typed_cons(INTERPRETED_CELL_NEWGEN_DOMAIN, p, l);
}
void interpreted_cell_assign_contents(interpreted_cell r, interpreted_cell v) {
  check_interpreted_cell(r);
  check_interpreted_cell(v);
  message_assert("defined references to domain interpreted_cell",
                 interpreted_cell_defined_p(r) && interpreted_cell_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_interpreted_cell_));
}
void interpreted_cell_non_recursive_free(interpreted_cell p) {
  // should clear up contents...
  free(p);
}
void write_interpreted_cell(FILE* f, interpreted_cell p) {
  gen_write(f, (gen_chunk*) p);
}
interpreted_cell read_interpreted_cell(FILE* f) {
  return (interpreted_cell) gen_read(f);
}
interpreted_cell make_interpreted_cell(cell a1, cell_interpretation a2) {
  return (interpreted_cell) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, interpreted_cell_domain, a1, a2);
}

/* PATH_SELECTOR
 */
path_selector copy_path_selector(path_selector p) {
  return (path_selector) gen_copy_tree((gen_chunk*) p);
}
void free_path_selector(path_selector p) {
  gen_free((gen_chunk*) p);
}
path_selector check_path_selector(path_selector p) {
  return (path_selector) gen_check((gen_chunk*) p, path_selector_domain);
}
bool path_selector_consistent_p(path_selector p) {
  check_path_selector(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool path_selector_defined_p(path_selector p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_path_selector_cons(path_selector p, list l) {
  return gen_typed_cons(PATH_SELECTOR_NEWGEN_DOMAIN, p, l);
}
void path_selector_assign_contents(path_selector r, path_selector v) {
  check_path_selector(r);
  check_path_selector(v);
  message_assert("defined references to domain path_selector",
                 path_selector_defined_p(r) && path_selector_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_path_selector_));
}
void path_selector_non_recursive_free(path_selector p) {
  // should clear up contents...
  free(p);
}
void write_path_selector(FILE* f, path_selector p) {
  gen_write(f, (gen_chunk*) p);
}
path_selector read_path_selector(FILE* f) {
  return (path_selector) gen_read(f);
}
string path_selector_tag_as_string(enum path_selector_utype tag) {
  switch (tag) {
  case is_path_selector_expression: return "expression";
  case is_path_selector_recursive_selector: return "recursive_selector";
  default: return string_undefined;
  }
}
path_selector make_path_selector(enum path_selector_utype tag, void * val) {
  return (path_selector) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, path_selector_domain, tag, val);
}
path_selector make_path_selector_expression(expression _field_) {
  return make_path_selector(is_path_selector_expression, (void*)(intptr_t) _field_);
}
path_selector make_path_selector_recursive_selector(recursive_selector _field_) {
  return make_path_selector(is_path_selector_recursive_selector, (void*)(intptr_t) _field_);
}

/* PATH_SELECTORS
 */
path_selectors copy_path_selectors(path_selectors p) {
  return (path_selectors) gen_copy_tree((gen_chunk*) p);
}
void free_path_selectors(path_selectors p) {
  gen_free((gen_chunk*) p);
}
path_selectors check_path_selectors(path_selectors p) {
  return (path_selectors) gen_check((gen_chunk*) p, path_selectors_domain);
}
bool path_selectors_consistent_p(path_selectors p) {
  check_path_selectors(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool path_selectors_defined_p(path_selectors p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_path_selectors_cons(path_selectors p, list l) {
  return gen_typed_cons(PATH_SELECTORS_NEWGEN_DOMAIN, p, l);
}
void path_selectors_assign_contents(path_selectors r, path_selectors v) {
  check_path_selectors(r);
  check_path_selectors(v);
  message_assert("defined references to domain path_selectors",
                 path_selectors_defined_p(r) && path_selectors_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_path_selectors_));
}
void path_selectors_non_recursive_free(path_selectors p) {
  // should clear up contents...
  free(p);
}
void write_path_selectors(FILE* f, path_selectors p) {
  gen_write(f, (gen_chunk*) p);
}
path_selectors read_path_selectors(FILE* f) {
  return (path_selectors) gen_read(f);
}
path_selectors make_path_selectors(list a) {
  return (path_selectors) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, path_selectors_domain, a);
}

/* PERSISTANT_EXPRESSION_TO_EFFECTS
 */
persistant_expression_to_effects copy_persistant_expression_to_effects(persistant_expression_to_effects p) {
  return (persistant_expression_to_effects) gen_copy_tree((gen_chunk*) p);
}
void free_persistant_expression_to_effects(persistant_expression_to_effects p) {
  gen_free((gen_chunk*) p);
}
persistant_expression_to_effects check_persistant_expression_to_effects(persistant_expression_to_effects p) {
  return (persistant_expression_to_effects) gen_check((gen_chunk*) p, persistant_expression_to_effects_domain);
}
bool persistant_expression_to_effects_consistent_p(persistant_expression_to_effects p) {
  check_persistant_expression_to_effects(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool persistant_expression_to_effects_defined_p(persistant_expression_to_effects p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_persistant_expression_to_effects_cons(persistant_expression_to_effects p, list l) {
  return gen_typed_cons(PERSISTANT_EXPRESSION_TO_EFFECTS_NEWGEN_DOMAIN, p, l);
}
void persistant_expression_to_effects_assign_contents(persistant_expression_to_effects r, persistant_expression_to_effects v) {
  check_persistant_expression_to_effects(r);
  check_persistant_expression_to_effects(v);
  message_assert("defined references to domain persistant_expression_to_effects",
                 persistant_expression_to_effects_defined_p(r) && persistant_expression_to_effects_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_persistant_expression_to_effects_));
}
void persistant_expression_to_effects_non_recursive_free(persistant_expression_to_effects p) {
  // should clear up contents...
  free(p);
}
void write_persistant_expression_to_effects(FILE* f, persistant_expression_to_effects p) {
  gen_write(f, (gen_chunk*) p);
}
persistant_expression_to_effects read_persistant_expression_to_effects(FILE* f) {
  return (persistant_expression_to_effects) gen_read(f);
}
persistant_expression_to_effects make_persistant_expression_to_effects(void) {
  return (persistant_expression_to_effects) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, persistant_expression_to_effects_domain);
}
effects apply_persistant_expression_to_effects(persistant_expression_to_effects f, expression k) {
  return (effects) (intptr_t)HASH_GET(p, p, persistant_expression_to_effects_hash_table(f), k);
}
void update_persistant_expression_to_effects(persistant_expression_to_effects f, expression k, effects v) {
  HASH_UPDATE(p, p, persistant_expression_to_effects_hash_table(f), k, (intptr_t)v);
}
void extend_persistant_expression_to_effects(persistant_expression_to_effects f, expression k, effects v) {
  HASH_EXTEND(p, p, persistant_expression_to_effects_hash_table(f), k, (intptr_t)v);
}
effects delete_persistant_expression_to_effects(persistant_expression_to_effects f, expression k) {
  return (effects)(intptr_t) HASH_DELETE(p, p, persistant_expression_to_effects_hash_table(f), k);
}
bool bound_persistant_expression_to_effects_p(persistant_expression_to_effects f, expression k) {
  return (intptr_t)HASH_BOUND_P(p, p, persistant_expression_to_effects_hash_table(f), k);
}

/* RECURSIVE_SELECTOR
 */
recursive_selector copy_recursive_selector(recursive_selector p) {
  return (recursive_selector) gen_copy_tree((gen_chunk*) p);
}
void free_recursive_selector(recursive_selector p) {
  gen_free((gen_chunk*) p);
}
recursive_selector check_recursive_selector(recursive_selector p) {
  return (recursive_selector) gen_check((gen_chunk*) p, recursive_selector_domain);
}
bool recursive_selector_consistent_p(recursive_selector p) {
  check_recursive_selector(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool recursive_selector_defined_p(recursive_selector p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_recursive_selector_cons(recursive_selector p, list l) {
  return gen_typed_cons(RECURSIVE_SELECTOR_NEWGEN_DOMAIN, p, l);
}
void recursive_selector_assign_contents(recursive_selector r, recursive_selector v) {
  check_recursive_selector(r);
  check_recursive_selector(v);
  message_assert("defined references to domain recursive_selector",
                 recursive_selector_defined_p(r) && recursive_selector_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_recursive_selector_));
}
void recursive_selector_non_recursive_free(recursive_selector p) {
  // should clear up contents...
  free(p);
}
void write_recursive_selector(FILE* f, recursive_selector p) {
  gen_write(f, (gen_chunk*) p);
}
recursive_selector read_recursive_selector(FILE* f) {
  return (recursive_selector) gen_read(f);
}
recursive_selector make_recursive_selector(list a1, expression a2) {
  return (recursive_selector) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, recursive_selector_domain, a1, a2);
}

/* STATEMENT_CELL_RELATIONS
 */
statement_cell_relations copy_statement_cell_relations(statement_cell_relations p) {
  return (statement_cell_relations) gen_copy_tree((gen_chunk*) p);
}
void free_statement_cell_relations(statement_cell_relations p) {
  gen_free((gen_chunk*) p);
}
statement_cell_relations check_statement_cell_relations(statement_cell_relations p) {
  return (statement_cell_relations) gen_check((gen_chunk*) p, statement_cell_relations_domain);
}
bool statement_cell_relations_consistent_p(statement_cell_relations p) {
  check_statement_cell_relations(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool statement_cell_relations_defined_p(statement_cell_relations p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_statement_cell_relations_cons(statement_cell_relations p, list l) {
  return gen_typed_cons(STATEMENT_CELL_RELATIONS_NEWGEN_DOMAIN, p, l);
}
void statement_cell_relations_assign_contents(statement_cell_relations r, statement_cell_relations v) {
  check_statement_cell_relations(r);
  check_statement_cell_relations(v);
  message_assert("defined references to domain statement_cell_relations",
                 statement_cell_relations_defined_p(r) && statement_cell_relations_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_statement_cell_relations_));
}
void statement_cell_relations_non_recursive_free(statement_cell_relations p) {
  // should clear up contents...
  free(p);
}
void write_statement_cell_relations(FILE* f, statement_cell_relations p) {
  gen_write(f, (gen_chunk*) p);
}
statement_cell_relations read_statement_cell_relations(FILE* f) {
  return (statement_cell_relations) gen_read(f);
}
statement_cell_relations make_statement_cell_relations(void) {
  return (statement_cell_relations) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, statement_cell_relations_domain);
}
cell_relations apply_statement_cell_relations(statement_cell_relations f, statement k) {
  return (cell_relations) (intptr_t)HASH_GET(p, p, statement_cell_relations_hash_table(f), k);
}
void update_statement_cell_relations(statement_cell_relations f, statement k, cell_relations v) {
  HASH_UPDATE(p, p, statement_cell_relations_hash_table(f), k, (intptr_t)v);
}
void extend_statement_cell_relations(statement_cell_relations f, statement k, cell_relations v) {
  HASH_EXTEND(p, p, statement_cell_relations_hash_table(f), k, (intptr_t)v);
}
cell_relations delete_statement_cell_relations(statement_cell_relations f, statement k) {
  return (cell_relations)(intptr_t) HASH_DELETE(p, p, statement_cell_relations_hash_table(f), k);
}
bool bound_statement_cell_relations_p(statement_cell_relations f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, statement_cell_relations_hash_table(f), k);
}

/* STATEMENT_EFFECTS
 */
statement_effects copy_statement_effects(statement_effects p) {
  return (statement_effects) gen_copy_tree((gen_chunk*) p);
}
void free_statement_effects(statement_effects p) {
  gen_free((gen_chunk*) p);
}
statement_effects check_statement_effects(statement_effects p) {
  return (statement_effects) gen_check((gen_chunk*) p, statement_effects_domain);
}
bool statement_effects_consistent_p(statement_effects p) {
  check_statement_effects(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool statement_effects_defined_p(statement_effects p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_statement_effects_cons(statement_effects p, list l) {
  return gen_typed_cons(STATEMENT_EFFECTS_NEWGEN_DOMAIN, p, l);
}
void statement_effects_assign_contents(statement_effects r, statement_effects v) {
  check_statement_effects(r);
  check_statement_effects(v);
  message_assert("defined references to domain statement_effects",
                 statement_effects_defined_p(r) && statement_effects_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_statement_effects_));
}
void statement_effects_non_recursive_free(statement_effects p) {
  // should clear up contents...
  free(p);
}
void write_statement_effects(FILE* f, statement_effects p) {
  gen_write(f, (gen_chunk*) p);
}
statement_effects read_statement_effects(FILE* f) {
  return (statement_effects) gen_read(f);
}
statement_effects make_statement_effects(void) {
  return (statement_effects) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, statement_effects_domain);
}
effects apply_statement_effects(statement_effects f, statement k) {
  return (effects) (intptr_t)HASH_GET(p, p, statement_effects_hash_table(f), k);
}
void update_statement_effects(statement_effects f, statement k, effects v) {
  HASH_UPDATE(p, p, statement_effects_hash_table(f), k, (intptr_t)v);
}
void extend_statement_effects(statement_effects f, statement k, effects v) {
  HASH_EXTEND(p, p, statement_effects_hash_table(f), k, (intptr_t)v);
}
effects delete_statement_effects(statement_effects f, statement k) {
  return (effects)(intptr_t) HASH_DELETE(p, p, statement_effects_hash_table(f), k);
}
bool bound_statement_effects_p(statement_effects f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, statement_effects_hash_table(f), k);
}

