#ifndef _newgen_step_private_included
#define _newgen_step_private_included
#define _gen_step_private_start 206
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_entity_domain_defined_)
#define _newgen_entity_domain_defined_
#define ENTITY_NEWGEN_DOMAIN (entity_domain)
#define entity_NEWGEN_DOMAIN (entity_domain)
typedef struct _newgen_struct_entity_ * entity;
#endif /* _newgen_entity_domain_defined_ */

#if !defined(_newgen_expression_domain_defined_)
#define _newgen_expression_domain_defined_
#define EXPRESSION_NEWGEN_DOMAIN (expression_domain)
#define expression_NEWGEN_DOMAIN (expression_domain)
typedef struct _newgen_struct_expression_ * expression;
#endif /* _newgen_expression_domain_defined_ */

#if !defined(_newgen_effect_domain_defined_)
#define _newgen_effect_domain_defined_
#define EFFECT_NEWGEN_DOMAIN (effect_domain)
#define effect_NEWGEN_DOMAIN (effect_domain)
typedef struct _newgen_struct_effect_ * effect;
#endif /* _newgen_effect_domain_defined_ */

#if !defined(_newgen_statement_domain_defined_)
#define _newgen_statement_domain_defined_
#define STATEMENT_NEWGEN_DOMAIN (statement_domain)
#define statement_NEWGEN_DOMAIN (statement_domain)
typedef struct _newgen_struct_statement_ * statement;
#endif /* _newgen_statement_domain_defined_ */

#define map_effect_bool_domain (_gen_step_private_start+0)
#if !defined(_newgen_map_effect_bool_domain_defined_)
#define _newgen_map_effect_bool_domain_defined_
#define MAP_EFFECT_BOOL_NEWGEN_DOMAIN (map_effect_bool_domain)
#define map_effect_bool_NEWGEN_DOMAIN (map_effect_bool_domain)
typedef struct _newgen_struct_map_effect_bool_ * map_effect_bool;
#endif /* _newgen_map_effect_bool_domain_defined_ */

#define map_effect_step_point_domain (_gen_step_private_start+1)
#if !defined(_newgen_map_effect_step_point_domain_defined_)
#define _newgen_map_effect_step_point_domain_defined_
#define MAP_EFFECT_STEP_POINT_NEWGEN_DOMAIN (map_effect_step_point_domain)
#define map_effect_step_point_NEWGEN_DOMAIN (map_effect_step_point_domain)
typedef struct _newgen_struct_map_effect_step_point_ * map_effect_step_point;
#endif /* _newgen_map_effect_step_point_domain_defined_ */

#define map_entity_int_domain (_gen_step_private_start+2)
#if !defined(_newgen_map_entity_int_domain_defined_)
#define _newgen_map_entity_int_domain_defined_
#define MAP_ENTITY_INT_NEWGEN_DOMAIN (map_entity_int_domain)
#define map_entity_int_NEWGEN_DOMAIN (map_entity_int_domain)
typedef struct _newgen_struct_map_entity_int_ * map_entity_int;
#endif /* _newgen_map_entity_int_domain_defined_ */

#define step_clause_domain (_gen_step_private_start+3)
#if !defined(_newgen_step_clause_domain_defined_)
#define _newgen_step_clause_domain_defined_
#define STEP_CLAUSE_NEWGEN_DOMAIN (step_clause_domain)
#define step_clause_NEWGEN_DOMAIN (step_clause_domain)
typedef struct _newgen_struct_step_clause_ * step_clause;
#endif /* _newgen_step_clause_domain_defined_ */

#define step_comm_domain (_gen_step_private_start+4)
#if !defined(_newgen_step_comm_domain_defined_)
#define _newgen_step_comm_domain_defined_
#define STEP_COMM_NEWGEN_DOMAIN (step_comm_domain)
#define step_comm_NEWGEN_DOMAIN (step_comm_domain)
typedef struct _newgen_struct_step_comm_ * step_comm;
#endif /* _newgen_step_comm_domain_defined_ */

#define step_directives_domain (_gen_step_private_start+5)
#if !defined(_newgen_step_directives_domain_defined_)
#define _newgen_step_directives_domain_defined_
#define STEP_DIRECTIVES_NEWGEN_DOMAIN (step_directives_domain)
#define step_directives_NEWGEN_DOMAIN (step_directives_domain)
typedef struct _newgen_struct_step_directives_ * step_directives;
#endif /* _newgen_step_directives_domain_defined_ */

#define step_directive_domain (_gen_step_private_start+6)
#if !defined(_newgen_step_directive_domain_defined_)
#define _newgen_step_directive_domain_defined_
#define STEP_DIRECTIVE_NEWGEN_DOMAIN (step_directive_domain)
#define step_directive_NEWGEN_DOMAIN (step_directive_domain)
typedef struct _newgen_struct_step_directive_ * step_directive;
#endif /* _newgen_step_directive_domain_defined_ */

#define step_point_domain (_gen_step_private_start+7)
#if !defined(_newgen_step_point_domain_defined_)
#define _newgen_step_point_domain_defined_
#define STEP_POINT_NEWGEN_DOMAIN (step_point_domain)
#define step_point_NEWGEN_DOMAIN (step_point_domain)
typedef struct _newgen_struct_step_point_ * step_point;
#endif /* _newgen_step_point_domain_defined_ */

/* MAP_EFFECT_BOOL
 */
#define MAP_EFFECT_BOOL(x) ((map_effect_bool)((x).p))
#define map_effect_bool_CAST(x) MAP_EFFECT_BOOL(x)
#define MAP_EFFECT_BOOL_CAST(x) MAP_EFFECT_BOOL(x)
#define MAP_EFFECT_BOOL_(x) ((x).e)
#define MAP_EFFECT_BOOL_TYPE map_effect_bool
#define map_effect_bool_TYPE map_effect_bool
#define map_effect_bool_undefined ((map_effect_bool)gen_chunk_undefined)
#define map_effect_bool_undefined_p(x) ((x)==map_effect_bool_undefined)

extern map_effect_bool copy_map_effect_bool(map_effect_bool);
extern void free_map_effect_bool(map_effect_bool);
extern map_effect_bool check_map_effect_bool(map_effect_bool);
extern bool map_effect_bool_consistent_p(map_effect_bool);
extern bool map_effect_bool_defined_p(map_effect_bool);
#define gen_MAP_EFFECT_BOOL_cons gen_map_effect_bool_cons
extern list gen_map_effect_bool_cons(map_effect_bool, list);
extern void map_effect_bool_assign_contents(map_effect_bool, map_effect_bool);
extern void map_effect_bool_non_recursive_free(map_effect_bool);
extern void write_map_effect_bool(FILE*, map_effect_bool);
extern map_effect_bool read_map_effect_bool(FILE*);
extern map_effect_bool make_map_effect_bool(void);

struct _newgen_struct_map_effect_bool_ {
  intptr_t _type_;
  hash_table _map_effect_bool_holder_;
};

#define map_effect_bool_domain_number(x) ((x)->_type_)
#define map_effect_bool_hash_table(x) ((x)->_map_effect_bool_holder_)
#define map_effect_bool_key_type effect
#define map_effect_bool_value_type bool
#define MAP_EFFECT_BOOL_MAP(k,v,c,f) FUNCTION_MAP(map_effect_bool,p,b,k,v,c,f)
#define MAP_EFFECT_BOOL_FOREACH(k,v,f) FUNCTION_FOREACH(map_effect_bool,p,b,k,v,f)
extern bool apply_map_effect_bool(map_effect_bool, effect);
extern void update_map_effect_bool(map_effect_bool, effect, bool);
extern void extend_map_effect_bool(map_effect_bool, effect, bool);
extern bool delete_map_effect_bool(map_effect_bool, effect);
extern bool bound_map_effect_bool_p(map_effect_bool, effect);

/* MAP_EFFECT_STEP_POINT
 */
#define MAP_EFFECT_STEP_POINT(x) ((map_effect_step_point)((x).p))
#define map_effect_step_point_CAST(x) MAP_EFFECT_STEP_POINT(x)
#define MAP_EFFECT_STEP_POINT_CAST(x) MAP_EFFECT_STEP_POINT(x)
#define MAP_EFFECT_STEP_POINT_(x) ((x).e)
#define MAP_EFFECT_STEP_POINT_TYPE map_effect_step_point
#define map_effect_step_point_TYPE map_effect_step_point
#define map_effect_step_point_undefined ((map_effect_step_point)gen_chunk_undefined)
#define map_effect_step_point_undefined_p(x) ((x)==map_effect_step_point_undefined)

extern map_effect_step_point copy_map_effect_step_point(map_effect_step_point);
extern void free_map_effect_step_point(map_effect_step_point);
extern map_effect_step_point check_map_effect_step_point(map_effect_step_point);
extern bool map_effect_step_point_consistent_p(map_effect_step_point);
extern bool map_effect_step_point_defined_p(map_effect_step_point);
#define gen_MAP_EFFECT_STEP_POINT_cons gen_map_effect_step_point_cons
extern list gen_map_effect_step_point_cons(map_effect_step_point, list);
extern void map_effect_step_point_assign_contents(map_effect_step_point, map_effect_step_point);
extern void map_effect_step_point_non_recursive_free(map_effect_step_point);
extern void write_map_effect_step_point(FILE*, map_effect_step_point);
extern map_effect_step_point read_map_effect_step_point(FILE*);
extern map_effect_step_point make_map_effect_step_point(void);

struct _newgen_struct_map_effect_step_point_ {
  intptr_t _type_;
  hash_table _map_effect_step_point_holder_;
};

#define map_effect_step_point_domain_number(x) ((x)->_type_)
#define map_effect_step_point_hash_table(x) ((x)->_map_effect_step_point_holder_)
#define map_effect_step_point_key_type effect
#define map_effect_step_point_value_type step_point
#define MAP_EFFECT_STEP_POINT_MAP(k,v,c,f) FUNCTION_MAP(map_effect_step_point,p,p,k,v,c,f)
#define MAP_EFFECT_STEP_POINT_FOREACH(k,v,f) FUNCTION_FOREACH(map_effect_step_point,p,p,k,v,f)
extern step_point apply_map_effect_step_point(map_effect_step_point, effect);
extern void update_map_effect_step_point(map_effect_step_point, effect, step_point);
extern void extend_map_effect_step_point(map_effect_step_point, effect, step_point);
extern step_point delete_map_effect_step_point(map_effect_step_point, effect);
extern bool bound_map_effect_step_point_p(map_effect_step_point, effect);

/* MAP_ENTITY_INT
 */
#define MAP_ENTITY_INT(x) ((map_entity_int)((x).p))
#define map_entity_int_CAST(x) MAP_ENTITY_INT(x)
#define MAP_ENTITY_INT_CAST(x) MAP_ENTITY_INT(x)
#define MAP_ENTITY_INT_(x) ((x).e)
#define MAP_ENTITY_INT_TYPE map_entity_int
#define map_entity_int_TYPE map_entity_int
#define map_entity_int_undefined ((map_entity_int)gen_chunk_undefined)
#define map_entity_int_undefined_p(x) ((x)==map_entity_int_undefined)

extern map_entity_int copy_map_entity_int(map_entity_int);
extern void free_map_entity_int(map_entity_int);
extern map_entity_int check_map_entity_int(map_entity_int);
extern bool map_entity_int_consistent_p(map_entity_int);
extern bool map_entity_int_defined_p(map_entity_int);
#define gen_MAP_ENTITY_INT_cons gen_map_entity_int_cons
extern list gen_map_entity_int_cons(map_entity_int, list);
extern void map_entity_int_assign_contents(map_entity_int, map_entity_int);
extern void map_entity_int_non_recursive_free(map_entity_int);
extern void write_map_entity_int(FILE*, map_entity_int);
extern map_entity_int read_map_entity_int(FILE*);
extern map_entity_int make_map_entity_int(void);

struct _newgen_struct_map_entity_int_ {
  intptr_t _type_;
  hash_table _map_entity_int_holder_;
};

#define map_entity_int_domain_number(x) ((x)->_type_)
#define map_entity_int_hash_table(x) ((x)->_map_entity_int_holder_)
#define map_entity_int_key_type entity
#define map_entity_int_value_type intptr_t
#define MAP_ENTITY_INT_MAP(k,v,c,f) FUNCTION_MAP(map_entity_int,p,i,k,v,c,f)
#define MAP_ENTITY_INT_FOREACH(k,v,f) FUNCTION_FOREACH(map_entity_int,p,i,k,v,f)
extern intptr_t apply_map_entity_int(map_entity_int, entity);
extern void update_map_entity_int(map_entity_int, entity, intptr_t);
extern void extend_map_entity_int(map_entity_int, entity, intptr_t);
extern intptr_t delete_map_entity_int(map_entity_int, entity);
extern bool bound_map_entity_int_p(map_entity_int, entity);

/* STEP_CLAUSE
 */
#define STEP_CLAUSE(x) ((step_clause)((x).p))
#define step_clause_CAST(x) STEP_CLAUSE(x)
#define STEP_CLAUSE_CAST(x) STEP_CLAUSE(x)
#define STEP_CLAUSE_(x) ((x).e)
#define STEP_CLAUSE_TYPE step_clause
#define step_clause_TYPE step_clause
#define step_clause_undefined ((step_clause)gen_chunk_undefined)
#define step_clause_undefined_p(x) ((x)==step_clause_undefined)

extern step_clause copy_step_clause(step_clause);
extern void free_step_clause(step_clause);
extern step_clause check_step_clause(step_clause);
extern bool step_clause_consistent_p(step_clause);
extern bool step_clause_defined_p(step_clause);
#define gen_STEP_CLAUSE_cons gen_step_clause_cons
extern list gen_step_clause_cons(step_clause, list);
extern void step_clause_assign_contents(step_clause, step_clause);
extern void step_clause_non_recursive_free(step_clause);
extern void write_step_clause(FILE*, step_clause);
extern step_clause read_step_clause(FILE*);
enum step_clause_utype {
  is_step_clause_reduction,
  is_step_clause_private,
  is_step_clause_shared,
  is_step_clause_transformation,
  is_step_clause_nowait,
  is_step_clause_threadprivate,
  is_step_clause_copyin,
  is_step_clause_firstprivate,
  is_step_clause_schedule
};
extern string step_clause_tag_as_string(enum step_clause_utype);
extern step_clause make_step_clause(enum step_clause_utype, void *);
extern step_clause make_step_clause_reduction(map_entity_int);
extern step_clause make_step_clause_private(list);
extern step_clause make_step_clause_shared(list);
extern step_clause make_step_clause_transformation(intptr_t);
extern step_clause make_step_clause_nowait(void);
extern step_clause make_step_clause_threadprivate(list);
extern step_clause make_step_clause_copyin(list);
extern step_clause make_step_clause_firstprivate(list);
extern step_clause make_step_clause_schedule(list);

struct _newgen_struct_step_clause_ {
  intptr_t _type_;
  enum step_clause_utype _step_clause_tag__;
  union {
    map_entity_int _step_clause_reduction_; /* reduction:map_entity_int */
    list _step_clause_private_; /* private:entity* */
    list _step_clause_shared_; /* shared:entity* */
    intptr_t _step_clause_transformation_; /* transformation:int */
    gen_chunk _step_clause_nowait_; /* nowait:unit */
    list _step_clause_threadprivate_; /* threadprivate:entity* */
    list _step_clause_copyin_; /* copyin:entity* */
    list _step_clause_firstprivate_; /* firstprivate:entity* */
    list _step_clause_schedule_; /* schedule:string* */
  } _step_clause_union_;
};

#define step_clause_domain_number(x) ((x)->_type_)
#define step_clause_tag(x) ((x)->_step_clause_tag__)
#define step_clause_reduction_p(x) (step_clause_tag(x)==is_step_clause_reduction)
#define step_clause_reduction_(x) step_clause_reduction(x) /* old hack compatible */
#define step_clause_reduction(x) ((x)->_step_clause_union_._step_clause_reduction_)
#define step_clause_private_p(x) (step_clause_tag(x)==is_step_clause_private)
#define step_clause_private_(x) step_clause_private(x) /* old hack compatible */
#define step_clause_private(x) ((x)->_step_clause_union_._step_clause_private_)
#define step_clause_shared_p(x) (step_clause_tag(x)==is_step_clause_shared)
#define step_clause_shared_(x) step_clause_shared(x) /* old hack compatible */
#define step_clause_shared(x) ((x)->_step_clause_union_._step_clause_shared_)
#define step_clause_transformation_p(x) (step_clause_tag(x)==is_step_clause_transformation)
#define step_clause_transformation_(x) step_clause_transformation(x) /* old hack compatible */
#define step_clause_transformation(x) ((x)->_step_clause_union_._step_clause_transformation_)
#define step_clause_nowait_p(x) (step_clause_tag(x)==is_step_clause_nowait)
#define step_clause_nowait_(x) step_clause_nowait(x) /* old hack compatible */
#define step_clause_nowait(x) ((x)->_step_clause_union_._step_clause_nowait_.u)
#define step_clause_threadprivate_p(x) (step_clause_tag(x)==is_step_clause_threadprivate)
#define step_clause_threadprivate_(x) step_clause_threadprivate(x) /* old hack compatible */
#define step_clause_threadprivate(x) ((x)->_step_clause_union_._step_clause_threadprivate_)
#define step_clause_copyin_p(x) (step_clause_tag(x)==is_step_clause_copyin)
#define step_clause_copyin_(x) step_clause_copyin(x) /* old hack compatible */
#define step_clause_copyin(x) ((x)->_step_clause_union_._step_clause_copyin_)
#define step_clause_firstprivate_p(x) (step_clause_tag(x)==is_step_clause_firstprivate)
#define step_clause_firstprivate_(x) step_clause_firstprivate(x) /* old hack compatible */
#define step_clause_firstprivate(x) ((x)->_step_clause_union_._step_clause_firstprivate_)
#define step_clause_schedule_p(x) (step_clause_tag(x)==is_step_clause_schedule)
#define step_clause_schedule_(x) step_clause_schedule(x) /* old hack compatible */
#define step_clause_schedule(x) ((x)->_step_clause_union_._step_clause_schedule_)

/* STEP_COMM
 */
#define STEP_COMM(x) ((step_comm)((x).p))
#define step_comm_CAST(x) STEP_COMM(x)
#define STEP_COMM_CAST(x) STEP_COMM(x)
#define STEP_COMM_(x) ((x).e)
#define STEP_COMM_TYPE step_comm
#define step_comm_TYPE step_comm
#define step_comm_undefined ((step_comm)gen_chunk_undefined)
#define step_comm_undefined_p(x) ((x)==step_comm_undefined)

extern step_comm copy_step_comm(step_comm);
extern void free_step_comm(step_comm);
extern step_comm check_step_comm(step_comm);
extern bool step_comm_consistent_p(step_comm);
extern bool step_comm_defined_p(step_comm);
#define gen_STEP_COMM_cons gen_step_comm_cons
extern list gen_step_comm_cons(step_comm, list);
extern void step_comm_assign_contents(step_comm, step_comm);
extern void step_comm_non_recursive_free(step_comm);
extern void write_step_comm(FILE*, step_comm);
extern step_comm read_step_comm(FILE*);
extern step_comm make_step_comm(map_effect_step_point, map_effect_bool, map_effect_bool);

struct _newgen_struct_step_comm_ {
  intptr_t _type_;
  map_effect_step_point _step_comm_path_; /* path:map_effect_step_point */
  map_effect_bool _step_comm_interlaced_; /* interlaced:map_effect_bool */
  map_effect_bool _step_comm_partial_; /* partial:map_effect_bool */
};

#define step_comm_domain_number(x) ((x)->_type_)
#define step_comm_path_(x) step_comm_path(x) /* old hack compatible */
#define step_comm_path(x) ((x)->_step_comm_path_)
#define step_comm_interlaced_(x) step_comm_interlaced(x) /* old hack compatible */
#define step_comm_interlaced(x) ((x)->_step_comm_interlaced_)
#define step_comm_partial_(x) step_comm_partial(x) /* old hack compatible */
#define step_comm_partial(x) ((x)->_step_comm_partial_)

/* STEP_DIRECTIVES
 */
#define STEP_DIRECTIVES(x) ((step_directives)((x).p))
#define step_directives_CAST(x) STEP_DIRECTIVES(x)
#define STEP_DIRECTIVES_CAST(x) STEP_DIRECTIVES(x)
#define STEP_DIRECTIVES_(x) ((x).e)
#define STEP_DIRECTIVES_TYPE step_directives
#define step_directives_TYPE step_directives
#define step_directives_undefined ((step_directives)gen_chunk_undefined)
#define step_directives_undefined_p(x) ((x)==step_directives_undefined)

extern step_directives copy_step_directives(step_directives);
extern void free_step_directives(step_directives);
extern step_directives check_step_directives(step_directives);
extern bool step_directives_consistent_p(step_directives);
extern bool step_directives_defined_p(step_directives);
#define gen_STEP_DIRECTIVES_cons gen_step_directives_cons
extern list gen_step_directives_cons(step_directives, list);
extern void step_directives_assign_contents(step_directives, step_directives);
extern void step_directives_non_recursive_free(step_directives);
extern void write_step_directives(FILE*, step_directives);
extern step_directives read_step_directives(FILE*);
extern step_directives make_step_directives(void);

struct _newgen_struct_step_directives_ {
  intptr_t _type_;
  hash_table _step_directives_holder_;
};

#define step_directives_domain_number(x) ((x)->_type_)
#define step_directives_hash_table(x) ((x)->_step_directives_holder_)
#define step_directives_key_type statement
#define step_directives_value_type step_directive
#define STEP_DIRECTIVES_MAP(k,v,c,f) FUNCTION_MAP(step_directives,p,p,k,v,c,f)
#define STEP_DIRECTIVES_FOREACH(k,v,f) FUNCTION_FOREACH(step_directives,p,p,k,v,f)
extern step_directive apply_step_directives(step_directives, statement);
extern void update_step_directives(step_directives, statement, step_directive);
extern void extend_step_directives(step_directives, statement, step_directive);
extern step_directive delete_step_directives(step_directives, statement);
extern bool bound_step_directives_p(step_directives, statement);

/* STEP_DIRECTIVE
 */
#define STEP_DIRECTIVE(x) ((step_directive)((x).p))
#define step_directive_CAST(x) STEP_DIRECTIVE(x)
#define STEP_DIRECTIVE_CAST(x) STEP_DIRECTIVE(x)
#define STEP_DIRECTIVE_(x) ((x).e)
#define STEP_DIRECTIVE_TYPE step_directive
#define step_directive_TYPE step_directive
#define step_directive_undefined ((step_directive)gen_chunk_undefined)
#define step_directive_undefined_p(x) ((x)==step_directive_undefined)

extern step_directive copy_step_directive(step_directive);
extern void free_step_directive(step_directive);
extern step_directive check_step_directive(step_directive);
extern bool step_directive_consistent_p(step_directive);
extern bool step_directive_defined_p(step_directive);
#define gen_STEP_DIRECTIVE_cons gen_step_directive_cons
extern list gen_step_directive_cons(step_directive, list);
extern void step_directive_assign_contents(step_directive, step_directive);
extern void step_directive_non_recursive_free(step_directive);
extern void write_step_directive(FILE*, step_directive);
extern step_directive read_step_directive(FILE*);
extern step_directive make_step_directive(intptr_t, statement, list);

struct _newgen_struct_step_directive_ {
  intptr_t _type_;
  intptr_t _step_directive_type_; /* type:int */
  statement _step_directive_block_; /* block:statement */
  list _step_directive_clauses_; /* clauses:step_clause* */
};

#define step_directive_domain_number(x) ((x)->_type_)
#define step_directive_type_(x) step_directive_type(x) /* old hack compatible */
#define step_directive_type(x) ((x)->_step_directive_type_)
#define step_directive_block_(x) step_directive_block(x) /* old hack compatible */
#define step_directive_block(x) ((x)->_step_directive_block_)
#define step_directive_clauses_(x) step_directive_clauses(x) /* old hack compatible */
#define step_directive_clauses(x) ((x)->_step_directive_clauses_)

/* STEP_POINT
 */
#define STEP_POINT(x) ((step_point)((x).p))
#define step_point_CAST(x) STEP_POINT(x)
#define STEP_POINT_CAST(x) STEP_POINT(x)
#define STEP_POINT_(x) ((x).e)
#define STEP_POINT_TYPE step_point
#define step_point_TYPE step_point
#define step_point_undefined ((step_point)gen_chunk_undefined)
#define step_point_undefined_p(x) ((x)==step_point_undefined)

extern step_point copy_step_point(step_point);
extern void free_step_point(step_point);
extern step_point check_step_point(step_point);
extern bool step_point_consistent_p(step_point);
extern bool step_point_defined_p(step_point);
#define gen_STEP_POINT_cons gen_step_point_cons
extern list gen_step_point_cons(step_point, list);
extern void step_point_assign_contents(step_point, step_point);
extern void step_point_non_recursive_free(step_point);
extern void write_step_point(FILE*, step_point);
extern step_point read_step_point(FILE*);
extern step_point make_step_point(entity, statement, effect);

struct _newgen_struct_step_point_ {
  intptr_t _type_;
  entity _step_point_module_; /* module:entity */
  statement _step_point_stmt_; /* stmt:statement */
  effect _step_point_data_; /* data:effect */
};

#define step_point_domain_number(x) ((x)->_type_)
#define step_point_module_(x) step_point_module(x) /* old hack compatible */
#define step_point_module(x) ((x)->_step_point_module_)
#define step_point_stmt_(x) step_point_stmt(x) /* old hack compatible */
#define step_point_stmt(x) ((x)->_step_point_stmt_)
#define step_point_data_(x) step_point_data(x) /* old hack compatible */
#define step_point_data(x) ((x)->_step_point_data_)

#define step_private_spec "\
--NEWGEN-START 206\n\
import entity from \"ri.newgen\";\n\
import expression from \"ri.newgen\";\n\
import effect from \"effects.newgen\";\n\
import statement from \"ri.newgen\";\n\
map_effect_bool = persistant effect:effect -> bool:bool;\n\
map_effect_step_point = persistant effect:effect -> step_point:step_point;\n\
map_entity_int = entity:entity -> int:int;\n\
step_clause = reduction:map_entity_int + private:entity* + shared:entity* + transformation:int + nowait:unit + threadprivate:entity* + copyin:entity* + firstprivate:entity* + schedule:string*;\n\
step_comm = path:map_effect_step_point x interlaced:map_effect_bool x partial:map_effect_bool;\n\
step_directives = persistant statement:statement -> step_directive:step_directive;\n\
step_directive = type:int x persistant block:statement x clauses:step_clause*;\n\
step_point = module:entity x persistant stmt:statement x persistant data:effect;\n\
"
#endif
