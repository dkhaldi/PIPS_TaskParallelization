/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "alias_private.h"

/* ALIAS_ASSOCIATIONS
 */
alias_associations copy_alias_associations(alias_associations p) {
  return (alias_associations) gen_copy_tree((gen_chunk*) p);
}
void free_alias_associations(alias_associations p) {
  gen_free((gen_chunk*) p);
}
alias_associations check_alias_associations(alias_associations p) {
  return (alias_associations) gen_check((gen_chunk*) p, alias_associations_domain);
}
bool alias_associations_consistent_p(alias_associations p) {
  check_alias_associations(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool alias_associations_defined_p(alias_associations p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_alias_associations_cons(alias_associations p, list l) {
  return gen_typed_cons(ALIAS_ASSOCIATIONS_NEWGEN_DOMAIN, p, l);
}
void alias_associations_assign_contents(alias_associations r, alias_associations v) {
  check_alias_associations(r);
  check_alias_associations(v);
  message_assert("defined references to domain alias_associations",
                 alias_associations_defined_p(r) && alias_associations_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_alias_associations_));
}
void alias_associations_non_recursive_free(alias_associations p) {
  // should clear up contents...
  free(p);
}
void write_alias_associations(FILE* f, alias_associations p) {
  gen_write(f, (gen_chunk*) p);
}
alias_associations read_alias_associations(FILE* f) {
  return (alias_associations) gen_read(f);
}
alias_associations make_alias_associations(list a) {
  return (alias_associations) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, alias_associations_domain, a);
}

/* ALIAS_ASSOCIATION
 */
alias_association copy_alias_association(alias_association p) {
  return (alias_association) gen_copy_tree((gen_chunk*) p);
}
void free_alias_association(alias_association p) {
  gen_free((gen_chunk*) p);
}
alias_association check_alias_association(alias_association p) {
  return (alias_association) gen_check((gen_chunk*) p, alias_association_domain);
}
bool alias_association_consistent_p(alias_association p) {
  check_alias_association(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool alias_association_defined_p(alias_association p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_alias_association_cons(alias_association p, list l) {
  return gen_typed_cons(ALIAS_ASSOCIATION_NEWGEN_DOMAIN, p, l);
}
void alias_association_assign_contents(alias_association r, alias_association v) {
  check_alias_association(r);
  check_alias_association(v);
  message_assert("defined references to domain alias_association",
                 alias_association_defined_p(r) && alias_association_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_alias_association_));
}
void alias_association_non_recursive_free(alias_association p) {
  // should clear up contents...
  free(p);
}
void write_alias_association(FILE* f, alias_association p) {
  gen_write(f, (gen_chunk*) p);
}
alias_association read_alias_association(FILE* f) {
  return (alias_association) gen_read(f);
}
alias_association make_alias_association(entity a1, entity a2, expression a3, intptr_t a4, intptr_t a5, list a6) {
  return (alias_association) gen_alloc(7*sizeof(gen_chunk), GEN_CHECK_ALLOC, alias_association_domain, a1, a2, a3, a4, a5, a6);
}

/* CALL_SITE
 */
call_site copy_call_site(call_site p) {
  return (call_site) gen_copy_tree((gen_chunk*) p);
}
void free_call_site(call_site p) {
  gen_free((gen_chunk*) p);
}
call_site check_call_site(call_site p) {
  return (call_site) gen_check((gen_chunk*) p, call_site_domain);
}
bool call_site_consistent_p(call_site p) {
  check_call_site(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool call_site_defined_p(call_site p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_call_site_cons(call_site p, list l) {
  return gen_typed_cons(CALL_SITE_NEWGEN_DOMAIN, p, l);
}
void call_site_assign_contents(call_site r, call_site v) {
  check_call_site(r);
  check_call_site(v);
  message_assert("defined references to domain call_site",
                 call_site_defined_p(r) && call_site_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_call_site_));
}
void call_site_non_recursive_free(call_site p) {
  // should clear up contents...
  free(p);
}
void write_call_site(FILE* f, call_site p) {
  gen_write(f, (gen_chunk*) p);
}
call_site read_call_site(FILE* f) {
  return (call_site) gen_read(f);
}
call_site make_call_site(entity a1, intptr_t a2) {
  return (call_site) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, call_site_domain, a1, a2);
}

/* DYNAMIC_CHECK
 */
dynamic_check copy_dynamic_check(dynamic_check p) {
  return (dynamic_check) gen_copy_tree((gen_chunk*) p);
}
void free_dynamic_check(dynamic_check p) {
  gen_free((gen_chunk*) p);
}
dynamic_check check_dynamic_check(dynamic_check p) {
  return (dynamic_check) gen_check((gen_chunk*) p, dynamic_check_domain);
}
bool dynamic_check_consistent_p(dynamic_check p) {
  check_dynamic_check(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dynamic_check_defined_p(dynamic_check p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dynamic_check_cons(dynamic_check p, list l) {
  return gen_typed_cons(DYNAMIC_CHECK_NEWGEN_DOMAIN, p, l);
}
void dynamic_check_assign_contents(dynamic_check r, dynamic_check v) {
  check_dynamic_check(r);
  check_dynamic_check(v);
  message_assert("defined references to domain dynamic_check",
                 dynamic_check_defined_p(r) && dynamic_check_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dynamic_check_));
}
void dynamic_check_non_recursive_free(dynamic_check p) {
  // should clear up contents...
  free(p);
}
void write_dynamic_check(FILE* f, dynamic_check p) {
  gen_write(f, (gen_chunk*) p);
}
dynamic_check read_dynamic_check(FILE* f) {
  return (dynamic_check) gen_read(f);
}
dynamic_check make_dynamic_check(entity a1, entity a2, bool a3) {
  return (dynamic_check) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, dynamic_check_domain, a1, a2, a3);
}

