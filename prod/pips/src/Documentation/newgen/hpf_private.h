#ifndef _newgen_hpf_private_included
#define _newgen_hpf_private_included
#define _gen_hpf_private_start 186
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_align_domain_defined_)
#define _newgen_align_domain_defined_
#define ALIGN_NEWGEN_DOMAIN (align_domain)
#define align_NEWGEN_DOMAIN (align_domain)
typedef struct _newgen_struct_align_ * align;
#endif /* _newgen_align_domain_defined_ */

#if !defined(_newgen_distribute_domain_defined_)
#define _newgen_distribute_domain_defined_
#define DISTRIBUTE_NEWGEN_DOMAIN (distribute_domain)
#define distribute_NEWGEN_DOMAIN (distribute_domain)
typedef struct _newgen_struct_distribute_ * distribute;
#endif /* _newgen_distribute_domain_defined_ */

#if !defined(_newgen_entity_domain_defined_)
#define _newgen_entity_domain_defined_
#define ENTITY_NEWGEN_DOMAIN (entity_domain)
#define entity_NEWGEN_DOMAIN (entity_domain)
typedef struct _newgen_struct_entity_ * entity;
#endif /* _newgen_entity_domain_defined_ */

#if !defined(_newgen_entity_int_domain_defined_)
#define _newgen_entity_int_domain_defined_
#define ENTITY_INT_NEWGEN_DOMAIN (entity_int_domain)
#define entity_int_NEWGEN_DOMAIN (entity_int_domain)
typedef struct _newgen_struct_entity_int_ * entity_int;
#endif /* _newgen_entity_int_domain_defined_ */

#if !defined(_newgen_statement_domain_defined_)
#define _newgen_statement_domain_defined_
#define STATEMENT_NEWGEN_DOMAIN (statement_domain)
#define statement_NEWGEN_DOMAIN (statement_domain)
typedef struct _newgen_struct_statement_ * statement;
#endif /* _newgen_statement_domain_defined_ */

#if !defined(_newgen_reduction_operator_domain_defined_)
#define _newgen_reduction_operator_domain_defined_
#define REDUCTION_OPERATOR_NEWGEN_DOMAIN (reduction_operator_domain)
#define reduction_operator_NEWGEN_DOMAIN (reduction_operator_domain)
typedef struct _newgen_struct_reduction_operator_ * reduction_operator;
#endif /* _newgen_reduction_operator_domain_defined_ */

#define alignmap_domain (_gen_hpf_private_start+0)
#if !defined(_newgen_alignmap_domain_defined_)
#define _newgen_alignmap_domain_defined_
#define ALIGNMAP_NEWGEN_DOMAIN (alignmap_domain)
#define alignmap_NEWGEN_DOMAIN (alignmap_domain)
typedef struct _newgen_struct_alignmap_ * alignmap;
#endif /* _newgen_alignmap_domain_defined_ */

#define data_status_domain (_gen_hpf_private_start+1)
#if !defined(_newgen_data_status_domain_defined_)
#define _newgen_data_status_domain_defined_
#define DATA_STATUS_NEWGEN_DOMAIN (data_status_domain)
#define data_status_NEWGEN_DOMAIN (data_status_domain)
typedef struct _newgen_struct_data_status_ * data_status;
#endif /* _newgen_data_status_domain_defined_ */

#define distributemap_domain (_gen_hpf_private_start+2)
#if !defined(_newgen_distributemap_domain_defined_)
#define _newgen_distributemap_domain_defined_
#define DISTRIBUTEMAP_NEWGEN_DOMAIN (distributemap_domain)
#define distributemap_NEWGEN_DOMAIN (distributemap_domain)
typedef struct _newgen_struct_distributemap_ * distributemap;
#endif /* _newgen_distributemap_domain_defined_ */

#define dynamic_status_domain (_gen_hpf_private_start+3)
#if !defined(_newgen_dynamic_status_domain_defined_)
#define _newgen_dynamic_status_domain_defined_
#define DYNAMIC_STATUS_NEWGEN_DOMAIN (dynamic_status_domain)
#define dynamic_status_NEWGEN_DOMAIN (dynamic_status_domain)
typedef struct _newgen_struct_dynamic_status_ * dynamic_status;
#endif /* _newgen_dynamic_status_domain_defined_ */

#define entities_domain (_gen_hpf_private_start+4)
#if !defined(_newgen_entities_domain_defined_)
#define _newgen_entities_domain_defined_
#define ENTITIES_NEWGEN_DOMAIN (entities_domain)
#define entities_NEWGEN_DOMAIN (entities_domain)
typedef struct _newgen_struct_entities_ * entities;
#endif /* _newgen_entities_domain_defined_ */

#define entity_entities_domain (_gen_hpf_private_start+5)
#if !defined(_newgen_entity_entities_domain_defined_)
#define _newgen_entity_entities_domain_defined_
#define ENTITY_ENTITIES_NEWGEN_DOMAIN (entity_entities_domain)
#define entity_entities_NEWGEN_DOMAIN (entity_entities_domain)
typedef struct _newgen_struct_entity_entities_ * entity_entities;
#endif /* _newgen_entity_entities_domain_defined_ */

#define entitymap_domain (_gen_hpf_private_start+6)
#if !defined(_newgen_entitymap_domain_defined_)
#define _newgen_entitymap_domain_defined_
#define ENTITYMAP_NEWGEN_DOMAIN (entitymap_domain)
#define entitymap_NEWGEN_DOMAIN (entitymap_domain)
typedef struct _newgen_struct_entitymap_ * entitymap;
#endif /* _newgen_entitymap_domain_defined_ */

#define entity_status_domain (_gen_hpf_private_start+7)
#if !defined(_newgen_entity_status_domain_defined_)
#define _newgen_entity_status_domain_defined_
#define ENTITY_STATUS_NEWGEN_DOMAIN (entity_status_domain)
#define entity_status_NEWGEN_DOMAIN (entity_status_domain)
typedef struct _newgen_struct_entity_status_ * entity_status;
#endif /* _newgen_entity_status_domain_defined_ */

#define hpfc_reductions_domain (_gen_hpf_private_start+8)
#if !defined(_newgen_hpfc_reductions_domain_defined_)
#define _newgen_hpfc_reductions_domain_defined_
#define HPFC_REDUCTIONS_NEWGEN_DOMAIN (hpfc_reductions_domain)
#define hpfc_reductions_NEWGEN_DOMAIN (hpfc_reductions_domain)
typedef struct _newgen_struct_hpfc_reductions_ * hpfc_reductions;
#endif /* _newgen_hpfc_reductions_domain_defined_ */

#define hpfc_status_domain (_gen_hpf_private_start+9)
#if !defined(_newgen_hpfc_status_domain_defined_)
#define _newgen_hpfc_status_domain_defined_
#define HPFC_STATUS_NEWGEN_DOMAIN (hpfc_status_domain)
#define hpfc_status_NEWGEN_DOMAIN (hpfc_status_domain)
typedef struct _newgen_struct_hpfc_status_ * hpfc_status;
#endif /* _newgen_hpfc_status_domain_defined_ */

#define hpf_newdecl_domain (_gen_hpf_private_start+10)
#if !defined(_newgen_hpf_newdecl_domain_defined_)
#define _newgen_hpf_newdecl_domain_defined_
#define HPF_NEWDECL_NEWGEN_DOMAIN (hpf_newdecl_domain)
#define hpf_newdecl_NEWGEN_DOMAIN (hpf_newdecl_domain)
typedef struct _newgen_struct_hpf_newdecl_ * hpf_newdecl;
#endif /* _newgen_hpf_newdecl_domain_defined_ */

#define hpf_newdecls_domain (_gen_hpf_private_start+11)
#if !defined(_newgen_hpf_newdecls_domain_defined_)
#define _newgen_hpf_newdecls_domain_defined_
#define HPF_NEWDECLS_NEWGEN_DOMAIN (hpf_newdecls_domain)
#define hpf_newdecls_NEWGEN_DOMAIN (hpf_newdecls_domain)
typedef struct _newgen_struct_hpf_newdecls_ * hpf_newdecls;
#endif /* _newgen_hpf_newdecls_domain_defined_ */

#define newdeclmap_domain (_gen_hpf_private_start+12)
#if !defined(_newgen_newdeclmap_domain_defined_)
#define _newgen_newdeclmap_domain_defined_
#define NEWDECLMAP_NEWGEN_DOMAIN (newdeclmap_domain)
#define newdeclmap_NEWGEN_DOMAIN (newdeclmap_domain)
typedef struct _newgen_struct_newdeclmap_ * newdeclmap;
#endif /* _newgen_newdeclmap_domain_defined_ */

#define numbers_status_domain (_gen_hpf_private_start+13)
#if !defined(_newgen_numbers_status_domain_defined_)
#define _newgen_numbers_status_domain_defined_
#define NUMBERS_STATUS_NEWGEN_DOMAIN (numbers_status_domain)
#define numbers_status_NEWGEN_DOMAIN (numbers_status_domain)
typedef struct _newgen_struct_numbers_status_ * numbers_status;
#endif /* _newgen_numbers_status_domain_defined_ */

#define overlap_domain (_gen_hpf_private_start+14)
#if !defined(_newgen_overlap_domain_defined_)
#define _newgen_overlap_domain_defined_
#define OVERLAP_NEWGEN_DOMAIN (overlap_domain)
#define overlap_NEWGEN_DOMAIN (overlap_domain)
typedef struct _newgen_struct_overlap_ * overlap;
#endif /* _newgen_overlap_domain_defined_ */

#define overlapsmap_domain (_gen_hpf_private_start+15)
#if !defined(_newgen_overlapsmap_domain_defined_)
#define _newgen_overlapsmap_domain_defined_
#define OVERLAPSMAP_NEWGEN_DOMAIN (overlapsmap_domain)
#define overlapsmap_NEWGEN_DOMAIN (overlapsmap_domain)
typedef struct _newgen_struct_overlapsmap_ * overlapsmap;
#endif /* _newgen_overlapsmap_domain_defined_ */

#define remapping_domain (_gen_hpf_private_start+16)
#if !defined(_newgen_remapping_domain_defined_)
#define _newgen_remapping_domain_defined_
#define REMAPPING_NEWGEN_DOMAIN (remapping_domain)
#define remapping_NEWGEN_DOMAIN (remapping_domain)
typedef struct _newgen_struct_remapping_ * remapping;
#endif /* _newgen_remapping_domain_defined_ */

#define renaming_domain (_gen_hpf_private_start+17)
#if !defined(_newgen_renaming_domain_defined_)
#define _newgen_renaming_domain_defined_
#define RENAMING_NEWGEN_DOMAIN (renaming_domain)
#define renaming_NEWGEN_DOMAIN (renaming_domain)
typedef struct _newgen_struct_renaming_ * renaming;
#endif /* _newgen_renaming_domain_defined_ */

#define statement_entities_domain (_gen_hpf_private_start+18)
#if !defined(_newgen_statement_entities_domain_defined_)
#define _newgen_statement_entities_domain_defined_
#define STATEMENT_ENTITIES_NEWGEN_DOMAIN (statement_entities_domain)
#define statement_entities_NEWGEN_DOMAIN (statement_entities_domain)
typedef struct _newgen_struct_statement_entities_ * statement_entities;
#endif /* _newgen_statement_entities_domain_defined_ */

#define statement_renamings_domain (_gen_hpf_private_start+19)
#if !defined(_newgen_statement_renamings_domain_defined_)
#define _newgen_statement_renamings_domain_defined_
#define STATEMENT_RENAMINGS_NEWGEN_DOMAIN (statement_renamings_domain)
#define statement_renamings_NEWGEN_DOMAIN (statement_renamings_domain)
typedef struct _newgen_struct_statement_renamings_ * statement_renamings;
#endif /* _newgen_statement_renamings_domain_defined_ */

/* ALIGNMAP
 */
#define ALIGNMAP(x) ((alignmap)((x).p))
#define alignmap_CAST(x) ALIGNMAP(x)
#define ALIGNMAP_CAST(x) ALIGNMAP(x)
#define ALIGNMAP_(x) ((x).e)
#define ALIGNMAP_TYPE alignmap
#define alignmap_TYPE alignmap
#define alignmap_undefined ((alignmap)gen_chunk_undefined)
#define alignmap_undefined_p(x) ((x)==alignmap_undefined)

extern alignmap copy_alignmap(alignmap);
extern void free_alignmap(alignmap);
extern alignmap check_alignmap(alignmap);
extern bool alignmap_consistent_p(alignmap);
extern bool alignmap_defined_p(alignmap);
#define gen_ALIGNMAP_cons gen_alignmap_cons
extern list gen_alignmap_cons(alignmap, list);
extern void alignmap_assign_contents(alignmap, alignmap);
extern void alignmap_non_recursive_free(alignmap);
extern void write_alignmap(FILE*, alignmap);
extern alignmap read_alignmap(FILE*);
extern alignmap make_alignmap(void);

struct _newgen_struct_alignmap_ {
  intptr_t _type_;
  hash_table _alignmap_holder_;
};

#define alignmap_domain_number(x) ((x)->_type_)
#define alignmap_hash_table(x) ((x)->_alignmap_holder_)
#define alignmap_key_type entity
#define alignmap_value_type align
#define ALIGNMAP_MAP(k,v,c,f) FUNCTION_MAP(alignmap,p,p,k,v,c,f)
#define ALIGNMAP_FOREACH(k,v,f) FUNCTION_FOREACH(alignmap,p,p,k,v,f)
extern align apply_alignmap(alignmap, entity);
extern void update_alignmap(alignmap, entity, align);
extern void extend_alignmap(alignmap, entity, align);
extern align delete_alignmap(alignmap, entity);
extern bool bound_alignmap_p(alignmap, entity);

/* DATA_STATUS
 */
#define DATA_STATUS(x) ((data_status)((x).p))
#define data_status_CAST(x) DATA_STATUS(x)
#define DATA_STATUS_CAST(x) DATA_STATUS(x)
#define DATA_STATUS_(x) ((x).e)
#define DATA_STATUS_TYPE data_status
#define data_status_TYPE data_status
#define data_status_undefined ((data_status)gen_chunk_undefined)
#define data_status_undefined_p(x) ((x)==data_status_undefined)

extern data_status copy_data_status(data_status);
extern void free_data_status(data_status);
extern data_status check_data_status(data_status);
extern bool data_status_consistent_p(data_status);
extern bool data_status_defined_p(data_status);
#define gen_DATA_STATUS_cons gen_data_status_cons
extern list gen_data_status_cons(data_status, list);
extern void data_status_assign_contents(data_status, data_status);
extern void data_status_non_recursive_free(data_status);
extern void write_data_status(FILE*, data_status);
extern data_status read_data_status(FILE*);
extern data_status make_data_status(newdeclmap, alignmap, distributemap, list, list, list);

struct _newgen_struct_data_status_ {
  intptr_t _type_;
  newdeclmap _data_status_newdeclmap_; /* newdeclmap:newdeclmap */
  alignmap _data_status_alignmap_; /* alignmap:alignmap */
  distributemap _data_status_distributemap_; /* distributemap:distributemap */
  list _data_status_arrays_; /* arrays:entity* */
  list _data_status_templates_; /* templates:entity* */
  list _data_status_processors_; /* processors:entity* */
};

#define data_status_domain_number(x) ((x)->_type_)
#define data_status_newdeclmap_(x) data_status_newdeclmap(x) /* old hack compatible */
#define data_status_newdeclmap(x) ((x)->_data_status_newdeclmap_)
#define data_status_alignmap_(x) data_status_alignmap(x) /* old hack compatible */
#define data_status_alignmap(x) ((x)->_data_status_alignmap_)
#define data_status_distributemap_(x) data_status_distributemap(x) /* old hack compatible */
#define data_status_distributemap(x) ((x)->_data_status_distributemap_)
#define data_status_arrays_(x) data_status_arrays(x) /* old hack compatible */
#define data_status_arrays(x) ((x)->_data_status_arrays_)
#define data_status_templates_(x) data_status_templates(x) /* old hack compatible */
#define data_status_templates(x) ((x)->_data_status_templates_)
#define data_status_processors_(x) data_status_processors(x) /* old hack compatible */
#define data_status_processors(x) ((x)->_data_status_processors_)

/* DISTRIBUTEMAP
 */
#define DISTRIBUTEMAP(x) ((distributemap)((x).p))
#define distributemap_CAST(x) DISTRIBUTEMAP(x)
#define DISTRIBUTEMAP_CAST(x) DISTRIBUTEMAP(x)
#define DISTRIBUTEMAP_(x) ((x).e)
#define DISTRIBUTEMAP_TYPE distributemap
#define distributemap_TYPE distributemap
#define distributemap_undefined ((distributemap)gen_chunk_undefined)
#define distributemap_undefined_p(x) ((x)==distributemap_undefined)

extern distributemap copy_distributemap(distributemap);
extern void free_distributemap(distributemap);
extern distributemap check_distributemap(distributemap);
extern bool distributemap_consistent_p(distributemap);
extern bool distributemap_defined_p(distributemap);
#define gen_DISTRIBUTEMAP_cons gen_distributemap_cons
extern list gen_distributemap_cons(distributemap, list);
extern void distributemap_assign_contents(distributemap, distributemap);
extern void distributemap_non_recursive_free(distributemap);
extern void write_distributemap(FILE*, distributemap);
extern distributemap read_distributemap(FILE*);
extern distributemap make_distributemap(void);

struct _newgen_struct_distributemap_ {
  intptr_t _type_;
  hash_table _distributemap_holder_;
};

#define distributemap_domain_number(x) ((x)->_type_)
#define distributemap_hash_table(x) ((x)->_distributemap_holder_)
#define distributemap_key_type entity
#define distributemap_value_type distribute
#define DISTRIBUTEMAP_MAP(k,v,c,f) FUNCTION_MAP(distributemap,p,p,k,v,c,f)
#define DISTRIBUTEMAP_FOREACH(k,v,f) FUNCTION_FOREACH(distributemap,p,p,k,v,f)
extern distribute apply_distributemap(distributemap, entity);
extern void update_distributemap(distributemap, entity, distribute);
extern void extend_distributemap(distributemap, entity, distribute);
extern distribute delete_distributemap(distributemap, entity);
extern bool bound_distributemap_p(distributemap, entity);

/* DYNAMIC_STATUS
 */
#define DYNAMIC_STATUS(x) ((dynamic_status)((x).p))
#define dynamic_status_CAST(x) DYNAMIC_STATUS(x)
#define DYNAMIC_STATUS_CAST(x) DYNAMIC_STATUS(x)
#define DYNAMIC_STATUS_(x) ((x).e)
#define DYNAMIC_STATUS_TYPE dynamic_status
#define dynamic_status_TYPE dynamic_status
#define dynamic_status_undefined ((dynamic_status)gen_chunk_undefined)
#define dynamic_status_undefined_p(x) ((x)==dynamic_status_undefined)

extern dynamic_status copy_dynamic_status(dynamic_status);
extern void free_dynamic_status(dynamic_status);
extern dynamic_status check_dynamic_status(dynamic_status);
extern bool dynamic_status_consistent_p(dynamic_status);
extern bool dynamic_status_defined_p(dynamic_status);
#define gen_DYNAMIC_STATUS_cons gen_dynamic_status_cons
extern list gen_dynamic_status_cons(dynamic_status, list);
extern void dynamic_status_assign_contents(dynamic_status, dynamic_status);
extern void dynamic_status_non_recursive_free(dynamic_status);
extern void write_dynamic_status(FILE*, dynamic_status);
extern dynamic_status read_dynamic_status(FILE*);
extern dynamic_status make_dynamic_status(entity_entities, entitymap, statement_renamings, statement_entities);

struct _newgen_struct_dynamic_status_ {
  intptr_t _type_;
  entity_entities _dynamic_status_dynamics_; /* dynamics:entity_entities */
  entitymap _dynamic_status_primary_; /* primary:entitymap */
  statement_renamings _dynamic_status_renamings_; /* renamings:statement_renamings */
  statement_entities _dynamic_status_tokeep_; /* tokeep:statement_entities */
};

#define dynamic_status_domain_number(x) ((x)->_type_)
#define dynamic_status_dynamics_(x) dynamic_status_dynamics(x) /* old hack compatible */
#define dynamic_status_dynamics(x) ((x)->_dynamic_status_dynamics_)
#define dynamic_status_primary_(x) dynamic_status_primary(x) /* old hack compatible */
#define dynamic_status_primary(x) ((x)->_dynamic_status_primary_)
#define dynamic_status_renamings_(x) dynamic_status_renamings(x) /* old hack compatible */
#define dynamic_status_renamings(x) ((x)->_dynamic_status_renamings_)
#define dynamic_status_tokeep_(x) dynamic_status_tokeep(x) /* old hack compatible */
#define dynamic_status_tokeep(x) ((x)->_dynamic_status_tokeep_)

/* ENTITIES
 */
#define ENTITIES(x) ((entities)((x).p))
#define entities_CAST(x) ENTITIES(x)
#define ENTITIES_CAST(x) ENTITIES(x)
#define ENTITIES_(x) ((x).e)
#define ENTITIES_TYPE entities
#define entities_TYPE entities
#define entities_undefined ((entities)gen_chunk_undefined)
#define entities_undefined_p(x) ((x)==entities_undefined)

extern entities copy_entities(entities);
extern void free_entities(entities);
extern entities check_entities(entities);
extern bool entities_consistent_p(entities);
extern bool entities_defined_p(entities);
#define gen_ENTITIES_cons gen_entities_cons
extern list gen_entities_cons(entities, list);
extern void entities_assign_contents(entities, entities);
extern void entities_non_recursive_free(entities);
extern void write_entities(FILE*, entities);
extern entities read_entities(FILE*);
extern entities make_entities(list);

struct _newgen_struct_entities_ {
  intptr_t _type_;
  list _entities_holder_;
};

#define entities_domain_number(x) ((x)->_type_)
#define entities_list(x) ((x)->_entities_holder_)

/* ENTITY_ENTITIES
 */
#define ENTITY_ENTITIES(x) ((entity_entities)((x).p))
#define entity_entities_CAST(x) ENTITY_ENTITIES(x)
#define ENTITY_ENTITIES_CAST(x) ENTITY_ENTITIES(x)
#define ENTITY_ENTITIES_(x) ((x).e)
#define ENTITY_ENTITIES_TYPE entity_entities
#define entity_entities_TYPE entity_entities
#define entity_entities_undefined ((entity_entities)gen_chunk_undefined)
#define entity_entities_undefined_p(x) ((x)==entity_entities_undefined)

extern entity_entities copy_entity_entities(entity_entities);
extern void free_entity_entities(entity_entities);
extern entity_entities check_entity_entities(entity_entities);
extern bool entity_entities_consistent_p(entity_entities);
extern bool entity_entities_defined_p(entity_entities);
#define gen_ENTITY_ENTITIES_cons gen_entity_entities_cons
extern list gen_entity_entities_cons(entity_entities, list);
extern void entity_entities_assign_contents(entity_entities, entity_entities);
extern void entity_entities_non_recursive_free(entity_entities);
extern void write_entity_entities(FILE*, entity_entities);
extern entity_entities read_entity_entities(FILE*);
extern entity_entities make_entity_entities(void);

struct _newgen_struct_entity_entities_ {
  intptr_t _type_;
  hash_table _entity_entities_holder_;
};

#define entity_entities_domain_number(x) ((x)->_type_)
#define entity_entities_hash_table(x) ((x)->_entity_entities_holder_)
#define entity_entities_key_type entity
#define entity_entities_value_type entities
#define ENTITY_ENTITIES_MAP(k,v,c,f) FUNCTION_MAP(entity_entities,p,p,k,v,c,f)
#define ENTITY_ENTITIES_FOREACH(k,v,f) FUNCTION_FOREACH(entity_entities,p,p,k,v,f)
extern entities apply_entity_entities(entity_entities, entity);
extern void update_entity_entities(entity_entities, entity, entities);
extern void extend_entity_entities(entity_entities, entity, entities);
extern entities delete_entity_entities(entity_entities, entity);
extern bool bound_entity_entities_p(entity_entities, entity);

/* ENTITYMAP
 */
#define ENTITYMAP(x) ((entitymap)((x).p))
#define entitymap_CAST(x) ENTITYMAP(x)
#define ENTITYMAP_CAST(x) ENTITYMAP(x)
#define ENTITYMAP_(x) ((x).e)
#define ENTITYMAP_TYPE entitymap
#define entitymap_TYPE entitymap
#define entitymap_undefined ((entitymap)gen_chunk_undefined)
#define entitymap_undefined_p(x) ((x)==entitymap_undefined)

extern entitymap copy_entitymap(entitymap);
extern void free_entitymap(entitymap);
extern entitymap check_entitymap(entitymap);
extern bool entitymap_consistent_p(entitymap);
extern bool entitymap_defined_p(entitymap);
#define gen_ENTITYMAP_cons gen_entitymap_cons
extern list gen_entitymap_cons(entitymap, list);
extern void entitymap_assign_contents(entitymap, entitymap);
extern void entitymap_non_recursive_free(entitymap);
extern void write_entitymap(FILE*, entitymap);
extern entitymap read_entitymap(FILE*);
extern entitymap make_entitymap(void);

struct _newgen_struct_entitymap_ {
  intptr_t _type_;
  hash_table _entitymap_holder_;
};

#define entitymap_domain_number(x) ((x)->_type_)
#define entitymap_hash_table(x) ((x)->_entitymap_holder_)
#define entitymap_key_type entity
#define entitymap_value_type entity
#define ENTITYMAP_MAP(k,v,c,f) FUNCTION_MAP(entitymap,p,p,k,v,c,f)
#define ENTITYMAP_FOREACH(k,v,f) FUNCTION_FOREACH(entitymap,p,p,k,v,f)
extern entity apply_entitymap(entitymap, entity);
extern void update_entitymap(entitymap, entity, entity);
extern void extend_entitymap(entitymap, entity, entity);
extern entity delete_entitymap(entitymap, entity);
extern bool bound_entitymap_p(entitymap, entity);

/* ENTITY_STATUS
 */
#define ENTITY_STATUS(x) ((entity_status)((x).p))
#define entity_status_CAST(x) ENTITY_STATUS(x)
#define ENTITY_STATUS_CAST(x) ENTITY_STATUS(x)
#define ENTITY_STATUS_(x) ((x).e)
#define ENTITY_STATUS_TYPE entity_status
#define entity_status_TYPE entity_status
#define entity_status_undefined ((entity_status)gen_chunk_undefined)
#define entity_status_undefined_p(x) ((x)==entity_status_undefined)

extern entity_status copy_entity_status(entity_status);
extern void free_entity_status(entity_status);
extern entity_status check_entity_status(entity_status);
extern bool entity_status_consistent_p(entity_status);
extern bool entity_status_defined_p(entity_status);
#define gen_ENTITY_STATUS_cons gen_entity_status_cons
extern list gen_entity_status_cons(entity_status, list);
extern void entity_status_assign_contents(entity_status, entity_status);
extern void entity_status_non_recursive_free(entity_status);
extern void write_entity_status(FILE*, entity_status);
extern entity_status read_entity_status(FILE*);
extern entity_status make_entity_status(entitymap, entitymap, entitymap, entitymap, entity_int);

struct _newgen_struct_entity_status_ {
  intptr_t _type_;
  entitymap _entity_status_new_host_; /* new_host:entitymap */
  entitymap _entity_status_new_node_; /* new_node:entitymap */
  entitymap _entity_status_old_host_; /* old_host:entitymap */
  entitymap _entity_status_old_node_; /* old_node:entitymap */
  entity_int _entity_status_referenced_; /* referenced:entity_int */
};

#define entity_status_domain_number(x) ((x)->_type_)
#define entity_status_new_host_(x) entity_status_new_host(x) /* old hack compatible */
#define entity_status_new_host(x) ((x)->_entity_status_new_host_)
#define entity_status_new_node_(x) entity_status_new_node(x) /* old hack compatible */
#define entity_status_new_node(x) ((x)->_entity_status_new_node_)
#define entity_status_old_host_(x) entity_status_old_host(x) /* old hack compatible */
#define entity_status_old_host(x) ((x)->_entity_status_old_host_)
#define entity_status_old_node_(x) entity_status_old_node(x) /* old hack compatible */
#define entity_status_old_node(x) ((x)->_entity_status_old_node_)
#define entity_status_referenced_(x) entity_status_referenced(x) /* old hack compatible */
#define entity_status_referenced(x) ((x)->_entity_status_referenced_)

/* HPFC_REDUCTIONS
 */
#define HPFC_REDUCTIONS(x) ((hpfc_reductions)((x).p))
#define hpfc_reductions_CAST(x) HPFC_REDUCTIONS(x)
#define HPFC_REDUCTIONS_CAST(x) HPFC_REDUCTIONS(x)
#define HPFC_REDUCTIONS_(x) ((x).e)
#define HPFC_REDUCTIONS_TYPE hpfc_reductions
#define hpfc_reductions_TYPE hpfc_reductions
#define hpfc_reductions_undefined ((hpfc_reductions)gen_chunk_undefined)
#define hpfc_reductions_undefined_p(x) ((x)==hpfc_reductions_undefined)

extern hpfc_reductions copy_hpfc_reductions(hpfc_reductions);
extern void free_hpfc_reductions(hpfc_reductions);
extern hpfc_reductions check_hpfc_reductions(hpfc_reductions);
extern bool hpfc_reductions_consistent_p(hpfc_reductions);
extern bool hpfc_reductions_defined_p(hpfc_reductions);
#define gen_HPFC_REDUCTIONS_cons gen_hpfc_reductions_cons
extern list gen_hpfc_reductions_cons(hpfc_reductions, list);
extern void hpfc_reductions_assign_contents(hpfc_reductions, hpfc_reductions);
extern void hpfc_reductions_non_recursive_free(hpfc_reductions);
extern void write_hpfc_reductions(FILE*, hpfc_reductions);
extern hpfc_reductions read_hpfc_reductions(FILE*);
extern hpfc_reductions make_hpfc_reductions(entity, entity, reduction_operator);

struct _newgen_struct_hpfc_reductions_ {
  intptr_t _type_;
  entity _hpfc_reductions_initial_; /* initial:entity */
  entity _hpfc_reductions_replacement_; /* replacement:entity */
  reduction_operator _hpfc_reductions_operator_; /* operator:reduction_operator */
};

#define hpfc_reductions_domain_number(x) ((x)->_type_)
#define hpfc_reductions_initial_(x) hpfc_reductions_initial(x) /* old hack compatible */
#define hpfc_reductions_initial(x) ((x)->_hpfc_reductions_initial_)
#define hpfc_reductions_replacement_(x) hpfc_reductions_replacement(x) /* old hack compatible */
#define hpfc_reductions_replacement(x) ((x)->_hpfc_reductions_replacement_)
#define hpfc_reductions_operator_(x) hpfc_reductions_operator(x) /* old hack compatible */
#define hpfc_reductions_operator(x) ((x)->_hpfc_reductions_operator_)

/* HPFC_STATUS
 */
#define HPFC_STATUS(x) ((hpfc_status)((x).p))
#define hpfc_status_CAST(x) HPFC_STATUS(x)
#define HPFC_STATUS_CAST(x) HPFC_STATUS(x)
#define HPFC_STATUS_(x) ((x).e)
#define HPFC_STATUS_TYPE hpfc_status
#define hpfc_status_TYPE hpfc_status
#define hpfc_status_undefined ((hpfc_status)gen_chunk_undefined)
#define hpfc_status_undefined_p(x) ((x)==hpfc_status_undefined)

extern hpfc_status copy_hpfc_status(hpfc_status);
extern void free_hpfc_status(hpfc_status);
extern hpfc_status check_hpfc_status(hpfc_status);
extern bool hpfc_status_consistent_p(hpfc_status);
extern bool hpfc_status_defined_p(hpfc_status);
#define gen_HPFC_STATUS_cons gen_hpfc_status_cons
extern list gen_hpfc_status_cons(hpfc_status, list);
extern void hpfc_status_assign_contents(hpfc_status, hpfc_status);
extern void hpfc_status_non_recursive_free(hpfc_status);
extern void write_hpfc_status(FILE*, hpfc_status);
extern hpfc_status read_hpfc_status(FILE*);
extern hpfc_status make_hpfc_status(overlapsmap, data_status, numbers_status, entity_status, list, dynamic_status, list, list, list, statement_entities);

struct _newgen_struct_hpfc_status_ {
  intptr_t _type_;
  overlapsmap _hpfc_status_overlapsmap_; /* overlapsmap:overlapsmap */
  data_status _hpfc_status_data_status_; /* data_status:data_status */
  numbers_status _hpfc_status_numbers_status_; /* numbers_status:numbers_status */
  entity_status _hpfc_status_entity_status_; /* entity_status:entity_status */
  list _hpfc_status_commons_; /* commons:entity* */
  dynamic_status _hpfc_status_dynamic_status_; /* dynamic_status:dynamic_status */
  list _hpfc_status_pures_; /* pures:entity* */
  list _hpfc_status_ios_; /* ios:entity* */
  list _hpfc_status_computed_; /* computed:remapping* */
  statement_entities _hpfc_status_reductions_; /* reductions:statement_entities */
};

#define hpfc_status_domain_number(x) ((x)->_type_)
#define hpfc_status_overlapsmap_(x) hpfc_status_overlapsmap(x) /* old hack compatible */
#define hpfc_status_overlapsmap(x) ((x)->_hpfc_status_overlapsmap_)
#define hpfc_status_data_status_(x) hpfc_status_data_status(x) /* old hack compatible */
#define hpfc_status_data_status(x) ((x)->_hpfc_status_data_status_)
#define hpfc_status_numbers_status_(x) hpfc_status_numbers_status(x) /* old hack compatible */
#define hpfc_status_numbers_status(x) ((x)->_hpfc_status_numbers_status_)
#define hpfc_status_entity_status_(x) hpfc_status_entity_status(x) /* old hack compatible */
#define hpfc_status_entity_status(x) ((x)->_hpfc_status_entity_status_)
#define hpfc_status_commons_(x) hpfc_status_commons(x) /* old hack compatible */
#define hpfc_status_commons(x) ((x)->_hpfc_status_commons_)
#define hpfc_status_dynamic_status_(x) hpfc_status_dynamic_status(x) /* old hack compatible */
#define hpfc_status_dynamic_status(x) ((x)->_hpfc_status_dynamic_status_)
#define hpfc_status_pures_(x) hpfc_status_pures(x) /* old hack compatible */
#define hpfc_status_pures(x) ((x)->_hpfc_status_pures_)
#define hpfc_status_ios_(x) hpfc_status_ios(x) /* old hack compatible */
#define hpfc_status_ios(x) ((x)->_hpfc_status_ios_)
#define hpfc_status_computed_(x) hpfc_status_computed(x) /* old hack compatible */
#define hpfc_status_computed(x) ((x)->_hpfc_status_computed_)
#define hpfc_status_reductions_(x) hpfc_status_reductions(x) /* old hack compatible */
#define hpfc_status_reductions(x) ((x)->_hpfc_status_reductions_)

/* HPF_NEWDECL
 */
#define HPF_NEWDECL(x) ((hpf_newdecl)((x).p))
#define hpf_newdecl_CAST(x) HPF_NEWDECL(x)
#define HPF_NEWDECL_CAST(x) HPF_NEWDECL(x)
#define HPF_NEWDECL_(x) ((x).e)
#define HPF_NEWDECL_TYPE hpf_newdecl
#define hpf_newdecl_TYPE hpf_newdecl
#define hpf_newdecl_undefined ((hpf_newdecl)gen_chunk_undefined)
#define hpf_newdecl_undefined_p(x) ((x)==hpf_newdecl_undefined)

extern hpf_newdecl copy_hpf_newdecl(hpf_newdecl);
extern void free_hpf_newdecl(hpf_newdecl);
extern hpf_newdecl check_hpf_newdecl(hpf_newdecl);
extern bool hpf_newdecl_consistent_p(hpf_newdecl);
extern bool hpf_newdecl_defined_p(hpf_newdecl);
#define gen_HPF_NEWDECL_cons gen_hpf_newdecl_cons
extern list gen_hpf_newdecl_cons(hpf_newdecl, list);
extern void hpf_newdecl_assign_contents(hpf_newdecl, hpf_newdecl);
extern void hpf_newdecl_non_recursive_free(hpf_newdecl);
extern void write_hpf_newdecl(FILE*, hpf_newdecl);
extern hpf_newdecl read_hpf_newdecl(FILE*);
enum hpf_newdecl_utype {
  is_hpf_newdecl_none,
  is_hpf_newdecl_alpha,
  is_hpf_newdecl_beta,
  is_hpf_newdecl_gamma,
  is_hpf_newdecl_delta
};
extern string hpf_newdecl_tag_as_string(enum hpf_newdecl_utype);
extern hpf_newdecl make_hpf_newdecl(enum hpf_newdecl_utype, void *);
extern hpf_newdecl make_hpf_newdecl_none(void);
extern hpf_newdecl make_hpf_newdecl_alpha(void);
extern hpf_newdecl make_hpf_newdecl_beta(void);
extern hpf_newdecl make_hpf_newdecl_gamma(void);
extern hpf_newdecl make_hpf_newdecl_delta(void);

struct _newgen_struct_hpf_newdecl_ {
  intptr_t _type_;
  enum hpf_newdecl_utype _hpf_newdecl_tag__;
  union {
    gen_chunk _hpf_newdecl_none_; /* none:unit */
    gen_chunk _hpf_newdecl_alpha_; /* alpha:unit */
    gen_chunk _hpf_newdecl_beta_; /* beta:unit */
    gen_chunk _hpf_newdecl_gamma_; /* gamma:unit */
    gen_chunk _hpf_newdecl_delta_; /* delta:unit */
  } _hpf_newdecl_union_;
};

#define hpf_newdecl_domain_number(x) ((x)->_type_)
#define hpf_newdecl_tag(x) ((x)->_hpf_newdecl_tag__)
#define hpf_newdecl_none_p(x) (hpf_newdecl_tag(x)==is_hpf_newdecl_none)
#define hpf_newdecl_none_(x) hpf_newdecl_none(x) /* old hack compatible */
#define hpf_newdecl_none(x) ((x)->_hpf_newdecl_union_._hpf_newdecl_none_.u)
#define hpf_newdecl_alpha_p(x) (hpf_newdecl_tag(x)==is_hpf_newdecl_alpha)
#define hpf_newdecl_alpha_(x) hpf_newdecl_alpha(x) /* old hack compatible */
#define hpf_newdecl_alpha(x) ((x)->_hpf_newdecl_union_._hpf_newdecl_alpha_.u)
#define hpf_newdecl_beta_p(x) (hpf_newdecl_tag(x)==is_hpf_newdecl_beta)
#define hpf_newdecl_beta_(x) hpf_newdecl_beta(x) /* old hack compatible */
#define hpf_newdecl_beta(x) ((x)->_hpf_newdecl_union_._hpf_newdecl_beta_.u)
#define hpf_newdecl_gamma_p(x) (hpf_newdecl_tag(x)==is_hpf_newdecl_gamma)
#define hpf_newdecl_gamma_(x) hpf_newdecl_gamma(x) /* old hack compatible */
#define hpf_newdecl_gamma(x) ((x)->_hpf_newdecl_union_._hpf_newdecl_gamma_.u)
#define hpf_newdecl_delta_p(x) (hpf_newdecl_tag(x)==is_hpf_newdecl_delta)
#define hpf_newdecl_delta_(x) hpf_newdecl_delta(x) /* old hack compatible */
#define hpf_newdecl_delta(x) ((x)->_hpf_newdecl_union_._hpf_newdecl_delta_.u)

/* HPF_NEWDECLS
 */
#define HPF_NEWDECLS(x) ((hpf_newdecls)((x).p))
#define hpf_newdecls_CAST(x) HPF_NEWDECLS(x)
#define HPF_NEWDECLS_CAST(x) HPF_NEWDECLS(x)
#define HPF_NEWDECLS_(x) ((x).e)
#define HPF_NEWDECLS_TYPE hpf_newdecls
#define hpf_newdecls_TYPE hpf_newdecls
#define hpf_newdecls_undefined ((hpf_newdecls)gen_chunk_undefined)
#define hpf_newdecls_undefined_p(x) ((x)==hpf_newdecls_undefined)

extern hpf_newdecls copy_hpf_newdecls(hpf_newdecls);
extern void free_hpf_newdecls(hpf_newdecls);
extern hpf_newdecls check_hpf_newdecls(hpf_newdecls);
extern bool hpf_newdecls_consistent_p(hpf_newdecls);
extern bool hpf_newdecls_defined_p(hpf_newdecls);
#define gen_HPF_NEWDECLS_cons gen_hpf_newdecls_cons
extern list gen_hpf_newdecls_cons(hpf_newdecls, list);
extern void hpf_newdecls_assign_contents(hpf_newdecls, hpf_newdecls);
extern void hpf_newdecls_non_recursive_free(hpf_newdecls);
extern void write_hpf_newdecls(FILE*, hpf_newdecls);
extern hpf_newdecls read_hpf_newdecls(FILE*);
extern hpf_newdecls make_hpf_newdecls(list);

struct _newgen_struct_hpf_newdecls_ {
  intptr_t _type_;
  list _hpf_newdecls_holder_;
};

#define hpf_newdecls_domain_number(x) ((x)->_type_)
#define hpf_newdecls_dimensions(x) ((x)->_hpf_newdecls_holder_)

/* NEWDECLMAP
 */
#define NEWDECLMAP(x) ((newdeclmap)((x).p))
#define newdeclmap_CAST(x) NEWDECLMAP(x)
#define NEWDECLMAP_CAST(x) NEWDECLMAP(x)
#define NEWDECLMAP_(x) ((x).e)
#define NEWDECLMAP_TYPE newdeclmap
#define newdeclmap_TYPE newdeclmap
#define newdeclmap_undefined ((newdeclmap)gen_chunk_undefined)
#define newdeclmap_undefined_p(x) ((x)==newdeclmap_undefined)

extern newdeclmap copy_newdeclmap(newdeclmap);
extern void free_newdeclmap(newdeclmap);
extern newdeclmap check_newdeclmap(newdeclmap);
extern bool newdeclmap_consistent_p(newdeclmap);
extern bool newdeclmap_defined_p(newdeclmap);
#define gen_NEWDECLMAP_cons gen_newdeclmap_cons
extern list gen_newdeclmap_cons(newdeclmap, list);
extern void newdeclmap_assign_contents(newdeclmap, newdeclmap);
extern void newdeclmap_non_recursive_free(newdeclmap);
extern void write_newdeclmap(FILE*, newdeclmap);
extern newdeclmap read_newdeclmap(FILE*);
extern newdeclmap make_newdeclmap(void);

struct _newgen_struct_newdeclmap_ {
  intptr_t _type_;
  hash_table _newdeclmap_holder_;
};

#define newdeclmap_domain_number(x) ((x)->_type_)
#define newdeclmap_hash_table(x) ((x)->_newdeclmap_holder_)
#define newdeclmap_key_type entity
#define newdeclmap_value_type hpf_newdecls
#define NEWDECLMAP_MAP(k,v,c,f) FUNCTION_MAP(newdeclmap,p,p,k,v,c,f)
#define NEWDECLMAP_FOREACH(k,v,f) FUNCTION_FOREACH(newdeclmap,p,p,k,v,f)
extern hpf_newdecls apply_newdeclmap(newdeclmap, entity);
extern void update_newdeclmap(newdeclmap, entity, hpf_newdecls);
extern void extend_newdeclmap(newdeclmap, entity, hpf_newdecls);
extern hpf_newdecls delete_newdeclmap(newdeclmap, entity);
extern bool bound_newdeclmap_p(newdeclmap, entity);

/* NUMBERS_STATUS
 */
#define NUMBERS_STATUS(x) ((numbers_status)((x).p))
#define numbers_status_CAST(x) NUMBERS_STATUS(x)
#define NUMBERS_STATUS_CAST(x) NUMBERS_STATUS(x)
#define NUMBERS_STATUS_(x) ((x).e)
#define NUMBERS_STATUS_TYPE numbers_status
#define numbers_status_TYPE numbers_status
#define numbers_status_undefined ((numbers_status)gen_chunk_undefined)
#define numbers_status_undefined_p(x) ((x)==numbers_status_undefined)

extern numbers_status copy_numbers_status(numbers_status);
extern void free_numbers_status(numbers_status);
extern numbers_status check_numbers_status(numbers_status);
extern bool numbers_status_consistent_p(numbers_status);
extern bool numbers_status_defined_p(numbers_status);
#define gen_NUMBERS_STATUS_cons gen_numbers_status_cons
extern list gen_numbers_status_cons(numbers_status, list);
extern void numbers_status_assign_contents(numbers_status, numbers_status);
extern void numbers_status_non_recursive_free(numbers_status);
extern void write_numbers_status(FILE*, numbers_status);
extern numbers_status read_numbers_status(FILE*);
extern numbers_status make_numbers_status(entity_int, intptr_t, intptr_t, intptr_t);

struct _newgen_struct_numbers_status_ {
  intptr_t _type_;
  entity_int _numbers_status_numbermap_; /* numbermap:entity_int */
  intptr_t _numbers_status_arrays_; /* arrays:int */
  intptr_t _numbers_status_templates_; /* templates:int */
  intptr_t _numbers_status_processors_; /* processors:int */
};

#define numbers_status_domain_number(x) ((x)->_type_)
#define numbers_status_numbermap_(x) numbers_status_numbermap(x) /* old hack compatible */
#define numbers_status_numbermap(x) ((x)->_numbers_status_numbermap_)
#define numbers_status_arrays_(x) numbers_status_arrays(x) /* old hack compatible */
#define numbers_status_arrays(x) ((x)->_numbers_status_arrays_)
#define numbers_status_templates_(x) numbers_status_templates(x) /* old hack compatible */
#define numbers_status_templates(x) ((x)->_numbers_status_templates_)
#define numbers_status_processors_(x) numbers_status_processors(x) /* old hack compatible */
#define numbers_status_processors(x) ((x)->_numbers_status_processors_)

/* OVERLAP
 */
#define OVERLAP(x) ((overlap)((x).p))
#define overlap_CAST(x) OVERLAP(x)
#define OVERLAP_CAST(x) OVERLAP(x)
#define OVERLAP_(x) ((x).e)
#define OVERLAP_TYPE overlap
#define overlap_TYPE overlap
#define overlap_undefined ((overlap)gen_chunk_undefined)
#define overlap_undefined_p(x) ((x)==overlap_undefined)

extern overlap copy_overlap(overlap);
extern void free_overlap(overlap);
extern overlap check_overlap(overlap);
extern bool overlap_consistent_p(overlap);
extern bool overlap_defined_p(overlap);
#define gen_OVERLAP_cons gen_overlap_cons
extern list gen_overlap_cons(overlap, list);
extern void overlap_assign_contents(overlap, overlap);
extern void overlap_non_recursive_free(overlap);
extern void write_overlap(FILE*, overlap);
extern overlap read_overlap(FILE*);
extern overlap make_overlap(intptr_t, intptr_t);

struct _newgen_struct_overlap_ {
  intptr_t _type_;
  intptr_t _overlap_lower_; /* lower:int */
  intptr_t _overlap_upper_; /* upper:int */
};

#define overlap_domain_number(x) ((x)->_type_)
#define overlap_lower_(x) overlap_lower(x) /* old hack compatible */
#define overlap_lower(x) ((x)->_overlap_lower_)
#define overlap_upper_(x) overlap_upper(x) /* old hack compatible */
#define overlap_upper(x) ((x)->_overlap_upper_)

/* OVERLAPSMAP
 */
#define OVERLAPSMAP(x) ((overlapsmap)((x).p))
#define overlapsmap_CAST(x) OVERLAPSMAP(x)
#define OVERLAPSMAP_CAST(x) OVERLAPSMAP(x)
#define OVERLAPSMAP_(x) ((x).e)
#define OVERLAPSMAP_TYPE overlapsmap
#define overlapsmap_TYPE overlapsmap
#define overlapsmap_undefined ((overlapsmap)gen_chunk_undefined)
#define overlapsmap_undefined_p(x) ((x)==overlapsmap_undefined)

extern overlapsmap copy_overlapsmap(overlapsmap);
extern void free_overlapsmap(overlapsmap);
extern overlapsmap check_overlapsmap(overlapsmap);
extern bool overlapsmap_consistent_p(overlapsmap);
extern bool overlapsmap_defined_p(overlapsmap);
#define gen_OVERLAPSMAP_cons gen_overlapsmap_cons
extern list gen_overlapsmap_cons(overlapsmap, list);
extern void overlapsmap_assign_contents(overlapsmap, overlapsmap);
extern void overlapsmap_non_recursive_free(overlapsmap);
extern void write_overlapsmap(FILE*, overlapsmap);
extern overlapsmap read_overlapsmap(FILE*);
extern overlapsmap make_overlapsmap(void);

struct _newgen_struct_overlapsmap_ {
  intptr_t _type_;
  hash_table _overlapsmap_holder_;
};

#define overlapsmap_domain_number(x) ((x)->_type_)
#define overlapsmap_hash_table(x) ((x)->_overlapsmap_holder_)
#define overlapsmap_key_type entity
#define overlapsmap_value_type list
#define OVERLAPSMAP_MAP(k,v,c,f) FUNCTION_MAP(overlapsmap,p,p,k,v,c,f)
#define OVERLAPSMAP_FOREACH(k,v,f) FUNCTION_FOREACH(overlapsmap,p,p,k,v,f)
extern list apply_overlapsmap(overlapsmap, entity);
extern void update_overlapsmap(overlapsmap, entity, list);
extern void extend_overlapsmap(overlapsmap, entity, list);
extern list delete_overlapsmap(overlapsmap, entity);
extern bool bound_overlapsmap_p(overlapsmap, entity);

/* REMAPPING
 */
#define REMAPPING(x) ((remapping)((x).p))
#define remapping_CAST(x) REMAPPING(x)
#define REMAPPING_CAST(x) REMAPPING(x)
#define REMAPPING_(x) ((x).e)
#define REMAPPING_TYPE remapping
#define remapping_TYPE remapping
#define remapping_undefined ((remapping)gen_chunk_undefined)
#define remapping_undefined_p(x) ((x)==remapping_undefined)

extern remapping copy_remapping(remapping);
extern void free_remapping(remapping);
extern remapping check_remapping(remapping);
extern bool remapping_consistent_p(remapping);
extern bool remapping_defined_p(remapping);
#define gen_REMAPPING_cons gen_remapping_cons
extern list gen_remapping_cons(remapping, list);
extern void remapping_assign_contents(remapping, remapping);
extern void remapping_non_recursive_free(remapping);
extern void write_remapping(FILE*, remapping);
extern remapping read_remapping(FILE*);
extern remapping make_remapping(renaming, list);

struct _newgen_struct_remapping_ {
  intptr_t _type_;
  renaming _remapping_renaming_; /* renaming:renaming */
  list _remapping_referenced_; /* referenced:entity* */
};

#define remapping_domain_number(x) ((x)->_type_)
#define remapping_renaming_(x) remapping_renaming(x) /* old hack compatible */
#define remapping_renaming(x) ((x)->_remapping_renaming_)
#define remapping_referenced_(x) remapping_referenced(x) /* old hack compatible */
#define remapping_referenced(x) ((x)->_remapping_referenced_)

/* RENAMING
 */
#define RENAMING(x) ((renaming)((x).p))
#define renaming_CAST(x) RENAMING(x)
#define RENAMING_CAST(x) RENAMING(x)
#define RENAMING_(x) ((x).e)
#define RENAMING_TYPE renaming
#define renaming_TYPE renaming
#define renaming_undefined ((renaming)gen_chunk_undefined)
#define renaming_undefined_p(x) ((x)==renaming_undefined)

extern renaming copy_renaming(renaming);
extern void free_renaming(renaming);
extern renaming check_renaming(renaming);
extern bool renaming_consistent_p(renaming);
extern bool renaming_defined_p(renaming);
#define gen_RENAMING_cons gen_renaming_cons
extern list gen_renaming_cons(renaming, list);
extern void renaming_assign_contents(renaming, renaming);
extern void renaming_non_recursive_free(renaming);
extern void write_renaming(FILE*, renaming);
extern renaming read_renaming(FILE*);
extern renaming make_renaming(entity, entity);

struct _newgen_struct_renaming_ {
  intptr_t _type_;
  entity _renaming_old_; /* old:entity */
  entity _renaming_new_; /* new:entity */
};

#define renaming_domain_number(x) ((x)->_type_)
#define renaming_old_(x) renaming_old(x) /* old hack compatible */
#define renaming_old(x) ((x)->_renaming_old_)
#define renaming_new_(x) renaming_new(x) /* old hack compatible */
#define renaming_new(x) ((x)->_renaming_new_)

/* STATEMENT_ENTITIES
 */
#define STATEMENT_ENTITIES(x) ((statement_entities)((x).p))
#define statement_entities_CAST(x) STATEMENT_ENTITIES(x)
#define STATEMENT_ENTITIES_CAST(x) STATEMENT_ENTITIES(x)
#define STATEMENT_ENTITIES_(x) ((x).e)
#define STATEMENT_ENTITIES_TYPE statement_entities
#define statement_entities_TYPE statement_entities
#define statement_entities_undefined ((statement_entities)gen_chunk_undefined)
#define statement_entities_undefined_p(x) ((x)==statement_entities_undefined)

extern statement_entities copy_statement_entities(statement_entities);
extern void free_statement_entities(statement_entities);
extern statement_entities check_statement_entities(statement_entities);
extern bool statement_entities_consistent_p(statement_entities);
extern bool statement_entities_defined_p(statement_entities);
#define gen_STATEMENT_ENTITIES_cons gen_statement_entities_cons
extern list gen_statement_entities_cons(statement_entities, list);
extern void statement_entities_assign_contents(statement_entities, statement_entities);
extern void statement_entities_non_recursive_free(statement_entities);
extern void write_statement_entities(FILE*, statement_entities);
extern statement_entities read_statement_entities(FILE*);
extern statement_entities make_statement_entities(void);

struct _newgen_struct_statement_entities_ {
  intptr_t _type_;
  hash_table _statement_entities_holder_;
};

#define statement_entities_domain_number(x) ((x)->_type_)
#define statement_entities_hash_table(x) ((x)->_statement_entities_holder_)
#define statement_entities_key_type statement
#define statement_entities_value_type entities
#define STATEMENT_ENTITIES_MAP(k,v,c,f) FUNCTION_MAP(statement_entities,p,p,k,v,c,f)
#define STATEMENT_ENTITIES_FOREACH(k,v,f) FUNCTION_FOREACH(statement_entities,p,p,k,v,f)
extern entities apply_statement_entities(statement_entities, statement);
extern void update_statement_entities(statement_entities, statement, entities);
extern void extend_statement_entities(statement_entities, statement, entities);
extern entities delete_statement_entities(statement_entities, statement);
extern bool bound_statement_entities_p(statement_entities, statement);

/* STATEMENT_RENAMINGS
 */
#define STATEMENT_RENAMINGS(x) ((statement_renamings)((x).p))
#define statement_renamings_CAST(x) STATEMENT_RENAMINGS(x)
#define STATEMENT_RENAMINGS_CAST(x) STATEMENT_RENAMINGS(x)
#define STATEMENT_RENAMINGS_(x) ((x).e)
#define STATEMENT_RENAMINGS_TYPE statement_renamings
#define statement_renamings_TYPE statement_renamings
#define statement_renamings_undefined ((statement_renamings)gen_chunk_undefined)
#define statement_renamings_undefined_p(x) ((x)==statement_renamings_undefined)

extern statement_renamings copy_statement_renamings(statement_renamings);
extern void free_statement_renamings(statement_renamings);
extern statement_renamings check_statement_renamings(statement_renamings);
extern bool statement_renamings_consistent_p(statement_renamings);
extern bool statement_renamings_defined_p(statement_renamings);
#define gen_STATEMENT_RENAMINGS_cons gen_statement_renamings_cons
extern list gen_statement_renamings_cons(statement_renamings, list);
extern void statement_renamings_assign_contents(statement_renamings, statement_renamings);
extern void statement_renamings_non_recursive_free(statement_renamings);
extern void write_statement_renamings(FILE*, statement_renamings);
extern statement_renamings read_statement_renamings(FILE*);
extern statement_renamings make_statement_renamings(void);

struct _newgen_struct_statement_renamings_ {
  intptr_t _type_;
  hash_table _statement_renamings_holder_;
};

#define statement_renamings_domain_number(x) ((x)->_type_)
#define statement_renamings_hash_table(x) ((x)->_statement_renamings_holder_)
#define statement_renamings_key_type statement
#define statement_renamings_value_type list
#define STATEMENT_RENAMINGS_MAP(k,v,c,f) FUNCTION_MAP(statement_renamings,p,p,k,v,c,f)
#define STATEMENT_RENAMINGS_FOREACH(k,v,f) FUNCTION_FOREACH(statement_renamings,p,p,k,v,f)
extern list apply_statement_renamings(statement_renamings, statement);
extern void update_statement_renamings(statement_renamings, statement, list);
extern void extend_statement_renamings(statement_renamings, statement, list);
extern list delete_statement_renamings(statement_renamings, statement);
extern bool bound_statement_renamings_p(statement_renamings, statement);

#define hpf_private_spec "\
--NEWGEN-START 186\n\
import align from \"hpf.newgen\";\n\
import distribute from \"hpf.newgen\";\n\
import entity from \"ri.newgen\";\n\
import entity_int from \"ri.newgen\";\n\
import statement from \"ri.newgen\";\n\
import reduction_operator from \"reductions_private.newgen\";\n\
alignmap = entity:entity -> align:align;\n\
data_status = newdeclmap:newdeclmap x alignmap:alignmap x distributemap:distributemap x arrays:entity* x templates:entity* x processors:entity*;\n\
distributemap = entity:entity -> distribute:distribute;\n\
dynamic_status = dynamics:entity_entities x primary:entitymap x renamings:statement_renamings x tokeep:statement_entities;\n\
entities = list:entity*;\n\
entity_entities = entity:entity -> entities:entities;\n\
entitymap = entity:entity -> entity:entity;\n\
entity_status = new_host:entitymap x new_node:entitymap x old_host:entitymap x old_node:entitymap x referenced:entity_int;\n\
hpfc_reductions = initial:entity x replacement:entity x operator:reduction_operator;\n\
hpfc_status = overlapsmap:overlapsmap x data_status:data_status x numbers_status:numbers_status x entity_status:entity_status x commons:entity* x dynamic_status:dynamic_status x pures:entity* x ios:entity* x computed:remapping* x reductions:statement_entities;\n\
hpf_newdecl = none:unit + alpha:unit + beta:unit + gamma:unit + delta:unit;\n\
hpf_newdecls = dimensions:hpf_newdecl*;\n\
newdeclmap = entity:entity -> hpf_newdecls:hpf_newdecls;\n\
numbers_status = numbermap:entity_int x arrays:int x templates:int x processors:int;\n\
overlap = lower:int x upper:int;\n\
overlapsmap = entity:entity -> overlap:overlap*;\n\
remapping = renaming:renaming x referenced:entity*;\n\
renaming = old:entity x new:entity;\n\
statement_entities = persistant statement:statement -> entities:entities;\n\
statement_renamings = persistant statement:statement -> renaming:renaming*;\n\
"
#endif
