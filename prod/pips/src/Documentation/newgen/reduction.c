/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "reduction.h"

/* GEXPRESSION
 */
gexpression copy_gexpression(gexpression p) {
  return (gexpression) gen_copy_tree((gen_chunk*) p);
}
void free_gexpression(gexpression p) {
  gen_free((gen_chunk*) p);
}
gexpression check_gexpression(gexpression p) {
  return (gexpression) gen_check((gen_chunk*) p, gexpression_domain);
}
bool gexpression_consistent_p(gexpression p) {
  check_gexpression(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool gexpression_defined_p(gexpression p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_gexpression_cons(gexpression p, list l) {
  return gen_typed_cons(GEXPRESSION_NEWGEN_DOMAIN, p, l);
}
void gexpression_assign_contents(gexpression r, gexpression v) {
  check_gexpression(r);
  check_gexpression(v);
  message_assert("defined references to domain gexpression",
                 gexpression_defined_p(r) && gexpression_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_gexpression_));
}
void gexpression_non_recursive_free(gexpression p) {
  // should clear up contents...
  free(p);
}
void write_gexpression(FILE* f, gexpression p) {
  gen_write(f, (gen_chunk*) p);
}
gexpression read_gexpression(FILE* f) {
  return (gexpression) gen_read(f);
}
gexpression make_gexpression(expression a1, expression a2) {
  return (gexpression) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, gexpression_domain, a1, a2);
}

/* PATTERN
 */
pattern copy_pattern(pattern p) {
  return (pattern) gen_copy_tree((gen_chunk*) p);
}
void free_pattern(pattern p) {
  gen_free((gen_chunk*) p);
}
pattern check_pattern(pattern p) {
  return (pattern) gen_check((gen_chunk*) p, pattern_domain);
}
bool pattern_consistent_p(pattern p) {
  check_pattern(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool pattern_defined_p(pattern p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_pattern_cons(pattern p, list l) {
  return gen_typed_cons(PATTERN_NEWGEN_DOMAIN, p, l);
}
void pattern_assign_contents(pattern r, pattern v) {
  check_pattern(r);
  check_pattern(v);
  message_assert("defined references to domain pattern",
                 pattern_defined_p(r) && pattern_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_pattern_));
}
void pattern_non_recursive_free(pattern p) {
  // should clear up contents...
  free(p);
}
void write_pattern(FILE* f, pattern p) {
  gen_write(f, (gen_chunk*) p);
}
pattern read_pattern(FILE* f) {
  return (pattern) gen_read(f);
}
pattern make_pattern(entity a1, expression a2, expression a3, entity a4, list a5) {
  return (pattern) gen_alloc(6*sizeof(gen_chunk), GEN_CHECK_ALLOC, pattern_domain, a1, a2, a3, a4, a5);
}

/* REDUCED_LOOPS
 */
reduced_loops copy_reduced_loops(reduced_loops p) {
  return (reduced_loops) gen_copy_tree((gen_chunk*) p);
}
void free_reduced_loops(reduced_loops p) {
  gen_free((gen_chunk*) p);
}
reduced_loops check_reduced_loops(reduced_loops p) {
  return (reduced_loops) gen_check((gen_chunk*) p, reduced_loops_domain);
}
bool reduced_loops_consistent_p(reduced_loops p) {
  check_reduced_loops(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool reduced_loops_defined_p(reduced_loops p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_reduced_loops_cons(reduced_loops p, list l) {
  return gen_typed_cons(REDUCED_LOOPS_NEWGEN_DOMAIN, p, l);
}
void reduced_loops_assign_contents(reduced_loops r, reduced_loops v) {
  check_reduced_loops(r);
  check_reduced_loops(v);
  message_assert("defined references to domain reduced_loops",
                 reduced_loops_defined_p(r) && reduced_loops_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_reduced_loops_));
}
void reduced_loops_non_recursive_free(reduced_loops p) {
  // should clear up contents...
  free(p);
}
void write_reduced_loops(FILE* f, reduced_loops p) {
  gen_write(f, (gen_chunk*) p);
}
reduced_loops read_reduced_loops(FILE* f) {
  return (reduced_loops) gen_read(f);
}
reduced_loops make_reduced_loops(list a) {
  return (reduced_loops) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, reduced_loops_domain, a);
}

/* SEXPRESSION
 */
sexpression copy_sexpression(sexpression p) {
  return (sexpression) gen_copy_tree((gen_chunk*) p);
}
void free_sexpression(sexpression p) {
  gen_free((gen_chunk*) p);
}
sexpression check_sexpression(sexpression p) {
  return (sexpression) gen_check((gen_chunk*) p, sexpression_domain);
}
bool sexpression_consistent_p(sexpression p) {
  check_sexpression(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool sexpression_defined_p(sexpression p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_sexpression_cons(sexpression p, list l) {
  return gen_typed_cons(SEXPRESSION_NEWGEN_DOMAIN, p, l);
}
void sexpression_assign_contents(sexpression r, sexpression v) {
  check_sexpression(r);
  check_sexpression(v);
  message_assert("defined references to domain sexpression",
                 sexpression_defined_p(r) && sexpression_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_sexpression_));
}
void sexpression_non_recursive_free(sexpression p) {
  // should clear up contents...
  free(p);
}
void write_sexpression(FILE* f, sexpression p) {
  gen_write(f, (gen_chunk*) p);
}
sexpression read_sexpression(FILE* f) {
  return (sexpression) gen_read(f);
}
sexpression make_sexpression(list a) {
  return (sexpression) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, sexpression_domain, a);
}

