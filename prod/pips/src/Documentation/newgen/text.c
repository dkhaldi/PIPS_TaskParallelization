/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "text.h"

/* SENTENCE
 */
sentence copy_sentence(sentence p) {
  return (sentence) gen_copy_tree((gen_chunk*) p);
}
void free_sentence(sentence p) {
  gen_free((gen_chunk*) p);
}
sentence check_sentence(sentence p) {
  return (sentence) gen_check((gen_chunk*) p, sentence_domain);
}
bool sentence_consistent_p(sentence p) {
  check_sentence(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool sentence_defined_p(sentence p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_sentence_cons(sentence p, list l) {
  return gen_typed_cons(SENTENCE_NEWGEN_DOMAIN, p, l);
}
void sentence_assign_contents(sentence r, sentence v) {
  check_sentence(r);
  check_sentence(v);
  message_assert("defined references to domain sentence",
                 sentence_defined_p(r) && sentence_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_sentence_));
}
void sentence_non_recursive_free(sentence p) {
  // should clear up contents...
  free(p);
}
void write_sentence(FILE* f, sentence p) {
  gen_write(f, (gen_chunk*) p);
}
sentence read_sentence(FILE* f) {
  return (sentence) gen_read(f);
}
string sentence_tag_as_string(enum sentence_utype tag) {
  switch (tag) {
  case is_sentence_formatted: return "formatted";
  case is_sentence_unformatted: return "unformatted";
  default: return string_undefined;
  }
}
sentence make_sentence(enum sentence_utype tag, void * val) {
  return (sentence) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, sentence_domain, tag, val);
}
sentence make_sentence_formatted(string _field_) {
  return make_sentence(is_sentence_formatted, (void*)(intptr_t) _field_);
}
sentence make_sentence_unformatted(unformatted _field_) {
  return make_sentence(is_sentence_unformatted, (void*)(intptr_t) _field_);
}

/* TEXT
 */
text copy_text(text p) {
  return (text) gen_copy_tree((gen_chunk*) p);
}
void free_text(text p) {
  gen_free((gen_chunk*) p);
}
text check_text(text p) {
  return (text) gen_check((gen_chunk*) p, text_domain);
}
bool text_consistent_p(text p) {
  check_text(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool text_defined_p(text p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_text_cons(text p, list l) {
  return gen_typed_cons(TEXT_NEWGEN_DOMAIN, p, l);
}
void text_assign_contents(text r, text v) {
  check_text(r);
  check_text(v);
  message_assert("defined references to domain text",
                 text_defined_p(r) && text_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_text_));
}
void text_non_recursive_free(text p) {
  // should clear up contents...
  free(p);
}
void write_text(FILE* f, text p) {
  gen_write(f, (gen_chunk*) p);
}
text read_text(FILE* f) {
  return (text) gen_read(f);
}
text make_text(list a) {
  return (text) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, text_domain, a);
}

/* UNFORMATTED
 */
unformatted copy_unformatted(unformatted p) {
  return (unformatted) gen_copy_tree((gen_chunk*) p);
}
void free_unformatted(unformatted p) {
  gen_free((gen_chunk*) p);
}
unformatted check_unformatted(unformatted p) {
  return (unformatted) gen_check((gen_chunk*) p, unformatted_domain);
}
bool unformatted_consistent_p(unformatted p) {
  check_unformatted(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool unformatted_defined_p(unformatted p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_unformatted_cons(unformatted p, list l) {
  return gen_typed_cons(UNFORMATTED_NEWGEN_DOMAIN, p, l);
}
void unformatted_assign_contents(unformatted r, unformatted v) {
  check_unformatted(r);
  check_unformatted(v);
  message_assert("defined references to domain unformatted",
                 unformatted_defined_p(r) && unformatted_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_unformatted_));
}
void unformatted_non_recursive_free(unformatted p) {
  // should clear up contents...
  free(p);
}
void write_unformatted(FILE* f, unformatted p) {
  gen_write(f, (gen_chunk*) p);
}
unformatted read_unformatted(FILE* f) {
  return (unformatted) gen_read(f);
}
unformatted make_unformatted(string a1, intptr_t a2, intptr_t a3, list a4) {
  return (unformatted) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, unformatted_domain, a1, a2, a3, a4);
}

