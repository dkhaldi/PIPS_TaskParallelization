/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "makefile.h"

/* MAKEFILE
 */
makefile copy_makefile(makefile p) {
  return (makefile) gen_copy_tree((gen_chunk*) p);
}
void free_makefile(makefile p) {
  gen_free((gen_chunk*) p);
}
makefile check_makefile(makefile p) {
  return (makefile) gen_check((gen_chunk*) p, makefile_domain);
}
bool makefile_consistent_p(makefile p) {
  check_makefile(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool makefile_defined_p(makefile p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_makefile_cons(makefile p, list l) {
  return gen_typed_cons(MAKEFILE_NEWGEN_DOMAIN, p, l);
}
void makefile_assign_contents(makefile r, makefile v) {
  check_makefile(r);
  check_makefile(v);
  message_assert("defined references to domain makefile",
                 makefile_defined_p(r) && makefile_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_makefile_));
}
void makefile_non_recursive_free(makefile p) {
  // should clear up contents...
  free(p);
}
void write_makefile(FILE* f, makefile p) {
  gen_write(f, (gen_chunk*) p);
}
makefile read_makefile(FILE* f) {
  return (makefile) gen_read(f);
}
makefile make_makefile(list a1, list a2) {
  return (makefile) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, makefile_domain, a1, a2);
}

/* OWNER
 */
owner copy_owner(owner p) {
  return (owner) gen_copy_tree((gen_chunk*) p);
}
void free_owner(owner p) {
  gen_free((gen_chunk*) p);
}
owner check_owner(owner p) {
  return (owner) gen_check((gen_chunk*) p, owner_domain);
}
bool owner_consistent_p(owner p) {
  check_owner(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool owner_defined_p(owner p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_owner_cons(owner p, list l) {
  return gen_typed_cons(OWNER_NEWGEN_DOMAIN, p, l);
}
void owner_assign_contents(owner r, owner v) {
  check_owner(r);
  check_owner(v);
  message_assert("defined references to domain owner",
                 owner_defined_p(r) && owner_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_owner_));
}
void owner_non_recursive_free(owner p) {
  // should clear up contents...
  free(p);
}
void write_owner(FILE* f, owner p) {
  gen_write(f, (gen_chunk*) p);
}
owner read_owner(FILE* f) {
  return (owner) gen_read(f);
}
string owner_tag_as_string(enum owner_utype tag) {
  switch (tag) {
  case is_owner_program: return "program";
  case is_owner_module: return "module";
  case is_owner_main: return "main";
  case is_owner_callees: return "callees";
  case is_owner_callers: return "callers";
  case is_owner_all: return "all";
  case is_owner_select: return "select";
  case is_owner_compilation_unit: return "compilation_unit";
  default: return string_undefined;
  }
}
owner make_owner(enum owner_utype tag, void * val) {
  return (owner) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, owner_domain, tag, val);
}
owner make_owner_program(void) {
  return make_owner(is_owner_program, UU);
}
owner make_owner_module(void) {
  return make_owner(is_owner_module, UU);
}
owner make_owner_main(void) {
  return make_owner(is_owner_main, UU);
}
owner make_owner_callees(void) {
  return make_owner(is_owner_callees, UU);
}
owner make_owner_callers(void) {
  return make_owner(is_owner_callers, UU);
}
owner make_owner_all(void) {
  return make_owner(is_owner_all, UU);
}
owner make_owner_select(void) {
  return make_owner(is_owner_select, UU);
}
owner make_owner_compilation_unit(void) {
  return make_owner(is_owner_compilation_unit, UU);
}

/* REAL_RESOURCE
 */
real_resource copy_real_resource(real_resource p) {
  return (real_resource) gen_copy_tree((gen_chunk*) p);
}
void free_real_resource(real_resource p) {
  gen_free((gen_chunk*) p);
}
real_resource check_real_resource(real_resource p) {
  return (real_resource) gen_check((gen_chunk*) p, real_resource_domain);
}
bool real_resource_consistent_p(real_resource p) {
  check_real_resource(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool real_resource_defined_p(real_resource p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_real_resource_cons(real_resource p, list l) {
  return gen_typed_cons(REAL_RESOURCE_NEWGEN_DOMAIN, p, l);
}
void real_resource_assign_contents(real_resource r, real_resource v) {
  check_real_resource(r);
  check_real_resource(v);
  message_assert("defined references to domain real_resource",
                 real_resource_defined_p(r) && real_resource_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_real_resource_));
}
void real_resource_non_recursive_free(real_resource p) {
  // should clear up contents...
  free(p);
}
void write_real_resource(FILE* f, real_resource p) {
  gen_write(f, (gen_chunk*) p);
}
real_resource read_real_resource(FILE* f) {
  return (real_resource) gen_read(f);
}
real_resource make_real_resource(string a1, string a2) {
  return (real_resource) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, real_resource_domain, a1, a2);
}

/* RULE
 */
rule copy_rule(rule p) {
  return (rule) gen_copy_tree((gen_chunk*) p);
}
void free_rule(rule p) {
  gen_free((gen_chunk*) p);
}
rule check_rule(rule p) {
  return (rule) gen_check((gen_chunk*) p, rule_domain);
}
bool rule_consistent_p(rule p) {
  check_rule(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool rule_defined_p(rule p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_rule_cons(rule p, list l) {
  return gen_typed_cons(RULE_NEWGEN_DOMAIN, p, l);
}
void rule_assign_contents(rule r, rule v) {
  check_rule(r);
  check_rule(v);
  message_assert("defined references to domain rule",
                 rule_defined_p(r) && rule_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_rule_));
}
void rule_non_recursive_free(rule p) {
  // should clear up contents...
  free(p);
}
void write_rule(FILE* f, rule p) {
  gen_write(f, (gen_chunk*) p);
}
rule read_rule(FILE* f) {
  return (rule) gen_read(f);
}
rule make_rule(string a1, list a2, list a3, list a4, list a5, list a6, list a7) {
  return (rule) gen_alloc(8*sizeof(gen_chunk), GEN_CHECK_ALLOC, rule_domain, a1, a2, a3, a4, a5, a6, a7);
}

/* VIRTUAL_RESOURCE
 */
virtual_resource copy_virtual_resource(virtual_resource p) {
  return (virtual_resource) gen_copy_tree((gen_chunk*) p);
}
void free_virtual_resource(virtual_resource p) {
  gen_free((gen_chunk*) p);
}
virtual_resource check_virtual_resource(virtual_resource p) {
  return (virtual_resource) gen_check((gen_chunk*) p, virtual_resource_domain);
}
bool virtual_resource_consistent_p(virtual_resource p) {
  check_virtual_resource(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool virtual_resource_defined_p(virtual_resource p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_virtual_resource_cons(virtual_resource p, list l) {
  return gen_typed_cons(VIRTUAL_RESOURCE_NEWGEN_DOMAIN, p, l);
}
void virtual_resource_assign_contents(virtual_resource r, virtual_resource v) {
  check_virtual_resource(r);
  check_virtual_resource(v);
  message_assert("defined references to domain virtual_resource",
                 virtual_resource_defined_p(r) && virtual_resource_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_virtual_resource_));
}
void virtual_resource_non_recursive_free(virtual_resource p) {
  // should clear up contents...
  free(p);
}
void write_virtual_resource(FILE* f, virtual_resource p) {
  gen_write(f, (gen_chunk*) p);
}
virtual_resource read_virtual_resource(FILE* f) {
  return (virtual_resource) gen_read(f);
}
virtual_resource make_virtual_resource(string a1, owner a2) {
  return (virtual_resource) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, virtual_resource_domain, a1, a2);
}

