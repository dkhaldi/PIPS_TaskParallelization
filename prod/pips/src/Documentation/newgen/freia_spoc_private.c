/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "freia_spoc_private.h"

/* DAG
 */
dag copy_dag(dag p) {
  return (dag) gen_copy_tree((gen_chunk*) p);
}
void free_dag(dag p) {
  gen_free((gen_chunk*) p);
}
dag check_dag(dag p) {
  return (dag) gen_check((gen_chunk*) p, dag_domain);
}
bool dag_consistent_p(dag p) {
  check_dag(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dag_defined_p(dag p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dag_cons(dag p, list l) {
  return gen_typed_cons(DAG_NEWGEN_DOMAIN, p, l);
}
void dag_assign_contents(dag r, dag v) {
  check_dag(r);
  check_dag(v);
  message_assert("defined references to domain dag",
                 dag_defined_p(r) && dag_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dag_));
}
void dag_non_recursive_free(dag p) {
  // should clear up contents...
  free(p);
}
void write_dag(FILE* f, dag p) {
  gen_write(f, (gen_chunk*) p);
}
dag read_dag(FILE* f) {
  return (dag) gen_read(f);
}
dag make_dag(list a1, list a2, list a3) {
  return (dag) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, dag_domain, a1, a2, a3);
}

/* DAGVTX
 */
dagvtx copy_dagvtx(dagvtx p) {
  return (dagvtx) gen_copy_tree((gen_chunk*) p);
}
void free_dagvtx(dagvtx p) {
  gen_free((gen_chunk*) p);
}
dagvtx check_dagvtx(dagvtx p) {
  return (dagvtx) gen_check((gen_chunk*) p, dagvtx_domain);
}
bool dagvtx_consistent_p(dagvtx p) {
  check_dagvtx(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dagvtx_defined_p(dagvtx p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dagvtx_cons(dagvtx p, list l) {
  return gen_typed_cons(DAGVTX_NEWGEN_DOMAIN, p, l);
}
void dagvtx_assign_contents(dagvtx r, dagvtx v) {
  check_dagvtx(r);
  check_dagvtx(v);
  message_assert("defined references to domain dagvtx",
                 dagvtx_defined_p(r) && dagvtx_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dagvtx_));
}
void dagvtx_non_recursive_free(dagvtx p) {
  // should clear up contents...
  free(p);
}
void write_dagvtx(FILE* f, dagvtx p) {
  gen_write(f, (gen_chunk*) p);
}
dagvtx read_dagvtx(FILE* f) {
  return (dagvtx) gen_read(f);
}
dagvtx make_dagvtx(vtxcontent a1, list a2) {
  return (dagvtx) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, dagvtx_domain, a1, a2);
}

/* PSTATEMENT
 */
pstatement copy_pstatement(pstatement p) {
  return (pstatement) gen_copy_tree((gen_chunk*) p);
}
void free_pstatement(pstatement p) {
  gen_free((gen_chunk*) p);
}
pstatement check_pstatement(pstatement p) {
  return (pstatement) gen_check((gen_chunk*) p, pstatement_domain);
}
bool pstatement_consistent_p(pstatement p) {
  check_pstatement(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool pstatement_defined_p(pstatement p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_pstatement_cons(pstatement p, list l) {
  return gen_typed_cons(PSTATEMENT_NEWGEN_DOMAIN, p, l);
}
void pstatement_assign_contents(pstatement r, pstatement v) {
  check_pstatement(r);
  check_pstatement(v);
  message_assert("defined references to domain pstatement",
                 pstatement_defined_p(r) && pstatement_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_pstatement_));
}
void pstatement_non_recursive_free(pstatement p) {
  // should clear up contents...
  free(p);
}
void write_pstatement(FILE* f, pstatement p) {
  gen_write(f, (gen_chunk*) p);
}
pstatement read_pstatement(FILE* f) {
  return (pstatement) gen_read(f);
}
string pstatement_tag_as_string(enum pstatement_utype tag) {
  switch (tag) {
  case is_pstatement_statement: return "statement";
  case is_pstatement_empty: return "empty";
  default: return string_undefined;
  }
}
pstatement make_pstatement(enum pstatement_utype tag, void * val) {
  return (pstatement) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, pstatement_domain, tag, val);
}
pstatement make_pstatement_statement(statement _field_) {
  return make_pstatement(is_pstatement_statement, (void*)(intptr_t) _field_);
}
pstatement make_pstatement_empty(void) {
  return make_pstatement(is_pstatement_empty, UU);
}

/* VTXCONTENT
 */
vtxcontent copy_vtxcontent(vtxcontent p) {
  return (vtxcontent) gen_copy_tree((gen_chunk*) p);
}
void free_vtxcontent(vtxcontent p) {
  gen_free((gen_chunk*) p);
}
vtxcontent check_vtxcontent(vtxcontent p) {
  return (vtxcontent) gen_check((gen_chunk*) p, vtxcontent_domain);
}
bool vtxcontent_consistent_p(vtxcontent p) {
  check_vtxcontent(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool vtxcontent_defined_p(vtxcontent p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_vtxcontent_cons(vtxcontent p, list l) {
  return gen_typed_cons(VTXCONTENT_NEWGEN_DOMAIN, p, l);
}
void vtxcontent_assign_contents(vtxcontent r, vtxcontent v) {
  check_vtxcontent(r);
  check_vtxcontent(v);
  message_assert("defined references to domain vtxcontent",
                 vtxcontent_defined_p(r) && vtxcontent_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_vtxcontent_));
}
void vtxcontent_non_recursive_free(vtxcontent p) {
  // should clear up contents...
  free(p);
}
void write_vtxcontent(FILE* f, vtxcontent p) {
  gen_write(f, (gen_chunk*) p);
}
vtxcontent read_vtxcontent(FILE* f) {
  return (vtxcontent) gen_read(f);
}
vtxcontent make_vtxcontent(intptr_t a1, intptr_t a2, pstatement a3, list a4, entity a5) {
  return (vtxcontent) gen_alloc(6*sizeof(gen_chunk), GEN_CHECK_ALLOC, vtxcontent_domain, a1, a2, a3, a4, a5);
}

