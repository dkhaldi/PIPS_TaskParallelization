/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "abc_private.h"

/* ABC_CHECKED
 */
abc_checked copy_abc_checked(abc_checked p) {
  return (abc_checked) gen_copy_tree((gen_chunk*) p);
}
void free_abc_checked(abc_checked p) {
  gen_free((gen_chunk*) p);
}
abc_checked check_abc_checked(abc_checked p) {
  return (abc_checked) gen_check((gen_chunk*) p, abc_checked_domain);
}
bool abc_checked_consistent_p(abc_checked p) {
  check_abc_checked(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool abc_checked_defined_p(abc_checked p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_abc_checked_cons(abc_checked p, list l) {
  return gen_typed_cons(ABC_CHECKED_NEWGEN_DOMAIN, p, l);
}
void abc_checked_assign_contents(abc_checked r, abc_checked v) {
  check_abc_checked(r);
  check_abc_checked(v);
  message_assert("defined references to domain abc_checked",
                 abc_checked_defined_p(r) && abc_checked_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_abc_checked_));
}
void abc_checked_non_recursive_free(abc_checked p) {
  // should clear up contents...
  free(p);
}
void write_abc_checked(FILE* f, abc_checked p) {
  gen_write(f, (gen_chunk*) p);
}
abc_checked read_abc_checked(FILE* f) {
  return (abc_checked) gen_read(f);
}
abc_checked make_abc_checked(list a) {
  return (abc_checked) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, abc_checked_domain, a);
}

/* ARRAY_DIMENSION_CHECKED
 */
array_dimension_checked copy_array_dimension_checked(array_dimension_checked p) {
  return (array_dimension_checked) gen_copy_tree((gen_chunk*) p);
}
void free_array_dimension_checked(array_dimension_checked p) {
  gen_free((gen_chunk*) p);
}
array_dimension_checked check_array_dimension_checked(array_dimension_checked p) {
  return (array_dimension_checked) gen_check((gen_chunk*) p, array_dimension_checked_domain);
}
bool array_dimension_checked_consistent_p(array_dimension_checked p) {
  check_array_dimension_checked(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool array_dimension_checked_defined_p(array_dimension_checked p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_array_dimension_checked_cons(array_dimension_checked p, list l) {
  return gen_typed_cons(ARRAY_DIMENSION_CHECKED_NEWGEN_DOMAIN, p, l);
}
void array_dimension_checked_assign_contents(array_dimension_checked r, array_dimension_checked v) {
  check_array_dimension_checked(r);
  check_array_dimension_checked(v);
  message_assert("defined references to domain array_dimension_checked",
                 array_dimension_checked_defined_p(r) && array_dimension_checked_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_array_dimension_checked_));
}
void array_dimension_checked_non_recursive_free(array_dimension_checked p) {
  // should clear up contents...
  free(p);
}
void write_array_dimension_checked(FILE* f, array_dimension_checked p) {
  gen_write(f, (gen_chunk*) p);
}
array_dimension_checked read_array_dimension_checked(FILE* f) {
  return (array_dimension_checked) gen_read(f);
}
array_dimension_checked make_array_dimension_checked(entity a1, list a2) {
  return (array_dimension_checked) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, array_dimension_checked_domain, a1, a2);
}

/* DIMENSION_CHECKED
 */
dimension_checked copy_dimension_checked(dimension_checked p) {
  return (dimension_checked) gen_copy_tree((gen_chunk*) p);
}
void free_dimension_checked(dimension_checked p) {
  gen_free((gen_chunk*) p);
}
dimension_checked check_dimension_checked(dimension_checked p) {
  return (dimension_checked) gen_check((gen_chunk*) p, dimension_checked_domain);
}
bool dimension_checked_consistent_p(dimension_checked p) {
  check_dimension_checked(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool dimension_checked_defined_p(dimension_checked p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_dimension_checked_cons(dimension_checked p, list l) {
  return gen_typed_cons(DIMENSION_CHECKED_NEWGEN_DOMAIN, p, l);
}
void dimension_checked_assign_contents(dimension_checked r, dimension_checked v) {
  check_dimension_checked(r);
  check_dimension_checked(v);
  message_assert("defined references to domain dimension_checked",
                 dimension_checked_defined_p(r) && dimension_checked_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_dimension_checked_));
}
void dimension_checked_non_recursive_free(dimension_checked p) {
  // should clear up contents...
  free(p);
}
void write_dimension_checked(FILE* f, dimension_checked p) {
  gen_write(f, (gen_chunk*) p);
}
dimension_checked read_dimension_checked(FILE* f) {
  return (dimension_checked) gen_read(f);
}
dimension_checked make_dimension_checked(intptr_t a1, bool a2, bool a3) {
  return (dimension_checked) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, dimension_checked_domain, a1, a2, a3);
}

