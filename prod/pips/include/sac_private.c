/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * operator_id_sons;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "sac_private.h"


/* MATCHTREE
 */
matchTree copy_matchTree(matchTree p) {
  return (matchTree) gen_copy_tree((gen_chunk*) p);
}
void free_matchTree(matchTree p) {
  gen_free((gen_chunk*) p);
}
matchTree check_matchTree(matchTree p) {
  return (matchTree) gen_check((gen_chunk*) p, matchTree_domain);
}
bool matchTree_consistent_p(matchTree p) {
  check_matchTree(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool matchTree_defined_p(matchTree p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_matchTree_cons(matchTree p, list l) {
  return gen_typed_cons(MATCHTREE_NEWGEN_DOMAIN, p, l);
}
void matchTree_assign_contents(matchTree r, matchTree v) {
  check_matchTree(r);
  check_matchTree(v);
  message_assert("defined references to domain matchTree",
                 matchTree_defined_p(r) && matchTree_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_matchTree_));
}
void matchTree_non_recursive_free(matchTree p) {
  // should clear up contents...
  free(p);
}
void write_matchTree(FILE* f, matchTree p) {
  gen_write(f, (gen_chunk*) p);
}
matchTree read_matchTree(FILE* f) {
  return (matchTree) gen_read(f);
}
matchTree make_matchTree(list a1, matchTreeSons a2) {
  return (matchTree) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, matchTree_domain, a1, a2);
}

/* MATCHTREESONS
 */
matchTreeSons copy_matchTreeSons(matchTreeSons p) {
  return (matchTreeSons) gen_copy_tree((gen_chunk*) p);
}
void free_matchTreeSons(matchTreeSons p) {
  gen_free((gen_chunk*) p);
}
matchTreeSons check_matchTreeSons(matchTreeSons p) {
  return (matchTreeSons) gen_check((gen_chunk*) p, matchTreeSons_domain);
}
bool matchTreeSons_consistent_p(matchTreeSons p) {
  check_matchTreeSons(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool matchTreeSons_defined_p(matchTreeSons p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_matchTreeSons_cons(matchTreeSons p, list l) {
  return gen_typed_cons(MATCHTREESONS_NEWGEN_DOMAIN, p, l);
}
void matchTreeSons_assign_contents(matchTreeSons r, matchTreeSons v) {
  check_matchTreeSons(r);
  check_matchTreeSons(v);
  message_assert("defined references to domain matchTreeSons",
                 matchTreeSons_defined_p(r) && matchTreeSons_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_matchTreeSons_));
}
void matchTreeSons_non_recursive_free(matchTreeSons p) {
  // should clear up contents...
  free(p);
}
void write_matchTreeSons(FILE* f, matchTreeSons p) {
  gen_write(f, (gen_chunk*) p);
}
matchTreeSons read_matchTreeSons(FILE* f) {
  return (matchTreeSons) gen_read(f);
}
matchTreeSons make_matchTreeSons(void) {
  return (matchTreeSons) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, matchTreeSons_domain);
}
matchTree apply_matchTreeSons(matchTreeSons f, intptr_t k) {
  return (matchTree) (intptr_t)HASH_GET(i, p, matchTreeSons_hash_table(f), k);
}
void update_matchTreeSons(matchTreeSons f, intptr_t k, matchTree v) {
  HASH_UPDATE(i, p, matchTreeSons_hash_table(f), k, (intptr_t)v);
}
void extend_matchTreeSons(matchTreeSons f, intptr_t k, matchTree v) {
  HASH_EXTEND(i, p, matchTreeSons_hash_table(f), k, (intptr_t)v);
}
matchTree delete_matchTreeSons(matchTreeSons f, intptr_t k) {
  return (matchTree)(intptr_t) HASH_DELETE(i, p, matchTreeSons_hash_table(f), k);
}
bool bound_matchTreeSons_p(matchTreeSons f, intptr_t k) {
  return (intptr_t)HASH_BOUND_P(i, p, matchTreeSons_hash_table(f), k);
}

/* MATCH
 */
match copy_match(match p) {
  return (match) gen_copy_tree((gen_chunk*) p);
}
void free_match(match p) {
  gen_free((gen_chunk*) p);
}
match check_match(match p) {
  return (match) gen_check((gen_chunk*) p, match_domain);
}
bool match_consistent_p(match p) {
  check_match(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool match_defined_p(match p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_match_cons(match p, list l) {
  return gen_typed_cons(MATCH_NEWGEN_DOMAIN, p, l);
}
void match_assign_contents(match r, match v) {
  check_match(r);
  check_match(v);
  message_assert("defined references to domain match",
                 match_defined_p(r) && match_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_match_));
}
void match_non_recursive_free(match p) {
  // should clear up contents...
  free(p);
}
void write_match(FILE* f, match p) {
  gen_write(f, (gen_chunk*) p);
}
match read_match(FILE* f) {
  return (match) gen_read(f);
}
match make_match(opcodeClass a1, list a2) {
  return (match) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, match_domain, a1, a2);
}

/* OPCODE
 */
opcode copy_opcode(opcode p) {
  return (opcode) gen_copy_tree((gen_chunk*) p);
}
void free_opcode(opcode p) {
  gen_free((gen_chunk*) p);
}
opcode check_opcode(opcode p) {
  return (opcode) gen_check((gen_chunk*) p, opcode_domain);
}
bool opcode_consistent_p(opcode p) {
  check_opcode(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool opcode_defined_p(opcode p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_opcode_cons(opcode p, list l) {
  return gen_typed_cons(OPCODE_NEWGEN_DOMAIN, p, l);
}
void opcode_assign_contents(opcode r, opcode v) {
  check_opcode(r);
  check_opcode(v);
  message_assert("defined references to domain opcode",
                 opcode_defined_p(r) && opcode_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_opcode_));
}
void opcode_non_recursive_free(opcode p) {
  // should clear up contents...
  free(p);
}
void write_opcode(FILE* f, opcode p) {
  gen_write(f, (gen_chunk*) p);
}
opcode read_opcode(FILE* f) {
  return (opcode) gen_read(f);
}
opcode make_opcode(string a1, intptr_t a2, list a3, float a4) {
  return (opcode) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, opcode_domain, a1, a2, a3, a4);
}

/* OPERATOR_ID_TREE
 */
operator_id_tree copy_operator_id_tree(operator_id_tree p) {
  return (operator_id_tree) gen_copy_tree((gen_chunk*) p);
}
void free_operator_id_tree(operator_id_tree p) {
  gen_free((gen_chunk*) p);
}
operator_id_tree check_operator_id_tree(operator_id_tree p) {
  return (operator_id_tree) gen_check((gen_chunk*) p, operator_id_tree_domain);
}
bool operator_id_tree_consistent_p(operator_id_tree p) {
  check_operator_id_tree(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool operator_id_tree_defined_p(operator_id_tree p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_operator_id_tree_cons(operator_id_tree p, list l) {
  return gen_typed_cons(OPERATOR_ID_TREE_NEWGEN_DOMAIN, p, l);
}
void operator_id_tree_assign_contents(operator_id_tree r, operator_id_tree v) {
  check_operator_id_tree(r);
  check_operator_id_tree(v);
  message_assert("defined references to domain operator_id_tree",
                 operator_id_tree_defined_p(r) && operator_id_tree_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_operator_id_tree_));
}
void operator_id_tree_non_recursive_free(operator_id_tree p) {
  // should clear up contents...
  free(p);
}
void write_operator_id_tree(FILE* f, operator_id_tree p) {
  gen_write(f, (gen_chunk*) p);
}
operator_id_tree read_operator_id_tree(FILE* f) {
  return (operator_id_tree) gen_read(f);
}
operator_id_tree make_operator_id_tree(intptr_t a1, operator_id_sons a2) {
  return (operator_id_tree) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, operator_id_tree_domain, a1, a2);
}

/* PATTERNARG
 */
patternArg copy_patternArg(patternArg p) {
  return (patternArg) gen_copy_tree((gen_chunk*) p);
}
void free_patternArg(patternArg p) {
  gen_free((gen_chunk*) p);
}
patternArg check_patternArg(patternArg p) {
  return (patternArg) gen_check((gen_chunk*) p, patternArg_domain);
}
bool patternArg_consistent_p(patternArg p) {
  check_patternArg(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool patternArg_defined_p(patternArg p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_patternArg_cons(patternArg p, list l) {
  return gen_typed_cons(PATTERNARG_NEWGEN_DOMAIN, p, l);
}
void patternArg_assign_contents(patternArg r, patternArg v) {
  check_patternArg(r);
  check_patternArg(v);
  message_assert("defined references to domain patternArg",
                 patternArg_defined_p(r) && patternArg_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_patternArg_));
}
void patternArg_non_recursive_free(patternArg p) {
  // should clear up contents...
  free(p);
}
void write_patternArg(FILE* f, patternArg p) {
  gen_write(f, (gen_chunk*) p);
}
patternArg read_patternArg(FILE* f) {
  return (patternArg) gen_read(f);
}
string patternArg_tag_as_string(enum patternArg_utype tag) {
  switch (tag) {
  case is_patternArg_static: return "static";
  case is_patternArg_dynamic: return "dynamic";
  default: return string_undefined;
  }
}
patternArg make_patternArg(enum patternArg_utype tag, void * val) {
  return (patternArg) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, patternArg_domain, tag, val);
}
patternArg make_patternArg_static(intptr_t _field_) {
  return make_patternArg(is_patternArg_static, (void*)(intptr_t) _field_);
}
patternArg make_patternArg_dynamic(void) {
  return make_patternArg(is_patternArg_dynamic, UU);
}

/* PATTERNX
 */
patternx copy_patternx(patternx p) {
  return (patternx) gen_copy_tree((gen_chunk*) p);
}
void free_patternx(patternx p) {
  gen_free((gen_chunk*) p);
}
patternx check_patternx(patternx p) {
  return (patternx) gen_check((gen_chunk*) p, patternx_domain);
}
bool patternx_consistent_p(patternx p) {
  check_patternx(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool patternx_defined_p(patternx p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_patternx_cons(patternx p, list l) {
  return gen_typed_cons(PATTERNX_NEWGEN_DOMAIN, p, l);
}
void patternx_assign_contents(patternx r, patternx v) {
  check_patternx(r);
  check_patternx(v);
  message_assert("defined references to domain patternx",
                 patternx_defined_p(r) && patternx_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_patternx_));
}
void patternx_non_recursive_free(patternx p) {
  // should clear up contents...
  free(p);
}
void write_patternx(FILE* f, patternx p) {
  gen_write(f, (gen_chunk*) p);
}
patternx read_patternx(FILE* f) {
  return (patternx) gen_read(f);
}
patternx make_patternx(opcodeClass a1, list a2) {
  return (patternx) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, patternx_domain, a1, a2);
}

/* REDUCTIONINFO
 */
reductionInfo copy_reductionInfo(reductionInfo p) {
  return (reductionInfo) gen_copy_tree((gen_chunk*) p);
}
void free_reductionInfo(reductionInfo p) {
  gen_free((gen_chunk*) p);
}
reductionInfo check_reductionInfo(reductionInfo p) {
  return (reductionInfo) gen_check((gen_chunk*) p, reductionInfo_domain);
}
bool reductionInfo_consistent_p(reductionInfo p) {
  check_reductionInfo(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool reductionInfo_defined_p(reductionInfo p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_reductionInfo_cons(reductionInfo p, list l) {
  return gen_typed_cons(REDUCTIONINFO_NEWGEN_DOMAIN, p, l);
}
void reductionInfo_assign_contents(reductionInfo r, reductionInfo v) {
  check_reductionInfo(r);
  check_reductionInfo(v);
  message_assert("defined references to domain reductionInfo",
                 reductionInfo_defined_p(r) && reductionInfo_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_reductionInfo_));
}
void reductionInfo_non_recursive_free(reductionInfo p) {
  // should clear up contents...
  free(p);
}
void write_reductionInfo(FILE* f, reductionInfo p) {
  gen_write(f, (gen_chunk*) p);
}
reductionInfo read_reductionInfo(FILE* f) {
  return (reductionInfo) gen_read(f);
}
reductionInfo make_reductionInfo(reduction a1, intptr_t a2, entity a3) {
  return (reductionInfo) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, reductionInfo_domain, a1, a2, a3);
}

/* SIMDSTATEMENT
 */
simdstatement copy_simdstatement(simdstatement p) {
  return (simdstatement) gen_copy_tree((gen_chunk*) p);
}
void free_simdstatement(simdstatement p) {
  gen_free((gen_chunk*) p);
}
simdstatement check_simdstatement(simdstatement p) {
  return (simdstatement) gen_check((gen_chunk*) p, simdstatement_domain);
}
bool simdstatement_consistent_p(simdstatement p) {
  check_simdstatement(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool simdstatement_defined_p(simdstatement p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_simdstatement_cons(simdstatement p, list l) {
  return gen_typed_cons(SIMDSTATEMENT_NEWGEN_DOMAIN, p, l);
}
void simdstatement_assign_contents(simdstatement r, simdstatement v) {
  check_simdstatement(r);
  check_simdstatement(v);
  message_assert("defined references to domain simdstatement",
                 simdstatement_defined_p(r) && simdstatement_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_simdstatement_));
}
void simdstatement_non_recursive_free(simdstatement p) {
  // should clear up contents...
  free(p);
}
void write_simdstatement(FILE* f, simdstatement p) {
  gen_write(f, (gen_chunk*) p);
}
simdstatement read_simdstatement(FILE* f) {
  return (simdstatement) gen_read(f);
}
simdstatement make_simdstatement(opcode a1, intptr_t a2, entity * a3, expression * a4) {
  return (simdstatement) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, simdstatement_domain, a1, a2, a3, a4);
}

/* OPCODECLASS
 */
opcodeClass copy_opcodeClass(opcodeClass p) {
  return (opcodeClass) gen_copy_tree((gen_chunk*) p);
}
void free_opcodeClass(opcodeClass p) {
  gen_free((gen_chunk*) p);
}
opcodeClass check_opcodeClass(opcodeClass p) {
  return (opcodeClass) gen_check((gen_chunk*) p, opcodeClass_domain);
}
bool opcodeClass_consistent_p(opcodeClass p) {
  check_opcodeClass(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool opcodeClass_defined_p(opcodeClass p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_opcodeClass_cons(opcodeClass p, list l) {
  return gen_typed_cons(OPCODECLASS_NEWGEN_DOMAIN, p, l);
}
void opcodeClass_assign_contents(opcodeClass r, opcodeClass v) {
  check_opcodeClass(r);
  check_opcodeClass(v);
  message_assert("defined references to domain opcodeClass",
                 opcodeClass_defined_p(r) && opcodeClass_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_opcodeClass_));
}
void opcodeClass_non_recursive_free(opcodeClass p) {
  // should clear up contents...
  free(p);
}
opcodeClass gen_find_opcodeClass(char* s) {
  return (opcodeClass) gen_find_tabulated(s, opcodeClass_domain);
}
void write_tabulated_opcodeClass(FILE* f) {
  (void) gen_write_tabulated(f, opcodeClass_domain);
}
void read_tabulated_opcodeClass(FILE* f) {
  int domain = gen_read_tabulated(f, 0);
  if (domain!=opcodeClass_domain) {
    fprintf(stderr, "[newgen internal error]""inconsistent domain number for opcodeClass: %d (expecting %d)\n",
            domain, opcodeClass_domain);
    abort();
  }
}
opcodeClass make_opcodeClass(string a1, intptr_t a2, list a3) {
  return (opcodeClass) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, opcodeClass_domain, a1, a2, a3);
}

/* TRANSFORMATION
 */
transformation copy_transformation(transformation p) {
  return (transformation) gen_copy_tree((gen_chunk*) p);
}
void free_transformation(transformation p) {
  gen_free((gen_chunk*) p);
}
transformation check_transformation(transformation p) {
  return (transformation) gen_check((gen_chunk*) p, transformation_domain);
}
bool transformation_consistent_p(transformation p) {
  check_transformation(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool transformation_defined_p(transformation p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_transformation_cons(transformation p, list l) {
  return gen_typed_cons(TRANSFORMATION_NEWGEN_DOMAIN, p, l);
}
void transformation_assign_contents(transformation r, transformation v) {
  check_transformation(r);
  check_transformation(v);
  message_assert("defined references to domain transformation",
                 transformation_defined_p(r) && transformation_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_transformation_));
}
void transformation_non_recursive_free(transformation p) {
  // should clear up contents...
  free(p);
}
void write_transformation(FILE* f, transformation p) {
  gen_write(f, (gen_chunk*) p);
}
transformation read_transformation(FILE* f) {
  return (transformation) gen_read(f);
}
transformation make_transformation(string a1, intptr_t a2, intptr_t a3, intptr_t a4, intptr_t a5, intptr_t a6, int * a7) {
  return (transformation) gen_alloc(8*sizeof(gen_chunk), GEN_CHECK_ALLOC, transformation_domain, a1, a2, a3, a4, a5, a6, a7);
}

