#ifndef _newgen_effects_included
#define _newgen_effects_included
#define _gen_effects_start 129
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_entity_domain_defined_)
#define _newgen_entity_domain_defined_
#define ENTITY_NEWGEN_DOMAIN (entity_domain)
#define entity_NEWGEN_DOMAIN (entity_domain)
typedef struct _newgen_struct_entity_ * entity;
#endif /* _newgen_entity_domain_defined_ */

#if !defined(_newgen_reference_domain_defined_)
#define _newgen_reference_domain_defined_
#define REFERENCE_NEWGEN_DOMAIN (reference_domain)
#define reference_NEWGEN_DOMAIN (reference_domain)
typedef struct _newgen_struct_reference_ * reference;
#endif /* _newgen_reference_domain_defined_ */

#if !defined(_newgen_preference_domain_defined_)
#define _newgen_preference_domain_defined_
#define PREFERENCE_NEWGEN_DOMAIN (preference_domain)
#define preference_NEWGEN_DOMAIN (preference_domain)
typedef struct _newgen_struct_preference_ * preference;
#endif /* _newgen_preference_domain_defined_ */

#if !defined(_newgen_expression_domain_defined_)
#define _newgen_expression_domain_defined_
#define EXPRESSION_NEWGEN_DOMAIN (expression_domain)
#define expression_NEWGEN_DOMAIN (expression_domain)
typedef struct _newgen_struct_expression_ * expression;
#endif /* _newgen_expression_domain_defined_ */

#if !defined(_newgen_statement_domain_defined_)
#define _newgen_statement_domain_defined_
#define STATEMENT_NEWGEN_DOMAIN (statement_domain)
#define statement_NEWGEN_DOMAIN (statement_domain)
typedef struct _newgen_struct_statement_ * statement;
#endif /* _newgen_statement_domain_defined_ */

#if !defined(_newgen_Psysteme_domain_defined_)
#define _newgen_Psysteme_domain_defined_
#define newgen_Psysteme(p) (p) /* old hack compatible */
#define PSYSTEME_NEWGEN_EXTERNAL (_gen_effects_start+0)
#define PSYSTEME_NEWGEN_DOMAIN (PSYSTEME_NEWGEN_EXTERNAL)
#define Psysteme_NEWGEN_DOMAIN (PSYSTEME_NEWGEN_EXTERNAL)
#endif /* _newgen_Psysteme_domain_defined_ */

#define action_kind_domain (_gen_effects_start+1)
#if !defined(_newgen_action_kind_domain_defined_)
#define _newgen_action_kind_domain_defined_
#define ACTION_KIND_NEWGEN_DOMAIN (action_kind_domain)
#define action_kind_NEWGEN_DOMAIN (action_kind_domain)
typedef struct _newgen_struct_action_kind_ * action_kind;
#endif /* _newgen_action_kind_domain_defined_ */

#define action_domain (_gen_effects_start+2)
#if !defined(_newgen_action_domain_defined_)
#define _newgen_action_domain_defined_
#define ACTION_NEWGEN_DOMAIN (action_domain)
#define action_NEWGEN_DOMAIN (action_domain)
typedef struct _newgen_struct_action_ * action;
#endif /* _newgen_action_domain_defined_ */

#define approximation_domain (_gen_effects_start+3)
#if !defined(_newgen_approximation_domain_defined_)
#define _newgen_approximation_domain_defined_
#define APPROXIMATION_NEWGEN_DOMAIN (approximation_domain)
#define approximation_NEWGEN_DOMAIN (approximation_domain)
typedef struct _newgen_struct_approximation_ * approximation;
#endif /* _newgen_approximation_domain_defined_ */

#define cell_interpretation_domain (_gen_effects_start+4)
#if !defined(_newgen_cell_interpretation_domain_defined_)
#define _newgen_cell_interpretation_domain_defined_
#define CELL_INTERPRETATION_NEWGEN_DOMAIN (cell_interpretation_domain)
#define cell_interpretation_NEWGEN_DOMAIN (cell_interpretation_domain)
typedef struct _newgen_struct_cell_interpretation_ * cell_interpretation;
#endif /* _newgen_cell_interpretation_domain_defined_ */

#define cell_domain (_gen_effects_start+5)
#if !defined(_newgen_cell_domain_defined_)
#define _newgen_cell_domain_defined_
#define CELL_NEWGEN_DOMAIN (cell_domain)
#define cell_NEWGEN_DOMAIN (cell_domain)
typedef struct _newgen_struct_cell_ * cell;
#endif /* _newgen_cell_domain_defined_ */

#define cell_relation_domain (_gen_effects_start+6)
#if !defined(_newgen_cell_relation_domain_defined_)
#define _newgen_cell_relation_domain_defined_
#define CELL_RELATION_NEWGEN_DOMAIN (cell_relation_domain)
#define cell_relation_NEWGEN_DOMAIN (cell_relation_domain)
typedef struct _newgen_struct_cell_relation_ * cell_relation;
#endif /* _newgen_cell_relation_domain_defined_ */

#define cell_relations_domain (_gen_effects_start+7)
#if !defined(_newgen_cell_relations_domain_defined_)
#define _newgen_cell_relations_domain_defined_
#define CELL_RELATIONS_NEWGEN_DOMAIN (cell_relations_domain)
#define cell_relations_NEWGEN_DOMAIN (cell_relations_domain)
typedef struct _newgen_struct_cell_relations_ * cell_relations;
#endif /* _newgen_cell_relations_domain_defined_ */

#define descriptor_domain (_gen_effects_start+8)
#if !defined(_newgen_descriptor_domain_defined_)
#define _newgen_descriptor_domain_defined_
#define DESCRIPTOR_NEWGEN_DOMAIN (descriptor_domain)
#define descriptor_NEWGEN_DOMAIN (descriptor_domain)
typedef struct _newgen_struct_descriptor_ * descriptor;
#endif /* _newgen_descriptor_domain_defined_ */

#define effect_domain (_gen_effects_start+9)
#if !defined(_newgen_effect_domain_defined_)
#define _newgen_effect_domain_defined_
#define EFFECT_NEWGEN_DOMAIN (effect_domain)
#define effect_NEWGEN_DOMAIN (effect_domain)
typedef struct _newgen_struct_effect_ * effect;
#endif /* _newgen_effect_domain_defined_ */

#define effects_classes_domain (_gen_effects_start+10)
#if !defined(_newgen_effects_classes_domain_defined_)
#define _newgen_effects_classes_domain_defined_
#define EFFECTS_CLASSES_NEWGEN_DOMAIN (effects_classes_domain)
#define effects_classes_NEWGEN_DOMAIN (effects_classes_domain)
typedef struct _newgen_struct_effects_classes_ * effects_classes;
#endif /* _newgen_effects_classes_domain_defined_ */

#define effects_domain (_gen_effects_start+11)
#if !defined(_newgen_effects_domain_defined_)
#define _newgen_effects_domain_defined_
#define EFFECTS_NEWGEN_DOMAIN (effects_domain)
#define effects_NEWGEN_DOMAIN (effects_domain)
typedef struct _newgen_struct_effects_ * effects;
#endif /* _newgen_effects_domain_defined_ */

#define entity_effects_domain (_gen_effects_start+12)
#if !defined(_newgen_entity_effects_domain_defined_)
#define _newgen_entity_effects_domain_defined_
#define ENTITY_EFFECTS_NEWGEN_DOMAIN (entity_effects_domain)
#define entity_effects_NEWGEN_DOMAIN (entity_effects_domain)
typedef struct _newgen_struct_entity_effects_ * entity_effects;
#endif /* _newgen_entity_effects_domain_defined_ */

#define gap_domain (_gen_effects_start+13)
#if !defined(_newgen_gap_domain_defined_)
#define _newgen_gap_domain_defined_
#define GAP_NEWGEN_DOMAIN (gap_domain)
#define gap_NEWGEN_DOMAIN (gap_domain)
typedef struct _newgen_struct_gap_ * gap;
#endif /* _newgen_gap_domain_defined_ */

#define interpreted_cell_domain (_gen_effects_start+14)
#if !defined(_newgen_interpreted_cell_domain_defined_)
#define _newgen_interpreted_cell_domain_defined_
#define INTERPRETED_CELL_NEWGEN_DOMAIN (interpreted_cell_domain)
#define interpreted_cell_NEWGEN_DOMAIN (interpreted_cell_domain)
typedef struct _newgen_struct_interpreted_cell_ * interpreted_cell;
#endif /* _newgen_interpreted_cell_domain_defined_ */

#define path_selector_domain (_gen_effects_start+15)
#if !defined(_newgen_path_selector_domain_defined_)
#define _newgen_path_selector_domain_defined_
#define PATH_SELECTOR_NEWGEN_DOMAIN (path_selector_domain)
#define path_selector_NEWGEN_DOMAIN (path_selector_domain)
typedef struct _newgen_struct_path_selector_ * path_selector;
#endif /* _newgen_path_selector_domain_defined_ */

#define path_selectors_domain (_gen_effects_start+16)
#if !defined(_newgen_path_selectors_domain_defined_)
#define _newgen_path_selectors_domain_defined_
#define PATH_SELECTORS_NEWGEN_DOMAIN (path_selectors_domain)
#define path_selectors_NEWGEN_DOMAIN (path_selectors_domain)
typedef struct _newgen_struct_path_selectors_ * path_selectors;
#endif /* _newgen_path_selectors_domain_defined_ */

#define persistant_expression_to_effects_domain (_gen_effects_start+17)
#if !defined(_newgen_persistant_expression_to_effects_domain_defined_)
#define _newgen_persistant_expression_to_effects_domain_defined_
#define PERSISTANT_EXPRESSION_TO_EFFECTS_NEWGEN_DOMAIN (persistant_expression_to_effects_domain)
#define persistant_expression_to_effects_NEWGEN_DOMAIN (persistant_expression_to_effects_domain)
typedef struct _newgen_struct_persistant_expression_to_effects_ * persistant_expression_to_effects;
#endif /* _newgen_persistant_expression_to_effects_domain_defined_ */

#define recursive_selector_domain (_gen_effects_start+18)
#if !defined(_newgen_recursive_selector_domain_defined_)
#define _newgen_recursive_selector_domain_defined_
#define RECURSIVE_SELECTOR_NEWGEN_DOMAIN (recursive_selector_domain)
#define recursive_selector_NEWGEN_DOMAIN (recursive_selector_domain)
typedef struct _newgen_struct_recursive_selector_ * recursive_selector;
#endif /* _newgen_recursive_selector_domain_defined_ */

#define statement_cell_relations_domain (_gen_effects_start+19)
#if !defined(_newgen_statement_cell_relations_domain_defined_)
#define _newgen_statement_cell_relations_domain_defined_
#define STATEMENT_CELL_RELATIONS_NEWGEN_DOMAIN (statement_cell_relations_domain)
#define statement_cell_relations_NEWGEN_DOMAIN (statement_cell_relations_domain)
typedef struct _newgen_struct_statement_cell_relations_ * statement_cell_relations;
#endif /* _newgen_statement_cell_relations_domain_defined_ */

#define statement_effects_domain (_gen_effects_start+20)
#if !defined(_newgen_statement_effects_domain_defined_)
#define _newgen_statement_effects_domain_defined_
#define STATEMENT_EFFECTS_NEWGEN_DOMAIN (statement_effects_domain)
#define statement_effects_NEWGEN_DOMAIN (statement_effects_domain)
typedef struct _newgen_struct_statement_effects_ * statement_effects;
#endif /* _newgen_statement_effects_domain_defined_ */


/* ACTION_KIND
 */
#define ACTION_KIND(x) ((action_kind)((x).p))
#define action_kind_CAST(x) ACTION_KIND(x)
#define ACTION_KIND_CAST(x) ACTION_KIND(x)
#define ACTION_KIND_(x) ((x).e)
#define ACTION_KIND_TYPE action_kind
#define action_kind_TYPE action_kind
#define action_kind_undefined ((action_kind)gen_chunk_undefined)
#define action_kind_undefined_p(x) ((x)==action_kind_undefined)

extern action_kind copy_action_kind(action_kind);
extern void free_action_kind(action_kind);
extern action_kind check_action_kind(action_kind);
extern bool action_kind_consistent_p(action_kind);
extern bool action_kind_defined_p(action_kind);
#define gen_ACTION_KIND_cons gen_action_kind_cons
extern list gen_action_kind_cons(action_kind, list);
extern void action_kind_assign_contents(action_kind, action_kind);
extern void action_kind_non_recursive_free(action_kind);
extern void write_action_kind(FILE*, action_kind);
extern action_kind read_action_kind(FILE*);
enum action_kind_utype {
  is_action_kind_store,
  is_action_kind_environment,
  is_action_kind_type_declaration
};
extern string action_kind_tag_as_string(enum action_kind_utype);
extern action_kind make_action_kind(enum action_kind_utype, void *);
extern action_kind make_action_kind_store(void);
extern action_kind make_action_kind_environment(void);
extern action_kind make_action_kind_type_declaration(void);

struct _newgen_struct_action_kind_ {
  intptr_t _type_;
  enum action_kind_utype _action_kind_tag__;
  union {
    gen_chunk _action_kind_store_; /* store:unit */
    gen_chunk _action_kind_environment_; /* environment:unit */
    gen_chunk _action_kind_type_declaration_; /* type_declaration:unit */
  } _action_kind_union_;
};

#define action_kind_domain_number(x) ((x)->_type_)
#define action_kind_tag(x) ((x)->_action_kind_tag__)
#define action_kind_store_p(x) (action_kind_tag(x)==is_action_kind_store)
#define action_kind_store_(x) action_kind_store(x) /* old hack compatible */
#define action_kind_store(x) ((x)->_action_kind_union_._action_kind_store_.u)
#define action_kind_environment_p(x) (action_kind_tag(x)==is_action_kind_environment)
#define action_kind_environment_(x) action_kind_environment(x) /* old hack compatible */
#define action_kind_environment(x) ((x)->_action_kind_union_._action_kind_environment_.u)
#define action_kind_type_declaration_p(x) (action_kind_tag(x)==is_action_kind_type_declaration)
#define action_kind_type_declaration_(x) action_kind_type_declaration(x) /* old hack compatible */
#define action_kind_type_declaration(x) ((x)->_action_kind_union_._action_kind_type_declaration_.u)

/* ACTION
 */
#define ACTION(x) ((action)((x).p))
#define action_CAST(x) ACTION(x)
#define ACTION_CAST(x) ACTION(x)
#define ACTION_(x) ((x).e)
#define ACTION_TYPE action
#define action_TYPE action
#define action_undefined ((action)gen_chunk_undefined)
#define action_undefined_p(x) ((x)==action_undefined)

extern action copy_action(action);
extern void free_action(action);
extern action check_action(action);
extern bool action_consistent_p(action);
extern bool action_defined_p(action);
#define gen_ACTION_cons gen_action_cons
extern list gen_action_cons(action, list);
extern void action_assign_contents(action, action);
extern void action_non_recursive_free(action);
extern void write_action(FILE*, action);
extern action read_action(FILE*);
enum action_utype {
  is_action_read,
  is_action_write
};
extern string action_tag_as_string(enum action_utype);
extern action make_action(enum action_utype, void *);
extern action make_action_read(action_kind);
extern action make_action_write(action_kind);

struct _newgen_struct_action_ {
  intptr_t _type_;
  enum action_utype _action_tag__;
  union {
    action_kind _action_read_; /* read:action_kind */
    action_kind _action_write_; /* write:action_kind */
  } _action_union_;
};

#define action_domain_number(x) ((x)->_type_)
#define action_tag(x) ((x)->_action_tag__)
#define action_read_p(x) (action_tag(x)==is_action_read)
#define action_read_(x) action_read(x) /* old hack compatible */
#define action_read(x) ((x)->_action_union_._action_read_)
#define action_write_p(x) (action_tag(x)==is_action_write)
#define action_write_(x) action_write(x) /* old hack compatible */
#define action_write(x) ((x)->_action_union_._action_write_)

/* APPROXIMATION
 */
#define APPROXIMATION(x) ((approximation)((x).p))
#define approximation_CAST(x) APPROXIMATION(x)
#define APPROXIMATION_CAST(x) APPROXIMATION(x)
#define APPROXIMATION_(x) ((x).e)
#define APPROXIMATION_TYPE approximation
#define approximation_TYPE approximation
#define approximation_undefined ((approximation)gen_chunk_undefined)
#define approximation_undefined_p(x) ((x)==approximation_undefined)

extern approximation copy_approximation(approximation);
extern void free_approximation(approximation);
extern approximation check_approximation(approximation);
extern bool approximation_consistent_p(approximation);
extern bool approximation_defined_p(approximation);
#define gen_APPROXIMATION_cons gen_approximation_cons
extern list gen_approximation_cons(approximation, list);
extern void approximation_assign_contents(approximation, approximation);
extern void approximation_non_recursive_free(approximation);
extern void write_approximation(FILE*, approximation);
extern approximation read_approximation(FILE*);
enum approximation_utype {
  is_approximation_may,
  is_approximation_must,
  is_approximation_exact
};
extern string approximation_tag_as_string(enum approximation_utype);
extern approximation make_approximation(enum approximation_utype, void *);
extern approximation make_approximation_may(void);
extern approximation make_approximation_must(void);
extern approximation make_approximation_exact(void);

struct _newgen_struct_approximation_ {
  intptr_t _type_;
  enum approximation_utype _approximation_tag__;
  union {
    gen_chunk _approximation_may_; /* may:unit */
    gen_chunk _approximation_must_; /* must:unit */
    gen_chunk _approximation_exact_; /* exact:unit */
  } _approximation_union_;
};

#define approximation_domain_number(x) ((x)->_type_)
#define approximation_tag(x) ((x)->_approximation_tag__)
#define approximation_may_p(x) (approximation_tag(x)==is_approximation_may)
#define approximation_may_(x) approximation_may(x) /* old hack compatible */
#define approximation_may(x) ((x)->_approximation_union_._approximation_may_.u)
#define approximation_must_p(x) (approximation_tag(x)==is_approximation_must)
#define approximation_must_(x) approximation_must(x) /* old hack compatible */
#define approximation_must(x) ((x)->_approximation_union_._approximation_must_.u)
#define approximation_exact_p(x) (approximation_tag(x)==is_approximation_exact)
#define approximation_exact_(x) approximation_exact(x) /* old hack compatible */
#define approximation_exact(x) ((x)->_approximation_union_._approximation_exact_.u)

/* CELL_INTERPRETATION
 */
#define CELL_INTERPRETATION(x) ((cell_interpretation)((x).p))
#define cell_interpretation_CAST(x) CELL_INTERPRETATION(x)
#define CELL_INTERPRETATION_CAST(x) CELL_INTERPRETATION(x)
#define CELL_INTERPRETATION_(x) ((x).e)
#define CELL_INTERPRETATION_TYPE cell_interpretation
#define cell_interpretation_TYPE cell_interpretation
#define cell_interpretation_undefined ((cell_interpretation)gen_chunk_undefined)
#define cell_interpretation_undefined_p(x) ((x)==cell_interpretation_undefined)

extern cell_interpretation copy_cell_interpretation(cell_interpretation);
extern void free_cell_interpretation(cell_interpretation);
extern cell_interpretation check_cell_interpretation(cell_interpretation);
extern bool cell_interpretation_consistent_p(cell_interpretation);
extern bool cell_interpretation_defined_p(cell_interpretation);
#define gen_CELL_INTERPRETATION_cons gen_cell_interpretation_cons
extern list gen_cell_interpretation_cons(cell_interpretation, list);
extern void cell_interpretation_assign_contents(cell_interpretation, cell_interpretation);
extern void cell_interpretation_non_recursive_free(cell_interpretation);
extern void write_cell_interpretation(FILE*, cell_interpretation);
extern cell_interpretation read_cell_interpretation(FILE*);
enum cell_interpretation_utype {
  is_cell_interpretation_value_of,
  is_cell_interpretation_address_of
};
extern string cell_interpretation_tag_as_string(enum cell_interpretation_utype);
extern cell_interpretation make_cell_interpretation(enum cell_interpretation_utype, void *);
extern cell_interpretation make_cell_interpretation_value_of(void);
extern cell_interpretation make_cell_interpretation_address_of(void);

struct _newgen_struct_cell_interpretation_ {
  intptr_t _type_;
  enum cell_interpretation_utype _cell_interpretation_tag__;
  union {
    gen_chunk _cell_interpretation_value_of_; /* value_of:unit */
    gen_chunk _cell_interpretation_address_of_; /* address_of:unit */
  } _cell_interpretation_union_;
};

#define cell_interpretation_domain_number(x) ((x)->_type_)
#define cell_interpretation_tag(x) ((x)->_cell_interpretation_tag__)
#define cell_interpretation_value_of_p(x) (cell_interpretation_tag(x)==is_cell_interpretation_value_of)
#define cell_interpretation_value_of_(x) cell_interpretation_value_of(x) /* old hack compatible */
#define cell_interpretation_value_of(x) ((x)->_cell_interpretation_union_._cell_interpretation_value_of_.u)
#define cell_interpretation_address_of_p(x) (cell_interpretation_tag(x)==is_cell_interpretation_address_of)
#define cell_interpretation_address_of_(x) cell_interpretation_address_of(x) /* old hack compatible */
#define cell_interpretation_address_of(x) ((x)->_cell_interpretation_union_._cell_interpretation_address_of_.u)

/* CELL
 */
#define CELL(x) ((cell)((x).p))
#define cell_CAST(x) CELL(x)
#define CELL_CAST(x) CELL(x)
#define CELL_(x) ((x).e)
#define CELL_TYPE cell
#define cell_TYPE cell
#define cell_undefined ((cell)gen_chunk_undefined)
#define cell_undefined_p(x) ((x)==cell_undefined)

extern cell copy_cell(cell);
extern void free_cell(cell);
extern cell check_cell(cell);
extern bool cell_consistent_p(cell);
extern bool cell_defined_p(cell);
#define gen_CELL_cons gen_cell_cons
extern list gen_cell_cons(cell, list);
extern void cell_assign_contents(cell, cell);
extern void cell_non_recursive_free(cell);
extern void write_cell(FILE*, cell);
extern cell read_cell(FILE*);
enum cell_utype {
  is_cell_reference,
  is_cell_preference,
  is_cell_gap
};
extern string cell_tag_as_string(enum cell_utype);
extern cell make_cell(enum cell_utype, void *);
extern cell make_cell_reference(reference);
extern cell make_cell_preference(preference);
extern cell make_cell_gap(gap);

struct _newgen_struct_cell_ {
  intptr_t _type_;
  enum cell_utype _cell_tag__;
  union {
    reference _cell_reference_; /* reference:reference */
    preference _cell_preference_; /* preference:preference */
    gap _cell_gap_; /* gap:gap */
  } _cell_union_;
};

#define cell_domain_number(x) ((x)->_type_)
#define cell_tag(x) ((x)->_cell_tag__)
#define cell_reference_p(x) (cell_tag(x)==is_cell_reference)
#define cell_reference_(x) cell_reference(x) /* old hack compatible */
#define cell_reference(x) ((x)->_cell_union_._cell_reference_)
#define cell_preference_p(x) (cell_tag(x)==is_cell_preference)
#define cell_preference_(x) cell_preference(x) /* old hack compatible */
#define cell_preference(x) ((x)->_cell_union_._cell_preference_)
#define cell_gap_p(x) (cell_tag(x)==is_cell_gap)
#define cell_gap_(x) cell_gap(x) /* old hack compatible */
#define cell_gap(x) ((x)->_cell_union_._cell_gap_)

/* CELL_RELATION
 */
#define CELL_RELATION(x) ((cell_relation)((x).p))
#define cell_relation_CAST(x) CELL_RELATION(x)
#define CELL_RELATION_CAST(x) CELL_RELATION(x)
#define CELL_RELATION_(x) ((x).e)
#define CELL_RELATION_TYPE cell_relation
#define cell_relation_TYPE cell_relation
#define cell_relation_undefined ((cell_relation)gen_chunk_undefined)
#define cell_relation_undefined_p(x) ((x)==cell_relation_undefined)

extern cell_relation copy_cell_relation(cell_relation);
extern void free_cell_relation(cell_relation);
extern cell_relation check_cell_relation(cell_relation);
extern bool cell_relation_consistent_p(cell_relation);
extern bool cell_relation_defined_p(cell_relation);
#define gen_CELL_RELATION_cons gen_cell_relation_cons
extern list gen_cell_relation_cons(cell_relation, list);
extern void cell_relation_assign_contents(cell_relation, cell_relation);
extern void cell_relation_non_recursive_free(cell_relation);
extern void write_cell_relation(FILE*, cell_relation);
extern cell_relation read_cell_relation(FILE*);
extern cell_relation make_cell_relation(interpreted_cell, interpreted_cell, approximation, descriptor);

struct _newgen_struct_cell_relation_ {
  intptr_t _type_;
  interpreted_cell _cell_relation_first_; /* first:interpreted_cell */
  interpreted_cell _cell_relation_second_; /* second:interpreted_cell */
  approximation _cell_relation_approximation_; /* approximation:approximation */
  descriptor _cell_relation_descriptor_; /* descriptor:descriptor */
};

#define cell_relation_domain_number(x) ((x)->_type_)
#define cell_relation_first_(x) cell_relation_first(x) /* old hack compatible */
#define cell_relation_first(x) ((x)->_cell_relation_first_)
#define cell_relation_second_(x) cell_relation_second(x) /* old hack compatible */
#define cell_relation_second(x) ((x)->_cell_relation_second_)
#define cell_relation_approximation_(x) cell_relation_approximation(x) /* old hack compatible */
#define cell_relation_approximation(x) ((x)->_cell_relation_approximation_)
#define cell_relation_descriptor_(x) cell_relation_descriptor(x) /* old hack compatible */
#define cell_relation_descriptor(x) ((x)->_cell_relation_descriptor_)

/* CELL_RELATIONS
 */
#define CELL_RELATIONS(x) ((cell_relations)((x).p))
#define cell_relations_CAST(x) CELL_RELATIONS(x)
#define CELL_RELATIONS_CAST(x) CELL_RELATIONS(x)
#define CELL_RELATIONS_(x) ((x).e)
#define CELL_RELATIONS_TYPE cell_relations
#define cell_relations_TYPE cell_relations
#define cell_relations_undefined ((cell_relations)gen_chunk_undefined)
#define cell_relations_undefined_p(x) ((x)==cell_relations_undefined)

extern cell_relations copy_cell_relations(cell_relations);
extern void free_cell_relations(cell_relations);
extern cell_relations check_cell_relations(cell_relations);
extern bool cell_relations_consistent_p(cell_relations);
extern bool cell_relations_defined_p(cell_relations);
#define gen_CELL_RELATIONS_cons gen_cell_relations_cons
extern list gen_cell_relations_cons(cell_relations, list);
extern void cell_relations_assign_contents(cell_relations, cell_relations);
extern void cell_relations_non_recursive_free(cell_relations);
extern void write_cell_relations(FILE*, cell_relations);
extern cell_relations read_cell_relations(FILE*);
extern cell_relations make_cell_relations(list);

struct _newgen_struct_cell_relations_ {
  intptr_t _type_;
  list _cell_relations_holder_;
};

#define cell_relations_domain_number(x) ((x)->_type_)
#define cell_relations_list(x) ((x)->_cell_relations_holder_)

/* DESCRIPTOR
 */
#define DESCRIPTOR(x) ((descriptor)((x).p))
#define descriptor_CAST(x) DESCRIPTOR(x)
#define DESCRIPTOR_CAST(x) DESCRIPTOR(x)
#define DESCRIPTOR_(x) ((x).e)
#define DESCRIPTOR_TYPE descriptor
#define descriptor_TYPE descriptor
#define descriptor_undefined ((descriptor)gen_chunk_undefined)
#define descriptor_undefined_p(x) ((x)==descriptor_undefined)

extern descriptor copy_descriptor(descriptor);
extern void free_descriptor(descriptor);
extern descriptor check_descriptor(descriptor);
extern bool descriptor_consistent_p(descriptor);
extern bool descriptor_defined_p(descriptor);
#define gen_DESCRIPTOR_cons gen_descriptor_cons
extern list gen_descriptor_cons(descriptor, list);
extern void descriptor_assign_contents(descriptor, descriptor);
extern void descriptor_non_recursive_free(descriptor);
extern void write_descriptor(FILE*, descriptor);
extern descriptor read_descriptor(FILE*);
enum descriptor_utype {
  is_descriptor_convexunion,
  is_descriptor_convex,
  is_descriptor_none
};
extern string descriptor_tag_as_string(enum descriptor_utype);
extern descriptor make_descriptor(enum descriptor_utype, void *);
extern descriptor make_descriptor_convexunion(list);
extern descriptor make_descriptor_convex(Psysteme);
extern descriptor make_descriptor_none(void);

struct _newgen_struct_descriptor_ {
  intptr_t _type_;
  enum descriptor_utype _descriptor_tag__;
  union {
    list _descriptor_convexunion_; /* convexunion:Psysteme* */
    Psysteme _descriptor_convex_; /* convex:Psysteme */
    gen_chunk _descriptor_none_; /* none:unit */
  } _descriptor_union_;
};

#define descriptor_domain_number(x) ((x)->_type_)
#define descriptor_tag(x) ((x)->_descriptor_tag__)
#define descriptor_convexunion_p(x) (descriptor_tag(x)==is_descriptor_convexunion)
#define descriptor_convexunion_(x) descriptor_convexunion(x) /* old hack compatible */
#define descriptor_convexunion(x) ((x)->_descriptor_union_._descriptor_convexunion_)
#define descriptor_convex_p(x) (descriptor_tag(x)==is_descriptor_convex)
#define descriptor_convex_(x) descriptor_convex(x) /* old hack compatible */
#define descriptor_convex(x) ((x)->_descriptor_union_._descriptor_convex_)
#define descriptor_none_p(x) (descriptor_tag(x)==is_descriptor_none)
#define descriptor_none_(x) descriptor_none(x) /* old hack compatible */
#define descriptor_none(x) ((x)->_descriptor_union_._descriptor_none_.u)

/* EFFECT
 */
#define EFFECT(x) ((effect)((x).p))
#define effect_CAST(x) EFFECT(x)
#define EFFECT_CAST(x) EFFECT(x)
#define EFFECT_(x) ((x).e)
#define EFFECT_TYPE effect
#define effect_TYPE effect
#define effect_undefined ((effect)gen_chunk_undefined)
#define effect_undefined_p(x) ((x)==effect_undefined)

extern effect copy_effect(effect);
extern void free_effect(effect);
extern effect check_effect(effect);
extern bool effect_consistent_p(effect);
extern bool effect_defined_p(effect);
#define gen_EFFECT_cons gen_effect_cons
extern list gen_effect_cons(effect, list);
extern void effect_assign_contents(effect, effect);
extern void effect_non_recursive_free(effect);
extern void write_effect(FILE*, effect);
extern effect read_effect(FILE*);
extern effect make_effect(cell, action, approximation, descriptor);

struct _newgen_struct_effect_ {
  intptr_t _type_;
  cell _effect_cell_; /* cell:cell */
  action _effect_action_; /* action:action */
  approximation _effect_approximation_; /* approximation:approximation */
  descriptor _effect_descriptor_; /* descriptor:descriptor */
};

#define effect_domain_number(x) ((x)->_type_)
#define effect_cell_(x) effect_cell(x) /* old hack compatible */
#define effect_cell(x) ((x)->_effect_cell_)
#define effect_action_(x) effect_action(x) /* old hack compatible */
#define effect_action(x) ((x)->_effect_action_)
#define effect_approximation_(x) effect_approximation(x) /* old hack compatible */
#define effect_approximation(x) ((x)->_effect_approximation_)
#define effect_descriptor_(x) effect_descriptor(x) /* old hack compatible */
#define effect_descriptor(x) ((x)->_effect_descriptor_)

/* EFFECTS_CLASSES
 */
#define EFFECTS_CLASSES(x) ((effects_classes)((x).p))
#define effects_classes_CAST(x) EFFECTS_CLASSES(x)
#define EFFECTS_CLASSES_CAST(x) EFFECTS_CLASSES(x)
#define EFFECTS_CLASSES_(x) ((x).e)
#define EFFECTS_CLASSES_TYPE effects_classes
#define effects_classes_TYPE effects_classes
#define effects_classes_undefined ((effects_classes)gen_chunk_undefined)
#define effects_classes_undefined_p(x) ((x)==effects_classes_undefined)

extern effects_classes copy_effects_classes(effects_classes);
extern void free_effects_classes(effects_classes);
extern effects_classes check_effects_classes(effects_classes);
extern bool effects_classes_consistent_p(effects_classes);
extern bool effects_classes_defined_p(effects_classes);
#define gen_EFFECTS_CLASSES_cons gen_effects_classes_cons
extern list gen_effects_classes_cons(effects_classes, list);
extern void effects_classes_assign_contents(effects_classes, effects_classes);
extern void effects_classes_non_recursive_free(effects_classes);
extern void write_effects_classes(FILE*, effects_classes);
extern effects_classes read_effects_classes(FILE*);
extern effects_classes make_effects_classes(list);

struct _newgen_struct_effects_classes_ {
  intptr_t _type_;
  list _effects_classes_holder_;
};

#define effects_classes_domain_number(x) ((x)->_type_)
#define effects_classes_classes(x) ((x)->_effects_classes_holder_)

/* EFFECTS
 */
#define EFFECTS(x) ((effects)((x).p))
#define effects_CAST(x) EFFECTS(x)
#define EFFECTS_CAST(x) EFFECTS(x)
#define EFFECTS_(x) ((x).e)
#define EFFECTS_TYPE effects
#define effects_TYPE effects
#define effects_undefined ((effects)gen_chunk_undefined)
#define effects_undefined_p(x) ((x)==effects_undefined)

extern effects copy_effects(effects);
extern void free_effects(effects);
extern effects check_effects(effects);
extern bool effects_consistent_p(effects);
extern bool effects_defined_p(effects);
#define gen_EFFECTS_cons gen_effects_cons
extern list gen_effects_cons(effects, list);
extern void effects_assign_contents(effects, effects);
extern void effects_non_recursive_free(effects);
extern void write_effects(FILE*, effects);
extern effects read_effects(FILE*);
extern effects make_effects(list);

struct _newgen_struct_effects_ {
  intptr_t _type_;
  list _effects_holder_;
};

#define effects_domain_number(x) ((x)->_type_)
#define effects_effects(x) ((x)->_effects_holder_)

/* ENTITY_EFFECTS
 */
#define ENTITY_EFFECTS(x) ((entity_effects)((x).p))
#define entity_effects_CAST(x) ENTITY_EFFECTS(x)
#define ENTITY_EFFECTS_CAST(x) ENTITY_EFFECTS(x)
#define ENTITY_EFFECTS_(x) ((x).e)
#define ENTITY_EFFECTS_TYPE entity_effects
#define entity_effects_TYPE entity_effects
#define entity_effects_undefined ((entity_effects)gen_chunk_undefined)
#define entity_effects_undefined_p(x) ((x)==entity_effects_undefined)

extern entity_effects copy_entity_effects(entity_effects);
extern void free_entity_effects(entity_effects);
extern entity_effects check_entity_effects(entity_effects);
extern bool entity_effects_consistent_p(entity_effects);
extern bool entity_effects_defined_p(entity_effects);
#define gen_ENTITY_EFFECTS_cons gen_entity_effects_cons
extern list gen_entity_effects_cons(entity_effects, list);
extern void entity_effects_assign_contents(entity_effects, entity_effects);
extern void entity_effects_non_recursive_free(entity_effects);
extern void write_entity_effects(FILE*, entity_effects);
extern entity_effects read_entity_effects(FILE*);
extern entity_effects make_entity_effects(void);

struct _newgen_struct_entity_effects_ {
  intptr_t _type_;
  hash_table _entity_effects_holder_;
};

#define entity_effects_domain_number(x) ((x)->_type_)
#define entity_effects_hash_table(x) ((x)->_entity_effects_holder_)
#define entity_effects_key_type entity
#define entity_effects_value_type effects
#define ENTITY_EFFECTS_MAP(k,v,c,f) FUNCTION_MAP(entity_effects,p,p,k,v,c,f)
#define ENTITY_EFFECTS_FOREACH(k,v,f) FUNCTION_FOREACH(entity_effects,p,p,k,v,f)
extern effects apply_entity_effects(entity_effects, entity);
extern void update_entity_effects(entity_effects, entity, effects);
extern void extend_entity_effects(entity_effects, entity, effects);
extern effects delete_entity_effects(entity_effects, entity);
extern bool bound_entity_effects_p(entity_effects, entity);

/* GAP
 */
#define GAP(x) ((gap)((x).p))
#define gap_CAST(x) GAP(x)
#define GAP_CAST(x) GAP(x)
#define GAP_(x) ((x).e)
#define GAP_TYPE gap
#define gap_TYPE gap
#define gap_undefined ((gap)gen_chunk_undefined)
#define gap_undefined_p(x) ((x)==gap_undefined)

extern gap copy_gap(gap);
extern void free_gap(gap);
extern gap check_gap(gap);
extern bool gap_consistent_p(gap);
extern bool gap_defined_p(gap);
#define gen_GAP_cons gen_gap_cons
extern list gen_gap_cons(gap, list);
extern void gap_assign_contents(gap, gap);
extern void gap_non_recursive_free(gap);
extern void write_gap(FILE*, gap);
extern gap read_gap(FILE*);
extern gap make_gap(entity, path_selectors);

struct _newgen_struct_gap_ {
  intptr_t _type_;
  entity _gap_variable_; /* variable:entity */
  path_selectors _gap_path_selectors_; /* path_selectors:path_selectors */
};

#define gap_domain_number(x) ((x)->_type_)
#define gap_variable_(x) gap_variable(x) /* old hack compatible */
#define gap_variable(x) ((x)->_gap_variable_)
#define gap_path_selectors_(x) gap_path_selectors(x) /* old hack compatible */
#define gap_path_selectors(x) ((x)->_gap_path_selectors_)

/* INTERPRETED_CELL
 */
#define INTERPRETED_CELL(x) ((interpreted_cell)((x).p))
#define interpreted_cell_CAST(x) INTERPRETED_CELL(x)
#define INTERPRETED_CELL_CAST(x) INTERPRETED_CELL(x)
#define INTERPRETED_CELL_(x) ((x).e)
#define INTERPRETED_CELL_TYPE interpreted_cell
#define interpreted_cell_TYPE interpreted_cell
#define interpreted_cell_undefined ((interpreted_cell)gen_chunk_undefined)
#define interpreted_cell_undefined_p(x) ((x)==interpreted_cell_undefined)

extern interpreted_cell copy_interpreted_cell(interpreted_cell);
extern void free_interpreted_cell(interpreted_cell);
extern interpreted_cell check_interpreted_cell(interpreted_cell);
extern bool interpreted_cell_consistent_p(interpreted_cell);
extern bool interpreted_cell_defined_p(interpreted_cell);
#define gen_INTERPRETED_CELL_cons gen_interpreted_cell_cons
extern list gen_interpreted_cell_cons(interpreted_cell, list);
extern void interpreted_cell_assign_contents(interpreted_cell, interpreted_cell);
extern void interpreted_cell_non_recursive_free(interpreted_cell);
extern void write_interpreted_cell(FILE*, interpreted_cell);
extern interpreted_cell read_interpreted_cell(FILE*);
extern interpreted_cell make_interpreted_cell(cell, cell_interpretation);

struct _newgen_struct_interpreted_cell_ {
  intptr_t _type_;
  cell _interpreted_cell_cell_; /* cell:cell */
  cell_interpretation _interpreted_cell_cell_interpretation_; /* cell_interpretation:cell_interpretation */
};

#define interpreted_cell_domain_number(x) ((x)->_type_)
#define interpreted_cell_cell_(x) interpreted_cell_cell(x) /* old hack compatible */
#define interpreted_cell_cell(x) ((x)->_interpreted_cell_cell_)
#define interpreted_cell_cell_interpretation_(x) interpreted_cell_cell_interpretation(x) /* old hack compatible */
#define interpreted_cell_cell_interpretation(x) ((x)->_interpreted_cell_cell_interpretation_)

/* PATH_SELECTOR
 */
#define PATH_SELECTOR(x) ((path_selector)((x).p))
#define path_selector_CAST(x) PATH_SELECTOR(x)
#define PATH_SELECTOR_CAST(x) PATH_SELECTOR(x)
#define PATH_SELECTOR_(x) ((x).e)
#define PATH_SELECTOR_TYPE path_selector
#define path_selector_TYPE path_selector
#define path_selector_undefined ((path_selector)gen_chunk_undefined)
#define path_selector_undefined_p(x) ((x)==path_selector_undefined)

extern path_selector copy_path_selector(path_selector);
extern void free_path_selector(path_selector);
extern path_selector check_path_selector(path_selector);
extern bool path_selector_consistent_p(path_selector);
extern bool path_selector_defined_p(path_selector);
#define gen_PATH_SELECTOR_cons gen_path_selector_cons
extern list gen_path_selector_cons(path_selector, list);
extern void path_selector_assign_contents(path_selector, path_selector);
extern void path_selector_non_recursive_free(path_selector);
extern void write_path_selector(FILE*, path_selector);
extern path_selector read_path_selector(FILE*);
enum path_selector_utype {
  is_path_selector_expression,
  is_path_selector_recursive_selector
};
extern string path_selector_tag_as_string(enum path_selector_utype);
extern path_selector make_path_selector(enum path_selector_utype, void *);
extern path_selector make_path_selector_expression(expression);
extern path_selector make_path_selector_recursive_selector(recursive_selector);

struct _newgen_struct_path_selector_ {
  intptr_t _type_;
  enum path_selector_utype _path_selector_tag__;
  union {
    expression _path_selector_expression_; /* expression:expression */
    recursive_selector _path_selector_recursive_selector_; /* recursive_selector:recursive_selector */
  } _path_selector_union_;
};

#define path_selector_domain_number(x) ((x)->_type_)
#define path_selector_tag(x) ((x)->_path_selector_tag__)
#define path_selector_expression_p(x) (path_selector_tag(x)==is_path_selector_expression)
#define path_selector_expression_(x) path_selector_expression(x) /* old hack compatible */
#define path_selector_expression(x) ((x)->_path_selector_union_._path_selector_expression_)
#define path_selector_recursive_selector_p(x) (path_selector_tag(x)==is_path_selector_recursive_selector)
#define path_selector_recursive_selector_(x) path_selector_recursive_selector(x) /* old hack compatible */
#define path_selector_recursive_selector(x) ((x)->_path_selector_union_._path_selector_recursive_selector_)

/* PATH_SELECTORS
 */
#define PATH_SELECTORS(x) ((path_selectors)((x).p))
#define path_selectors_CAST(x) PATH_SELECTORS(x)
#define PATH_SELECTORS_CAST(x) PATH_SELECTORS(x)
#define PATH_SELECTORS_(x) ((x).e)
#define PATH_SELECTORS_TYPE path_selectors
#define path_selectors_TYPE path_selectors
#define path_selectors_undefined ((path_selectors)gen_chunk_undefined)
#define path_selectors_undefined_p(x) ((x)==path_selectors_undefined)

extern path_selectors copy_path_selectors(path_selectors);
extern void free_path_selectors(path_selectors);
extern path_selectors check_path_selectors(path_selectors);
extern bool path_selectors_consistent_p(path_selectors);
extern bool path_selectors_defined_p(path_selectors);
#define gen_PATH_SELECTORS_cons gen_path_selectors_cons
extern list gen_path_selectors_cons(path_selectors, list);
extern void path_selectors_assign_contents(path_selectors, path_selectors);
extern void path_selectors_non_recursive_free(path_selectors);
extern void write_path_selectors(FILE*, path_selectors);
extern path_selectors read_path_selectors(FILE*);
extern path_selectors make_path_selectors(list);

struct _newgen_struct_path_selectors_ {
  intptr_t _type_;
  list _path_selectors_holder_;
};

#define path_selectors_domain_number(x) ((x)->_type_)
#define path_selectors_path_selector(x) ((x)->_path_selectors_holder_)

/* PERSISTANT_EXPRESSION_TO_EFFECTS
 */
#define PERSISTANT_EXPRESSION_TO_EFFECTS(x) ((persistant_expression_to_effects)((x).p))
#define persistant_expression_to_effects_CAST(x) PERSISTANT_EXPRESSION_TO_EFFECTS(x)
#define PERSISTANT_EXPRESSION_TO_EFFECTS_CAST(x) PERSISTANT_EXPRESSION_TO_EFFECTS(x)
#define PERSISTANT_EXPRESSION_TO_EFFECTS_(x) ((x).e)
#define PERSISTANT_EXPRESSION_TO_EFFECTS_TYPE persistant_expression_to_effects
#define persistant_expression_to_effects_TYPE persistant_expression_to_effects
#define persistant_expression_to_effects_undefined ((persistant_expression_to_effects)gen_chunk_undefined)
#define persistant_expression_to_effects_undefined_p(x) ((x)==persistant_expression_to_effects_undefined)

extern persistant_expression_to_effects copy_persistant_expression_to_effects(persistant_expression_to_effects);
extern void free_persistant_expression_to_effects(persistant_expression_to_effects);
extern persistant_expression_to_effects check_persistant_expression_to_effects(persistant_expression_to_effects);
extern bool persistant_expression_to_effects_consistent_p(persistant_expression_to_effects);
extern bool persistant_expression_to_effects_defined_p(persistant_expression_to_effects);
#define gen_PERSISTANT_EXPRESSION_TO_EFFECTS_cons gen_persistant_expression_to_effects_cons
extern list gen_persistant_expression_to_effects_cons(persistant_expression_to_effects, list);
extern void persistant_expression_to_effects_assign_contents(persistant_expression_to_effects, persistant_expression_to_effects);
extern void persistant_expression_to_effects_non_recursive_free(persistant_expression_to_effects);
extern void write_persistant_expression_to_effects(FILE*, persistant_expression_to_effects);
extern persistant_expression_to_effects read_persistant_expression_to_effects(FILE*);
extern persistant_expression_to_effects make_persistant_expression_to_effects(void);

struct _newgen_struct_persistant_expression_to_effects_ {
  intptr_t _type_;
  hash_table _persistant_expression_to_effects_holder_;
};

#define persistant_expression_to_effects_domain_number(x) ((x)->_type_)
#define persistant_expression_to_effects_hash_table(x) ((x)->_persistant_expression_to_effects_holder_)
#define persistant_expression_to_effects_key_type expression
#define persistant_expression_to_effects_value_type effects
#define PERSISTANT_EXPRESSION_TO_EFFECTS_MAP(k,v,c,f) FUNCTION_MAP(persistant_expression_to_effects,p,p,k,v,c,f)
#define PERSISTANT_EXPRESSION_TO_EFFECTS_FOREACH(k,v,f) FUNCTION_FOREACH(persistant_expression_to_effects,p,p,k,v,f)
extern effects apply_persistant_expression_to_effects(persistant_expression_to_effects, expression);
extern void update_persistant_expression_to_effects(persistant_expression_to_effects, expression, effects);
extern void extend_persistant_expression_to_effects(persistant_expression_to_effects, expression, effects);
extern effects delete_persistant_expression_to_effects(persistant_expression_to_effects, expression);
extern bool bound_persistant_expression_to_effects_p(persistant_expression_to_effects, expression);

/* RECURSIVE_SELECTOR
 */
#define RECURSIVE_SELECTOR(x) ((recursive_selector)((x).p))
#define recursive_selector_CAST(x) RECURSIVE_SELECTOR(x)
#define RECURSIVE_SELECTOR_CAST(x) RECURSIVE_SELECTOR(x)
#define RECURSIVE_SELECTOR_(x) ((x).e)
#define RECURSIVE_SELECTOR_TYPE recursive_selector
#define recursive_selector_TYPE recursive_selector
#define recursive_selector_undefined ((recursive_selector)gen_chunk_undefined)
#define recursive_selector_undefined_p(x) ((x)==recursive_selector_undefined)

extern recursive_selector copy_recursive_selector(recursive_selector);
extern void free_recursive_selector(recursive_selector);
extern recursive_selector check_recursive_selector(recursive_selector);
extern bool recursive_selector_consistent_p(recursive_selector);
extern bool recursive_selector_defined_p(recursive_selector);
#define gen_RECURSIVE_SELECTOR_cons gen_recursive_selector_cons
extern list gen_recursive_selector_cons(recursive_selector, list);
extern void recursive_selector_assign_contents(recursive_selector, recursive_selector);
extern void recursive_selector_non_recursive_free(recursive_selector);
extern void write_recursive_selector(FILE*, recursive_selector);
extern recursive_selector read_recursive_selector(FILE*);
extern recursive_selector make_recursive_selector(list, expression);

struct _newgen_struct_recursive_selector_ {
  intptr_t _type_;
  list _recursive_selector_basis_; /* basis:path_selectors* */
  expression _recursive_selector_coefficient_; /* coefficient:expression */
};

#define recursive_selector_domain_number(x) ((x)->_type_)
#define recursive_selector_basis_(x) recursive_selector_basis(x) /* old hack compatible */
#define recursive_selector_basis(x) ((x)->_recursive_selector_basis_)
#define recursive_selector_coefficient_(x) recursive_selector_coefficient(x) /* old hack compatible */
#define recursive_selector_coefficient(x) ((x)->_recursive_selector_coefficient_)

/* STATEMENT_CELL_RELATIONS
 */
#define STATEMENT_CELL_RELATIONS(x) ((statement_cell_relations)((x).p))
#define statement_cell_relations_CAST(x) STATEMENT_CELL_RELATIONS(x)
#define STATEMENT_CELL_RELATIONS_CAST(x) STATEMENT_CELL_RELATIONS(x)
#define STATEMENT_CELL_RELATIONS_(x) ((x).e)
#define STATEMENT_CELL_RELATIONS_TYPE statement_cell_relations
#define statement_cell_relations_TYPE statement_cell_relations
#define statement_cell_relations_undefined ((statement_cell_relations)gen_chunk_undefined)
#define statement_cell_relations_undefined_p(x) ((x)==statement_cell_relations_undefined)

extern statement_cell_relations copy_statement_cell_relations(statement_cell_relations);
extern void free_statement_cell_relations(statement_cell_relations);
extern statement_cell_relations check_statement_cell_relations(statement_cell_relations);
extern bool statement_cell_relations_consistent_p(statement_cell_relations);
extern bool statement_cell_relations_defined_p(statement_cell_relations);
#define gen_STATEMENT_CELL_RELATIONS_cons gen_statement_cell_relations_cons
extern list gen_statement_cell_relations_cons(statement_cell_relations, list);
extern void statement_cell_relations_assign_contents(statement_cell_relations, statement_cell_relations);
extern void statement_cell_relations_non_recursive_free(statement_cell_relations);
extern void write_statement_cell_relations(FILE*, statement_cell_relations);
extern statement_cell_relations read_statement_cell_relations(FILE*);
extern statement_cell_relations make_statement_cell_relations(void);

struct _newgen_struct_statement_cell_relations_ {
  intptr_t _type_;
  hash_table _statement_cell_relations_holder_;
};

#define statement_cell_relations_domain_number(x) ((x)->_type_)
#define statement_cell_relations_hash_table(x) ((x)->_statement_cell_relations_holder_)
#define statement_cell_relations_key_type statement
#define statement_cell_relations_value_type cell_relations
#define STATEMENT_CELL_RELATIONS_MAP(k,v,c,f) FUNCTION_MAP(statement_cell_relations,p,p,k,v,c,f)
#define STATEMENT_CELL_RELATIONS_FOREACH(k,v,f) FUNCTION_FOREACH(statement_cell_relations,p,p,k,v,f)
extern cell_relations apply_statement_cell_relations(statement_cell_relations, statement);
extern void update_statement_cell_relations(statement_cell_relations, statement, cell_relations);
extern void extend_statement_cell_relations(statement_cell_relations, statement, cell_relations);
extern cell_relations delete_statement_cell_relations(statement_cell_relations, statement);
extern bool bound_statement_cell_relations_p(statement_cell_relations, statement);

/* STATEMENT_EFFECTS
 */
#define STATEMENT_EFFECTS(x) ((statement_effects)((x).p))
#define statement_effects_CAST(x) STATEMENT_EFFECTS(x)
#define STATEMENT_EFFECTS_CAST(x) STATEMENT_EFFECTS(x)
#define STATEMENT_EFFECTS_(x) ((x).e)
#define STATEMENT_EFFECTS_TYPE statement_effects
#define statement_effects_TYPE statement_effects
#define statement_effects_undefined ((statement_effects)gen_chunk_undefined)
#define statement_effects_undefined_p(x) ((x)==statement_effects_undefined)

extern statement_effects copy_statement_effects(statement_effects);
extern void free_statement_effects(statement_effects);
extern statement_effects check_statement_effects(statement_effects);
extern bool statement_effects_consistent_p(statement_effects);
extern bool statement_effects_defined_p(statement_effects);
#define gen_STATEMENT_EFFECTS_cons gen_statement_effects_cons
extern list gen_statement_effects_cons(statement_effects, list);
extern void statement_effects_assign_contents(statement_effects, statement_effects);
extern void statement_effects_non_recursive_free(statement_effects);
extern void write_statement_effects(FILE*, statement_effects);
extern statement_effects read_statement_effects(FILE*);
extern statement_effects make_statement_effects(void);

struct _newgen_struct_statement_effects_ {
  intptr_t _type_;
  hash_table _statement_effects_holder_;
};

#define statement_effects_domain_number(x) ((x)->_type_)
#define statement_effects_hash_table(x) ((x)->_statement_effects_holder_)
#define statement_effects_key_type statement
#define statement_effects_value_type effects
#define STATEMENT_EFFECTS_MAP(k,v,c,f) FUNCTION_MAP(statement_effects,p,p,k,v,c,f)
#define STATEMENT_EFFECTS_FOREACH(k,v,f) FUNCTION_FOREACH(statement_effects,p,p,k,v,f)
extern effects apply_statement_effects(statement_effects, statement);
extern void update_statement_effects(statement_effects, statement, effects);
extern void extend_statement_effects(statement_effects, statement, effects);
extern effects delete_statement_effects(statement_effects, statement);
extern bool bound_statement_effects_p(statement_effects, statement);

#define effects_spec "\
--NEWGEN-START 129\n\
import entity from \"ri.newgen\";\n\
import reference from \"ri.newgen\";\n\
import preference from \"ri.newgen\";\n\
import expression from \"ri.newgen\";\n\
import statement from \"ri.newgen\";\n\
external Psysteme;\n\
action_kind = store:unit + environment:unit + type_declaration:unit;\n\
action = read:action_kind + write:action_kind;\n\
approximation = may:unit + must:unit + exact:unit;\n\
cell_interpretation = value_of:unit + address_of:unit;\n\
cell = reference:reference + preference:preference + gap:gap;\n\
cell_relation = first:interpreted_cell x second:interpreted_cell x approximation:approximation x descriptor:descriptor;\n\
cell_relations = list:cell_relation*;\n\
descriptor = convexunion:Psysteme* + convex:Psysteme + none:unit;\n\
effect = cell:cell x action:action x approximation:approximation x descriptor:descriptor;\n\
effects_classes = classes:effects*;\n\
effects = effects:effect*;\n\
entity_effects = entity:entity -> effects:effects;\n\
gap = variable:entity x path_selectors:path_selectors;\n\
interpreted_cell = cell:cell x cell_interpretation:cell_interpretation;\n\
path_selector = expression:expression + recursive_selector:recursive_selector;\n\
path_selectors = path_selector:path_selector*;\n\
persistant_expression_to_effects = persistant expression:expression -> effects:effects;\n\
recursive_selector = basis:path_selectors* x coefficient:expression;\n\
statement_cell_relations = persistant statement:statement -> cell_relations:cell_relations;\n\
statement_effects = persistant statement:statement -> effects:effects;\n\
"
#endif
