/* Warning! Do not modify this file that is automatically generated! */
/* Modify src/Libs/ri-util/ri-util-local.h instead, to add your own modifications. */

/* header file built by cproto */

#ifndef  ri_util_header_included
#define  ri_util_header_included
/*

  $Id: ri-util-local.h 23065 2016-03-02 09:05:50Z coelho $

  Copyright 1989-2016 MINES ParisTech

  This file is part of PIPS.

  PIPS is free software: you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  any later version.

  PIPS is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.

  See the GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with PIPS.  If not, see <http://www.gnu.org/licenses/>.

*/
/* RI-UTIL Library: Functions dealing with and constants related to
 * PIPS intermediate representation ri.newgen,
 * that are NOT generated by NewGen
 */

 /* Pvecteur is an external type for NewGen and the ri data structure
  * and is not included in ri.h
  *
  * It is included here to avoid changes in many PIPS modules which
  * use ri-util
  *
  * Idem for type Ppolynome (PB 25/07/90); FI: polynomials are not
  * used in ri.newgen; they should not be mentionned here
  *
  * Idem for type Psysteme (FI 3 November 1990)
  *
  * New function call need to be defined to handle omp pragma as a
  * standard PIPS expression. To be easily recognized, all the defined
  * values are prefixed by "OMP_".
  */

/*
 * Modifications:
 * --------------
 * Molka Becher (MB), June 2010
 * - Add and Check of definition of C Intrinsics (#define)
 * - Add of definition of QuadPrecision type and LongDoubleComplex type
 * - Add of package & variable names for memmove intrinsic (string.h)
 */


#include "linear.h"
#include "genC.h"

#include "ri.h"
#include "text.h"
#include "cloning.h"

#include "newgen.h"
#include "naming.h"

/* FC 2015-07-20
 * yuk, temporary fix to avoid an include cycle ri-util <-> prettyprint
 # #include "prettyprint.h"
 */
extern string basic_to_string(basic);
extern string string_of_type(type);
extern void print_type(type);
extern bool same_type_name_p(type, type);

#define UNBOUNDED_DIMENSION_NAME         "UNBOUNDED-DIMENSION"
#define IMPLIED_DO_NAME                  "IMPLIED-DO"
#define IMPLIED_DO_FUNCTION_NAME         "IMPLIED-DO"
#define REPEAT_VALUE_NAME                "REPEAT-VALUE"
#define REPEAT_VALUE_FUNCTION_NAME       "REPEAT-VALUE"
#define STATIC_INITIALIZATION_NAME       "STATIC-INITIALIZATION"
#define STATIC_INITIALIZATION_FUNCTION_NAME     "STATIC-INITIALIZATION"
#define DATA_LIST_FUNCTION_NAME          "DATA-LIST="
#define IO_LIST_STRING_NAME              "IOLIST="


#define BRACE_INTRINSIC                  "BRACE_INTRINSIC"
#define NULL_STATEMENT_INTRINSIC         "NULL_STATEMENT_INTRINSIC"

#define IMPLIED_COMPLEX_NAME             "CMPLX_"
#define IMPLIED_DCOMPLEX_NAME            "DCMPLX_"

#define FIELD_OPERATOR_NAME              "."
#define POINT_TO_OPERATOR_NAME           "->"
#define DEREFERENCING_OPERATOR_NAME      "*indirection"

#define ASSIGN_OPERATOR_NAME             "="
#define ASSIGN_OPERATOR_PRECEDENCE       (2)
#define POST_INCREMENT_OPERATOR_NAME     "post++"
#define POST_DECREMENT_OPERATOR_NAME     "post--"
#define PRE_INCREMENT_OPERATOR_NAME      "++pre"
#define PRE_DECREMENT_OPERATOR_NAME      "--pre"
#define MULTIPLY_UPDATE_OPERATOR_NAME    "*="
#define DIVIDE_UPDATE_OPERATOR_NAME      "/="
#define PLUS_UPDATE_OPERATOR_NAME        "+="
#define MINUS_UPDATE_OPERATOR_NAME       "-="
#define LEFT_SHIFT_UPDATE_OPERATOR_NAME  "<<="
#define RIGHT_SHIFT_UPDATE_OPERATOR_NAME ">>="
#define BITWISE_OR_UPDATE_OPERATOR_NAME  "|="

#define COMMA_OPERATOR_NAME             ","

#define PLUS_OPERATOR_NAME              "+"
#define PLUS_C_OPERATOR_NAME            "+C" /* includes pointer arithmetic */
#define MINUS_OPERATOR_NAME             "-"
#define MINUS_C_OPERATOR_NAME           "-C" /* includes pointer arithmetic */
#define UNARY_MINUS_OPERATOR_NAME       "--"
#define UNARY_PLUS_OPERATOR_NAME        "+unary"
#define MULTIPLY_OPERATOR_NAME          "*"
#define DIVIDE_OPERATOR_NAME            "/"
#define INVERSE_OPERATOR_NAME           "_INV_" /* internal stuff */
#define POWER_OPERATOR_NAME             "**"
#define MODULO_OPERATOR_NAME            "MOD"
#define REAL_MODULO_OPERATOR_NAME       "AMOD"
#define DOUBLE_MODULO_OPERATOR_NAME     "DMOD"
#define SIGN_OPERATOR_NAME              "SIGN"
#define ISIGN_OPERATOR_NAME             "ISIGN"
#define DSIGN_OPERATOR_NAME             "DSIGN"
#define DIM_OPERATOR_NAME               "DIM"
#define IDIM_OPERATOR_NAME              "IDIM"
#define DDIM_OPERATOR_NAME              "DDIM"
#define DPROD_OPERATOR_NAME             "DPROD"
#define CONJG_OPERATOR_NAME             "CONJG"
#define DCONJG_OPERATOR_NAME            "DCONJG"
#define SQRT_OPERATOR_NAME              "SQRT"
#define DSQRT_OPERATOR_NAME             "DSQRT"
#define CSQRT_OPERATOR_NAME             "CSQRT"
#define CDSQRT_OPERATOR_NAME            "CDSQRT"
#define EXP_OPERATOR_NAME               "EXP"
#define DEXP_OPERATOR_NAME              "DEXP"
#define CEXP_OPERATOR_NAME              "CEXP"
#define CDEXP_OPERATOR_NAME             "CDEXP"
#define LOG_OPERATOR_NAME               "LOG"
#define ALOG_OPERATOR_NAME              "ALOG"
#define DLOG_OPERATOR_NAME              "DLOG"
#define CLOG_OPERATOR_NAME              "CLOG"
#define CDLOG_OPERATOR_NAME             "CDLOG"
#define LOG10_OPERATOR_NAME             "LOG10"
#define ALOG10_OPERATOR_NAME            "ALOG10"
#define DLOG10_OPERATOR_NAME            "DLOG10"
#define SIN_OPERATOR_NAME               "SIN"
#define DSIN_OPERATOR_NAME              "DSIN"
#define CSIN_OPERATOR_NAME              "CSIN"
#define CDSIN_OPERATOR_NAME             "CDSIN"
#define COS_OPERATOR_NAME               "COS"
#define DCOS_OPERATOR_NAME              "DCOS"
#define CCOS_OPERATOR_NAME              "CCOS"
#define CDCOS_OPERATOR_NAME             "CDCOS"
#define TAN_OPERATOR_NAME               "TAN"
#define DTAN_OPERATOR_NAME              "DTAN"
#define ASIN_OPERATOR_NAME              "ASIN"
#define DASIN_OPERATOR_NAME             "DASIN"
#define ACOS_OPERATOR_NAME              "ACOS"
#define DACOS_OPERATOR_NAME             "DACOS"
#define ATAN_OPERATOR_NAME              "ATAN"
#define DATAN_OPERATOR_NAME             "DATAN"
#define ATAN2_OPERATOR_NAME             "ATAN2"
#define DATAN2_OPERATOR_NAME            "DATAN2"
#define SINH_OPERATOR_NAME              "SINH"
#define DSINH_OPERATOR_NAME             "DSINH"
#define COSH_OPERATOR_NAME              "COSH"
#define DCOSH_OPERATOR_NAME             "DCOSH"
#define TANH_OPERATOR_NAME              "TANH"
#define DTANH_OPERATOR_NAME             "DTANH"
#define LEFT_SHIFT_OPERATOR_NAME        "<<"
#define RIGHT_SHIFT_OPERATOR_NAME       ">>"

// Conflicts with reserved prefixes for BLOCKDATA (&), COMMON (~),
// MAIN (%), FILESEP (!), MEMBER_SEP_STRING (^), ENUM (?) & al.
// Use "-" to avoid conflict with user defined symbols
#define ADDRESS_OF_OPERATOR_NAME         "__address-of__"       // &
#define BITWISE_AND_OPERATOR_NAME        "__bit-and__"          // &
#define BITWISE_NOT_OPERATOR_NAME        "__bit-not__"          // ~
#define BITWISE_XOR_OPERATOR_NAME        "__C-xor__"            // ^
#define C_AND_OPERATOR_NAME              "__C-and__"            // &&
#define MODULO_UPDATE_OPERATOR_NAME      "__C-modulo-update__"  // %=
#define BITWISE_AND_UPDATE_OPERATOR_NAME "__C-bit-and-update__" // &=
#define BITWISE_XOR_UPDATE_OPERATOR_NAME "__C-bit-xor-update__" // ^=
#define CONDITIONAL_OPERATOR_NAME        "__C-conditional__"    // ?
#define C_NOT_OPERATOR_NAME              "__C-logical-not__"    // !
#define C_NON_EQUAL_OPERATOR_NAME        "__C-non-equal__"      // !=
#define C_MODULO_OPERATOR_NAME           "__C-modulo__"         // %

#define BITWISE_OR_OPERATOR_NAME        "|"
#define MIN_OPERATOR_NAME               "MIN"
#define MIN0_OPERATOR_NAME              "MIN0"
#define MIN1_OPERATOR_NAME              "MIN1"
#define AMIN0_OPERATOR_NAME             "AMIN0"
#define AMIN1_OPERATOR_NAME             "AMIN1"
#define DMIN1_OPERATOR_NAME             "DMIN1"
#define MAX_OPERATOR_NAME               "MAX"
#define MAX0_OPERATOR_NAME              "MAX0"
#define AMAX0_OPERATOR_NAME             "AMAX0"
#define MAX1_OPERATOR_NAME              "MAX1"
#define AMAX1_OPERATOR_NAME             "AMAX1"
#define DMAX1_OPERATOR_NAME             "DMAX1"
#define ABS_OPERATOR_NAME               "ABS"
#define IABS_OPERATOR_NAME              "IABS"
#define DABS_OPERATOR_NAME              "DABS"
#define CABS_OPERATOR_NAME              "CABS"
#define CDABS_OPERATOR_NAME             "CDABS"

#define LENGTH_OPERATOR_NAME            "LEN"
#define INDEX_OPERATOR_NAME             "INDEX"
#define LGE_OPERATOR_NAME               "LGE"
#define LGT_OPERATOR_NAME               "LGT"
#define LLE_OPERATOR_NAME               "LLE"
#define LLT_OPERATOR_NAME               "LLT"

/* generic conversion names.
 */
#define INT_GENERIC_CONVERSION_NAME     "INT"
#define IFIX_GENERIC_CONVERSION_NAME    "IFIX"
#define IDINT_GENERIC_CONVERSION_NAME   "IDINT"
#define REAL_GENERIC_CONVERSION_NAME    "REAL"
#define FLOAT_GENERIC_CONVERSION_NAME   "FLOAT"
#define DFLOAT_GENERIC_CONVERSION_NAME  "DFLOAT"
#define SNGL_GENERIC_CONVERSION_NAME    "SNGL"
#define DBLE_GENERIC_CONVERSION_NAME    "DBLE"
#define DREAL_GENERIC_CONVERSION_NAME   "DREAL"
#define CMPLX_GENERIC_CONVERSION_NAME   "CMPLX"
#define DCMPLX_GENERIC_CONVERSION_NAME  "DCMPLX"

#define INT_TO_CHAR_CONVERSION_NAME     "CHAR"
#define CHAR_TO_INT_CONVERSION_NAME     "ICHAR"

#define AINT_CONVERSION_NAME            "AINT"
#define DINT_CONVERSION_NAME            "DINT"
#define ANINT_CONVERSION_NAME           "ANINT"
#define DNINT_CONVERSION_NAME           "DNINT"
#define NINT_CONVERSION_NAME            "NINT"
#define IDNINT_CONVERSION_NAME          "IDNINT"
#define AIMAG_CONVERSION_NAME           "AIMAG"
#define DIMAG_CONVERSION_NAME           "DIMAG"

/* FI: intrinsics are defined at a third place after bootstrap and effects!
 *     I guess the name should be defined here and used in table(s) there
 */

#define AND_OPERATOR_NAME               ".AND."
#define OR_OPERATOR_NAME                ".OR."
#define C_OR_OPERATOR_NAME              "||"
#define NOT_OPERATOR_NAME               ".NOT."
#define NON_EQUAL_OPERATOR_NAME         ".NE."
#define EQUIV_OPERATOR_NAME             ".EQV."
#define NON_EQUIV_OPERATOR_NAME         ".NEQV."

#define TRUE_OPERATOR_NAME              ".TRUE."
#define FALSE_OPERATOR_NAME             ".FALSE."
#define ONE_OPERATOR_NAME               "1"
#define ZERO_OPERATOR_NAME              "0"

#define GREATER_OR_EQUAL_OPERATOR_NAME  ".GE."
#define C_GREATER_OR_EQUAL_OPERATOR_NAME        ">="
#define GREATER_THAN_OPERATOR_NAME      ".GT."
#define C_GREATER_THAN_OPERATOR_NAME    ">"
#define LESS_OR_EQUAL_OPERATOR_NAME     ".LE."
#define C_LESS_OR_EQUAL_OPERATOR_NAME   "<="
#define LESS_THAN_OPERATOR_NAME         ".LT."
#define C_LESS_THAN_OPERATOR_NAME       "<"
#define EQUAL_OPERATOR_NAME             ".EQ."
#define C_EQUAL_OPERATOR_NAME           "=="

#define CONTINUE_FUNCTION_NAME          "CONTINUE"
#define C_CONTINUE_FUNCTION_NAME        ";"
#define C_STATEMENT_END_STRING          ";"
#define RETURN_FUNCTION_NAME            "RETURN"
#define STOP_FUNCTION_NAME              "STOP"
#define PAUSE_FUNCTION_NAME             "PAUSE"
#define END_FUNCTION_NAME               "END"
#define ENDDO_FUNCTION_NAME             "ENDDO"

#define BREAK_FUNCTION_NAME             "break"
#define CASE_FUNCTION_NAME              "case"
#define DEFAULT_FUNCTION_NAME           "default"
#define C_RETURN_FUNCTION_NAME          "return"

#define SUBSTRING_FUNCTION_NAME         "_SUBSTR"
#define CONCATENATION_FUNCTION_NAME     "//"
#define ASSIGN_SUBSTRING_FUNCTION_NAME  "_ASSIGN_SUBSTR"

#define WRITE_FUNCTION_NAME             "WRITE"
#define PRINT_FUNCTION_NAME             "PRINT"
#define REWIND_FUNCTION_NAME            "REWIND"
#define OPEN_FUNCTION_NAME              "OPEN"
#define CLOSE_FUNCTION_NAME             "CLOSE"
#define INQUIRE_FUNCTION_NAME           "INQUIRE"
#define BACKSPACE_FUNCTION_NAME         "BACKSPACE"
#define READ_FUNCTION_NAME              "READ"
#define BUFFERIN_FUNCTION_NAME          "BUFFERIN"
#define BUFFEROUT_FUNCTION_NAME         "BUFFEROUT"
#define ENDFILE_FUNCTION_NAME           "ENDFILE"
#define FORMAT_FUNCTION_NAME            "FORMAT"


/* Bit manipulation functions */
#define ISHFT_OPERATOR_NAME             "ISHFT"
#define ISHFTC_OPERATOR_NAME            "ISHFTC"
#define IBITS_OPERATOR_NAME             "IBITS"
#define MVBITS_OPERATOR_NAME            "MVBITS"
#define BTEST_OPERATOR_NAME             "BTEST"
#define IBSET_OPERATOR_NAME             "IBSET"
#define IBCLR_OPERATOR_NAME             "IBCLR"
#define BIT_SIZE_OPERATOR_NAME          "BIT_SIZE"
#define IAND_OPERATOR_NAME              "IAND"
#define IEOR_OPERATOR_NAME              "IEOR"
#define IOR_OPERATOR_NAME               "IOR"

/* OMP related function and opertor names */

#define OMP_IF_FUNCTION_NAME            "if"
#define OMP_OMP_FUNCTION_NAME           "omp"
#define OMP_FOR_FUNCTION_NAME           "for"
#define OMP_PRIVATE_FUNCTION_NAME       "private"
#define OMP_PARALLEL_FUNCTION_NAME      "parallel"
#define OMP_REDUCTION_FUNCTION_NAME     "reduction"

/* F95 */
#define ALLOCATE_FUNCTION_NAME          "ALLOCATE"
#define DEALLOCATE_FUNCTION_NAME        "DEALLOCATE"
#define ETIME_FUNCTION_NAME             "ETIME"
#define DTIME_FUNCTION_NAME             "DTIME"
#define CPU_TIME_FUNCTION_NAME          "CPU_TIME"

/* F2003 */
#define C_LOC_FUNCTION_NAME             "C_LOC"

/* F2008 */

/* BSD <err.h> */
#define ERR_FUNCTION_NAME		"err"
#define ERRX_FUNCTION_NAME		"errx"
#define WARN_FUNCTION_NAME		"warn"
#define WARNX_FUNCTION_NAME		"warnx"
#define VERR_FUNCTION_NAME		"verr"
#define VERRX_FUNCTION_NAME		"verrx"
#define VWARN_FUNCTION_NAME		"vwarn"
#define VWARNX_FUNCTION_NAME		"vwarnx"

/* time.h */
#define CLOCK_FUNCTION_NAME		"clock"
#define TIME_FUNCTION_NAME		"time"
#define DIFFTIME_FUNCTION_NAME		"difftime"
#define MKTIME_FUNCTION_NAME		"mktime"
#define STRFTIME_FUNCTION_NAME		"strftime"
#define STRPTIME_FUNCTION_NAME		"strptime"
#define STRFTIME_L_FUNCTION_NAME	"strftime_l"
#define STRPTIME_L_FUNCTION_NAME	"strptime_l"
#define GMTIME_FUNCTION_NAME		"gmtime"
#define LOCALTIME_FUNCTION_NAME		"localtime"
#define GMTIME_R_FUNCTION_NAME		"gmtime_r"
#define LOCALTIME_R_FUNCTION_NAME	"localtime_r"
#define ASCTIME_FUNCTION_NAME		"asctime"
#define CTIME_FUNCTION_NAME		"ctime"
#define ASCTIME_R_FUNCTION_NAME		"asctime_r"
#define CTIME_R_FUNCTION_NAME		"ctime_r"
#define TZSET_FUNCTION_NAME		"tzset"
#define STIME_FUNCTION_NAME             "stime"
#define TIMEGM_FUNCTION_NAME            "timegm"
#define TIMELOCAL_FUNCTION_NAME         "timelocal"
#define DYSIZE_FUNCTION_NAME            "dysize"
#define NANOSLEEP_FUNCTION_NAME         "nanosleep"
#define CLOCK_GETRES_FUNCTION_NAME      "clock_getres"
#define CLOCK_GETTIME_FUNCTION_NAME     "clock_gettime"
#define CLOCK_SETTIME_FUNCTION_NAME     "clock_settime"
#define CLOCK_NANOSLEEP_FUNCTION_NAME   "clock_nanosleep"
#define CLOCK_GETCPULOCKID_FUNCTION_NAME "clock_getcpulockid"
#define TIMER_CREATE_FUNCTION_NAME      "timer_create"
#define TIMER_DELETE_FUNCTION_NAME      "timer_delete"
#define TIMER_SETTIME_FUNCTION_NAME     "timer_settime"
#define TIMER_GETTIME_FUNCTION_NAME     "timer_gettime"
#define TIMER_GETOVERRUN_FUNCTION_NAME  "timer_getoverrun"
#define GETDATE_FUNCTION_NAME           "getdate"
#define GETDATE_R_FUNCTION_NAME         "getdate_r"

//to check
#define DRAND48_FUNCTION_NAME           "drand48"
#define ERAND48_FUNCTION_NAME           "erand48"
#define JRAND48_FUNCTION_NAME           "jrand48"
#define LCONG48_FUNCTION_NAME           "lcong48"
#define LRAND48_FUNCTION_NAME           "lrand48"
#define MRAND48_FUNCTION_NAME           "mrand48"
#define NRAND48_FUNCTION_NAME           "nrand48"
#define SEED48_FUNCTION_NAME            "seed48"
#define SRAND48_FUNCTION_NAME           "srand48"

#define PUTENV_FUNCTION_NAME            "putenv"
#define SETKEY_FUNCTION_NAME            "setkey"
#define SWAB_FUNCTION_NAME              "swab"
#define MKSTEMP_FUNCTION_NAME           "mkstemp"
#define MKSTEMP64_FUNCTION_NAME         "mkstemp64"
#define A614_FUNCTION_NAME              "a64l"
#define ECVT_FUNCTION_NAME              "ecvt"
#define FCVT_FUNCTION_NAME              "fcvt"
#define GCVT_FUNCTION_NAME              "gcvt"
#define GETSUBOPT_FUNCTION_NAME         "getsubopt"
#define GRANTPT_FUNCTION_NAME           "grantpt"
#define INITSTATE_FUNCTION_NAME         "initstate"
#define C_164A_FUNCTION_NAME            "l64a"
#define MKTEMP_FUNCTION_NAME            "mktemp"
#define PTSNAME_FUNCTION_NAME           "ptsname"
#define REALPATH_FUNCTION_NAME          "realpath"
#define SETSTATE_FUNCTION_NAME          "setstate"
#define TTYSLOT_FUNCTION_NAME           "ttyslot"
#define UNLOCKPT_FUNCTION_NAME          "unlockpt"
#define VALLOC_FUNCTION_NAME            "valloc"
#define DUP2_FUNCTION_NAME              "dup2"
#define QECVT_FUNCTION_NAME             "qecvt"
#define QFCVT_FUNCTION_NAME             "qfcvt"
#define QGCVT_FUNCTION_NAME             "qgcvt"
#define GETCWD_FUNCTION_NAME            "getcwd"
#define GETEXECNAME_FUNCTION_NAME       "getexecname"
#define GETLOGIN_FUNCTION_NAME          "getlogin"
#define GETOPT_FUNCTION_NAME            "getopt" // unistd.h
#define GETOPT_LONG_FUNCTION_NAME       "getopt_long"
#define GETOPT_LONG_ONLY_FUNCTION_NAME  "getopt_long_only"
#define GETPASS_FUNCTION_NAME           "getpass"
#define GETPASSPHRASE_FUNCTION_NAME     "getpassphrase"
#define GETPW_FUNCTION_NAME             "getpw"
#define ISATTY_FUNCTION_NAME            "isatty"
#define MEMALIGN_FUNCTION_NAME          "memalign"
#define TTYNAME_FUNCTION_NAME           "ttyname"
#define LLTOSTR_FUNCTION_NAME           "lltostr"
#define ULLTOSTR_FUNCTION_NAME          "ulltostr"

#define POSIX_MEMALIGN_FUNCTION_NAME    "posix_memalign"
#define ATOQ_FUNCTION_NAME              "atoq"
#define RANDOM_FUNCTION_NAME            "random"
#define SRANDOM_FUNCTION_NAME           "srandom"
#define MOD_INTRINSIC_NAME              "MOD"

/* PIPS run-time support for C code generation
 *
 * The first argument is the number of effective arguments, the second
 * argument is the first effective argument and other arguments are
 * passed as varargs. For instance:
 *
 * pips_min(5, 1, 2, 3, 4, 5);
 *
 * Initially, the source code for these two operators is available in
 * validation/Hyperplane/run_time.src/pips_run_time.c
 */
#define PIPS_C_MIN_OPERATOR_NAME        "pips_min"
#define PIPS_C_MAX_OPERATOR_NAME        "pips_max"


 /* Here are C intrinsics arranged in the order of the standard
    ISO/IEC 9899:TC2. MB */
/* include <assert.h> */

#define ASSERT_FUNCTION_NAME            "__assert"
#define ASSERT_FAIL_FUNCTION_NAME       "__assert_fail"

/* include <complex.h> */

#define CACOS_OPERATOR_NAME             "cacos"
#define CACOSF_OPERATOR_NAME            "cacosf"
#define CACOSL_OPERATOR_NAME            "cacosl"
#define CASIN_OPERATOR_NAME             "casin"
#define CASINF_OPERATOR_NAME            "casinf"
#define CASINL_OPERATOR_NAME            "casinl"
#define CATAN_OPERATOR_NAME             "catan"
#define CATANF_OPERATOR_NAME            "catanf"
#define CATANL_OPERATOR_NAME            "catanl"
#define C_CCOS_OPERATOR_NAME            "ccos"
#define CCOSF_OPERATOR_NAME             "ccosf"
#define CCOSL_OPERATOR_NAME             "ccosl"
#define C_CSIN_OPERATOR_NAME            "csin"
#define CSINF_OPERATOR_NAME             "csinf"
#define CSINL_OPERATOR_NAME             "csinl"
#define CTAN_OPERATOR_NAME              "ctan"
#define CTANF_OPERATOR_NAME             "ctanf"
#define CTANL_OPERATOR_NAME             "ctanl"
#define CACOSH_OPERATOR_NAME            "cacosh"
#define CACOSHF_OPERATOR_NAME           "cacoshf"
#define CACOSHL_OPERATOR_NAME           "cacoshl"
#define CASINH_OPERATOR_NAME            "casinh"
#define CASINHF_OPERATOR_NAME           "casinhf"
#define CASINHL_OPERATOR_NAME           "casinhl"
#define CATANH_OPERATOR_NAME            "catanh"
#define CATANHF_OPERATOR_NAME           "catanhf"
#define CATANHL_OPERATOR_NAME           "catanhl"
#define CCOSH_OPERATOR_NAME             "ccosh"
#define CCOSHF_OPERATOR_NAME            "ccoshf"
#define CCOSHL_OPERATOR_NAME            "ccoshl"
#define CSINH_OPERATOR_NAME             "csinh"
#define CSINHF_OPERATOR_NAME            "csinhf"
#define CSINHL_OPERATOR_NAME            "csinhl"
#define CTANH_OPERATOR_NAME             "ctanh"
#define CTANHF_OPERATOR_NAME            "ctanhf"
#define CTANHL_OPERATOR_NAME            "ctanhl"
#define C_CEXP_OPERATOR_NAME            "cexp"
#define CEXPF_OPERATOR_NAME             "cexpf"
#define CEXPL_OPERATOR_NAME             "cexpl"
#define C_CLOG_OPERATOR_NAME            "clog"
#define CLOGF_OPERATOR_NAME             "clogf"
#define CLOGL_OPERATOR_NAME             "clogl"
#define C_CABS_OPERATOR_NAME            "cabs"
#define CABSF_OPERATOR_NAME             "cabsf"
#define CABSL_OPERATOR_NAME             "cabsl"
#define CPOW_OPERATOR_NAME              "cpow"
#define CPOWF_OPERATOR_NAME             "cpowf"
#define CPOWL_OPERATOR_NAME             "cpowl"
#define C_CSQRT_OPERATOR_NAME           "csqrt"
#define CSQRTF_OPERATOR_NAME            "csqrtf"
#define CSQRTL_OPERATOR_NAME            "csqrtl"
#define CARG_OPERATOR_NAME              "carg"
#define CARGF_OPERATOR_NAME             "cargf"
#define CARGL_OPERATOR_NAME             "cargl"
#define CIMAG_OPERATOR_NAME             "cimag"
#define GCC_CIMAG_OPERATOR_NAME         "__imag__"
#define CIMAGF_OPERATOR_NAME            "cimagf"
#define CIMAGL_OPERATOR_NAME            "cimagl"
#define CONJ_OPERATOR_NAME              "conj"
#define CONJF_OPERATOR_NAME             "conjf"
#define CONJL_OPERATOR_NAME             "conjl"
#define CPROJ_OPERATOR_NAME             "cproj"
#define CPROJF_OPERATOR_NAME            "cprojf"
#define CPROJL_OPERATOR_NAME            "cprojl"
#define CREAL_OPERATOR_NAME             "creal"
#define GCC_CREAL_OPERATOR_NAME         "__real__"
#define CREALF_OPERATOR_NAME            "crealf"
#define CREALL_OPERATOR_NAME            "creall"


/* #include <ctype.h> */

#define ISALNUM_OPERATOR_NAME           "isalnum"
#define ISALPHA_OPERATOR_NAME           "isalpha"
#define ISBLANK_OPERATOR_NAME           "isblank"
#define ISCNTRL_OPERATOR_NAME           "iscntrl"
#define ISDIGIT_OPERATOR_NAME           "isdigit"
#define ISGRAPH_OPERATOR_NAME           "isgraph"
#define ISLOWER_OPERATOR_NAME           "islower"
#define ISPRINT_OPERATOR_NAME           "isprint"
#define ISPUNCT_OPERATOR_NAME           "ispunct"
#define ISSPACE_OPERATOR_NAME           "isspace"
#define ISUPPER_OPERATOR_NAME           "isupper"
#define ISXDIGIT_OPERATOR_NAME          "isxdigit"
#define TOLOWER_OPERATOR_NAME           "tolower"
#define TOUPPER_OPERATOR_NAME           "toupper"

//not found in standard C99 (in GNU C Library)
#define ISASCII_OPERATOR_NAME           "isascii"
#define TOASCII_OPERATOR_NAME           "toascii"
#define _TOLOWER_OPERATOR_NAME          "_tolower"
#define _TOUPPER_OPERATOR_NAME          "_toupper"

/* Part of the binary standard */
#define CTYPE_B_LOC_OPERATOR_NAME       "__ctype_b_loc"


/* bits/errno.h */
#define __ERRNO_LOCATION_OPERATOR_NAME "__errno_location"


/* #include <fenv.h> */
#define FECLEAREXCEPT_FUNCTION_NAME        "feclearexcept"
#define FERAISEEXCEPT_FUNCTION_NAME        "feraiseexcept"
#define FESETEXCEPTFLAG_FUNCTION_NAME      "fesetexceptflag"
#define FETESTEXCEPT_FUNCTION_NAME         "fetestexcept"
#define FEGETROUND_FUNCTION_NAME           "fegetround"
#define FESETROUND_FUNCTION_NAME           "fesetround"

/* #include <inttypes.h> */
#define IMAXABS_FUNCTION_NAME              "imaxabs"
#define IMAXDIV_FUNCTION_NAME              "imaxdiv"

/* #include <locale.h> */
#define SETLOCALE_FUNCTION_NAME            "setlocale"

/* #include <math.h> */

#define FPCLASSIFY_OPERATOR_NAME           "fpclassify"
#define ISFINITE_OPERATOR_NAME             "isfinite"
#define ISINF_OPERATOR_NAME                "isinf"
#define ISNAN_OPERATOR_NAME                "isnan"
#define ISNANL_OPERATOR_NAME               "isnanl"
#define ISNANF_OPERATOR_NAME               "isnanf"
#define ISNORMAL_OPERATOR_NAME             "isnormal"
#define SIGNBIT_OPERATOR_NAME              "signbit"
#define C_ACOS_OPERATOR_NAME               "acos"
#define ACOSF_OPERATOR_NAME                "acosf"
#define ACOSL_OPERATOR_NAME                "acosl"
#define C_ASIN_OPERATOR_NAME               "asin"
#define ASINF_OPERATOR_NAME                "asinf"
#define ASINL_OPERATOR_NAME                "asinl"
#define C_ATAN_OPERATOR_NAME               "atan"
#define ATANF_OPERATOR_NAME                "atanf"
#define ATANL_OPERATOR_NAME                "atanl"
#define C_ATAN2_OPERATOR_NAME              "atan2"
#define ATAN2F_OPERATOR_NAME               "atan2f"
#define ATAN2L_OPERATOR_NAME               "atan2l"
#define C_COS_OPERATOR_NAME                "cos"
#define COSF_OPERATOR_NAME                 "cosf"
#define COSL_OPERATOR_NAME                 "cosl"
#define C_SIN_OPERATOR_NAME                "sin"
#define SINF_OPERATOR_NAME                 "sinf"
#define SINL_OPERATOR_NAME                 "sinl"
#define C_TAN_OPERATOR_NAME                "tan"
#define TANF_OPERATOR_NAME                 "tanf"
#define TANL_OPERATOR_NAME                 "tanl"
#define C_ACOSH_OPERATOR_NAME              "acosh"
#define ACOSHF_OPERATOR_NAME               "acoshf"
#define ACOSHL_OPERATOR_NAME               "acoshl"
#define C_ASINH_OPERATOR_NAME              "asinh"
#define ASINHF_OPERATOR_NAME               "asinhf"
#define ASINHL_OPERATOR_NAME               "asinhl"
#define C_ATANH_OPERATOR_NAME              "atanh"
#define ATANHF_OPERATOR_NAME               "atanhf"
#define ATANHL_OPERATOR_NAME               "atanhl"
#define C_COSH_OPERATOR_NAME               "cosh"
#define COSHF_OPERATOR_NAME                "coshf"
#define COSHL_OPERATOR_NAME                "coshl"
#define C_SINH_OPERATOR_NAME               "sinh"
#define SINHF_OPERATOR_NAME                "sinhf"
#define SINHL_OPERATOR_NAME                "sinhl"
#define C_TANH_OPERATOR_NAME               "tanh"
#define TANHF_OPERATOR_NAME                "tanhf"
#define TANHL_OPERATOR_NAME                "tanhl"
#define C_EXP_OPERATOR_NAME                "exp"
#define EXPF_OPERATOR_NAME                 "expf"
#define EXPL_OPERATOR_NAME                 "expl"
#define EXP2_OPERATOR_NAME                 "exp2"
#define EXP2F_OPERATOR_NAME                "exp2f"
#define EXP2L_OPERATOR_NAME                "exp2l"
#define EXPM1_OPERATOR_NAME                "expm1"
#define EXPM1F_OPERATOR_NAME               "expm1f"
#define EXPM1L_OPERATOR_NAME               "expm1l"
#define FREXP_OPERATOR_NAME                "frexp"
#define ILOGB_OPERATOR_NAME                "ilogb"
#define ILOGBF_OPERATOR_NAME               "ilogbf"
#define ILOGBL_OPERATOR_NAME               "ilogbl"
#define LDEXP_OPERATOR_NAME                "ldexp"
#define LDEXPF_OPERATOR_NAME               "ldexpf"
#define LDEXPL_OPERATOR_NAME               "ldexpl"
#define C_LOG_OPERATOR_NAME                "log"
#define LOGF_OPERATOR_NAME                 "logf"
#define LOGL_OPERATOR_NAME                 "logl"
#define C_LOG10_OPERATOR_NAME              "log10"
#define LOG10F_OPERATOR_NAME               "log10f"
#define LOG10L_OPERATOR_NAME               "log10l"
#define LOG1P_OPERATOR_NAME                "log1p"
#define LOG1PF_OPERATOR_NAME               "log1pf"
#define LOG1PL_OPERATOR_NAME               "log1pl"
#define LOG2_OPERATOR_NAME                 "log2"
#define LOG2F_OPERATOR_NAME                "log2f"
#define LOG2L_OPERATOR_NAME                "log2l"
#define LOGB_OPERATOR_NAME                 "logb"
#define LOGBF_OPERATOR_NAME                "logbf"
#define LOGBL_OPERATOR_NAME                "logbl"
#define MODF_OPERATOR_NAME                 "modf"
#define SCALBN_OPERATOR_NAME               "scalbn"
#define SCALBNF_OPERATOR_NAME              "scalbnf"
#define SCALBNL_OPERATOR_NAME              "scalbnl"
#define SCALB_OPERATOR_NAME                "scalb"
#define SCALBLN_OPERATOR_NAME              "scalbln"
#define SCALBLNF_OPERATOR_NAME             "scalblnf"
#define SCALBLNL_OPERATOR_NAME             "scalblnl"
#define CBRT_OPERATOR_NAME                 "cbrt"
#define CBRTF_OPERATOR_NAME                "cbrtf"
#define CBRTL_OPERATOR_NAME                "cbrtl"
#define FABS_OPERATOR_NAME                 "fabs"
#define FABSF_OPERATOR_NAME                "fabsf"
#define FABSL_OPERATOR_NAME                "fabsl"
#define HYPOT_OPERATOR_NAME                "hypot"
#define HYPOTF_OPERATOR_NAME               "hypotf"
#define HYPOTL_OPERATOR_NAME               "hypotl"
#define POW_OPERATOR_NAME                  "pow"
#define POWF_OPERATOR_NAME                 "powf"
#define POWL_OPERATOR_NAME                 "powl"
#define C_SQRT_OPERATOR_NAME               "sqrt"
#define SQRTF_OPERATOR_NAME                "sqrtf"
#define SQRTL_OPERATOR_NAME                "sqrtl"
#define ERF_OPERATOR_NAME                  "erf"
#define ERFF_OPERATOR_NAME                 "erff"
#define ERFL_OPERATOR_NAME                 "erfl"
#define ERFC_OPERATOR_NAME                 "erfc"
#define ERFCF_OPERATOR_NAME                "erfcf"
#define ERFCL_OPERATOR_NAME                "erfcl"
#define GAMMA_OPERATOR_NAME                "gamma"
#define LGAMMA_OPERATOR_NAME               "lgamma"
#define LGAMMAF_OPERATOR_NAME              "lgammaf"
#define LGAMMAL_OPERATOR_NAME              "lgammal"
#define TGAMMA_OPERATOR_NAME               "tgamma"
#define TGAMMAF_OPERATOR_NAME              "tgammaf"
#define TGAMMAL_OPERATOR_NAME              "tgammal"
#define CEIL_OPERATOR_NAME                 "ceil"
#define CEILF_OPERATOR_NAME                "ceilf"
#define CEILL_OPERATOR_NAME                "ceill"
#define FLOOR_OPERATOR_NAME                "floor"
#define FLOORF_OPERATOR_NAME               "floorf"
#define FLOORL_OPERATOR_NAME               "floorl"
#define NEARBYINT_OPERATOR_NAME            "nearbyint"
#define NEARBYINTF_OPERATOR_NAME           "nearbyintf"
#define NEARBYINTL_OPERATOR_NAME           "nearbyintl"
#define RINT_OPERATOR_NAME                 "rint"
#define RINTF_OPERATOR_NAME                "rintf"
#define RINTL_OPERATOR_NAME                "rintl"
#define LRINT_OPERATOR_NAME                "lrint"
#define LRINTF_OPERATOR_NAME               "lrintf"
#define LRINTL_OPERATOR_NAME               "lrintl"
#define LLRINT_OPERATOR_NAME               "llrint"
#define LLRINTF_OPERATOR_NAME              "llrintf"
#define LLRINTL_OPERATOR_NAME              "llrintl"
#define ROUND_OPERATOR_NAME                "round"
#define ROUNDF_OPERATOR_NAME               "roundf"
#define ROUNDL_OPERATOR_NAME               "roundl"
#define LROUND_OPERATOR_NAME               "lround"
#define LROUNDF_OPERATOR_NAME              "lroundf"
#define LROUNDL_OPERATOR_NAME              "lroundl"
#define LLROUND_OPERATOR_NAME              "llround"
#define LLROUNDF_OPERATOR_NAME             "llroundf"
#define LLROUNDL_OPERATOR_NAME             "llroundl"
#define TRUNC_OPERATOR_NAME                "trunc"
#define TRUNCF_OPERATOR_NAME               "truncf"
#define TRUNCL_OPERATOR_NAME               "truncl"
#define FMOD_OPERATOR_NAME                 "fmod"
#define FMODF_OPERATOR_NAME                "fmodf"
#define FMODL_OPERATOR_NAME                "fmodl"
#define REMAINDER_OPERATOR_NAME            "remainder"
#define REMAINDERF_OPERATOR_NAME           "remainderf"
#define REMAINDERL_OPERATOR_NAME           "remainderl"
#define COPYSIGN_OPERATOR_NAME             "copysign"
#define COPYSIGNF_OPERATOR_NAME            "copysignf"
#define COPYSIGNL_OPERATOR_NAME            "copysignl"
#define NAN_OPERATOR_NAME                  "nan"
#define NANF_OPERATOR_NAME                 "nanf"
#define NANL_OPERATOR_NAME                 "nanl"
#define NEXTAFTER_OPERATOR_NAME            "nextafter"
#define NEXTAFTERF_OPERATOR_NAME           "nextafterf"
#define NEXTAFTERL_OPERATOR_NAME           "nextafterl"
#define NEXTTOWARD_OPERATOR_NAME           "nexttoward"
#define NEXTTOWARDF_OPERATOR_NAME          "nexttowardf"
#define NEXTTOWARDL_OPERATOR_NAME          "nexttowardl"
#define FDIM_OPERATOR_NAME                 "fdim"
#define FDIMF_OPERATOR_NAME                "fdimf"
#define FDIML_OPERATOR_NAME                "fdiml"
#define FMAX_OPERATOR_NAME                 "fmax"
#define FMAXF_OPERATOR_NAME                "fmaxf"
#define FMAXL_OPERATOR_NAME                "fmaxl"
#define FMIN_OPERATOR_NAME                 "fmin"
#define FMINF_OPERATOR_NAME                "fminf"
#define FMINL_OPERATOR_NAME                "fminl"
#define FMA_OPERATOR_NAME                  "fma"
#define FMAF_OPERATOR_NAME                 "fmaf"
#define FMAL_OPERATOR_NAME                 "fmal"
#define ISGREATER_OPERATOR_NAME            "isgreater"
#define ISGREATEREQUAL_OPERATOR_NAME       "isgreaterequal"
#define ISLESS_OPERATOR_NAME               "isless"
#define ISLESSEQUAL_OPERATOR_NAME          "islessequal"
#define ISLESSGREATER_OPERATOR_NAME        "islessgreater"
#define ISUNORDERED_OPERATOR_NAME          "isunordered"


/* signal.h */
#define SIGNAL_OPERATOR_NAME               "signal"
#define RAISE_FUNCTION_NAME                "raise"


/* vararg stuff. va_args is a special construct because its second
   parameter is a type, not an expression. */
#define BUILTIN_VA_END                 "__builtin_va_end"
#define BUILTIN_VA_START               "__builtin_va_start"
#define BUILTIN_VA_COPY                "__builtin_va_copy"


/*io functions: C library and system IO. Amira Mensi*/

/* unistd.h */

#define LSEEK_FUNCTION_NAME             "lseek"
#define LSEEK64_FUNCTION_NAME           "lseekg4"
#define C_CLOSE_FUNCTION_NAME           "close"
#define C_READ_FUNCTION_NAME            "read"
#define C_WRITE_FUNCTION_NAME           "write"
#define PREAD_FUNCTION_NAME             "pread"
#define PWRITE_FUNCTION_NAME            "pwrite"
#define PREAD64_FUNCTION_NAME           "pread64"
#define PIPE_FUNCTION_NAME              "pipe"
#define PIPE2_FUNCTION_NAME             "pipe2"
#define SLEEP_FUNCTION_NAME             "sleep"
#define UALARM_FUNCTION_NAME            "ualarm"
#define USLEEP_FUNCTION_NAME            "usleep"
#define C_PAUSE_FUNCTION_NAME           "pause"
#define CHOWN_FUNCTION_NAME             "chown"
#define FCHOWN_FUNCTION_NAME            "fchown"
#define LCHOWN_FUNCTION_NAME            "lchown"
#define FCHOWNAT_FUNCTION_NAME          "fchownat"
#define CHDIR_FUNCTION_NAME             "chdir"
#define FCHDIR_FUNCTION_NAME            "fchdir"
#define GETCWD_FUNCTION_NAME            "getcwd"
#define GET_CURRENT_DIR_NAME_FUNCTION_NAME "get_current_dir_name"
#define GETWD_FUNCTION_NAME             "getwd"
#define DUP_FUNCTION_NAME               "dup"
#define DUP2_FUNCTION_NAME              "dup2"
#define DUP3_FUNCTION_NAME              "dup3"
#define EXECVE_FUNCTION_NAME            "execve"
#define FEXECVE_FUNCTION_NAME           "fexecve"
#define EXECV_FUNCTION_NAME             "execv"
#define EXECLE_FUNCTION_NAME            "execle"
#define EXECL_FUNCTION_NAME             "execl"
#define EXECVP_FUNCTION_NAME            "execvp"
#define EXECLP_FUNCTION_NAME            "execlp"
#define EXECVPE_FUNCTION_NAME           "execvpe"
#define NICE_FUNCTION_NAME              "nice"
#define _EXIT_FUNCTION_NAME             "_exit"
#define PATHCONF_FUNCTION_NAME          "pathconf"
#define FPATHCONF_FUNCTION_NAME         "fpathconf"
#define SYSCONF_FUNCTION_NAME           "sysconf"
#define CONFSTR_FUNCTION_NAME           "constrf"
#define GETPID_FUNCTION_NAME            "getpid"
#define GETPPID_FUNCTION_NAME           "getppid"
#define GETPGRP_FUNCTION_NAME           "getpgrp"
#define __GETPGID_FUNCTION_NAME         "__getpgid"
#define GETPGID_FUNCTION_NAME           "getpgid"
#define SETPGID_FUNCTION_NAME           "setpgid"
#define SETPGRP_FUNCTION_NAME           "setpgrp"
#define SETSID_FUNCTION_NAME            "setsid"
#define GETSID_FUNCTION_NAME            "getsid"
#define GETUID_FUNCTION_NAME            "getuid"
#define GETEUID_FUNCTION_NAME           "geteuid"
#define GETGID_FUNCTION_NAME            "getgid"
#define GETEGID_FUNCTION_NAME           "getegid"
#define GETPGROUPS_FUNCTION_NAME        "getgroups"
#define GROUP_MEMBER_FUNCTION_NAME      "group_member"
#define SETUID_FUNCTION_NAME            "setuid"
#define SETREUID_FUNCTION_NAME          "setreuid"
#define SETEUID_FUNCTION_NAME           "seteuid"
#define SETGID_FUNCTION_NAME            "setgid"
#define SETREGID_FUNCTION_NAME          "setregid"
#define SETEGID_FUNCTION_NAME           "setegid"
#define GETRESUID_FUNCTION_NAME         "getresuid"
#define GETRESGID_FUNCTION_NAME         "getresgid"
#define SETRESUID_FUNCTION_NAME         "setresuid"
#define SETRESGID_FUNCTION_NAME         "setresgid"
#define FORK_FUNCTION_NAME              "fork"
#define VFORK_FUNCTION_NAME             "vfork"
#define TTYNAME_FUNCTION_NAME           "ttyname"
#define TTYNAME_R_FUNCTION_NAME         "ttyname_r"
#define ISATTY_FUNCTION_NAME            "isatty"
#define TTYSLOT_FUNCTION_NAME           "ttyslot"
#define LINK_FUNCTION_NAME              "link"
#define LINKAT_FUNCTION_NAME            "linkat"
#define SYMLINK_FUNCTION_NAME           "symlink"
#define READLINK_FUNCTION_NAME          "readlink"
#define SYMLINKAT_FUNCTION_NAME         "symlinkar"
#define READLINKAT_FUNCTION_NAME        "readlinkat"
#define UNLINK_FUNCTION_NAME            "unlink"
#define UNLINKAT_FUNCTION_NAME          "unlinkat"
#define RMDIR_FUNCTION_NAME             "rmdir"
#define TCGETPGRP_FUNCTION_NAME         "tcgetpgrp"
#define TCSETPGRP_FUNCTION_NAME         "tcsetpgrp"
#define GETLOGIN_FUNCTION_NAME          "getlogin"
#define GETLOGIN_R_FUNCTION_NAME        "getlogin_r"
#define SETLOGIN_FUNCTION_NAME          "setlogin"
#define GETHOSTNAME_FUNCTION_NAME       "gethostname"
#define SETHOSTNAME_FUNCTION_NAME       "sethostname"
#define SETHOSTID_FUNCTION_NAME         "sethostid"
#define GETDOMAINNAME_FUNCTION_NAME     "getdomainname"
#define SETDOMAINNAME_FUNCTION_NAME     "setdomainname"
#define VHANGUP_FUNCTION_NAME           "vhangup"
#define REVOKE_FUNCTION_NAME            "revoke"
#define PROFIL_FUNCTION_NAME            "profil"
#define ACCT_FUNCTION_NAME              "acct"
#define GETUSERSHELL_FUNCTION_NAME      "getusershell"
#define ENDUSERSHELL_FUNCTION_NAME      "endusershell"
#define SETUSERSHELL_FUNCTION_NAME      "setusershell"
#define DAEMON_FUNCTION_NAME            "daemon"
#define CHROOT_FUNCTION_NAME            "chroot"
#define GETPASS_FUNCTION_NAME           "getpass"
#define FSYNC_FUNCTION_NAME             "fsync"
#define SYNCFS_FUNCTION_NAME            "syncfs"
#define GETHOSTID_FUNCTION_NAME         "gethostid"
#define GETPAGESIZE_FUNCTION_NAME       "getpagesize"
#define GETDTABLESIZE_FUNCTION_NAME     "getdtablesize"
#define TRUNCATE_FUNCTION_NAME          "truncate"
#define TRUNCATE64_FUNCTION_NAME        "truncate64"
#define FTRUNCATE_FUNCTION_NAME         "ftruncate"
#define FTRUNCATE64_FUNCTION_NAME       "ftruncate64"
#define BRK_FUNCTION_NAME               "brk"
#define SBRK_FUNCTION_NAME              "sbrk"
#define SYSCALL_FUNCTION_NAME           "syscall"
#define LOCKF_FUNCTION_NAME             "lockf"
#define LOCKF64_FUNCTION_NAME           "lockf64"
#define FDATASYNC_FUNCTION_NAME         "fdatasync"
#define CRYPT_FUNCTION_NAME             "crypt"
#define ENCRYPT_FUNCTION_NAME           "encrypt"
#define SWAB_FUNCTION_NAME              "swab"
#define CTERMID_FUNCTION_NAME           "ctermid"
/* Not found in unistd.h. Requires sys/types.h sys/stat.h and fcntl.h.
 * The man -S 2 page indicates it is overloaded with two or three
 * arguments.
 */
#define C_OPEN_FUNCTION_NAME            "open"

/*#include<stdio.h> */

#define PRINTF_FUNCTION_NAME            "printf"
#define FPRINTF_FUNCTION_NAME           "fprintf"
#define SCANF_FUNCTION_NAME             "scanf"
#define ISOC99_SCANF_FUNCTION_NAME      "__isoc99_scanf"
#define ISOC99_SCANF_USER_FUNCTION_NAME "scanf"
#define FSCANF_FUNCTION_NAME            "fscanf"
#define ISOC99_FSCANF_FUNCTION_NAME     "__isoc99_fscanf"
#define ISOC99_FSCANF_USER_FUNCTION_NAME "fscanf"
#define PUTS_FUNCTION_NAME              "puts"
#define GETS_FUNCTION_NAME              "gets"
#define FPUTS_FUNCTION_NAME             "fputs"
#define FGETS_FUNCTION_NAME             "fgets"
#define FPUTC_FUNCTION_NAME             "fputc"
#define FGETC_FUNCTION_NAME             "fgetc"
#define FOPEN_FUNCTION_NAME             "fopen"
#define FDOPEN_FUNCTION_NAME            "fdopen"
#define FREOPEN_FUNCTION_NAME           "freopen"
#define FCLOSE_FUNCTION_NAME            "fclose"
#define SNPRINTF_FUNCTION_NAME          "snprintf"
#define SSCANF_FUNCTION_NAME            "sscanf"
#define ISOC99_SSCANF_FUNCTION_NAME     "__isoc99_sscanf"
#define ISOC99_SSCANF_USER_FUNCTION_NAME "sscanf"
#define VFPRINTF_FUNCTION_NAME          "vfprintf"
#define VFSCANF_FUNCTION_NAME           "vfscanf"
#define ISOC99_VFSCANF_FUNCTION_NAME    "__isoc99_vfscanf"
#define ISOC99_VFSCANF_USER_FUNCTION_NAME "vfscanf"
#define VPRINTF_FUNCTION_NAME           "vprintf"
#define VSCANF_FUNCTION_NAME            "vscanf"
#define ISOC99_VSCANF_FUNCTION_NAME    "__isoc99_vscanf"
#define ISOC99_VSCANF_USER_FUNCTION_NAME "vscanf"
#define VSSCANF_FUNCTION_NAME           "vsscanf"
#define ISOC99_VSSCANF_FUNCTION_NAME     "__isoc99_vsscanf"
#define ISOC99_VSSCANF_USER_FUNCTION_NAME "vsscanf"
#define VSNPRINTF_FUNCTION_NAME         "vsnprintf"
#define VSPRINTF_FUNCTION_NAME          "vsprintf"
#define SPRINTF_FUNCTION_NAME           "sprintf"
#define GETC_FUNCTION_NAME              "getc"
#define _IO_GETC_FUNCTION_NAME          "_IO_getc" /* libio.h */
#define GETCHAR_FUNCTION_NAME           "getchar"
#define PUTC_FUNCTION_NAME              "putc"
#define _IO_PUTC_FUNCTION_NAME          "_IO_putc" /* libio.h */
#define PUTCHAR_FUNCTION_NAME           "putchar"
#define UNGETC_FUNCTION_NAME            "ungetc"
#define FREAD_FUNCTION_NAME             "fread"
#define FWRITE_FUNCTION_NAME            "fwrite"
#define FGETPOS_FUNCTION_NAME           "fgetpos"
#define FSEEK_FUNCTION_NAME             "fseek"
#define FSETPOS_FUNCTION_NAME           "fsetpos"
#define FTELL_FUNCTION_NAME             "ftell"
#define C_REWIND_FUNCTION_NAME          "rewind"
#define CLEARERR_FUNCTION_NAME          "clearerr"
#define FEOF_FUNCTION_NAME              "feof"
#define FERROR_FUNCTION_NAME            "ferror"
#define FILENO_FUNCTION_NAME            "fileno"
#define PERROR_FUNCTION_NAME            "perror"
// #define WRITE_SYSTEM_FUNCTION_NAME      "write"
// #define READ_SYSTEM_FUNCTION_NAME       "read"
#define REMOVE_FUNCTION_NAME            "remove"
#define RENAME_FUNCTION_NAME            "rename"
#define TMPFILE_FUNCTION_NAME           "tmpfile"
#define TMPNAM_FUNCTION_NAME            "tmpnam"
#define FFLUSH_FUNCTION_NAME            "fflush"
#define FREOPEN_FUNCTION_NAME           "freopen"
#define SETBUF_FUNCTION_NAME            "setbuf"
#define SETVBUF_FUNCTION_NAME           "setvbuf"
#define __FILBUF_FUNCTION_NAME          "__filbuf"
#define __FILSBUF_FUNCTION_NAME         "__flsbuf"
#define SETBUFFER_FUNCTION_NAME         "setbuffer"
#define SETLINEBUF_FUNCTION_NAME        "setlinebuf"
#define FDOPEN_FUNCTION_NAME            "fdopen"
#define CTERMID_FUNCTION_NAME           "ctermid"
#define FILENO_FUNCTION_NAME            "fileno"
#define POPEN_FUNCTION_NAME             "popen"
#define CUSERID_FUNCTION_NAME           "cuserid"
#define TEMPNAM_FUNCTION_NAME           "tempnam"
#define GETW_FUNCTION_NAME              "getw"
#define PUTW_FUNCTION_NAME              "putw"
#define PCLOSE_FUNCTION_NAME            "pclose"
#define FSEEKO_FUNCTION_NAME            "fseeko"
#define FTELLO_FUNCTION_NAME            "ftello"
#define FOPEN64_FUNCTION_NAME           "fopen64"
#define FREOPEN64_FUNCTION_NAME         "freopen64"
#define TMPFILE64_FUNCTION_NAME         "tmpfile64"
#define FGETPOS64_FUNCTION_NAME         "fgetpos64"
#define FSETPOS64_FUNCTION_NAME         "fsetpos64"
#define FSEEKO64_FUNCTION_NAME          "fseeko64"
#define FTELLO64_FUNCTION_NAME          "ftello64"
#define EXITHANDLE_FUNCTION_NAME        "exithandle"


/* random functions of <stdlib.h> */


#define ATOF_FUNCTION_NAME              "atof"
#define ATOI_FUNCTION_NAME              "atoi"
#define ATOL_FUNCTION_NAME              "atol"
#define ATOLL_FUNCTION_NAME             "atoll"
#define STRTOD_FUNCTION_NAME            "strtod"
#define STRTOF_FUNCTION_NAME            "strtof"
#define STRTOLD_FUNCTION_NAME           "strtold"
#define STRTOL_FUNCTION_NAME            "strtol"
#define STRTOLL_FUNCTION_NAME           "strtoll"
#define STRTOUL_FUNCTION_NAME           "strtoul"
#define STRTOULL_FUNCTION_NAME          "strtoull"
#define RAND_FUNCTION_NAME              "rand"
#define SRAND_FUNCTION_NAME             "srand"
#define CALLOC_FUNCTION_NAME            "calloc"
#define FREE_FUNCTION_NAME              "free"
#define MALLOC_FUNCTION_NAME            "malloc"
#define REALLOC_FUNCTION_NAME           "realloc"
#define ALLOCA_FUNCTION_NAME            "alloca"
#define ABORT_FUNCTION_NAME             "abort"
#define ATEXIT_FUNCTION_NAME            "atexit"
#define EXIT_FUNCTION_NAME              "exit"
#define _EXIT_FUNCTION_NAME             "_exit"
#define GETENV_FUNCTION_NAME            "getenv"
#define SYSTEM_FUNCTION_NAME            "system"
#define BSEARCH_FUNCTION_NAME           "bsearch"
#define QSORT_FUNCTION_NAME             "qsort"
#define C_ABS_FUNCTION_NAME             "abs"
#define LABS_FUNCTION_NAME              "labs"
#define LLABS_FUNCTION_NAME             "llabs"
#define DIV_FUNCTION_NAME               "div"
#define LDIV_FUNCTION_NAME              "ldiv"
#define LLDIV_FUNCTION_NAME             "lldiv"
#define MBLEN_FUNCTION_NAME             "mblen"
#define MBTOWC_FUNCTION_NAME            "mbtowc"
#define WCTOMB_FUNCTION_NAME            "wctomb"
#define MBSTOWCS_FUNCTION_NAME          "mbstowcs"
#define WCSTOMBS_FUNCTION_NAME          "wcstombs"



/* include <string.h> */

#define MEMCPY_FUNCTION_NAME            "memcpy"
#define MEMMOVE_FUNCTION_NAME           "memmove"
#define STRCPY_FUNCTION_NAME            "strcpy"
#define STRDUP_FUNCTION_NAME            "strdup"
#define STRNCPY_FUNCTION_NAME           "strncpy"
#define STRCAT_FUNCTION_NAME            "strcat"
#define STRNCAT_FUNCTION_NAME           "strncat"
#define MEMCMP_FUNCTION_NAME            "memcmp"
#define STRCMP_FUNCTION_NAME            "strcmp"
#define STRCOLL_FUNCTION_NAME           "strcoll"
#define STRNCMP_FUNCTION_NAME           "strncmp"
#define STRXFRM_FUNCTION_NAME           "strxfrm"
#define MEMCHR_FUNCTION_NAME            "memchr"
#define STRCHR_FUNCTION_NAME            "strchr"
#define STRCSPN_FUNCTION_NAME           "strcspn"
#define STRPBRK_FUNCTION_NAME           "strbprk"
#define STRRCHR_FUNCTION_NAME           "strrchr"
#define STRSPN_FUNCTION_NAME            "strspn"
#define STRSTR_FUNCTION_NAME            "strstr"
#define STRTOK_FUNCTION_NAME            "strtok"
#define MEMSET_FUNCTION_NAME            "memset"
//#define FOPEN_FUNCTION_NAME           "fopen"
#define STRERROR_FUNCTION_NAME          "strerror"
#define STRERROR_R_FUNCTION_NAME        "strerror_r"
#define STRLEN_FUNCTION_NAME            "strlen"


/*#include<time.h> */
#define TIME_FUNCTION_NAME              "time"
#define LOCALTIME_FUNCTION_NAME         "localtime"
#define DIFFTIME_FUNCTION_NAME          "difftime"
#define NANOSLEEP_FUNCTION_NAME         "nanosleep"


/* #include <wchar.h> */
#define FWPRINTF_FUNCTION_NAME          "fwprintf"
#define FWSCANF_FUNCTION_NAME           "fwscanf"
#define SWPRINTF_FUNCTION_NAME          "swprintf"
#define SWSCANF_FUNCTION_NAME           "swscanf"
#define VFWPRINTF_FUNCTION_NAME         "vfwprintf"
#define VFWSCANF_FUNCTION_NAME          "vfwscanf"
#define VSWPRINTF_FUNCTION_NAME         "vswprintf"
#define VSWSCANF_FUNCTION_NAME          "vswscanf"
#define VWPRINTF_FUNCTION_NAME          "vwprintf"
#define VWSCANF_FUNCTION_NAME           "vwscanf"
#define WPRINTF_FUNCTION_NAME           "wprintf"
#define WSCANF_FUNCTION_NAME            "wscanf"
#define FGETWC_FUNCTION_NAME            "fgetwc"
#define FGETWS_FUNCTION_NAME            "fgetws"
#define FPUTWC_FUNCTION_NAME            "fputwc"
#define FPUTWS_FUNCTION_NAME            "fputws"
#define FWIDE_FUNCTION_NAME             "fwide"
#define GETWC_FUNCTION_NAME             "getwc"
#define GETWCHAR_FUNCTION_NAME          "getwchar"
#define PUTWC_FUNCTION_NAME             "putwc"
#define PUTWCHAR_FUNCTION_NAME          "putwchar"
#define UNGETWC_FUNCTION_NAME           "ungetwc"
#define WCSTOD_FUNCTION_NAME            "wcstod"
#define WCSTOF_FUNCTION_NAME            "wcstof"
#define WCSTOLD_FUNCTION_NAME           "wcstold"
#define WCSTOL_FUNCTION_NAME            "wcstol"
#define WCSTOLL_FUNCTION_NAME           "wcstoll"
#define WCSTOUL_FUNCTION_NAME           "wcstoul"
#define WCSTOULL_FUNCTION_NAME          "wcstoull"
#define WCSCPY_FUNCTION_NAME            "wcscpy"
#define WCSNCPY_FUNCTION_NAME           "wcsncpy"
#define WMEMCPY_FUNCTION_NAME           "wmemcpy"
#define WMEMMOVE_FUNCTION_NAME          "wmemmove"
#define WCSCAT_FUNCTION_NAME            "wcscat"
#define WCSNCAT_FUNCTION_NAME           "wcsncat"
#define WCSCMP_FUNCTION_NAME            "wcscmp"
#define WCSCOLL_FUNCTION_NAME           "wcscoll"
#define WCSNCMP_FUNCTION_NAME           "wcsncmp"
#define WCSXFRM_FUNCTION_NAME           "wcsxfrm"
#define WMEMCMP_FUNCTION_NAME           "wmemcmp"
#define WCSCHR_FUNCTION_NAME            "wcschr"
#define WCSCSPN_FUNCTION_NAME           "wcscspn"
#define WCSPBRK_FUNCTION_NAME           "wcspbrk"
#define WCSRCHR_FUNCTION_NAME           "wcsrchr"
#define WCSSPN_FUNCTION_NAME            "wcsspn"
#define WCSSTR_FUNCTION_NAME            "wcsstr"
#define WCSTOK_FUNCTION_NAME            "wcstok"
#define WMEMCHR_FUNCTION_NAME           "wmemchr"
#define WCSLEN_FUNCTION_NAME            "wcslen"
#define WMEMSET_FUNCTION_NAME           "wmemset"
#define WCSFTIME_FUNCTION_NAME          "wcsftime"
#define BTOWC_FUNCTION_NAME             "btowc"
#define WCTOB_FUNCTION_NAME             "wctob"
#define MBSINIT_FUNCTION_NAME           "mbsinit"
#define MBRLEN_FUNCTION_NAME            "mbrlen"
#define MBRTOWC_FUNCTION_NAME           "mbrtowc"
#define WCRTOMB_FUNCTION_NAME           "wcrtomb"
#define MBSRTOWCS_FUNCTION_NAME         "mbsrtowcs"
#define WCSRTOMBS_FUNCTION_NAME         "wcsrtombs"


/* #include <wctype.h> */

#define ISWALNUM_OPERATOR_NAME           "iswalnum"
#define ISWALPHA_OPERATOR_NAME           "iswalpha"
#define ISWBLANK_OPERATOR_NAME           "iswblank"
#define ISWCNTRL_OPERATOR_NAME           "iswcntrl"
#define ISWDIGIT_OPERATOR_NAME           "iswdigit"
#define ISWGRAPH_OPERATOR_NAME           "iswgraph"
#define ISWLOWER_OPERATOR_NAME           "iswlower"
#define ISWPRINT_OPERATOR_NAME           "iswprint"
#define ISWPUNCT_OPERATOR_NAME           "iswpunct"
#define ISWSPACE_OPERATOR_NAME           "iswspace"
#define ISWUPPER_OPERATOR_NAME           "iswupper"
#define ISWXDIGIT_OPERATOR_NAME          "iswxdigit"
#define ISWCTYPE_OPERATOR_NAME           "iswctype"
#define WCTYPE_OPERATOR_NAME             "wctype"
#define TOWLOWER_OPERATOR_NAME           "towlower"
#define TOWUPPER_OPERATOR_NAME           "towupper"
#define TOWCTRANS_OPERATOR_NAME          "towctrans"
#define WCTRANS_OPERATOR_NAME            "wctrans"


/* #include <fcntl.h>*/

#define FCNTL_FUNCTION_NAME             "fcntl"
#define CREAT_FUNCTION_NAME             "creat"
#define DIRECTIO_FUNCTION_NAME          "directio"
#define OPEN64_FUNCTION_NAME            "open64"
#define CREAT64_FUNCTION_NAME           "creat64"

/* fcntl is declared with fcntl.h */
#define FSYNC_FUNCTION_NAME             "fsync"
#define FDATASYNC_FUNCTION_NAME         "fdatasync"
#define IOCTL_FUNCTION_NAME             "ioctl"   // sys/ioctl.h
#define SELECT_FUNCTION_NAME            "select"  // sys/select.h
#define PSELECT_FUNCTION_NAME           "pselect" // sys/select.h
#define STAT_FUNCTION_NAME              "stat"    // sys/stat.h
#define FSTAT_FUNCTION_NAME             "fstat"   // sys/stat.h
#define LSTAT_FUNCTION_NAME             "lstat"   // sys/stat.h





#define J0_OPERATOR_NAME "j0"
#define J1_OPERATOR_NAME "j1"
#define JN_OPERATOR_NAME "jn"
#define Y0_OPERATOR_NAME "y0"
#define Y1_OPERATOR_NAME "y1"
#define YN_OPERATOR_NAME "yn"

#define NEXTAFTER_OPERATOR_NAME "nextafter"
#define REMAINDER_OPERATOR_NAME "remainder"


#define MATHERR_OPERATOR_NAME "matherr"
#define SIGNIFICAND_OPERATOR_NAME "significand"


#define MODFF_OPERATOR_NAME "modff"
#define SIGFPE_OPERATOR_NAME "sigfpe"
#define SINGLE_TO_DECIMAL_OPERATOR_NAME "single_to_decimal"
#define DOUBLE_TO_DECIMAL_OPERATOR_NAME "double_to_decimal"
#define EXTENDED_TO_DECIMAL_OPERATOR_NAME "extended_to_decimal"
#define QUADRUPLE_TO_DECIMAL_OPERATOR_NAME "quadruple_to_decimal"
#define DECIMAL_TO_SINGLE_OPERATOR_NAME "decimal_to_single"
#define DECIMAL_TO_DOUBLE_OPERATOR_NAME "decimal_to_double"
#define DECIMAL_TO_EXTENDED_OPERATOR_NAME "decimal_to_extended"
#define DECIMAL_TO_QUADRUPLE_OPERATOR_NAME "decimal_to_quadruple"
#define STRING_TO_DECIMAL_OPERATOR_NAME "string_to_decimal"
#define FUNC_TO_DECIMAL_OPERATOR_NAME "func_to_decimal"
#define FILE_TO_DECIMAL_OPERATOR_NAME "file_to_decimal"
#define SECONVERT_OPERATOR_NAME "seconvert"
#define SFCONVERT_OPERATOR_NAME "sfconvert"
#define SGCONVERT_OPERATOR_NAME "sgconvert"
#define ECONVERT_OPERATOR_NAME "econvert"
#define FCONVERT_OPERATOR_NAME "fconvert"
#define GCONVERT_OPERATOR_NAME "gconvert"
#define QECONVERT_OPERATOR_NAME "qeconvert"
#define QFCONVERT_OPERATOR_NAME "qfconvert"
#define QGCONVERT_OPERATOR_NAME "qgconvert"

#define CLOCK_FUNCTION_NAME            "clock"
#define SECOND_FUNCTION_NAME            "SECOND" //gfortran extension
#define CLOCK_GETTIME_FUNCTION_NAME    "clock_gettime"
#define GETTIMEOFDAY_FUNCTION_NAME    "gettimeofday"

/* netdb.h */
#define __H_ERRNO_LOCATION_OPERATOR_NAME "__h_erno_location"


/* These operators are used within the optimize transformation in
   order to manipulate operators such as n-ary add and multiply or
   multiply-add operators ( JZ - sept 98)
 */
#define EOLE_FMA_OPERATOR_NAME          "EOLE-FMA-OP"
#define EOLE_FMS_OPERATOR_NAME          "EOLE-FMS-OP"
#define EOLE_PROD_OPERATOR_NAME         "EOLE-PROD-OP"
#define EOLE_SUM_OPERATOR_NAME          "EOLE-SUM-OP"

/* Integer Multiply Add and Sub, FC 27/10/2005 for FI
 */
#define IMA_OPERATOR_NAME                               "IMA-OP"
#define IMS_OPERATOR_NAME                               "IMS-OP"

/*****************************************************************************************/

/* moved from ricedg-local.h */
#define LOOP_COUNTER_MODULE_NAME        "LOOP-COUNTER"
#define DI_VAR_MODULE_NAME              "DI-VAR"

/* special pips intrinsics with global effects */
#define PIPS_MEMORY_BARRIER_OPERATOR_NAME "__pips_memory_barrier"
#define PIPS_IO_BARRIER_OPERATOR_NAME "__pips_io_barrier"

/* macros */

/* FI: entity_local_name() should be sufficient for these comparisons */
#define entity_an_operator_p(e,name) \
  (same_string_p(global_name_to_user_name(entity_name(e)), name##_OPERATOR_NAME))
#define entity_a_function_p(e,name) \
  (same_string_p(global_name_to_user_name(entity_name(e)), name##_FUNCTION_NAME))
#define entity_a_special_entity_p(e,name) \
  (same_string_p(global_name_to_user_name(entity_name(e)), name))

#define ENTITY_CONVERSION_P(e,name) \
  (strcmp(entity_local_name(e), name##_GENERIC_CONVERSION_NAME)==0)
#define ENTITY_CONVERSION_CMPLX_P(e) ENTITY_CONVERSION_P(e, CMPLX)
#define ENTITY_CONVERSION_DCMPLX_P(e) ENTITY_CONVERSION_P(e, DCMPLX)

#define ENTITY_CONTINUE_P(e) entity_a_function_p(e, CONTINUE)
#define ENTITY_STOP_P(e) entity_a_function_p(e, STOP)
#define ENTITY_RETURN_P(e) entity_a_function_p(e, RETURN)
#define ENTITY_C_RETURN_P(e) entity_a_function_p(e, C_RETURN)

#define ENTITY_ASSIGN_P(e) entity_an_operator_p(e, ASSIGN)
#define ENTITY_POST_INCREMENT_P(e) entity_an_operator_p(e, POST_INCREMENT)
#define ENTITY_POST_DECREMENT_P(e) entity_an_operator_p(e, POST_DECREMENT)
#define ENTITY_PRE_INCREMENT_P(e) entity_an_operator_p(e, PRE_INCREMENT)
#define ENTITY_PRE_DECREMENT_P(e) entity_an_operator_p(e, PRE_DECREMENT)
#define ENTITY_MULTIPLY_UPDATE_P(e) entity_an_operator_p(e, MULTIPLY_UPDATE)
#define ENTITY_DIVIDE_UPDATE_P(e) entity_an_operator_p(e, DIVIDE_UPDATE)
#define ENTITY_MODULO_UPDATE_P(e) entity_an_operator_p(e, MODULO_UPDATE)
#define ENTITY_PLUS_UPDATE_P(e) entity_an_operator_p(e, PLUS_UPDATE)
#define ENTITY_MINUS_UPDATE_P(e) entity_an_operator_p(e, MINUS_UPDATE)
#define ENTITY_LEFT_SHIFT_UPDATE_P(e) entity_an_operator_p(e, LEFT_SHIFT_UPDATE)
#define ENTITY_RIGHT_SHIFT_UPDATE_P(e) entity_an_operator_p(e, RIGHT_SHIFT_UPDATE)
#define ENTITY_BITWISE_AND_UPDATE_P(e) entity_an_operator_p(e, BITWISE_AND_UPDATE)
#define ENTITY_BITWISE_XOR_UPDATE_P(e) entity_an_operator_p(e, BITWISE_XOR_UPDATE)
#define ENTITY_BITWISE_OR_UPDATE_P(e) entity_an_operator_p(e, BITWISE_OR_UPDATE)
#define ENTITY_COMMA_P(e) entity_an_operator_p(e, COMMA)
#define ENTITY_ADDRESS_OF_P(e) entity_an_operator_p(e, ADDRESS_OF)
#define ENTITY_CONDITIONAL_P(e) entity_an_operator_p(e, CONDITIONAL)

#define ENTITY_PLUS_P(e) entity_an_operator_p(e, PLUS)
#define ENTITY_PLUS_C_P(e) entity_an_operator_p(e, PLUS_C)
#define ENTITY_MINUS_P(e) entity_an_operator_p(e, MINUS)
#define ENTITY_MINUS_C_P(e) entity_an_operator_p(e, MINUS_C)
#define ENTITY_UNARY_MINUS_P(e) entity_an_operator_p(e, UNARY_MINUS)
#define ENTITY_UNARY_PLUS_P(e) entity_an_operator_p(e, UNARY_PLUS)
#define ENTITY_MULTIPLY_P(e) entity_an_operator_p(e, MULTIPLY)
#define ENTITY_MODULO_P(e) entity_an_operator_p(e, MODULO)
#define ENTITY_C_MODULO_P(e) entity_an_operator_p(e, C_MODULO)
#define ENTITY_POWER_P(e) entity_an_operator_p(e, POWER)
#define ENTITY_DIVIDE_P(e) entity_an_operator_p(e, DIVIDE)

#define ENTITY_MIN_P(e) entity_an_operator_p(e, MIN)
#define ENTITY_C_MIN_P(e) entity_an_operator_p(e,PIPS_C_MIN)
#define ENTITY_MAX_P(e) entity_an_operator_p(e, MAX)
#define ENTITY_C_MAX_P(e) entity_an_operator_p(e,PIPS_C_MAX)
#define ENTITY_MIN0_P(e) entity_an_operator_p(e, MIN0)
#define ENTITY_MAX0_P(e) entity_an_operator_p(e, MAX0)
#define ENTITY_AMIN1_P(e) entity_an_operator_p(e, AMIN1)
#define ENTITY_AMAX1_P(e) entity_an_operator_p(e, AMAX1)
#define ENTITY_DMIN1_P(e) entity_an_operator_p(e, DMIN1)
#define ENTITY_DMAX1_P(e) entity_an_operator_p(e, DMAX1)
#define ENTITY_MIN_OR_MAX_P(e) (ENTITY_MIN_P(e) || ENTITY_MAX_P(e) )

#define ENTITY_ABS_P(e) entity_an_operator_p(e, ABS)
#define ENTITY_IABS_P(e) entity_an_operator_p(e, IABS)
#define ENTITY_DABS_P(e) entity_an_operator_p(e, DABS)
#define ENTITY_CABS_P(e) entity_an_operator_p(e, CABS)
//abs in stdlib.h C89
#define ENTITY_C_ABS_P(e) entity_a_function_p(e, C_ABS)
#define ENTITY_LABS_P(e) entity_a_function_p(e, LABS)
#define ENTITY_LLABS_P(e) entity_a_function_p(e, LLABS)     //C99
//abs in inttypes.h C99
#define ENTITY_IMAXABS_P(e) entity_a_function_p(e, IMAXABS)
//abs in math.h C99
#define ENTITY_FABS_P(e) entity_an_operator_p(e, FABS)
#define ENTITY_FABSF_P(e) entity_an_operator_p(e, FABSF)
#define ENTITY_FABSL_P(e) entity_an_operator_p(e, FABSL)
//abs in complex.h C99
#define ENTITY_C_CABS_P(e) entity_an_operator_p(e, C_CABS)
#define ENTITY_CABSF_P(e) entity_an_operator_p(e, CABSF)
#define ENTITY_CABSL_P(e) entity_an_operator_p(e, CABSL)

#define ENTITY_AND_P(e) (entity_an_operator_p(e, AND) || entity_an_operator_p(e, C_AND))
#define ENTITY_OR_P(e) (entity_an_operator_p(e, OR) || entity_an_operator_p(e, C_OR))
#define ENTITY_BITWISE_AND_P(e) (entity_an_operator_p(e, BITWISE_AND))
#define ENTITY_BITWISE_OR_P(e) (entity_an_operator_p(e, BITWISE_OR))
#define ENTITY_BITWISE_XOR_P(e) (entity_an_operator_p(e, BITWISE_XOR))
#define ENTITY_NOT_P(e) (entity_an_operator_p(e, NOT) || entity_an_operator_p(e, C_NOT))
// NON_EQUIV is in fact a logical operator - to simplify semantics
#define ENTITY_NON_EQUAL_P(e) (entity_an_operator_p(e, NON_EQUAL) || entity_an_operator_p(e, NON_EQUIV) || entity_an_operator_p(e, C_NON_EQUAL))
#define ENTITY_EQUIV_P(e) entity_an_operator_p(e, EQUIV)
#define ENTITY_NON_EQUIV_P(e) entity_an_operator_p(e, NON_EQUIV)
#define ENTITY_LEFT_SHIFT_P(e) entity_an_operator_p(e, LEFT_SHIFT)
#define ENTITY_RIGHT_SHIFT_P(e) entity_an_operator_p(e, RIGHT_SHIFT)

#define ENTITY_ADDRESS_OF_P(e) entity_an_operator_p(e, ADDRESS_OF)

/* Attention :
   This definition is different with the Fortran Standard where the logical
   operators are the following only: AND, OR, NOT, EQUIV, NEQUIV (NN-Mars 2000)*/

#define ENTITY_LOGICAL_OPERATOR_P(e) ( ENTITY_RELATIONAL_OPERATOR_P(e) || \
                                       ENTITY_AND_P(e) || \
                                       ENTITY_OR_P(e) || \
                                       ENTITY_NOT_P(e))

#define ENTITY_TRUE_P(e) entity_an_operator_p(e, TRUE)
#define ENTITY_FALSE_P(e) entity_an_operator_p(e, FALSE)
#define ENTITY_ONE_P(e) entity_an_operator_p(e, ONE)
#define ENTITY_ZERO_P(e) entity_an_operator_p(e, ZERO)

#define ENTITY_GREATER_OR_EQUAL_P(e) (entity_an_operator_p(e, GREATER_OR_EQUAL) || entity_an_operator_p(e, C_GREATER_OR_EQUAL))
#define ENTITY_GREATER_THAN_P(e)  (entity_an_operator_p(e, GREATER_THAN) || entity_an_operator_p(e, C_GREATER_THAN))
#define ENTITY_LESS_OR_EQUAL_P(e) (entity_an_operator_p(e, LESS_OR_EQUAL) || entity_an_operator_p(e, C_LESS_OR_EQUAL))
#define ENTITY_LESS_THAN_P(e) (entity_an_operator_p(e, LESS_THAN) || entity_an_operator_p(e, C_LESS_THAN))

// EQUIV is in fact a logical operator - to simplify semantics
#define ENTITY_EQUAL_P(e) (entity_an_operator_p(e, EQUAL) || entity_an_operator_p(e, EQUIV) || entity_an_operator_p(e, C_EQUAL))

#define ENTITY_RELATIONAL_OPERATOR_P(e) ( \
                                         ENTITY_GREATER_OR_EQUAL_P(e) || \
                                         ENTITY_GREATER_THAN_P(e) || \
                                         ENTITY_LESS_OR_EQUAL_P(e) || \
                                         ENTITY_LESS_THAN_P(e) || \
                                         ENTITY_NON_EQUAL_P(e) || \
                                         ENTITY_EQUAL_P(e) )

#define ENTITY_NAME_P(e, name)(same_string_p(entity_user_name(e),name))

/* Fortran IO Management */

#define ENTITY_WRITE_P(e)                ENTITY_NAME_P(e, "WRITE")
#define ENTITY_REWIND_P(e)               ENTITY_NAME_P(e, "REWIND")
#define ENTITY_OPEN_P(e)                 ENTITY_NAME_P(e, "OPEN")
#define ENTITY_CLOSE_P(e)                ENTITY_NAME_P(e, "CLOSE")
#define ENTITY_READ_P(e)                 ENTITY_NAME_P(e, READ_FUNCTION_NAME)
#define ENTITY_BUFFERIN_P(e)             ENTITY_NAME_P(e, "BUFFERIN")
#define ENTITY_BUFFEROUT_P(e)            ENTITY_NAME_P(e, "BUFFEROUT")
#define ENTITY_ENDFILE_P(e)              ENTITY_NAME_P(e, "ENDFILE")
#define ENTITY_IMPLIEDDO_P(e)            ENTITY_NAME_P(e, IMPLIED_DO_NAME)
#define ENTITY_IO_LIST_P(e)              ENTITY_NAME_P(e, IO_LIST_STRING_NAME)
#define ENTITY_FORMAT_P(e)               ENTITY_NAME_P(e, "FORMAT")

/* Bit manipulation functions. Amira Mensi */
#define ENTITY_ISHFT_P(e)                ENTITY_NAME_P(e, "ISHFT")
#define ENTITY_ISHFTC_P(e)               ENTITY_NAME_P(e, "ISHFTC")
#define ENTITY_IBITS_P(e)                ENTITY_NAME_P(e, "IBITS")
#define ENTITY_MVBITS_P(e)               ENTITY_NAME_P(e, "MVBITS")
#define ENTITY_BTEST_P(e)                ENTITY_NAME_P(e, "BTEST")
#define ENTITY_IBSET_P(e)                ENTITY_NAME_P(e, "IBSET")
#define ENTITY_IBCLR_P(e)                ENTITY_NAME_P(e, "IBCLR")
#define ENTITY_BIT_SIZE_P(e)             ENTITY_NAME_P(e, "BIT_SIZE")
#define ENTITY_IOR_P(e)                  ENTITY_NAME_P(e, "IOR")
#define ENTITY_IEOR_P(e)                 ENTITY_NAME_P(e, "IEOR")
#define ENTITY_IAND_P(e)                 ENTITY_NAME_P(e, "IAND")

/* OMP entity test */
#define ENTITY_OMP_IF_P(e)               ENTITY_NAME_P(e,OMP_IF_FUNCTION_NAME)
#define ENTITY_OMP_OMP_P(e)              ENTITY_NAME_P(e,OMP_OMP_FUNCTION_NAME)
#define ENTITY_OMP_FOR_P(e)              ENTITY_NAME_P(e,OMP_FOR_FUNCTION_NAME)
#define ENTITY_OMP_PRIVATE_P(e)          ENTITY_NAME_P(e,OMP_PRIVATE_FUNCTION_NAME)
#define ENTITY_OMP_PARALLEL_P(e)         ENTITY_NAME_P(e,OMP_PARALLEL_FUNCTION_NAME)
#define ENTITY_OMP_REDUCTION_P(e)        ENTITY_NAME_P(e,OMP_REDUCTION_FUNCTION_NAME)


/*io functions: C library and system io.Amira Mensi*/

/*#include<stdio.h> */

#define ENTITY_PRINTF_P(e)               ENTITY_NAME_P(e, "printf")
#define ENTITY_FPRINTF_P(e)              ENTITY_NAME_P(e, "fprintf")
#define ENTITY_SCANF_P(e)                ENTITY_NAME_P(e, "scanf")
#define ENTITY_ISOC99_SCANF_P(e)         ENTITY_NAME_P(e, ISOC99_SCANF_FUNCTION_NAME)
#define ENTITY_FSCANF_P(e)               ENTITY_NAME_P(e, "fscanf")
#define ENTITY_ISOC99_FSCANF_P(e)        ENTITY_NAME_P(e, ISOC99_FSCANF_FUNCTION_NAME)
#define ENTITY_PUTS_P(e)                 ENTITY_NAME_P(e, "puts")
#define ENTITY_GETS_P(e)                 ENTITY_NAME_P(e, "gets")
#define ENTITY_FPUTS_P(e)                ENTITY_NAME_P(e, "fputs")
#define ENTITY_FGETS_P(e)                ENTITY_NAME_P(e, "fgets")
#define ENTITY_FPUTC_P(e)                ENTITY_NAME_P(e, "fputc")
#define ENTITY_FGETC_P(e)                ENTITY_NAME_P(e, "fgetc")
#define ENTITY_FOPEN_P(e)                ENTITY_NAME_P(e, "fopen")
#define ENTITY_FDOPEN_P(e)               ENTITY_NAME_P(e, "fdopen")
#define ENTITY_FREOPEN_P(e)              ENTITY_NAME_P(e, "freopen")
#define ENTITY_FCLOSE_P(e)               ENTITY_NAME_P(e, "fclose")
#define ENTITY_SNPRINTF_P(e)             ENTITY_NAME_P(e, "snprintf")
#define ENTITY_SSCANF_P(e)               ENTITY_NAME_P(e, "sscanf")
#define ENTITY_ISOC99_SSCANF_P(e)        ENTITY_NAME_P(e, ISOC99_SSCANF_FUNCTION_NAME)
#define ENTITY_VFPRINTF_P(e)             ENTITY_NAME_P(e, "vfprintf")
#define ENTITY_VFSCANF_P(e)              ENTITY_NAME_P(e, "vfscanf")
#define ENTITY_ISOC99_VFSCANF_P(e)       ENTITY_NAME_P(e, ISOC99_VFSCANF_FUNCTION_NAME)
#define ENTITY_VPRINTF_P(e)              ENTITY_NAME_P(e, "vprintf")
#define ENTITY_VSCANF_P(e)               ENTITY_NAME_P(e, "vscanf")
#define ENTITY_ISOC99_VSCANF_P(e)        ENTITY_NAME_P(e, ISOC99_VSCANF_FUNCTION_NAME)
#define ENTITY_VSNPRINTF_P(e)            ENTITY_NAME_P(e, "vsnprintf")
#define ENTITY_VSPRINTF_P(e)             ENTITY_NAME_P(e, "vsprintf")
#define ENTITY_SPRINTF_P(e)              ENTITY_NAME_P(e, "sprintf")
#define ENTITY_VSSCANF_P(e)              ENTITY_NAME_P(e, "vsscanf")
#define ENTITY_ISOC99_VSSCANF_P(e)       ENTITY_NAME_P(e, ISOC99_VSSCANF_FUNCTION_NAME)
#define ENTITY_GETC_P(e)                 ENTITY_NAME_P(e, "getc")
#define ENTITY__IO_GETC_P(e)             ENTITY_NAME_P(e, "_IO_getc")
#define ENTITY_GETCHAR_P(e)              ENTITY_NAME_P(e, "getchar")
#define ENTITY_PUTC_P(e)                 ENTITY_NAME_P(e, "putc")
#define ENTITY__IO_PUTC_P(e)             ENTITY_NAME_P(e, "_IO_putc")
#define ENTITY_PUTCHAR_P(e)              ENTITY_NAME_P(e, "putchar")
#define ENTITY_UNGETC_P(e)               ENTITY_NAME_P(e, "ungetc")
#define ENTITY_FREAD_P(e)                ENTITY_NAME_P(e, "fread")
#define ENTITY_FWRITE_P(e)               ENTITY_NAME_P(e, "fwrite")
#define ENTITY_FGETPOS_P(e)              ENTITY_NAME_P(e, "fgetpos")
#define ENTITY_FSEEK_P(e)                ENTITY_NAME_P(e, "fseek")
#define ENTITY_FSETPOS_P(e)              ENTITY_NAME_P(e, "fsetpos")
#define ENTITY_FTELL_P(e)                ENTITY_NAME_P(e, "ftell")
#define ENTITY_C_REWIND_P(e)             ENTITY_NAME_P(e, "rewind")
#define ENTITY_CLEARERR_P(e)             ENTITY_NAME_P(e, "clearer")
#define ENTITY_FEOF_P(e)                 ENTITY_NAME_P(e, "feof")
#define ENTITY_FERROR_P(e)               ENTITY_NAME_P(e, "ferror")
#define ENTITY_FILENO_P(e)               ENTITY_NAME_P(e, "fileno")
#define ENTITY_PERROR_P(e)               ENTITY_NAME_P(e, "perror")

/*io functions: C library and system io.Amira Mensi*/

#define ENTITY_C_OPEN_SYSTEM_P(e)        ENTITY_NAME_P(e, C_OPEN_FUNCTION_NAME)
#define ENTITY_C_CLOSE_SYSTEM_P(e)       ENTITY_NAME_P(e, C_CLOSE_FUNCTION_NAME)
#define ENTITY_C_READ_SYSTEM_P(e)        ENTITY_NAME_P(e, C_READ_FUNCTION_NAME)
#define ENTITY_C_WRITE_SYSTEM_P(e)       ENTITY_NAME_P(e, C_WRITE_FUNCTION_NAME)
#define ENTITY_LINK_SYSTEM_P(e)          ENTITY_NAME_P(e, LINK_FUNCTION_NAME)
#define ENTITY_SYMLINK_SYSTEM_P(e)       ENTITY_NAME_P(e, SYMLINK_FUNCTION_NAME)
#define ENTITY_UNLINK_SYSTEM_P(e)        ENTITY_NAME_P(e, UNLINK_FUNCTION_NAME)

/* fcntl() */
#define ENTITY_FSYNC_SYSTEM_P(e)         ENTITY_NAME_P(e, FSYNC_FUNCTION_NAME)
#define ENTITY_FDATASYNC_SYSTEM_P(e)     ENTITY_NAME_P(e, FDATASYNC_FUNCTION_NAME)
#define ENTITY_IOCTL_SYSTEM_P(e)         ENTITY_NAME_P(e, IOCTL_FUNCTION_NAME)
#define ENTITY_SELECT_SYSTEM_P(e)        ENTITY_NAME_P(e, SELECT_FUNCTION_NAME)
#define ENTITY_PSELECT_SYSTEM_P(e)       ENTITY_NAME_P(e, PSELECT_FUNCTION_NAME)
#define ENTITY_STAT_SYSTEM_P(e)          ENTITY_NAME_P(e, STAT_FUNCTION_NAME)
#define ENTITY_FSTAT_SYSTEM_P(e)         ENTITY_NAME_P(e, FSTAT_FUNCTION_NAME)
#define ENTITY_LSTAT_SYSTEM_P(e)         ENTITY_NAME_P(e, LSTAT_FUNCTION_NAME)

#define ENTITY_REMOVE_SYSTEM_P(e)        ENTITY_NAME_P(e, "remove")
#define ENTITY_RENAME_SYSTEM_P(e)        ENTITY_NAME_P(e, "rename")
#define ENTITY_TMPFILE_SYSTEM_P(e)       ENTITY_NAME_P(e, "tmpfile")
#define ENTITY_TMPNAM_SYSTEM_P(e)        ENTITY_NAME_P(e, "tmpnam")
#define ENTITY_FFLUSH_SYSTEM_P(e)        ENTITY_NAME_P(e, "fflush")
#define ENTITY_FREOPEN_SYSTEM_P(e)       ENTITY_NAME_P(e, "freopen")
#define ENTITY_SETBUF_SYSTEM_P(e)        ENTITY_NAME_P(e, "setbuf")
#define ENTITY_SETVBUF_SYSTEM_P(e)       ENTITY_NAME_P(e, "setvbuf")
#define ENTITY__FILBUF_SYSTEM_P(e)       ENTITY_NAME_P(e, "__filbuf")
#define ENTITY__FILSBUF_SYSTEM_P(e)      ENTITY_NAME_P(e, "__flsbuf")
#define ENTITY_SETBUFFER_SYSTEM_P(e)     ENTITY_NAME_P(e, "setbuffer")
#define ENTITY_SETLINEBUF_SYSTEM_P(e)    ENTITY_NAME_P(e, "setlinebuf")
#define ENTITY_FDOPEN_SYSTEM_P(e)        ENTITY_NAME_P(e, "fdopen")
#define ENTITY_CTERMID_SYSTEM_P(e)       ENTITY_NAME_P(e, "ctermid")
#define ENTITY_FILENO_SYSTEM_P(e)        ENTITY_NAME_P(e, "fileno")
#define ENTITY_POPEN_SYSTEM_P(e)         ENTITY_NAME_P(e, "popen")
#define ENTITY_CUSERID_SYSTEM_P(e)       ENTITY_NAME_P(e, "cuserid")
#define ENTITY_TEMPNAM_SYSTEM_P(e)       ENTITY_NAME_P(e, "tempnam")
#define ENTITY_GETW_SYSTEM_P(e)          ENTITY_NAME_P(e, "getw")
#define ENTITY_PUTW_SYSTEM_P(e)          ENTITY_NAME_P(e, "putw")
#define ENTITY_PCLOSE_SYSTEM_P(e)        ENTITY_NAME_P(e, "pclose")
#define ENTITY_FSEEKO_SYSTEM_P(e)        ENTITY_NAME_P(e, "fseeko")
#define ENTITY_FTELLO_SYSTEM_P(e)        ENTITY_NAME_P(e, "ftello")
#define ENTITY_FOPEN64_SYSTEM_P(e)       ENTITY_NAME_P(e, "fopen64")
#define ENTITY_FREOPEN64_SYSTEM_P(e)     ENTITY_NAME_P(e, "freopen64")
#define ENTITY_TMPFILE64_SYSTEM_P(e)     ENTITY_NAME_P(e, "tmpfile64")
#define ENTITY_FGETPOS64_SYSTEM_P(e)     ENTITY_NAME_P(e, "fgetpos64")
#define ENTITY_FSETPOS64_SYSTEM_P(e)     ENTITY_NAME_P(e, "fsetpos64")
#define ENTITY_FSEEKO64_SYSTEM_P(e)      ENTITY_NAME_P(e, "fseeko64")
#define ENTITY_FTELLO64_SYSTEM_P(e)      ENTITY_NAME_P(e, "ftello64")

#define ENTITY_ABORT_SYSTEM_P(e)         ENTITY_NAME_P(e, "abort")
#define ENTITY_C_ABS_SYSTEM_P(e)         ENTITY_NAME_P(e, "abs")
#define ENTITY_ATEXIT_SYSTEM_P(e)        ENTITY_NAME_P(e, "atexit")
#define ENTITY_ATOF_SYSTEM_P(e)          ENTITY_NAME_P(e, "atof")
#define ENTITY_ATOI_SYSTEM_P(e)          ENTITY_NAME_P(e, "atoi")
#define ENTITY_BSEARCH_SYSTEM_P(e)       ENTITY_NAME_P(e, "bsearch")
#define ENTITY_CALLOC_SYSTEM_P(e)        ENTITY_NAME_P(e, "calloc")
#define ENTITY_DIV_SYSTEM_P(e)           ENTITY_NAME_P(e, "div")
#define ENTITY_EXIT_SYSTEM_P(e)          ENTITY_NAME_P(e, "exit")
#define ENTITY_FREE_SYSTEM_P(e)          ENTITY_NAME_P(e, "free")
#define ENTITY_GETENV_SYSTEM_P(e)        ENTITY_NAME_P(e, "getenv")
#define ENTITY_LABS_SYSTEM_P(e)          ENTITY_NAME_P(e, "labs")
#define ENTITY_LDIV_SYSTEM_P(e)          ENTITY_NAME_P(e, "ldiv")
#define ENTITY_MALLOC_SYSTEM_P(e)        ENTITY_NAME_P(e, "malloc")
#define ENTITY_MBLEN_SYSTEM_P(e)         ENTITY_NAME_P(e, "mblen")
#define ENTITY_MBSTOWCS_SYSTEM_P(e)      ENTITY_NAME_P(e, "mbstowcs")
#define ENTITY_MBTOWC_SYSTEM_P(e)        ENTITY_NAME_P(e, "mbtowc")
#define ENTITY_QSORT_SYSTEM_P(e)         ENTITY_NAME_P(e, "qsort")
#define ENTITY_REALLOC_SYSTEM_P(e)       ENTITY_NAME_P(e, "realloc")
#define ENTITY_STRTOD_SYSTEM_P(e)        ENTITY_NAME_P(e, "strtod")
#define ENTITY_STRTOL_SYSTEM_P(e)        ENTITY_NAME_P(e, "strtol")
#define ENTITY_STRTOUL_SYSTEM_P(e)       ENTITY_NAME_P(e, "strtoul")
#define ENTITY_SYSTEM_SYSTEM_P(e)        ENTITY_NAME_P(e, "system")
#define ENTITY_WCTOMB_SYSTEM_P(e)        ENTITY_NAME_P(e, "wctomb")
#define ENTITY_WCSTOMBS_SYSTEM_P(e)      ENTITY_NAME_P(e, "wcstombs")
#define ENTITY_EXITHANDLESYSTEM_P(e)     ENTITY_NAME_P(e, "exithandle")
#define ENTITY_DRAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "drand48")
#define ENTITY_ERAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "erand48")
#define ENTITY_JRAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "jrand48")
#define ENTITY_LCONG48_SYSTEM_P(e)       ENTITY_NAME_P(e, "lcong48")
#define ENTITY_LRAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "lrand48")
#define ENTITY_MRAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "mrand48")
#define ENTITY_NRAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "nrand48")
#define ENTITY_SEED48_SYSTEM_P(e)        ENTITY_NAME_P(e, "seed48")
#define ENTITY_SRAND48_SYSTEM_P(e)       ENTITY_NAME_P(e, "srand48")
#define ENTITY_PUTENV_SYSTEM_P(e)        ENTITY_NAME_P(e, "putenv")
#define ENTITY_SETKEY_SYSTEM_P(e)        ENTITY_NAME_P(e, "setkey")
#define ENTITY_SWAB_SYSTEM_P(e)          ENTITY_NAME_P(e, "swab")
#define ENTITY_MKSTEMP_SYSTEM_P(e)       ENTITY_NAME_P(e, "mkstemp")
#define ENTITY_MKSTEMP64_SYSTEM_P(e)     ENTITY_NAME_P(e, "mkstemp64")
#define ENTITY_A614_SYSTEM_P(e)          ENTITY_NAME_P(e, "a64l")
#define ENTITY_ECVT_SYSTEM_P(e)          ENTITY_NAME_P(e, "ecvt")
#define ENTITY_FCVT_SYSTEM_P(e)          ENTITY_NAME_P(e, "fcvt")
#define ENTITY_GCVT_SYSTEM_P(e)          ENTITY_NAME_P(e, "gcvt")
#define ENTITY_GETSUBOPT_SYSTEM_P(e)     ENTITY_NAME_P(e, "getsubopt")
#define ENTITY_GRANTPT_SYSTEM_P(e)       ENTITY_NAME_P(e, "grantpt")
#define ENTITY_INITSTATE_SYSTEM_P(e)     ENTITY_NAME_P(e, "initstate")
#define ENTITY_C_164A_SYSTEM_P(e)        ENTITY_NAME_P(e, "l64a")
#define ENTITY_MKTEMP_SYSTEM_P(e)        ENTITY_NAME_P(e, "mktemp")
#define ENTITY_PTSNAME_SYSTEM_P(e)       ENTITY_NAME_P(e, "ptsname")
#define ENTITY_REALPATH_SYSTEM_P(e)      ENTITY_NAME_P(e, "realpath")
#define ENTITY_SETSTATE_SYSTEM_P(e)      ENTITY_NAME_P(e, "setstate")
#define ENTITY_TTYSLOT_SYSTEM_P(e)       ENTITY_NAME_P(e, "ttyslot")
#define ENTITY_UNLOCKPT_SYSTEM_P(e)      ENTITY_NAME_P(e, "unlockpt")
#define ENTITY_VALLOC_SYSTEM_P(e)        ENTITY_NAME_P(e, "valloc")
#define ENTITY_DUP2_SYSTEM_P(e)          ENTITY_NAME_P(e, "dup2")
#define ENTITY_QECVT_SYSTEM_P(e)         ENTITY_NAME_P(e, "qecvt")
#define ENTITY_QFCVT_SYSTEM_P(e)         ENTITY_NAME_P(e, "qfcvt")
#define ENTITY_QGCVT_SYSTEM_P(e)         ENTITY_NAME_P(e, "qgcvt")
#define ENTITY_GETCWD_SYSTEM_P(e)        ENTITY_NAME_P(e, "getcwd")
#define ENTITY_GETEXECNAME_SYSTEM_P(e)   ENTITY_NAME_P(e, "getexecname")
#define ENTITY_GETLOGIN_SYSTEM_P(e)      ENTITY_NAME_P(e, "getlogin")
#define ENTITY_GETOPT_SYSTEM_P(e)        ENTITY_NAME_P(e, "getopt")
#define ENTITY_GETPASS_SYSTEM_P(e)       ENTITY_NAME_P(e, "getpass")
#define ENTITY_GETPASSPHRASE_SYSTEM_P(e) ENTITY_NAME_P(e, "getpassphrase")
#define ENTITY_GETPW_SYSTEM_P(e)         ENTITY_NAME_P(e, "getpw")
#define ENTITY_ISATTY_SYSTEM_P(e)        ENTITY_NAME_P(e, "isatty")
#define ENTITY_MEMALIGN_SYSTEM_P(e)      ENTITY_NAME_P(e, "memalign")
#define ENTITY_TTYNAME_SYSTEM_P(e)       ENTITY_NAME_P(e, "ttyname")
#define ENTITY_ATOLL_SYSTEM_P(e)         ENTITY_NAME_P(e, "atoll")
#define ENTITY_LLABS_SYSTEM_P(e)         ENTITY_NAME_P(e, "llabs")
#define ENTITY_LLDIV_SYSTEM_P(e)         ENTITY_NAME_P(e, "lldiv")
#define ENTITY_LLTOSTR_SYSTEM_P(e)       ENTITY_NAME_P(e, "lltostr")
#define ENTITY_STROLL_SYSTEM_P(e)        ENTITY_NAME_P(e, "strtoll")
#define ENTITY_STROULL_SYSTEM_P(e)       ENTITY_NAME_P(e, "strtoull")
#define ENTITY_ULLOSTR_SYSTEM_P(e)       ENTITY_NAME_P(e, "ulltostr")

/* include <assert.h> */

#define ENTITY_ASSERT_SYSTEM_P(e)        ENTITY_NAME_P(e, ASSERT_FUNCTION_NAME)
#define ENTITY_ASSERT_FAIL_SYSTEM_P(e)   ENTITY_NAME_P(e, ASSERT_FAIL_FUNCTION_NAME)

/* include <string.h> */

#define ENTITY_STRCMP_SYSTEM_P(e)        ENTITY_NAME_P(e, "strcmp")
#define ENTITY_STRNCMP_SYSTEM_P(e)       ENTITY_NAME_P(e, "strncmp")
#define ENTITY_STRCPY_SYSTEM_P(e)        ENTITY_NAME_P(e, "strcpy")
#define ENTITY_STRCAT_SYSTEM_P(e)        ENTITY_NAME_P(e, "strcat")
#define ENTITY_STRLEN_SYSTEM_P(e)        ENTITY_NAME_P(e, "strlen")
#define ENTITY_STRERROR_SYSTEM_P(e)      ENTITY_NAME_P(e, "strerror")
#define ENTITY_STRERROR_R_SYSTEM_P(e)    ENTITY_NAME_P(e, "strerror_r")

/* FI: Why is it declared "system"? Why is it in the middle of string functions? */
#define ENTITY_FOPEN_SYSTEM_P(e)         ENTITY_NAME_P(e, "fopen")

/* #include <fcntl.h>*/

#define ENTITY_FCNTL_SYSTEM_P(e)         ENTITY_NAME_P(e,"fcntl")
#define ENTITY_OPEN_SYSTEM_P(e)          ENTITY_NAME_P(e,"open")
#define ENTITY_CREAT_SYSTEM_P(e)         ENTITY_NAME_P(e,"creat")
#define ENTITY_DIRECTIO_SYSTEM_P(e)      ENTITY_NAME_P(e,"directio")
#define ENTITY_OPEN64_SYSTEM_P(e)        ENTITY_NAME_P(e,"open64")
#define ENTITY_CREAT64_SYSTEM_P(e)       ENTITY_NAME_P(e,"creat64")

/* some random functions of stdlib.h */

#define ENTITY_RANDOM_P(e)               ENTITY_NAME_P(e,"random")
#define ENTITY_SRANDOM_P(e)              ENTITY_NAME_P(e,"srandom")
#define ENTITY_RAND_P(e)                 ENTITY_NAME_P(e,"rand")
#define ENTITY_SRAND_P(e)                ENTITY_NAME_P(e,"srand")

/* signal.h */
#define ENTITY_SIGNAL_P(e)               ENTITY_NAME_P(e,"signal")

/* Fortran DATA management */

#define ENTITY_STATIC_INITIALIZATION_P(e) ENTITY_NAME_P(e, STATIC_INITIALIZATION_FUNCTION_NAME)
#define ENTITY_REPEAT_VALUE_P(e)          ENTITY_NAME_P(e, REPEAT_VALUE_FUNCTION_NAME)
#define ENTITY_DATA_LIST_P(e)             ENTITY_NAME_P(e, DATA_LIST_FUNCTION_NAME)

/* C initialization expression */

#define ENTITY_BRACE_INTRINSIC_P(e) ENTITY_NAME_P(e, BRACE_INTRINSIC)

#define ENTITY_IMPLIED_CMPLX_P(e) ENTITY_NAME_P(e, IMPLIED_COMPLEX_NAME)
#define ENTITY_IMPLIED_DCMPLX_P(e) ENTITY_NAME_P(e, IMPLIED_DCOMPLEX_NAME)

/* C data structure and pointer management */

#define ENTITY_FIELD_P(e)         entity_an_operator_p(e, FIELD)
#define ENTITY_POINT_TO_P(e)      entity_an_operator_p(e, POINT_TO)
#define ENTITY_DEREFERENCING_P(e) entity_an_operator_p(e, DEREFERENCING)
/* Defined elsewhere: #define ENTITY_ADDRESS_OF_P(e) entity_an_operator_p(e, ADDRESS_OF) */

/* C varargs stuff */
#define ENTITY_VA_END_P(e)   ENTITY_NAME_P(e, BUILTIN_VA_END)
#define ENTITY_VA_START_P(e) ENTITY_NAME_P(e, BUILTIN_VA_START)
#define ENTITY_VA_COPY_P(e)  ENTITY_NAME_P(e, BUILTIN_VA_COPY)


#define ENTITY_FIVE_OPERATION_P(e) ( ENTITY_PLUS_P(e) || \
                                     ENTITY_PLUS_C_P(e) || \
                                     ENTITY_MINUS_P(e) || \
                                     ENTITY_MINUS_C_P(e) || \
                                     ENTITY_UNARY_MINUS_P(e) || \
                                     ENTITY_MULTIPLY_P(e) || \
                                     ENTITY_MODULO_P(e) ||\
                                     ENTITY_DIVIDE_P(e) )

#define IO_CALL_P(call) io_intrinsic_p(call_function(call))

/*
 * Fortran 95 Allocatable
 */
#define ALLOCATABLE_PREFIX "__pips_allocatable__"
#define ALLOCATABLE_LBOUND_PREFIX "__pips__allocatable__lbound__"
#define ALLOCATABLE_UBOUND_PREFIX "__pips__allocatable__ubound__"
#define ENTITY_ALLOCATABLE_BOUND_P(e) \
  (strncmp(entity_user_name(e), ALLOCATABLE_LBOUND_PREFIX, strlen(ALLOCATABLE_LBOUND_PREFIX)) == 0 \
   || strncmp(entity_user_name(e), ALLOCATABLE_UBOUND_PREFIX, strlen(ALLOCATABLE_UBOUND_PREFIX)) == 0 )


/* classification of basics */

#define basic_numeric_simple_p(b) (basic_int_p(b) || basic_float_p(b))
#define basic_numeric_p(b) (basic_numeric_simple_p(b) || basic_complex_p(b))
#define basic_compatible_simple_p(b1, b2) (\
                (basic_numeric_simple_p(b1) && basic_numeric_simple_p(b2)) ||\
                (basic_string_p(b1) && basic_string_p(b2)) ||\
                (basic_logical_p(b1) && basic_logical_p(b2)) ||\
                (basic_overloaded_p(b1) && basic_overloaded_p(b2)) ||\
                (basic_undefined_p(b1) && basic_undefined_p(b2)))
#define basic_compatible_p(b1, b2) (\
                (basic_numeric_p(b1) && basic_numeric_p(b2)) ||\
                (basic_string_p(b1) && basic_string_p(b2)) ||\
                (basic_logical_p(b1) && basic_logical_p(b2)) ||\
                (basic_overloaded_p(b1) && basic_overloaded_p(b2)) ||\
                (basic_undefined_p(b1) && basic_undefined_p(b2)))

/*  constant sizes */

#define LABEL_SIZE 5
#define INDENTATION (get_int_property("PRETTYPRINT_INDENTATION"))
#define INDENT_A_LIST_OF_WORDS(list_of_words) { \
  if(list_of_words) { \
    list blanks = NIL; \
    for(int i=0; i<INDENTATION; i++) { \
      blanks = CHAIN_SWORD(blanks, " "); \
    } \
    list_of_words = gen_nconc(blanks,list_of_words); \
  } \
}

/*   default values */

#define STATEMENT_NUMBER_UNDEFINED (-1)
#define UNKNOWN_RAM_OFFSET (-1)
// It is for extern variables whose ram offset is not known
#define UNDEFINED_RAM_OFFSET (-2)
// It is for dynamic allocation of arrays whose ram offset is not known either.
/* FI: I would have assumed that it is used for the stack area, but I
   must be wrong... */
#define DYNAMIC_RAM_OFFSET (-3)


/* On devrait utiliser Newgen pour cela, mais comme on ne doit pas
   les utiliser directement (mais via statement_less_p), cela devrait
   decourager les temeraires */

#define MAKE_ORDERING(u,s) (u<<16|s)
#define ORDERING_NUMBER(o) (o>>16)
#define ORDERING_STATEMENT(o) (o & 0xffff)

#define NORMALIZE_EXPRESSION(e) \
    ((expression_normalized(e) == normalized_undefined) ? \
         (expression_normalized(e) = NormalizeExpression(e)) : \
         (expression_normalized(e)))

/*   MISC: newgen shorthands */

#define entity_declarations(e) (code_declarations(entity_code(e)))


/* An entity_variable_p(e) may hide a typedef and hence a functional
   type.  In C, use type_variable_p(ultimate_type(entity_type(e))) to
   make sure e is a variable.

   It may also be a dummy C parameter.

   It may also be a hidden entity such as an abstract location.

   To sum up, this predicate does not imply that entity e represents a
   variable declared in the source code by the programmer.

   See also the function variable_entity_p() which checks the storage
   of the entity.
 */
#define entity_variable_p(e) (type_variable_p(entity_type(e)))

#define entity_symbolic_p(e) (type_functional_p(entity_type(e)) && \
  storage_rom_p(entity_storage(e)) && value_symbolic_p(entity_initial(e)))

/* implemented as a macro to allow lhs */
#define module_language(e)\
    code_language(value_code(entity_initial((e))))

#define module_functional_parameters(func) \
        functional_parameters(type_functional(entity_type(func)))

#define call_intrinsic_p(C)                       \
  value_intrinsic_p(entity_initial(call_function(C)))


#define statement_block_p(stat) \
        (instruction_block_p(statement_instruction(stat)))

#define entity_constant_p(e) (type_functional_p(entity_type(e)) && \
  storage_rom_p(entity_storage(e)) && value_constant_p(entity_initial(e)))

#define loop_to_instruction make_instruction_loop
#define test_to_instruction make_instruction_test
#define call_to_instruction make_instruction_call

#define loop_to_statement(l) instruction_to_statement(loop_to_instruction(l))
#define test_to_statement(t) instruction_to_statement(test_to_instruction(t))
#define call_to_statement(c) instruction_to_statement(call_to_instruction(c))


/***************************************************** BOOLEAN EXPRESSIONS */

/* Building quickly bool expressions, FC. */

#define unary_intrinsic_expression(name, e)\
 call_to_expression(make_call(entity_intrinsic(name),CONS(EXPRESSION,e,NIL)))

#define binary_intrinsic_expression(name, e1, e2)\
 call_to_expression(make_call(entity_intrinsic(name),\
 CONS(EXPRESSION, e1, CONS(EXPRESSION, e2, NIL))))

#define not_expression(e) \
    unary_intrinsic_expression(NOT_OPERATOR_NAME, e)
#define or_expression(e1, e2) \
    binary_intrinsic_expression(OR_OPERATOR_NAME, e1, e2)
#define and_expression(e1, e2) \
    binary_intrinsic_expression(AND_OPERATOR_NAME, e1, e2)
#define ne_expression(e1, e2) \
    binary_intrinsic_expression(NON_EQUAL_OPERATOR_NAME, e1, e2)
#define eq_expression(e1, e2) \
    binary_intrinsic_expression(EQUAL_OPERATOR_NAME, e1, e2)
#define gt_expression(e1, e2) \
    binary_intrinsic_expression(GREATER_THAN_OPERATOR_NAME, e1, e2)
#define ge_expression(e1, e2) \
    binary_intrinsic_expression(GREATER_OR_EQUAL_OPERATOR_NAME, e1, e2)
#define lt_expression(e1, e2) \
    binary_intrinsic_expression(LESS_THAN_OPERATOR_NAME, e1, e2)
#define le_expression(e1, e2) \
    binary_intrinsic_expression(LESS_OR_EQUAL_OPERATOR_NAME, e1, e2)


/******************************************************** CONTROL GRAPH... */

/* For the control graph modifiers: */

/* To specify the way that remove_a_control_from_a_list_and_relink
   acts: */
enum remove_a_control_from_a_list_and_relink_direction
{
   /* Put some strange number to avoid random clash as much as
      possible... */
   source_is_predecessor_and_dest_is_successor = 119,
      source_is_successor_and_dest_is_predecessor = -123
      };
typedef enum remove_a_control_from_a_list_and_relink_direction
remove_a_control_from_a_list_and_relink_direction;

/* Constants for some ex-atomizer variable generation */

#define TMP_ENT 1
#define AUX_ENT 2
#define DOUBLE_PRECISION_SIZE 8


/***************************************************** HPF/HPFC DIRECTIVES */

/* moved here because needed by syntax:-(
 */
/* Directive names encoding: HPF_PREFIX + one character.
 * This encoding is achieved thru a sed script that transforms directives
 * into calls that can be parsed by the PIPS F77 parser. It's a hack but
 * it greatly reduced the number of lines for directive analysis, and
 * it allowed quite simply to figure out where the executable directives
 * are in the code.
 * However the syntax allowed in mapping directives is restricted to F77.
 */

/* prefix for spacial directive calls
 */
#define HPF_PREFIX              "HPFC"

/* suffixies for encoded hpf keywords
 */
#define BLOCK_SUFFIX            "K"
#define CYCLIC_SUFFIX           "C"
#define STAR_SUFFIX             "S"

/* suffixes for HPF directives managed by HPFC
 */
#define ALIGN_SUFFIX            "A"
#define REALIGN_SUFFIX          "B"
#define DISTRIBUTE_SUFFIX       "D"
#define REDISTRIBUTE_SUFFIX     "E"
#define INDEPENDENT_SUFFIX      "I"
#define NEW_SUFFIX              "N"
#define REDUCTION_SUFFIX        "R"
#define PROCESSORS_SUFFIX       "P"
#define TEMPLATE_SUFFIX         "T"
#define PURE_SUFFIX             "U"
#define DYNAMIC_SUFFIX          "Y"

/* suffixes for my own (FCD:-) directives.
 * these directives are used to instrument the code.
 * must be used carefully. may be ignore with some properties.
 */
#define TELL_SUFFIX             "0"
#define SYNCHRO_SUFFIX          "1"
#define TIMEON_SUFFIX           "2"
#define TIMEOFF_SUFFIX          "3"
#define SETBOOL_SUFFIX          "4"
#define SETINT_SUFFIX           "5"
#define HPFCIO_SUFFIX           "6"
#define HOSTSECTION_SUFFIX      "7"
#define DEAD_SUFFIX             "8"
#define FAKE_SUFFIX             "9"

/* property prefix for ignoring FCD directives
 * TIME, SYNCHRO and SET exists.
 */
#define FCD_IGNORE_PREFIX       "HPFC_IGNORE_FCD_"

/* __asm function
 */
#define ASM_FUNCTION_NAME "__asm"

/* soft block->sequence transition
 */
#define is_instruction_block is_instruction_sequence
#define instruction_block_p(i) instruction_sequence_p(i)
#define instruction_block(i) sequence_statements(instruction_sequence(i))

/* easy list constructor
 */
#define make_statement_list( stats... ) \
    (gen_make_list(statement_domain, ##stats, 0))
#define make_expression_list( stats... ) \
    (gen_make_list(expression_domain, ##stats, 0))

/* After the modification in Newgen:  unstructured = entry:control x exit:control
   we have create a macro to transform automatically unstructured_control to unstructured_entry */
#define unstructured_control unstructured_entry

/* Default type sizes */

#define DEFAULT_CHARACTER_TYPE_SIZE (1)
#define DEFAULT_SHORT_INTEGER_TYPE_SIZE (2)
#define DEFAULT_INTEGER_TYPE_SIZE (4)
#define DEFAULT_LONG_INTEGER_TYPE_SIZE (6)
#define DEFAULT_LONG_LONG_INTEGER_TYPE_SIZE (8)
#define DEFAULT_LONG_LONG_LONG_INTEGER_TYPE_SIZE (9)

// To avoid issues with the PIPS validation suite on a 32-bit pointer machine
//#define DEFAULT_POINTER_TYPE_SIZE (sizeof(void *)) // could be 4 or 8 or sizeof(pointer)
#define DEFAULT_POINTER_TYPE_SIZE (8)
#define DEFAULT_UNSIGNED_TYPE_SIZE (1) // type_size/10==1
#define DEFAULT_SIGNED_TYPE_SIZE (2) // type_size/10=2

/* The standard C integer types are represented as follow
char                   = 1
short_int              = 2
int                    = 4
long_int               = 6
long_long_int          = 8
__int128_t             = 9 (gcc extension)

unsigned_char          = 11
unsigned_short_int     = 12
unsigned_int           = 14
unsigned_long_int      = 16
unsigned_long_long_int = 18
__uint128_t            = 19 (gcc extension)

signed_char            = 21
signed_short_int       = 22
signed_int             = 24
signed_long_int        = 26
signed_long_long_int   = 28

mod(i,10) refers to the basic size and div(i,10) refers that
the variable is unsigned, signed or not */

#define DEFAULT_REAL_TYPE_SIZE (4)
#define DEFAULT_DOUBLEPRECISION_TYPE_SIZE (8)
#define DEFAULT_QUADPRECISION_TYPE_SIZE (16)
#define DEFAULT_COMPLEX_TYPE_SIZE (8)
#define DEFAULT_DOUBLECOMPLEX_TYPE_SIZE (16)
#define DEFAULT_LONGDOUBLECOMPLEX_TYPE_SIZE (32)
#define DEFAULT_LOGICAL_TYPE_SIZE (4)

/* Already defined */
//#define DEFAULT_POINTER_TYPE_SIZE (4)

/* package name for region variables */
#define REGIONS_MODULE_NAME "REGIONS-PACKAGE"

/* Implicit variables to handle IO effetcs */
/* package name for io routines */
#define IO_EFFECTS_PACKAGE_NAME "__IO_EFFECTS"
/* package name for time routines */
#define TIME_EFFECTS_PACKAGE_NAME "__TIME_EFFECTS"
/* package name for random routines */
#define RAND_EFFECTS_PACKAGE_NAME "_RANDOM_EFFECTS"
/* variable name for random unit */
#define RAND_GEN_EFFECTS_NAME "GEN_SEED"
/* package name for malloc routines (could be libc package) */
#define MALLOC_EFFECTS_PACKAGE_NAME "_MALLOC_EFFECTS"
/* variable name for heap effects */
#define MALLOC_EFFECTS_NAME "_MALLOC_"
/* package name for memmove routines */
#define MEMMOVE_EFFECTS_PACKAGE_NAME "_MEMMOVE_EFFECTS"
/* variable name for memmove unit */
#define MEMMOVE_EFFECTS_NAME "_MEMMOVE_"
/* array of Logical UNits; it is more or less handled as the current file pointer; in C, used for open, close, read, write... */
#define IO_EFFECTS_ARRAY_NAME "LUNS"
/* Array of struct io_files pointed to by pointers returned by fopen
   and used by fclose, fscanf, fprintf... */
#define IO_EFFECTS_IO_FILE_NAME "IO_FILES"
/* To express C IO intrinsics effects */
#define IO_EFFECTS_PTR_NAME "_C_IO_ptr"
/* array of end of file codes */
#define IO_EOF_ARRAY_NAME "END_LUNS"
/* array of error codes for LUNs */
#define IO_ERROR_ARRAY_NAME "ERR_LUNS"
/* variable holding time effects */
#define TIME_EFFECTS_VARIABLE_NAME "KALI" /* kali is the goddess of time in the Hindu mythology */
/* size of the unit specifier */
#define IO_EFFECTS_UNIT_SPECIFIER_LENGTH 4
/* Standard unit numbers depend on the operating system. Here are UNIX definitions. */
#define STDERR_LUN (0)
#define STDERR_NAME "stderr"
#define ENTITY_STDERR_P(e) entity_a_special_entity_p(e, STDERR_NAME)
#define STDIN_LUN (5)
#define STDIN_NAME "stdin"
#define ENTITY_STDIN_P(e) entity_a_special_entity_p(e, STDIN_NAME)
#define STDOUT_LUN (6)
#define STDOUT_NAME "stdout"
#define ENTITY_STDOUT_P(e) entity_a_special_entity_p(e, STDOUT_NAME)

/*Symbolic constants for the file descriptors belonging to the standard streams: unistd.h */
#if !defined(HAVE_UNISTD_H) && !defined(_UNISTD_H)
#define STDIN_FILENO (0)
#define STDOUT_FILENO (1)
#define STDERR_FILENO (2)
#endif

/* Implicit variable names for C */

#define IMPLICIT_VARIABLE_NAME_1 "__FUNCTION__"
#define IMPLICIT_VARIABLE_NAME_2 "__func__"

/* Empty comments (i.e. default comments) */
/* FI: this is a poor choice as the statements won't be gen_defined_p
   and as strdup() won't be usable without an extra test. Would it be
   so bad to use strdup(""); as empty_comments? */
#define empty_comments string_undefined

/** An alias for make_empty_block_statement */
#define make_empty_statement make_empty_block_statement

/** An alias for make_empty_block_statement */
#define make_nop_statement make_empty_block_statement


/* \addtogroup control_visitors */

/* @{ */
/* Macro to walk through all the controls reachable from a given control
  node of an unstructured

  Reachability is defined by successors and predecessors (i.e. the control
  flow graph is seen as non-directed)

  @param ctl is a name of a control node variable that is declared inside
  this macro and is used by the following code to access the visited
  control node

  @param code is the actions to execute on the visited control node

  @param c is a control node to start visiting with

  @param list is a list that will store the visited control nodes. It is
  used mainly for this macro to avoid visiting twice a node. The simple
  usage is to give a list variable initialized to NIL. A nice side effect
  is that it will contain the list of all the reachable control nodes. Do
  not forget to free this list afterwards. Another classical usage is to
  give to the macro a list with a list of nodes to avoid visiting.
*/
#define CONTROL_MAP( ctl, code, c, list )				\
  do {									\
    GENERIC_CONTROL_MAP( control_map_get_blocs, ctl, code, c, list )	\
      } while(0)


/* Walk through all the controls of un unstructured

  This macro do not work indeed because often the...

  The nodes are those reachable from the entry node and also from the exit
  node (that may be unreachable from the entry node of th unstructured).

  Reachability is defined by successors and predecessors (i.e. the control
  flow graph is seen as non-directed)

  @param c is a name of a control node variable that is declared inside
  this macro and is used by the following code to access the visited
  control node

  @param code is the actions to execute on the visited control node

  @param u is the unstructured to visit

  @param l is a list that will store the visited control nodes. It is used
  mainly for this macro to avoid visiting twice a node. The simple usage
  is to give a list variable initialized to NIL. A nice side effect is
  that it will contain the list of all the reachable control nodes. Do not
  forget to free this list afterwards. Another classical usage is to give
  to the macro a list with a list of nodes to avoid visiting.
*/
#define UNSTRUCTURED_CONTROL_MAP(c, u, l, code)				\
  /* The implementation is sub-optimal because it duplicates the	\
     code... */								\
  do {									\
    /* First get the control nodes reachable from the entry node: */	\
    control_map_get_blocs(unstructured_entry(u), &l);			\
    /* Add then the control nodes reachable from the exit nodes if not	\
       already in: */							\
    control_map_get_blocs(unstructured_exit(u), &l);			\
    /* Reverse the list because previous construction was done in the	\
       reverse way: */							\
    l = gen_nreverse(l);						\
    /* Iterate on all the selected control nodes: */			\
    FOREACH(CONTROL, c, l)						\
      code								\
  } while(0)


/* Walk through all the controls forward-reachable from a given control
  node of an unstructured

  Reachability is defined by successor-only relation (i.e. the control
  flow graph is seen as directed)

  @param ctl is a name of a control node variable that is declared inside
  this macro and is used by the following code to access the visited
  control node

  @param code is the actions to execute on the visited control node

  @param c is a control node to start visiting with

  @param list is a list that will store the visited control nodes. It is
  used mainly for this macro to avoid visiting twice a node. The simple
  usage is to give a list variable initialized to NIL. A nice side effect
  is that it will contain the list of all the forward-reachable control
  nodes. Do not forget to free this list afterwards. Another classical
  usage is to give to the macro a list with a list of nodes to avoid
  visiting.
*/
#define FORWARD_CONTROL_MAP( ctl, code, c, list )			\
  do {									\
    GENERIC_CONTROL_MAP( forward_control_map_get_blocs, ctl, code, c, list ) \
      } while(0)


/* Walk through all the controls backward-reachable from a given control
  node of an unstructured

  Reachability is defined by predecessor-only relation (i.e. the control
  flow graph is seen as directed)

  @param ctl is a name of a control node variable that is declared inside
  this macro and is used by the following code to access the visited
  control node

  @param code is the actions to execute on the visited control node

  @param c is a control node to start visiting with

  @param list is a list that will store the visited control nodes. It is
  used mainly for this macro to avoid visiting twice a node. The simple
  usage is to give a list variable initialized to NIL. A nice side effect
  is that it will contain the list of all the backward-reachable control
  nodes. Do not forget to free this list afterwards. Another classical
  usage is to give to the macro a list with a list of nodes to avoid
  visiting.
*/
#define BACKWARD_CONTROL_MAP( ctl, code, c, list )			\
  do {									\
    GENERIC_CONTROL_MAP( backward_control_map_get_blocs, ctl, code, c, list ) \
    } while(0)


/* Walk through all the controls backward-reachable from a given control
  node of an unstructured

  Reachability is defined by successor-only relation (i.e. the control
  flow graph is seen as directed)

  @param ctl is a name of a control node variable that is declared inside
  this macro and is used by the following code to access the visited
  control node

  @param code is the actions to execute on the visited control node

  @param c is a control node to start visiting with

  @param list is a list that will store the visited control nodes. It is
  used mainly for this macro to avoid visiting twice a node. The simple
  usage is to give a list variable initialized to NIL. A nice side effect
  is that it will contain the list of all the reachable control nodes. Do
  not forget to free this list afterwards. Another classical usage is to
  give to the macro a list with a list of nodes to avoid visiting.
*/
#define WIDE_FORWARD_CONTROL_MAP( ctl, code, c, list )		\
   do {								\
     GENERIC_CONTROL_MAP(wide_forward_control_map_get_blocs,	\
			 ctl, code, c, list )			\
     } while(0)


/* The control node visiting engine. */
#define GENERIC_CONTROL_MAP( get_controls, ctl, code, c, list ) \
{ \
    cons *_cm_list_init = (list) ; \
    cons *_cm_list = _cm_list_init ; \
    if( _cm_list == NIL ) {\
         get_controls( c, &_cm_list ) ; \
         _cm_list = gen_nreverse( _cm_list ) ; \
    }\
    MAPL( _cm_ctls, {control ctl = CONTROL( CAR( _cm_ctls )) ; \
 \
                 code ;}, \
          _cm_list ) ; \
   if( _cm_list_init == NIL ) \
        list = _cm_list ; \
}



/** @} */


/** @defgroup phase_definition Functions used to define phases

    It defines macros for simple transformation phases that use (at least)
    the CODE of a module and write back a (possibly) new version of the
    CODE.

    @{
*/


/** Start a phase that use a module CODE

 @param module_name is a string with the name of the module the phase is
 applied to

 @param debug_env_var is a string with the name of the environment variable used to get the debug level to use inside the phase

 @return the statement of the module
*/
#define PIPS_PHASE_PRELUDE(module_name, debug_env_var)                \
  /* Get and return the CODE resource of the module and define this   \
     module as the current one at the same time to avoid introducing	\
     a new variable: */                                               \
  set_current_module_statement((statement)                            \
                               db_get_memory_resource(DBR_CODE,       \
                                                      module_name,    \
                                                      true));         \
                                                                      \
  /* Set the current module entity required to have many things       \
     working in PIPS: */                                              \
  set_current_module_entity(module_name_to_entity(module_name));      \
                                                                      \
  /* The debug is now controled by this environment variable name: */	\
  debug_on(debug_env_var);                                            \
  pips_debug(1, "Entering...\n");                                     \
  pips_assert("Statement should be OK at entry...",                   \
	      statement_consistent_p(get_current_module_statement()))


/** End a transformation phase by putting back into PIPS the (possibly)
    modified statement

    @param new_module_statement point to the (potentially) new module
    statement of the module
 */
#define PIPS_PHASE_POSTLUDE(new_module_statement)                       \
  pips_assert("Statement should be OK at exit...",                      \
              statement_consistent_p(new_module_statement));            \
  pips_debug(1, "done\n");                                              \
  /* Exit current debug context */                                      \
  debug_off();                                                          \
                                                                        \
  /* Reorder the module, because some statements have been replaced. */	\
  module_reorder(new_module_statement);                                 \
                                                                        \
  /* Put the new CODE ressource into PIPS: */                           \
  DB_PUT_MEMORY_RESOURCE(DBR_CODE,                                      \
                         get_current_module_name(),                     \
                         new_module_statement);                         \
                                                                        \
  /* There is no longer a current module: */                            \
  reset_current_module_statement();                                     \
  reset_current_module_entity();                                        \
                                                                        \
  /* Assume it should have worked by returning true... */               \
  return true

/** @} */


/* polymorhism thanks to newgen ! */
#define INSTANCE_OF(type,value) ( (_int)((value)->u) == (_int)(type##_domain) )

#define binary_call_lhs(c) (EXPRESSION(CAR(call_arguments((c)))))
#define binary_call_rhs(c) (EXPRESSION(CAR(CDR(call_arguments((c))))))
#define expression_scalar_p(e) (expression_reference_p((e)) && reference_scalar_p(expression_reference((e))))
#define hash_contains_p(htp, key) (hash_get(htp, key) != HASH_UNDEFINED_VALUE)

enum range_to_expression_mode{
    range_to_distance,
    range_to_nbiter
} ;
#define range_to_distance_p(e) ((e) == range_to_distance)
#define range_to_nbiter_p(e) ((e) == range_to_nbiter)


#define GENERATED_LABEL_MODULE_NAME "__GENSYM"

/* that is all for ri-util-local.h
 */

typedef enum {
  IGNORE_IF_POLICY,
  AND_IF_POLICY,
  OR_IF_POLICY
} if_clause_policy;

/* for intrinsic registration */
typedef struct {
    list (*f)(call,int,bool,list*);
    int prec;
} intrinsic_desc_t;

enum {
    DEFAULT_ENTITY_KIND = 0,
    EFFECTS_PACKAGE = 1,
    ABSTRACT_LOCATION = 2,
    ENTITY_STACK_AREA = 4,
    ENTITY_HEAP_AREA = 8,
    ENTITY_DYNAMIC_AREA = 16,
    ENTITY_STATIC_AREA = 32,
    ENTITY_POINTER_DUMMY_TARGETS_AREA = 64,
    ENTITY_FORMAL_AREA = 128,
};

#define make_entity(n,t,s,i) make_entity(n,t,s,i,DEFAULT_ENTITY_KIND)

/* SPIRE API */
#define SEND_FUNCTION_NAME                        "send"
#define RECV_FUNCTION_NAME                        "recv"
#define SIGNAL_FUNCTION_NAME                      "signal"
#define WAIT_FUNCTION_NAME                        "wait"


/*MPI calls*/
#define MPI_INIT "MPI_Init"
#define MPI_FINALIZE "MPI_Finalize"
#define MPI_ISEND "MPI_Isend"
#define MPI_RECV "MPI_Recv"
#define MPI_BARRIER "MPI_Barrier"

/*MPI types*/
#define MPI_STATUS "MPI_Status"
#define MPI_REQUEST "MPI_Request"

/* intrinsic entity declarations */
#define ENTITY_SEND_P(e)              ENTITY_NAME_P(e, "send")

// for new entities
extern list integer_entities, real_entities, complex_entities,
  logical_entities, double_entities, char_entities;
/* eval.c */
extern value EvalExpression(expression /*e*/);
extern value EvalSyntax(syntax /*s*/);
extern value EvalCall(call /*c*/);
extern value EvalSizeofexpression(sizeofexpression /*soe*/);
extern value EvalConstant(constant /*c*/);
extern value EvalIntrinsic(entity /*e*/, list /*la*/);
extern value EvalConditionalOp(list /*la*/);
extern value EvalUnaryOp(int /*t*/, list /*la*/);
extern value EvalBinaryOp(int /*t*/, list /*la*/);
extern value EvalNaryOp(int /*t*/, list /*la*/);
extern int IsUnaryOperator(entity /*e*/);
extern int IsBinaryOperator(entity /*e*/);
extern int IsNaryOperator(entity /*e*/);
extern int ipow(int /*vg*/, int /*vd*/);
extern bool expression_integer_value(expression /*e*/, intptr_t */*pval*/);
extern bool expression_negative_integer_value_p(expression /*e*/);
extern bool positive_expression_p(expression /*e*/);
extern bool negative_expression_p(expression /*e*/);
extern bool expression_linear_p(expression /*e*/);
extern expression range_to_expression(range /*r*/, enum range_to_expression_mode mode);
extern bool range_count(range /*r*/, intptr_t */*pcount*/);
extern Pvecteur vect_product(Pvecteur */*pv1*/, Pvecteur */*pv2*/);
/* size.c */
extern int number_of_initial_values(list /*args*/);
extern bool SizeOfArray(entity /*e*/, int */*s*/);
extern int array_size(entity /*a*/);
extern Value ValueSizeOfArray(entity /*e*/);
extern int CSafeSizeOfArray(entity /*a*/);
extern int entity_memory_size(entity /*dt*/);
extern int type_memory_size(type /*t*/);
extern _int SizeOfElements(basic /*b*/);
extern int element_number(basic /*b*/, list /*ld*/);
extern bool NumberOfElements(basic /*b*/, list /*ld*/, int */*n*/);
extern Value ValueNumberOfElements(list /*ld*/);
extern int SizeOfIthDimension(entity /*e*/, int /*i*/);
extern int dimension_size(dimension /*d*/);
extern expression SizeOfDimension(dimension /*d*/);
extern expression SizeOfDimensions(list /*dims*/);
extern Value ValueSizeOfDimension(dimension /*d*/);
extern int ExpressionToInt(expression /*e*/);
extern int NumberOfDimension(entity /*e*/);
extern void set_entity_to_size(void);
extern void reset_entity_to_size(void);
extern void safe_reset_entity_to_size(void);
extern int storage_space_of_variable(entity /*v*/);
extern bool variable_entities_may_conflict_p(entity /*e1*/, entity /*e2*/);
/* pragma.c */
extern const string FORTRAN_PRAGMA_HEADER;
extern const string FORTRAN_OMP_CONTINUATION;
extern expression pragma_build_if_condition(expression /*cond*/, language /*l*/);
extern expression pragma_if_as_expr(expression /*arg*/);
extern expression pragma_private_as_expr_with_args(list /*args_expr*/);
extern expression pragma_private_as_expr(list /*args_ent*/);
extern list pragma_omp_parallel_as_exprs(void);
extern list pragma_omp_parallel_for_as_exprs(void);
extern list filter_variables_in_pragma_expr(list /*l_expr*/, list /*to_filter*/);
extern list pragma_omp_merge_expr(list /*outer_extensions*/, list /*l_pragma*/, language /*l*/);
extern void add_pragma_str_to_statement(statement /*st*/, const char */*s*/, bool /*copy_flag*/);
extern void add_pragma_strings_to_statement(statement /*st*/, list /*l*/, bool /*copy_flag*/);
extern void add_pragma_expr_to_statement(statement /*st*/, list /*l*/);
/* extension.c */
extern extensions empty_extensions(void);
extern bool empty_extensions_p(extensions /*es*/);
/* area.c */
extern entity DynamicArea;
extern entity StaticArea;
extern entity HeapArea;
extern entity StackArea;
extern entity AllocatableArea;
extern bool allocatable_area_p(entity /*aire*/);
extern bool dynamic_area_p(entity /*aire*/);
extern bool static_area_p(entity /*aire*/);
extern bool heap_area_p(entity /*aire*/);
extern bool formal_area_p(entity /*aire*/);
extern bool stack_area_p(entity /*aire*/);
extern bool pointer_dummy_targets_area_p(entity /*aire*/);
extern entity module_to_heap_area(entity /*f*/);
extern entity module_to_dynamic_area(entity /*f*/);
extern bool entity_area_p(entity /*e*/);
extern bool entity_special_area_p(entity /*e*/);
extern int current_offset_of_area(entity /*a*/, entity /*v*/);
extern bool empty_static_area_p(entity /*e*/);
extern void print_common_layout(FILE */*fd*/, entity /*c*/, bool /*debug_p*/);
/* util.c */
extern entity find_label_entity(const char */*module_name*/, const char */*label_local_name*/);
extern string module_codefilename(entity /*e*/);
extern string module_par_codefilename(entity /*e*/);
extern string module_fortranfilename(entity /*e*/);
extern string module_par_fortranfilename(entity /*e*/);
extern string module_pp_fortranfilename(entity /*e*/);
extern string module_predicat_fortranfilename(entity /*e*/);
extern string module_entitiesfilename(entity /*e*/);
extern entity find_ith_parameter(entity /*e*/, int /*i*/);
extern bool ith_parameter_p(entity /*f*/, entity /*v*/, int /*i*/);
extern expression reference_ith_index(reference /*ref*/, int /*i*/);
extern bool comment_string_p(const string /*comment*/);
extern string string_remove_trailing_line_feed(string /*s*/);
extern string string_remove_trailing_line_feeds(string /*s*/);
extern string string_strip_final_linefeeds(string /*s*/);
extern string string_fuse_final_linefeeds(string /*s*/);
/* ordering.c */
extern bool ordering_to_statement_initialized_p(void);
extern void print_ordering_to_statement(void);
extern statement ordering_to_statement(int /*o*/);
extern bool add_ordering_of_the_statement_to_current_mapping(statement /*stat*/);
extern bool overwrite_ordering_of_the_statement_to_current_mapping(statement /*stat*/);
extern hash_table set_ordering_to_statement(statement /*s*/);
extern void reset_ordering_to_statement(void);
/* declarations.c */
extern void check_fortran_declaration_dependencies(list /*ldecl*/);
extern list get_common_members(entity /*common*/, entity /*module*/, bool /*only_primary*/);
extern void print_C_common_layout(FILE */*fd*/, entity /*c*/, bool /*debug_p*/);
extern void fprint_functional(FILE */*fd*/, functional /*f*/);
extern void fprint_environment(FILE */*fd*/, entity /*m*/);
extern void fprint_C_environment(FILE */*fd*/, entity /*m*/);
extern void fprint_any_environment(FILE */*fd*/, entity /*m*/, bool /*is_fortran*/);
extern void split_initializations_in_statement(statement /*s*/);
extern void dump_functional(functional /*f*/, string_buffer /*result*/);
/* loop.c */
extern int Nbrdo;
extern bool enclosing_loops_map_undefined_p(void);
extern void set_enclosing_loops_map(statement_mapping /*m*/);
extern statement_mapping get_enclosing_loops_map(void);
extern void reset_enclosing_loops_map(void);
extern void free_enclosing_loops_map(void);
extern void make_enclosing_loops_map(void);
extern list load_statement_enclosing_loops(statement /*s*/);
extern void delete_statement_enclosing_loops(statement /*s*/);
extern bool statement_enclosing_loops_undefined_p(statement /*s*/);
extern void store_statement_enclosing_loops(statement /*s*/, list /*t*/);
extern void update_statement_enclosing_loops(statement /*s*/, list /*t*/);
extern void clean_enclosing_loops(void);
extern statement_mapping loops_mapping_of_statement(statement /*stat*/);
extern set distributable_loop(statement /*l*/);
extern bool index_private_p(loop /*lo*/);
extern set region_of_loop(statement /*l*/);
extern void region_of_statement(statement /*stat*/, set /*region*/);
extern list loop_private_variables_as_entites(loop /*obj*/, bool /*local*/, bool /*index*/);
extern void sort_all_loop_locals(statement /*s*/);
extern bool loop_parallel_p(loop /*l*/);
extern bool loop_sequential_p(loop /*l*/);
extern bool parallel_loop_statement_p(statement /*s*/);
extern int depth_of_parallel_perfect_loop_nest(statement /*s*/);
extern int depth_of_perfect_loop_nest(statement /*s*/);
extern statement get_first_inner_perfectly_nested_loop(statement /*stat*/);
extern bool perfectly_nested_loop_p(statement /*stat*/);
extern statement perfectly_nested_loop_to_body(statement /*loop_nest*/);
extern statement perfectly_nested_loop_to_body_at_depth(statement /*s*/, int /*depth*/);
extern entity perfectly_nested_loop_index_at_depth(statement /*s*/, int /*depth*/);
extern int loop_increment_value(loop /*l*/);
extern bool constant_step_loop_p(loop /*l*/);
extern bool normal_loop_p(loop /*l*/);
extern void number_of_sequential_and_parallel_loops(statement /*stat*/, int */*pseq*/, int */*ppar*/);
extern void print_number_of_loop_statistics(FILE */*out*/, string /*msg*/, statement /*s*/);
extern void print_parallelization_statistics(const char */*module*/, const char */*msg*/, statement /*s*/);
extern list copy_loops(list /*ll*/);
extern statement make_new_loop_statement(entity /*i*/, expression /*low*/, expression /*up*/, expression /*inc*/, statement /*b*/, execution /*e*/);
extern list statement_to_loop_statement_list(statement /*s*/);
extern bool range_contains_at_least_one_point_p(range /*r*/);
extern bool loop_executed_at_least_once_p(loop /*l*/);
extern bool range_contains_nothing_p(range /*r*/);
extern bool loop_executed_never_p(loop /*l*/);
extern bool index_of_a_loop_p(Variable /*v*/, list /*loops*/);
/* fortran90.c */
extern expression update_range(entity /*f*/, range /*r*/, expression /*lw*/, expression /*up*/, expression /*in*/, bool /*left*/);
/* constant.c */
extern int DefaultLengthOfBasic(tag /*t*/);
extern bool integer_constant_name_p(string /*name*/);
extern _int TK_CHARCON_to__int(const char */*name*/);
extern entity make_C_or_Fortran_constant_entity(const char */*name*/, tag /*bt*/, size_t /*size*/, bool /*is_fortran*/, bool (* /*error_manager*/)(const char *, const char *));
extern entity make_constant_entity(string /*name*/, tag /*bt*/, size_t /*size*/);
extern entity SafeMakeConstant(string /*name*/, tag /*bt*/, bool (* /*error_manager*/)(const char *, const char *));
extern entity MakeConstant(string /*name*/, tag /*bt*/);
extern bool constant_string_entity_p(entity /*e*/);
extern entity MakeComplexConstant(expression /*r*/, expression /*i*/);
extern expression MakeComplexConstantExpression(expression /*r*/, expression /*i*/);
extern bool complex_constant_expression_p(expression /*cce*/);
extern entity float_to_entity(float /*c*/);
extern entity int_to_entity(_int /*c*/);
extern bool logical_constant_p(entity /*ent*/);
extern bool float_constant_p(entity /*ent*/);
extern bool integer_constant_p(entity /*ent*/, int */*int_p*/);
extern bool integer_symbolic_constant_p(entity /*ent*/, int */*int_p*/);
extern expression MakeCharacterConstantExpression(string /*s*/);
extern value MakeValueSymbolic(expression /*e*/);
extern bool signed_constant_expression_p(expression /*e*/);
extern basic constant_basic(entity /*c*/);
extern double float_constant_to_double(entity /*c*/);
extern bool expression_is_constant_p(expression /*e*/);
/* constraint.c */
extern void vect_debug(Pvecteur /*v*/);
extern int compare_Pvecteur(Pvecteur */*pv1*/, Pvecteur */*pv2*/);
extern bool vecteur_nul_p(Pvecteur /*v*/);
/* bound_generation.c */
extern int bound_generation_compare_vector_component(Pvecteur */*pv1*/, Pvecteur */*pv2*/);
extern void make_bound_expression(Variable /*index*/, Pbase /*base*/, Psysteme /*sc*/, expression */*lower*/, expression */*upper*/);
/* entity.c */
extern void set_std_static_entities(void);
extern void set_internal_static_entities(void);
extern void reset_internal_static_entities(void);
extern void reset_std_static_entities(void);
extern void reset_static_entities(void);
extern void register_static_entity(entity */*e*/);
extern void print_entities(list /*l*/);
extern void print_entity_set(set /*s*/);
extern entity make_empty_module(const char */*full_name*/, type /*r*/, language /*l*/);
extern entity make_empty_program(const char */*name*/, language /*l*/);
extern entity make_empty_subroutine(const char */*name*/, language /*l*/);
extern entity make_empty_f95module(const char */*name*/, language /*l*/);
extern entity make_empty_function(const char */*name*/, type /*r*/, language /*l*/);
extern entity make_empty_blockdata(const char */*name*/, language /*l*/);
extern code EntityCode(entity /*e*/);
extern entity make_label(const char */*module_name*/, const char */*local_name*/);
extern void reset_label_counter(void);
extern char *new_label_local_name(entity /*module*/);
extern entity make_new_label(entity /*module*/);
extern entity make_loop_label(int /*desired_number*/, entity /*module*/);
extern bool label_defined_in_statement_p(entity /*l*/, statement /*s*/);
extern bool label_defined_in_current_module_p(entity /*l*/);
extern bool label_string_defined_in_current_module_p(string /*ls*/);
extern bool label_string_defined_in_statement_p(string /*ls*/, statement /*s*/);
extern string safe_entity_name(entity /*e*/);
extern const char *entity_local_name(entity /*e*/);
extern string entity_global_name(entity /*e*/);
extern const char *entity_user_name(entity /*e*/);
extern string empty_scope(void);
extern bool empty_scope_p(string /*s*/);
extern bool string_struct_scope_p(string /*s*/);
extern bool string_block_scope_p(string /*s*/);
extern string entity_name_without_scope(entity /*e*/);
extern string local_name_to_scope(const char */*ln*/);
extern const char *module_local_name(entity /*e*/);
extern const char *module_resource_name(entity /*e*/);
extern const char *label_local_name(entity /*e*/);
extern bool label_name_conflict_with_labels(const char */*n*/, list /*ll*/);
extern const char *entity_name_or_TCST(entity /*e*/);
extern const char *entity_and_common_name(entity /*e*/);
extern bool entity_empty_label_p(entity /*e*/);
extern bool entity_return_label_p(entity /*e*/);
extern bool entity_label_p(entity /*e*/);
extern bool entity_module_p(entity /*e*/);
extern bool entity_f95use_p(entity /*e*/);
extern bool entity_main_module_p(entity /*e*/);
extern bool entity_f95module_p(entity /*e*/);
extern bool entity_blockdata_p(entity /*e*/);
extern bool entity_common_p(entity /*e*/);
extern bool entity_function_p(entity /*e*/);
extern bool entity_subroutine_p(entity /*e*/);
extern bool entity_pointer_p(entity /*e*/);
extern bool entity_array_p(entity /*e*/);
extern bool entity_register_p(entity /*e*/);
extern void set_register_qualifier(entity /*v*/);
extern bool array_entity_p(entity /*e*/);
extern bool entity_variable_length_array_p(entity /*e*/);
extern bool assumed_size_array_p(entity /*e*/);
extern bool pointer_type_array_p(entity /*e*/);
extern bool unnormalized_array_p(entity /*e*/);
extern bool entity_field_p(entity /*e*/);
extern entity entity_field_to_entity_struct(entity /*f*/);
extern entity entity_field_to_entity_union(entity /*f*/);
extern entity entity_field_to_entity_struct_or_union(entity /*f*/);
extern int entity_field_rank(entity /*f*/);
extern bool entity_enum_p(entity /*e*/);
extern bool entity_enum_member_p(entity /*e*/);
extern bool entity_enum_variable_p(entity /*e*/);
extern bool entity_struct_p(entity /*e*/);
extern bool same_struct_entity_p(const entity /*e0*/, const entity /*e1*/);
extern bool entity_union_p(entity /*e*/);
extern bool derived_entity_p(entity /*e*/);
extern bool local_entity_of_module_p(entity /*e*/, entity /*module*/);
extern bool entity_in_common_p(entity /*e*/);
extern const char *entity_module_name(entity /*e*/);
extern code entity_code(entity /*e*/);
extern entity entity_empty_label(void);
extern bool top_level_entity_p(entity /*e*/);
extern bool io_entity_p(entity /*e*/);
extern bool io_luns_entity_p(entity /*e*/);
extern bool rand_effects_entity_p(entity /*e*/);
extern bool malloc_effect_entity_p(entity /*e*/);
extern bool memmove_effect_entity_p(entity /*e*/);
extern bool time_effect_entity_p(entity /*e*/);
extern bool effects_package_entity_p(entity /*e*/);
extern entity get_stdin_entity(void);
extern bool stdin_entity_p(entity /*e*/);
extern entity get_stdout_entity(void);
extern bool stdout_entity_p(entity /*e*/);
extern entity get_stderr_entity(void);
extern bool stderr_entity_p(entity /*e*/);
extern bool std_file_entity_p(entity /*e*/);
extern entity std_file_entity_to_pointed_file_entity(entity /*e*/);
extern bool intrinsic_entity_p(entity /*e*/);
extern bool symbolic_entity_p(entity /*e*/);
extern bool intrinsic_name_p(const char */*local_name*/);
extern entity entity_intrinsic(const char */*name*/);
extern entity CreateIntrinsic(string /*name*/);
extern bool same_entity_p(entity /*e1*/, entity /*e2*/);
extern int compare_entities(const entity */*pe1*/, const entity */*pe2*/);
extern void sort_list_of_entities(list /*l*/);
extern bool lexicographic_order_p(entity /*var1*/, entity /*var2*/);
extern basic entity_basic(entity /*e*/);
extern list entity_qualifiers(entity /*e*/);
extern bool entity_basic_p(entity /*e*/, enum basic_utype /*basictag*/);
extern bool entity_list_p(list /*el*/);
extern entity local_name_to_top_level_entity(const char */*n*/);
extern entity module_name_to_entity(const char */*mn*/);
extern entity module_name_to_runtime_entity(const char */*name*/);
extern entity FindEntity(const char */*package*/, const char */*name*/);
extern entity global_name_to_entity(const char */*name*/);
extern entity FindEntityFromUserName(const char */*package*/, const char */*name*/);
extern entity CreateEntity(const char */*package_name*/, const char */*local_name*/);
extern entity FindOrCreateEntity(const char */*package*/, const char */*local_name*/);
extern entity FindOrCreateTopLevelEntity(const char */*name*/);
extern expression entity_ith_bounds(entity /*e*/, int /*i*/);
extern bool io_intrinsic_p(entity /*e*/);
extern bool arithmetic_intrinsic_p(entity /*e*/);
extern entity get_continue_entity(void);
extern bool entity_continue_p(entity /*f*/);
extern list common_members_of_module(entity /*common*/, entity /*module*/, bool /*only_primary*/);
extern entity make_new_common(string /*name*/, entity /*mod*/);
extern entity make_new_integer_scalar_common_variable(string /*name*/, entity /*mod*/, entity /*com*/);
extern entity find_ith_formal_parameter(entity /*the_fnct*/, int /*rank*/);
extern list string_to_entity_list(string /*module*/, string /*names*/);
extern bool typedef_entity_p(entity /*e*/);
extern bool member_entity_p(entity /*e*/);
extern bool entity_formal_p(entity /*p*/);
extern bool dummy_parameter_entity_p(entity /*p*/);
extern entity MakeCompilationUnitEntity(const char */*name*/);
extern bool extern_entity_p(entity /*module*/, entity /*e*/);
extern bool explicit_extern_entity_p(entity /*module*/, entity /*e*/);
extern string storage_to_string(storage /*s*/);
extern entity entity_to_module_entity(entity /*e*/);
extern void update_dummy_parameter(parameter /*p*/, entity /*ep*/);
extern bool parameter_passing_mode_p(entity /*f*/, int tag);
extern bool parameter_passing_by_value_p(entity /*f*/);
extern bool parameter_passing_by_reference_p(entity /*f*/);
extern char *AddPackageToName(string /*p*/, string /*n*/);
extern entity update_operator_to_regular_operator(entity /*op*/);
extern bool entity_equivalence_p(entity /*e*/);
extern bool same_entity_name_p(entity /*e1*/, entity /*e2*/);
extern bool entity_in_list_p(entity /*ent*/, list /*ent_l*/);
extern list concat_new_entities(list /*l1*/, list /*l2*/);
extern bool entity_used_in_declarations_p(entity /*e*/, list /*ldecl*/);
extern bool type_used_in_type_declarations_p(entity /*e*/, list /*ldecl*/);
extern entity make_entity_copy(entity /*e*/);
extern entity make_entity_copy_with_new_name(entity /*e*/, string /*global_new_name*/, bool /*move_initialization_p*/);
extern entity make_entity_copy_with_new_name_and_suffix(entity /*e*/, string /*global_new_name*/, bool /*move_initialization_p*/);
extern void add_thread_safe_variable(entity /*v*/);
extern bool thread_safe_variable_p(entity /*v*/);
extern void add_abstract_state_variable(entity /*v*/);
extern bool abstract_state_variable_p(entity /*v*/);
extern bool entities_p(list /*el*/);
extern entity operator_neutral_element(entity /*op*/);
extern bool commutative_call_p(call /*c*/);
extern list entities_to_expressions(list /*l_ent*/);
extern entity find_enum_of_member(entity /*m*/);
extern bool c_module_p(entity /*m*/);
extern bool fortran_module_p(entity /*m*/);
extern list extract_references_from_declarations(list /*decls*/);
extern Pbase entity_list_to_base(list /*l*/);
extern set get_referenced_entities_filtered(void */*elem*/, bool (* /*chunk_filter*/)(void *), bool (* /*entity_filter*/)(entity));
extern bool entity_not_constant_or_intrinsic_p(entity /*e*/);
extern set get_referenced_entities(void */*elem*/);
extern bool do_get_declared_entities(statement /*s*/, set /*declared_entities*/);
extern set get_declared_entities(void */*elem*/);
extern bool entity_local_variable_p(entity /*var*/, entity /*module*/);
extern entity FindOrCreateEntityLikeModel(const char */*package*/, const char */*name*/, entity /*model*/);
extern entity AddEntityToModule(entity /*e*/, entity /*module*/);
extern void fprint_entity_list(FILE */*fp*/, list /*l*/);
/* variable.c */
extern bool variable_entity_p(entity /*e*/);
extern bool symbolic_constant_entity_p(entity /*e*/);
extern void AddEntityToDeclarations(entity /*e*/, entity /*module*/);
extern void RemoveLocalEntityFromDeclarations(entity /*e*/, entity /*module*/, statement /*s*/);
extern void AddLocalEntityToDeclarations(entity /*e*/, entity /*module*/, statement /*s*/);
extern void AddLocalEntityToDeclarationsOnly(entity /*e*/, entity /*module*/, statement /*s*/);
extern void AddEntityToCurrentModule(entity /*e*/);
extern void AddEntityToCurrentModuleWithoutDeclaration(entity /*e*/);
extern entity make_global_entity_from_local(entity /*local*/);
extern entity make_stderr_variable(void);
extern entity make_scalar_entity(const char */*name*/, const char */*module_name*/, basic /*base*/);
extern entity make_derived_entity(const char */*name*/, const char */*module_name*/, type /*t*/);
extern void reset_unique_variable_numbers(void);
extern entity generate_variable_with_unique_name_to_module(const char */*seed_name*/, const char */*prefix*/, const char */*suffix*/, entity /*module*/);
extern entity generic_clone_variable_with_unique_name(entity /*old_variable*/, statement /*declaration_statement*/, string /*prefix*/, string /*suffix*/, entity /*module*/, bool /*insert_p*/);
extern entity clone_variable_with_unique_name(entity /*old_variable*/, statement /*declaration_statement*/, string /*prefix*/, string /*suffix*/, entity /*module*/);
extern entity make_new_scalar_variable_with_prefix(const char */*prefix*/, entity /*module*/, basic /*b*/);
extern entity make_new_derived_entity_with_prefix(const char */*prefix*/, entity /*module*/, type /*t*/);
extern entity make_new_scalar_variable(entity /*module*/, basic /*b*/);
extern entity make_new_array_variable_with_prefix(const char */*prefix*/, entity /*module*/, basic /*b*/, list /*dimensions*/);
extern entity make_new_array_variable(entity /*module*/, basic /*b*/, list /*dimensions*/);
extern entity make_temporary_pointer_to_array_entity_with_prefix(char */*prefix*/, entity /*efrom*/, entity /*module*/, expression /*from*/);
extern entity make_temporary_pointer_to_array_entity(entity /*efrom*/, expression /*from*/, entity /*module*/);
extern entity make_new_module_variable(entity /*module*/, int /*d*/);
extern list integer_entities;
extern list real_entities;
extern list logical_entities;
extern list complex_entities;
extern list double_entities;
extern list char_entities;
extern entity make_new_entity(basic /*ba*/, int /*kind*/);
extern entity find_or_create_scalar_entity(const char */*name*/, const char */*module_name*/, tag /*base*/);
extern entity find_or_create_typed_entity(string /*name*/, const char */*module_name*/, tag /*base*/);
extern entity make_scalar_integer_entity(const char */*name*/, const char */*module_name*/);
extern bool entity_scalar_p(entity /*e*/);
extern bool entity_integer_scalar_p(entity /*e*/);
extern bool integer_scalar_entity_p(entity /*e*/);
extern bool entity_static_variable_p(entity /*e*/);
extern bool entity_atomic_reference_p(entity /*e*/);
extern bool entity_non_pointer_scalar_p(entity /*e*/);
extern dimension entity_ith_dimension(entity /*e*/, int /*i*/);
extern bool entity_unbounded_p(entity /*e*/);
extern bool array_with_numerical_bounds_p(entity /*a*/);
extern int variable_entity_dimension(entity /*v*/);
extern void remove_variable_entity(entity /*v*/);
extern entity make_integer_constant_entity(_int /*c*/);
extern int add_variable_to_area(entity /*a*/, entity /*v*/);
extern int add_C_variable_to_area(entity /*a*/, entity /*v*/);
extern int add_any_variable_to_area(entity /*a*/, entity /*v*/, bool /*is_fortran_p*/);
extern int new_add_any_variable_to_area(entity /*a*/, entity /*v*/, bool /*is_fortran_p*/);
extern bool formal_parameter_p(entity /*v*/);
extern bool static_global_variable_p(entity /*v*/);
extern bool global_variable_p(entity /*v*/);
extern bool variable_return_p(entity /*v*/);
extern bool variable_is_a_module_formal_parameter_p(entity /*a_variable*/, entity /*a_module*/);
extern bool variable_in_common_p(entity /*v*/);
extern bool variable_static_p(entity /*v*/);
extern bool variable_dynamic_p(entity /*v*/);
extern bool variable_stack_p(entity /*v*/);
extern bool variable_heap_p(entity /*v*/);
extern bool variable_in_module_p(entity /*v*/, entity /*m*/);
extern bool variable_in_list_p(entity /*e*/, list /*l*/);
extern bool entity_volatile_variable_p(entity /*v*/);
extern bool volatile_variable_p(variable /*v*/);
extern bool qualified_variable_p(entity /*v*/, unsigned int /*is_qualified*/);
extern bool const_variable_p(entity /*v*/);
extern void discard_module_declaration_text(entity /*a_module*/);
extern entity get_ith_dummy(string /*prefix*/, string /*suffix*/, int /*i*/);
extern expression generate_string_for_alternate_return_argument(string /*i*/);
extern entity generate_pseudo_formal_variable_for_formal_label(const char */*p*/, int /*l*/);
extern bool formal_label_replacement_p(entity /*fp*/);
extern bool actual_label_replacement_p(expression /*eap*/);
extern bool call_contains_alternate_returns_p(call /*c*/);
extern entity make_new_index_entity(entity /*old_index*/, string /*suffix*/);
extern bool implicit_c_variable_p(entity /*v*/);
extern expression variable_initial_expression(entity /*v*/);
extern bool self_initialization_p(entity /*v*/);
extern bool same_scalar_location_p(entity /*e1*/, entity /*e2*/);
extern list struct_variable_to_fields(entity /*v*/);
extern entity make_place_holder_variable(entity /*de*/);
extern bool place_holder_variable_p(entity /*ph*/);
/* instruction.c */
extern instruction make_call_instruction(entity /*e*/, list /*l*/);
extern instruction MakeNullaryCallInst(entity /*f*/);
extern instruction MakeUnaryCallInst(entity /*f*/, expression /*e*/);
extern instruction make_continue_instruction(void);
extern instruction make_assign_instruction(expression /*l*/, expression /*r*/);
extern instruction make_instruction_block(list /*statements*/);
extern bool native_call_p(call /*c*/, string /*op_name*/);
extern bool native_instruction_p(instruction /*i*/, string /*op_name*/);
extern bool instruction_assign_p(instruction /*i*/);
extern bool instruction_continue_p(instruction /*i*/);
extern bool return_instruction_p(instruction /*i*/);
extern bool fortran_return_instruction_p(instruction /*i*/);
extern bool C_return_instruction_p(instruction /*i*/);
extern bool exit_instruction_p(instruction /*i*/);
extern bool abort_instruction_p(instruction /*i*/);
extern bool instruction_stop_p(instruction /*i*/);
extern bool instruction_format_p(instruction /*i*/);
extern bool assignment_block_p(instruction /*i*/);
extern void flatten_block_if_necessary(instruction /*i*/);
extern string instruction_identification(instruction /*i*/);
extern string safe_instruction_identification(instruction /*i*/);
/* statement.c */
extern bool empty_code_p(statement /*s*/);
extern bool empty_code_list_p(list /*l*/);
extern bool empty_comments_p(const char */*s*/);
extern bool comments_equal_p(string /*c1*/, string /*c2*/);
extern bool statement_with_empty_comment_p(statement /*s*/);
extern bool assignment_statement_p(statement /*s*/);
extern bool assignment_block_or_statement_p(statement /*s*/);
extern bool return_statement_p(statement /*s*/);
extern bool exit_statement_p(statement /*s*/);
extern bool abort_statement_p(statement /*s*/);
extern bool fortran_return_statement_p(statement /*s*/);
extern bool C_return_statement_p(statement /*s*/);
extern bool continue_statement_p(statement /*s*/);
extern bool forloop_statement_p(statement /*s*/);
extern bool declaration_statement_p(statement /*s*/);
extern bool continue_statements_p(list /*sl*/);
extern bool stop_statement_p(statement /*s*/);
extern bool format_statement_p(statement /*s*/);
extern bool write_statement_p(statement /*s*/);
extern bool statement_less_p(statement /*st1*/, statement /*st2*/);
extern bool statement_possible_less_p(statement /*st1*/, statement /*st2*/);
extern bool statement_sequence_p(statement /*s*/);
extern bool statement_test_p(statement /*s*/);
extern bool statement_loop_p(statement /*s*/);
extern bool statement_whileloop_p(statement /*s*/);
extern bool statement_goto_p(statement /*s*/);
extern bool statement_call_p(statement /*s*/);
extern bool statement_unstructured_p(statement /*s*/);
extern bool statement_forloop_p(statement /*s*/);
extern bool statement_multitest_p(statement /*s*/);
extern bool statement_expression_p(statement /*s*/);
extern bool empty_statement_p(statement /*st*/);
extern bool unlabelled_statement_p(statement /*st*/);
extern bool nop_statement_p(statement /*s*/);
extern bool empty_statement_or_labelless_continue_p(statement /*st*/);
extern bool empty_statement_or_continue_p(statement /*st*/);
extern bool empty_statement_or_continue_without_comment_p(statement /*st*/);
extern bool check_io_statement_p(statement /*s*/);
extern string comments_dup(string /*comment*/);
extern string decls_text_dup(string /*dt*/);
extern statement make_assign_statement(expression /*l*/, expression /*r*/);
extern statement instruction_to_statement(instruction /*instr*/);
extern statement make_block_statement(list /*body*/);
extern statement make_empty_block_statement(void);
extern statement make_empty_statement_with_declarations_and_comments(list /*d*/, string /*dt*/, string /*c*/);
extern void move_statement_attributes(statement /*from*/, statement /*to*/);
extern void copy_statement_attributes(statement /*from*/, statement /*to*/);
extern statement make_statement_from_statement_list_or_empty_block(list /*l*/);
extern statement make_statement_from_statement_list(list /*l*/);
extern statement make_statement_from_statement_varargs_list(statement /*s*/, ...);
extern statement make_block_with_stmt_if_not_already(statement /*stmt*/);
extern statement make_return_statement(entity /*module*/);
extern instruction make_simple_Fortran_io_instruction(bool /*is_read_p*/, expression /*f*/, list /*io_list*/);
extern statement make_print_statement(string /*message*/);
extern statement make_C_print_statement(string /*message*/);
extern statement make_any_print_statement(string /*message*/);
extern statement make_stop_statement(string /*message*/);
extern statement make_exit_statement(int /*n*/, string /*errmess*/);
extern statement make_continue_statement(entity /*l*/);
extern statement make_plain_continue_statement(void);
extern statement make_declarations_statement(list /*idl*/, int /*sn*/, string /*cs*/);
extern statement make_declaration_statement(entity /*v*/, int /*sn*/, string /*cs*/);
extern bool declaration_statements_p(list /*sl*/);
extern statement add_initialization_information_to_declaration_statement(statement /*s*/, list /*iel*/);
extern list declaration_statement_to_initializations(statement /*s*/);
extern statement make_whileloop_statement(expression /*condition*/, statement /*s*/, int /*line_number*/, bool /*before*/);
extern statement make_call_statement(string /*function_name*/, list /*args*/, entity /*l*/, string /*c*/);
extern statement make_expression_statement(expression /*e*/);
extern sequence statement_sequence(statement /*s*/);
extern list statement_block(statement /*s*/);
extern test statement_test(statement /*s*/);
extern statement effective_test_true(test /*t*/);
extern loop statement_loop(statement /*s*/);
extern whileloop statement_whileloop(statement /*s*/);
extern statement statement_goto(statement /*s*/);
extern call statement_call(statement /*s*/);
extern unstructured statement_unstructured(statement /*s*/);
extern forloop statement_forloop(statement /*s*/);
extern multitest statement_multitest(statement /*s*/);
extern expression statement_expression(statement /*s*/);
extern statement apply_number_to_statement(hash_table /*nts*/, _int /*n*/);
extern hash_table build_number_to_statement(hash_table /*nts*/, statement /*s*/);
extern hash_table allocate_number_to_statement(void);
extern statement clear_labels(statement /*s*/);
extern void clear_label(statement /*s*/);
extern statement st_make_nice_test(expression /*condition*/, list /*ltrue*/, list /*lfalse*/);
extern statement makeloopbody(loop /*l*/, statement /*s_old*/, bool /*inner_p*/);
extern string external_statement_identification(statement /*s*/);
extern string statement_identification(statement /*s*/);
extern string safe_statement_identification(statement /*s*/);
extern string gather_all_comments_of_a_statement(statement /*s*/);
extern char **find_first_statement_comment(statement /*s*/);
extern bool try_to_put_a_comment_on_a_statement(statement /*s*/, string /*the_comments*/);
extern void put_a_comment_on_a_statement(statement /*s*/, string /*the_comments*/);
extern void append_comments_to_statement(statement /*s*/, string /*the_comments*/);
extern void insert_comments_to_statement(statement /*s*/, const char */*the_comments*/);
extern void add_one_line_of_comment(statement /*s*/, string /*format*/, ...);
extern statement add_comment_and_line_number(statement /*s*/, string /*sc*/, int /*sn*/);
extern void fix_sequence_statement_attributes(statement /*s*/);
extern void fix_statement_attributes_if_sequence(statement /*s*/);
extern entity statement_to_label(statement /*s*/);
extern statement add_label_to_statement(entity /*label*/, statement /*s*/, statement */*labeled_statement*/);
extern bool statement_does_return(statement /*s*/);
extern bool unstructured_does_return(unstructured /*u*/);
extern void gather_and_remove_all_format_statements_rewrite(statement /*s*/, list */*all_formats*/);
extern list gather_and_remove_all_format_statements(statement /*s*/);
extern void put_formats_at_module_beginning(statement /*s*/);
extern void put_formats_at_module_end(statement /*s*/);
extern bool figure_out_if_it_is_a_format(instruction /*i*/, bool */*format_inside_statement_has_been_found*/);
extern bool format_inside_statement_p(statement /*s*/);
extern int statement_to_comment_length(statement /*stmt*/);
extern persistant_statement_to_int statement_to_line_number(statement /*s*/);
extern void insert_statement(statement /*s*/, statement /*s1*/, bool /*before*/);
extern void insert_statement_no_matter_what(statement /*s*/, statement /*s1*/, bool /*before*/);
extern void append_statement_to_block_statement(statement /*b*/, statement /*s*/);
extern void push_generated_variable_commenter(string (* /*commenter*/)(entity));
extern void pop_generated_variable_commenter(void);
extern string generated_variable_comment(entity /*e*/);
extern statement add_declaration_statement(statement /*s*/, entity /*e*/);
extern statement add_declaration_statement_at_beginning(statement /*s*/, entity /*e*/);
extern void fix_block_statement_declarations(statement /*s*/);
extern statement remove_declaration_statement(statement /*s*/, entity /*e*/);
extern statement update_statement_instruction(statement /*s*/, instruction /*i*/);
extern void statement_replace_with_statement_list(statement /*as*/, statement /*rs*/, list /*sl*/);
extern list statement_to_implicit_target_labels(statement /*s*/);
extern list statement_to_labels(statement /*s*/);
extern bool all_statements_defined_p(statement /*s*/);
extern list statement_to_declarations(void */*s*/);
extern list statements_to_declarations(list /*sl*/);
extern list instruction_to_declarations(instruction /*i*/);
extern list statements_to_direct_declarations(list /*sl*/);
extern list statement_to_direct_declarations(statement /*s*/);
extern list statement_to_referenced_entities(statement /*s*/);
extern list statement_to_called_user_entities(statement /*s*/);
extern reference find_reference_to_variable(statement /*s*/, entity /*v*/);
extern int count_static_references_to_variable(statement /*s*/, entity /*v*/);
extern int count_references_to_variable(statement /*s*/, entity /*v*/);
extern int count_references_to_variable_element(statement /*s*/, entity /*v*/);
extern bool statement_substatement_walker(statement /*some*/, statement /*s*/);
extern bool statement_substatement_p(statement /*s*/, statement /*root*/);
extern int get_statement_depth(statement /*s*/, statement /*root*/);
extern statement find_statement_from_label(statement /*s*/, entity /*label*/);
extern statement find_statement_from_label_name(statement /*s*/, const char */*module_name*/, const char */*label_name*/);
extern bool statement_with_pragma_p(statement /*s*/);
extern extension get_extension_from_statement_with_pragma(statement /*s*/, const char */*seed*/);
extern list find_statements_with_pragma(statement /*s*/, const char */*begin*/);
extern bool statement_contains_user_call_p(statement /*s*/);
extern bool statement_may_have_control_effects_p(statement /*s*/);
extern bool statement_may_contain_exiting_intrinsic_call_p(statement /*s*/);
extern statement normalize_statement(statement /*s*/);
extern bool statement_in_statement_p(statement /*s*/, statement /*st*/);
extern bool statement_in_statements_p(statement /*s*/, list /*l*/);
extern void statement_remove_extensions(statement /*s*/);
extern void statement_remove_useless_label(statement /*s*/, bool */*changed*/);
extern bool belong_to_statement(statement /*stmt*/, statement /*s*/, bool /*found_p*/);
extern entity find_final_statement_label(statement /*s*/);
extern string comment_sentinel(tag /*t*/);
/* reorder.c */
extern void reset_unstructured_number(void);
extern void control_node_reorder(control /*c*/, set /*visited_control*/);
extern bool unstructured_reorder(unstructured /*u*/);
extern bool module_body_reorder(statement /*body*/);
extern bool module_reorder(statement /*body*/);
/* clean_up_sequences.c */
extern hash_table statement_to_goto_table;
extern void initialize_clean_up_sequences_statistics(void);
extern void display_clean_up_sequences_statistics(void);
extern bool statement_to_goto_table_flt(instruction /*i*/);
extern void compute_statement_to_goto_table(statement /*s*/);
extern void discard_statement_to_goto_table(void);
extern void adjust_goto_from_to(statement /*s1*/, statement /*s2*/);
extern bool clean_up_sequences_internal(statement /*s*/);
extern bool clean_up_sequences(statement /*s*/);
/* expression.c */
extern int fortran_string_compare(string /*fs1*/, string /*fs2*/);
extern tag suggest_basic_for_expression(expression /*e*/);
extern expression expression_mult(expression /*ex*/);
extern expression entity_to_expression(entity /*e*/);
extern expression make_entity_expression(entity /*e*/, cons */*inds*/);
extern expression reference_to_expression(reference /*r*/);
extern reference expression_to_reference(expression /*e*/);
extern reference add_subscript_to_reference(reference /*r*/, expression /*s*/);
extern void generic_reference_add_fixed_subscripts(reference /*r*/, type /*t*/, bool /*zero_p*/);
extern void reference_add_zero_subscripts(reference /*r*/, type /*t*/);
extern void reference_add_zero_subscript(reference /*r*/);
extern void reference_complete_with_zero_subscripts(reference /*r*/);
extern void reference_add_unbounded_subscripts(reference /*r*/, type /*t*/);
extern expression call_to_expression(call /*c*/);
extern expression make_call_expression(entity /*e*/, list /*l*/);
extern expression MakeNullaryCall(entity /*f*/);
extern expression MakeUnaryCall(entity /*f*/, expression /*a*/);
extern expression MakeBinaryCall(entity /*f*/, expression /*eg*/, expression /*ed*/);
extern expression MakeTernaryCall(entity /*f*/, expression /*e1*/, expression /*e2*/, expression /*e3*/);
extern expression make_assign_expression(expression /*lhs*/, expression /*rhs*/);
extern expression make_subscript_expression(expression /*a*/, list /*sl*/);
extern bool expression_brace_p(expression /*e*/);
extern bool expression_call_p(expression /*e*/);
extern bool expression_address_of_p(expression /*e*/);
extern call expression_call(expression /*e*/);
extern bool expression_cast_p(expression /*e*/);
extern cast expression_cast(expression /*e*/);
extern bool expression_sizeofexpression_p(expression /*e*/);
extern sizeofexpression expression_sizeofexpression(expression /*e*/);
extern bool expression_application_p(expression /*e*/);
extern application expression_application(expression /*e*/);
extern bool expression_field_p(expression /*e*/);
extern bool field_expression_p(expression /*e*/);
extern bool expression_pointer_p(expression /*e*/);
extern bool array_argument_p(expression /*e*/);
extern bool expression_reference_p(expression /*e*/);
extern entity expression_variable(expression /*e*/);
extern bool is_expression_reference_to_entity_p(expression /*e*/, entity /*v*/);
extern bool same_expression_in_list_p(expression /*e*/, list /*le*/);
extern bool expression_equal_in_list_p(expression /*e*/, list /*le*/);
extern bool logical_operator_expression_p(expression /*e*/);
extern bool relational_expression_p(expression /*e*/);
extern bool integer_expression_p(expression /*e*/);
extern bool logical_expression_p(expression /*e*/);
extern int trivial_expression_p(expression /*e*/);
extern expression expression_verbose_reduction_p_and_return_increment(expression /*incr*/, bool /*filter*/(expression));
extern bool expression_implied_do_p(expression /*e*/);
extern bool comma_expression_p(expression /*e*/);
extern bool expression_list_directed_p(expression /*e*/);
extern bool extended_integer_constant_expression_p(expression /*e*/);
extern bool extended_integer_constant_expression_p_to_int(expression /*e*/, int */*result*/);
extern bool integer_constant_expression_p(expression /*e*/);
extern bool signed_integer_constant_expression_p(expression /*e*/);
extern bool expression_with_constant_signed_integer_value_p(expression /*e*/);
extern bool assignment_expression_p(expression /*e*/);
extern bool add_expression_p(expression /*e*/);
extern bool sub_expression_p(expression /*e*/);
extern bool substraction_expression_p(expression /*e*/);
extern bool modulo_expression_p(expression /*e*/);
extern bool divide_expression_p(expression /*e*/);
extern bool power_expression_p(expression /*e*/);
extern bool abs_expression_p(expression /*e*/);
extern bool unary_minus_expression_p(expression /*e*/);
extern bool iabs_expression_p(expression /*e*/);
extern bool dabs_expression_p(expression /*e*/);
extern bool cabs_expression_p(expression /*e*/);
extern bool min0_expression_p(expression /*e*/);
extern bool max0_expression_p(expression /*e*/);
extern bool user_function_call_p(expression /*e*/);
extern bool operator_expression_p(expression /*e*/, string /*op_name*/);
extern expression make_true_expression(void);
extern expression make_false_expression(void);
extern bool true_expression_p(expression /*e*/);
extern bool false_expression_p(expression /*e*/);
extern bool unbounded_dimension_p(dimension /*dim*/);
extern expression find_ith_argument(list /*args*/, int /*n*/);
extern expression find_ith_expression(list /*le*/, int /*r*/);
extern expression int_to_expression(_int /*i*/);
extern expression make_zero_expression(void);
extern bool zero_expression_p(expression /*e*/);
extern expression float_to_expression(float /*c*/);
extern expression complex_to_expression(float /*re*/, float /*im*/);
extern expression bool_to_expression(bool /*b*/);
extern expression Value_to_expression(Value /*v*/);
extern list expression_to_reference_list(expression /*e*/, list /*lr*/);
extern list syntax_to_reference_list(syntax /*s*/, list /*lr*/);
extern bool expression_equal_p(expression /*e1*/, expression /*e2*/);
extern bool expression_equal_or_opposite_p(expression /*e1*/, expression /*e2*/);
extern bool expression_opposite_p(expression /*e1*/, expression /*e2*/);
extern bool expression_lists_equal_p(list /*l1*/, list /*l2*/);
extern bool same_expression_p(expression /*e1*/, expression /*e2*/);
extern bool sizeofexpression_equal_p(sizeofexpression /*s0*/, sizeofexpression /*s1*/);
extern bool cast_equal_p(cast /*c1*/, cast /*c2*/);
extern bool syntax_equal_p(syntax /*s1*/, syntax /*s2*/);
extern bool subscript_equal_p(subscript /*s1*/, subscript /*s2*/);
extern bool reference_equal_p(reference /*r1*/, reference /*r2*/);
extern bool range_equal_p(range /*r1*/, range /*r2*/);
extern bool call_equal_p(call /*c1*/, call /*c2*/);
extern int integer_constant_expression_value(expression /*e*/);
extern int signed_integer_constant_expression_value(expression /*e*/);
extern expression make_max_expression(expression /*e1*/, expression /*e2*/, enum language_utype /*lang*/);
extern expression make_min_expression(expression /*e1*/, expression /*e2*/, enum language_utype /*lang*/);
extern expression make_factor_expression(int /*coeff*/, entity /*vari*/);
extern expression make_vecteur_expression(Pvecteur /*pv*/);
extern statement Pvecteur_to_assign_statement(entity /*var*/, Pvecteur /*v*/);
extern expression make_constraint_expression(Pvecteur /*v*/, Variable /*index*/);
extern expression make_contrainte_expression(Pcontrainte /*pc*/, Variable /*index*/);
extern expression Pvecteur_to_expression(Pvecteur /*vect*/);
extern reference expression_reference(expression /*e*/);
extern bool expression_subscript_p(expression /*e*/);
extern subscript expression_subscript(expression /*e*/);
extern bool expression_range_p(expression /*e*/);
extern range expression_range(expression /*e*/);
extern bool array_reference_p(reference /*r*/);
extern bool references_do_not_conflict_p(reference /*r1*/, reference /*r2*/);
extern expression expression_list_to_binary_operator_call(list /*l*/, entity /*op*/);
extern expression expression_list_to_conjonction(list /*l*/);
extern bool expression_intrinsic_operation_p(expression /*exp*/);
extern bool call_constant_p(call /*c*/);
extern bool expression_equal_integer_p(expression /*exp*/, int /*i*/);
extern expression make_op_exp(char */*op_name*/, expression /*exp1*/, expression /*exp2*/);
extern expression add_integer_to_expression(expression /*exp*/, int /*val*/);
extern expression make_lin_op_exp(entity /*op_ent*/, expression /*exp1*/, expression /*exp2*/);
extern int expression_to_int(expression /*exp*/);
extern float expression_to_float(expression /*exp*/);
extern constant expression_constant(expression /*exp*/);
extern bool expression_string_constant_p(expression /*exp*/);
extern char *expression_string_constant(expression /*exp*/);
extern bool expression_integer_constant_p(expression /*e*/);
extern bool expression_constant_p(expression /*exp*/);
extern bool extended_expression_constant_p(expression /*exp*/);
extern bool expression_is_C_rhs_p(expression /*exp*/);
extern bool expression_one_p(expression /*exp*/);
extern bool expression_null_p(expression /*exp*/);
extern void davinci_dump_expression(FILE */*out*/, expression /*e*/);
extern void davinci_dump_all_expressions(FILE */*out*/, statement /*s*/);
extern expression substitute_entity_variable_in_expression(entity /*old*/, entity /*new*/, expression /*e*/);
extern expression substitute_entity_in_expression(entity /*old*/, entity /*new*/, expression /*e*/);
extern bool simplify_C_expression(expression /*e*/);
extern expression convert_bound_expression(expression /*e*/, bool /*upper_p*/, bool /*non_strict_p*/);
extern bool reference_with_constant_indices_p(reference /*r*/);
extern reference reference_with_store_independent_indices(reference /*r*/);
extern bool reference_with_unbounded_indices_p(reference /*r*/);
extern bool store_independent_reference_p(reference /*r*/);
extern entity expression_to_entity(expression /*e*/);
extern list expressions_to_entities(list /*expressions*/);
extern bool expression_similar_get_context_p(expression /*target*/, expression /*pattern*/, hash_table */*symbol_table*/);
extern bool expression_similar_p(expression /*target*/, expression /*pattern*/);
extern list make_list_of_constant(int /*val*/, int /*number*/);
extern bool brace_expression_p(expression /*e*/);
extern list brace_expression_to_statements(entity /*arr*/, expression /*e*/);
extern void brace_expression_to_updated_type(entity /*arr*/, expression /*e*/);
extern bool reference_scalar_p(reference /*r*/);
extern expression expressions_to_operation(const list /*l_exprs*/, entity /*op*/);
extern void update_expression_syntax(expression /*e*/, syntax /*s*/);
extern void local_assign_expression(expression /*caller*/, expression /*field*/);
extern expression syntax_to_expression(syntax /*s*/);
extern expression monome_to_expression(Pmonome /*pm*/);
extern expression polynome_to_expression(Ppolynome /*pp*/);
extern Ppolynome expression_to_polynome(expression /*exp*/);
extern bool simplify_expression(expression */*pexp*/);
extern void simplify_expressions(void */*obj*/);
extern expression reference_offset(reference /*ref*/);
extern expression replace_expression_content(expression /*e1*/, expression /*e2*/);
extern bool expression_minmax_p(expression /*e*/);
extern expression MakeSizeofExpression(expression /*e*/);
extern expression MakeSizeofType(type /*t*/);
extern expression MakeCastExpression(type /*t*/, expression /*e*/);
extern expression MakeCommaExpression(list /*l*/);
extern expression MakeBraceExpression(list /*l*/);
extern expression dereference_expression(expression /*e*/);
extern expression make_address_of_expression(expression /*e*/);
extern list subscript_expressions_to_constant_subscript_expressions(list /*sl*/);
extern expression pointer_reference_to_expression(reference /*r*/);
extern expression expression_to_dereferencing_expression(expression /*e*/);
extern bool C_initialization_expression_p(expression /*e*/);
extern list struct_initialization_expression_to_expressions(expression /*e*/);
extern void free_expressions(list /*el*/);
extern void clean_all_normalized(expression /*e*/);
extern expression subscript_value_stride(entity /*arr*/, list /*l_inds*/);
extern expression size_of_actual_array(entity /*actual_array*/, list /*l_actual_ref*/, int /*i*/);
extern expression make_ref_expr(entity /*ent*/, list /*args*/);
extern bool unbounded_expression_p(expression /*e*/);
extern expression make_unbounded_expression(void);
extern list make_unbounded_subscripts(int /*d*/);
extern bool user_call_p(call /*c*/);
/* type.c */
extern string type_to_string(const type /*t*/);
extern string safe_type_to_string(const type /*t*/);
extern basic MakeBasicOverloaded(void);
extern mode MakeModeReference(void);
extern mode MakeModeValue(void);
extern type MakeTypeStatement(void);
extern type MakeTypeUnknown(void);
extern type MakeTypeVoid(void);
extern type MakeTypeOverloaded(void);
extern type MakeTypeVariable(basic /*b*/, cons */*ld*/);
extern basic MakeBasic(int /*the_tag*/);
extern type MakeTypeArray(basic /*b*/, cons */*ld*/);
extern parameter MakeOverloadedParameter(void);
extern parameter MakePointerParameter(void);
extern parameter MakeVoidPointerParameter(void);
extern parameter MakeIntegerParameter(void);
extern parameter MakeLongIntegerParameter(void);
extern parameter MakeUnsignedIntegerParameter(void);
extern parameter MakeLongLongIntegerParameter(void);
extern parameter MakeRealParameter(void);
extern parameter MakeDoubleprecisionParameter(void);
extern parameter MakeQuadprecisionParameter(void);
extern parameter MakeLogicalParameter(void);
extern parameter MakeComplexParameter(void);
extern parameter MakeDoublecomplexParameter(void);
extern parameter MakeLongDoublecomplexParameter(void);
extern parameter MakeCharacterParameter(void);
extern parameter MakeAnyScalarParameter(tag /*t*/, _int /*size*/);
extern type MakeOverloadedResult(void);
extern type MakeUnsignedIntegerResult(void);
extern type MakeVoidPointerResult(void);
extern type MakeIntegerResult(void);
extern type MakeLongIntegerResult(void);
extern type MakeLongLongIntegerResult(void);
extern type MakeRealResult(void);
extern type MakeDoubleprecisionResult(void);
extern type MakeQuadprecisionResult(void);
extern type MakeLogicalResult(void);
extern type MakeComplexResult(void);
extern type MakeDoublecomplexResult(void);
extern type MakeLongDoublecomplexResult(void);
extern type MakeCharacterResult(void);
extern type MakeAnyScalarResult(tag /*t*/, _int /*size*/);
extern bool same_type_p(type /*t1*/, type /*t2*/);
extern bool generic_type_equal_p(type /*t1*/, type /*t2*/, bool /*strict_p*/, bool /*qualifier_p*/);
extern bool type_equal_p(type /*t1*/, type /*t2*/);
extern bool type_equal_up_to_qualifiers_p(type /*t1*/, type /*t2*/);
extern bool ultimate_type_equal_p(type /*t1*/, type /*t2*/);
extern bool concrete_type_equal_p(type /*t1*/, type /*t2*/);
extern type array_type_projection(type /*t*/);
extern bool array_pointer_type_equal_p(type /*t1*/, type /*t2*/);
extern bool array_pointer_string_type_equal_p(type /*t1*/, type /*t2*/);
extern bool array_element_type_p(type /*at*/, type /*et*/);
extern bool concrete_array_pointer_type_equal_p(type /*t1*/, type /*t2*/);
extern type make_scalar_integer_type(_int /*n*/);
extern type make_scalar_complex_type(_int /*n*/);
extern type make_scalar_overloaded_type(void);
extern bool area_equal_p(area /*a1*/, area /*a2*/);
extern bool dimension_equal_p(dimension /*d1*/, dimension /*d2*/);
extern bool dimensions_equal_p(list /*dims1*/, list /*dims2*/);
extern bool qualifiers_equal_p(list /*dims1*/, list /*dims2*/);
extern bool generic_variable_equal_p(variable /*v1*/, variable /*v2*/, bool /*strict_p*/, bool /*qualifier_p*/);
extern bool variable_equal_p(variable /*v1*/, variable /*v2*/);
extern bool generic_basic_equal_p(basic /*b1*/, basic /*b2*/, bool /*strict_p*/);
extern bool basic_equal_p(basic /*b1*/, basic /*b2*/);
extern bool same_basic_p(basic /*b1*/, basic /*b2*/);
extern bool compatible_basic_p(basic /*b1*/, basic /*b2*/);
extern bool generic_functional_equal_p(functional /*f1*/, functional /*f2*/, bool /*strict_p*/, bool /*qualifier_p*/);
extern bool functional_equal_p(functional /*f1*/, functional /*f2*/);
extern bool generic_parameter_equal_p(parameter /*p1*/, parameter /*p2*/, bool /*strict_p*/, bool /*qualifier_p*/);
extern bool parameter_equal_p(parameter /*p1*/, parameter /*p2*/);
extern bool mode_equal_p(mode /*m1*/, mode /*m2*/);
extern int string_type_size(basic /*b*/);
extern int basic_type_size(basic /*b*/);
extern basic expression_basic(expression /*expr*/);
extern dimension dimension_dup(dimension /*d*/);
extern list ldimensions_dup(list /*l*/);
extern dimension FindIthDimension(entity /*e*/, int /*i*/);
extern basic some_basic_of_any_expression(expression /*exp*/, bool /*apply_p*/, bool /*ultimate_p*/);
extern basic basic_of_any_expression(expression /*exp*/, bool /*apply_p*/);
extern basic basic_of_expression(expression /*exp*/);
extern basic basic_of_any_reference(reference /*r*/, bool /*apply_p*/, bool /*ultimate_p*/);
extern basic basic_of_reference(reference /*r*/);
extern basic basic_of_call(call /*c*/, bool /*apply_p*/, bool /*ultimate_p*/);
extern basic basic_of_external(call /*c*/);
extern basic basic_of_intrinsic(call /*c*/, bool /*apply_p*/, bool /*ultimate_p*/);
extern basic basic_of_constant(call /*c*/);
extern basic basic_union(expression /*exp1*/, expression /*exp2*/);
extern basic basic_ultimate(basic /*b*/);
extern basic basic_maximum(basic /*fb1*/, basic /*fb2*/);
extern basic basic_of_expressions(list /*expressions*/, bool /*skip_overloaded*/);
extern type intrinsic_call_to_type(call /*c*/);
extern type call_to_type(call /*c*/);
extern type reference_to_type(reference /*ref*/);
extern type expression_to_type(expression /*exp*/);
extern type expression_to_uncasted_type(expression /*exp*/);
extern type expression_to_user_type(expression /*e*/);
extern bool overloaded_type_p(type /*t*/);
extern bool is_inferior_basic(basic /*b1*/, basic /*b2*/);
extern basic simple_basic_dup(basic /*b*/);
extern entity basic_to_generic_conversion(basic /*b*/);
extern bool signed_type_p(type /*t*/);
extern bool unsigned_basic_p(basic /*b*/);
extern bool unsigned_type_p(type /*t*/);
extern bool long_type_p(type /*t*/);
extern bool bit_type_p(type /*t*/);
extern bool string_type_p(type /*t*/);
extern bool logical_type_p(type /*t*/);
extern bool char_type_p(type /*t*/);
extern bool basic_type_p(type /*t*/);
extern bool type_fundamental_basic_p(type /*t*/);
extern bool array_type_p(type /*t*/);
extern unsigned int array_type_dimension(type /*t*/);
extern bool scalar_type_p(type /*t*/);
extern bool type_pointer_on_struct_variable_p(type /*t*/);
extern bool variable_length_array_type_p(type /*t*/);
extern bool fixed_length_array_type_p(type /*t*/);
extern bool pointer_type_p(type /*t*/);
extern bool C_pointer_type_p(type /*t*/);
extern bool array_of_pointers_type_p(type /*t*/);
extern type pointed_type(type /*t*/);
extern bool FILE_star_type_p(type /*t*/);
extern list type_fields(type /*t*/);
extern bool derived_type_p(type /*t*/);
extern bool array_of_derived_type_p(type /*t*/);
extern bool struct_type_p(type /*t*/);
extern bool array_of_struct_type_p(type /*t*/);
extern bool union_type_p(type /*t*/);
extern bool enum_type_p(type /*t*/);
extern bool typedef_type_p(type /*t*/);
extern type make_standard_integer_type(type /*t*/, int /*size*/);
extern bool standard_long_integer_type_p(type /*t*/);
extern bool default_complex_type_p(type /*t*/);
extern bool float_type_p(type /*t*/);
extern bool scalar_integer_type_p(type /*t*/);
extern bool integer_type_p(type /*t*/);
extern type make_standard_long_integer_type(type /*t*/);
extern type ultimate_type(type /*t*/);
extern type ultimate_array_type(type /*t*/);
extern void entity_basic_concrete_types_init(void);
extern void entity_basic_concrete_types_reset(void);
extern type compute_basic_concrete_type(type /*t*/);
extern type entity_basic_concrete_type(entity /*e*/);
extern bool basic_concrete_type_leads_to_pointer_p(type /*bct*/);
extern bool call_compatible_type_p(type /*t*/);
extern type call_compatible_type(type /*t*/);
extern type call_to_functional_type(call /*c*/, bool /*ultimate_p*/);
extern bool type_struct_variable_p(type /*t*/);
extern bool type_union_variable_p(type /*t*/);
extern int number_of_fields(type /*t*/);
extern int number_of_items(type /*t*/);
extern list recursive_functional_type_supporting_entities(list /*sel*/, set /*vt*/, functional /*f*/);
extern list functional_type_supporting_entities(list /*sel*/, functional /*f*/);
extern list enum_supporting_entities(list /*sel*/, set /*vt*/, entity /*e*/);
extern list generic_constant_expression_supporting_entities(list /*sel*/, set /*vt*/, expression /*e*/, bool /*language_c_p*/);
extern list constant_expression_supporting_entities(list /*sel*/, set /*vt*/, expression /*e*/);
extern list fortran_constant_expression_supporting_entities(list /*sel*/, expression /*e*/);
extern list generic_symbolic_supporting_entities(list /*sel*/, set /*vt*/, symbolic /*s*/, bool /*language_c_p*/);
extern list symbolic_supporting_entities(list /*sel*/, set /*vt*/, symbolic /*s*/);
extern list basic_supporting_entities(list /*sel*/, set /*vt*/, basic /*b*/);
extern list variable_type_supporting_entities(list /*sel*/, set /*vt*/, variable /*v*/);
extern list recursive_type_supporting_entities(list /*sel*/, set /*vt*/, type /*t*/);
extern list type_supporting_entities(list /*sel*/, type /*t*/);
extern bool declarable_type_p(type /*t*/, list /*pdl*/);
extern list functional_type_supporting_references(list /*srl*/, functional /*f*/);
extern list enum_supporting_references(list /*srl*/, entity /*e*/);
extern list constant_expression_supporting_references(list /*srl*/, expression /*e*/);
extern list symbolic_supporting_references(list /*srl*/, symbolic /*s*/);
extern list basic_supporting_references(list /*srl*/, basic /*b*/);
extern list variable_type_supporting_references(list /*srl*/, variable /*v*/);
extern list fortran_type_supporting_entities(list /*srl*/, type /*t*/);
extern list type_supporting_references(list /*srl*/, type /*t*/);
extern bool check_C_function_type(entity /*f*/, list /*args*/);
extern size_t type_depth(type /*t*/);
extern int basic_depth(basic /*b*/);
extern int effect_type_depth(type /*t*/);
extern int effect_basic_depth(basic /*b*/);
extern list functional_type_supporting_types(functional /*f*/);
extern list type_supporting_types(type /*t*/);
extern type make_char_array_type(int /*n*/);
extern type make_scalar_char_pointer_type(void);
extern bool overloaded_parameters_p(list /*lparams*/);
extern type type_to_pointer_type(type /*t*/);
extern type type_to_pointed_type(type /*t*/);
extern type C_type_to_pointed_type(type /*t*/);
extern type type_to_returned_type(type /*t*/);
extern type type_to_final_pointed_type(type /*t*/);
extern list derived_type_fields(type /*t*/);
extern list derived_type_to_fields(type /*t*/);
extern entity find_field_in_field_list(entity /*f*/, list /*fl*/);
extern bool qualifier_equal_p(qualifier /*q1*/, qualifier /*q2*/);
extern string qualifier_to_string(qualifier /*q*/);
extern bool qualifiers_const_p(list /*ql*/);
extern bool qualifiers_restrict_p(list /*ql*/);
extern bool type_with_const_qualifier_p(type /*t*/);
extern type subscripted_type_to_type(type /*t*/, expression /*se*/);
extern dimension find_ith_dimension(list /*dims*/, int /*n*/);
extern int variable_dimension_number(variable /*v*/);
extern type type_to_array_type(type /*t*/);
extern type array_type_to_element_type(type /*t*/);
extern type array_type_to_sub_array_type(type /*t*/);
extern type array_type_to_pointer_type(type /*t*/);
extern list make_unbounded_dimensions(int /*d*/);
extern bool type_void_star_p(type /*t*/);
extern bool char_star_type_p(type /*t*/);
extern bool char_star_constant_function_type_p(type /*t*/);
extern list struct_type_to_fields(type /*lt*/);
extern bool dependent_type_p(type /*t*/);
extern list dependence_of_dependent_type(type /*t*/);
/* normalize.c */
extern normalized NormalizeExpression(expression /*e*/);
extern normalized NormalizeSyntax(syntax /*s*/);
extern normalized NormalizeCast(cast /*c*/);
extern normalized NormalizeCall(call /*c*/);
extern normalized NormalizeConstant(constant /*c*/);
extern normalized NormalizeReference(reference /*r*/);
extern normalized NormalizeIntrinsic(entity /*e*/, list /*la*/);
extern normalized binary_to_normalized(list /*la*/, int /*op*/);
extern bool EvalNormalized(normalized /*n*/, int */*pv*/);
extern void FreeNormalized(normalized /*n*/);
extern void free_expression_normalized(expression /*e*/);
extern void unnormalize_expression(void */*st*/);
extern Pvecteur expression_to_affine(expression /*e*/);
extern normalized normalize_reference(reference /*r*/);
extern void normalize_all_expressions_of(void */*obj*/);
extern void normalize_first_expressions_of(void */*obj*/);
/* static.c */
extern entity set_current_module_entity(entity /*e*/);
extern entity get_current_module_entity(void);
extern void reset_current_module_entity(void);
extern void error_reset_current_module_entity(void);
extern const char *get_current_module_name(void);
extern void set_current_module_declarations(list /*l*/);
extern void reset_current_module_declarations(void);
extern list get_current_module_declarations(void);
extern statement set_current_module_statement(statement /*s*/);
extern void push_current_module_statement(statement /*s*/);
extern void pop_current_module_statement(void);
extern statement get_current_module_statement(void);
extern void reset_current_module_statement(void);
extern void error_reset_current_module_statement(void);
extern hash_table keyword_typedef_table;
extern hash_table make_keyword_typedef_table(int /*tk*/);
extern void set_keyword_typedef_table(hash_table /*h*/);
extern void reset_keyword_typedef_table(void);
extern void free_keyword_typedef_table(void);
extern void declare_new_typedef(const string /*tn*/);
extern _int is_c_keyword_typedef(char */*s*/);
extern void make_statement_global_stack(void);
extern void push_statement_on_statement_global_stack(statement /*st*/);
extern statement get_current_statement_from_statement_global_stack(void);
extern statement pop_statement_global_stack(void);
extern void free_statement_global_stack(void);
extern bool statement_global_stack_defined_p(void);
/* arguments.c */
extern void print_homogeneous_arguments(list /*args*/, const char */*variable_name*/(entity));
extern void dump_arguments(cons */*args*/);
extern cons *arguments_add_entity(cons */*a*/, entity /*e*/);
extern cons *arguments_rm_entity(cons */*a*/, entity /*e*/);
extern cons *arguments_union(cons */*a1*/, cons */*a2*/);
extern bool arguments_equal_p(list /*a1*/, list /*a2*/);
extern bool entity_is_argument_p(entity /*e*/, cons */*args*/);
extern list arguments_intersection(list /*a1*/, list /*a2*/);
extern bool arguments_set_equal_p(list /*a1*/, list /*a2*/);
extern bool arguments_subset_p(list /*a1*/, list /*a2*/);
extern void free_arguments(cons */*args*/);
extern cons *dup_arguments(cons */*args*/);
extern cons *arguments_difference(cons */*a1*/, cons */*a2*/);
extern list base_to_entities(Pvecteur /*b*/);
/* module.c */
extern string build_new_top_level_module_name(const char */*prefix*/, bool /*prevent_suffix*/);
extern bool static_module_p(entity /*e*/);
extern bool compilation_unit_entity_p(entity /*e*/);
extern bool variable_in_module_p2(entity /*v*/, entity /*m*/);
extern void variable_declaration_verify(reference /*ref*/);
extern void symbolic_constant_declaration_verify(call /*c*/);
extern void add_non_declared_reference_to_declaration(reference /*ref*/);
extern void add_symbolic_constant_to_declaration(call /*c*/);
extern bool variable_declaration_coherency_p(entity /*module*/, statement /*st*/);
extern sentence get_header_comments(entity /*module*/);
extern sentence get_declaration_comments(entity /*module*/);
extern list module_formal_parameters(entity /*func*/);
extern int module_to_declaration_length(entity /*func*/);
extern list declaration_supporting_references(list /*dl*/);
extern list module_all_declarations(entity /*m*/);
extern bool c_language_module_p(entity /*m*/);
extern bool fortran_language_module_p(entity /*m*/);
extern bool fortran95_language_module_p(entity /*m*/);
extern entity generic_function_to_return_value(entity /*m*/, bool /*safe_p*/);
extern entity function_to_return_value(entity /*m*/);
extern entity any_function_to_return_value(entity /*m*/);
extern bool return_value_p(entity /*v*/);
extern bool function_return_value_p(entity /*v*/, entity /*f*/);
extern bool void_function_p(entity /*m*/);
extern list string_to_user_modules(const char */*s*/);
/* control.c */
extern char vcid_ri_util_control[];
extern void control_map_get_blocs(control /*c*/, list */*l*/);
extern void find_a_control_path(control /*b*/, control /*e*/, list */*pp*/, list */*vp*/, int /*dir*/);
extern void backward_control_map_get_blocs(control /*c*/, cons **/*l*/);
extern void backward_control_map_get_blocs_but(control /*c*/, control /*f*/, list */*l*/);
extern void forward_control_map_get_blocs(control /*c*/, cons **/*l*/);
extern void forward_control_map_get_blocs_but(control /*c*/, control /*f*/, list */*l*/);
extern void wide_forward_control_map_get_blocs(control /*c*/, cons **/*l*/);
extern bool is_control_in_list_p(control /*c*/, list /*cs*/);
extern int occurences_in_control_list(control /*c*/, list /*cs*/);
extern void control_list_patch(list /*l*/, control /*c_old*/, control /*c_new*/);
extern void transfer_control_predecessor(control /*old_node*/, control /*new_node*/, control /*c*/);
extern void transfer_control_successor(control /*old_node*/, control /*new_node*/, control /*c*/);
extern void replace_control_related_to_a_list(control /*old_node*/, control /*new_node*/, list /*controls*/);
extern void check_control_coherency(control /*c*/);
extern void print_control_node(control /*c*/);
extern void print_control_nodes(list /*l*/);
extern void display_address_of_control_nodes(list /*cs*/);
extern void display_linked_control_nodes(control /*c*/);
extern void remove_unreachable_following_control(control /*c*/, control /*do_not_delete_node*/, control /*do_not_delete_node_either*/);
extern void remove_some_unreachable_controls_of_an_unstructured(unstructured /*u*/);
extern void remove_all_unreachable_controls_of_an_unstructured(unstructured /*u*/);
extern void remove_a_control_from_a_list_and_relink(control /*c*/, list /*a_source_control_list_of_c*/, list /*a_dest_control_list_of_c*/, remove_a_control_from_a_list_and_relink_direction /*which_way*/);
extern void remove_a_control_from_an_unstructured(control /*c*/);
extern void remove_a_control_from_an_unstructured_without_relinking(control /*c*/);
extern void discard_an_unstructured_without_its_statements(unstructured /*u*/);
extern void free_a_control_without_its_statement(control /*c*/);
extern void discard_a_control_sequence_without_its_statements(control /*begin*/, control /*end*/);
extern list generate_a_statement_list_from_a_control_sequence(control /*begin*/, control /*end*/);
extern void link_2_control_nodes(control /*source*/, control /*target*/);
extern void link_3_control_nodes(control /*c_test*/, control /*c_then*/, control /*c_else*/);
extern void unlink_2_control_nodes(control /*source*/, control /*target*/);
extern void insert_control_in_arc(control /*c*/, control /*before*/, control /*after*/);
extern void fuse_2_control_nodes(control /*first*/, control /*second*/);
/* hpfc.c */
extern bool hpf_directive_string_p(const char */*s*/);
extern bool hpf_directive_entity_p(entity /*e*/);
extern bool realign_directive_p(entity /*f*/);
extern bool redistribute_directive_p(entity /*f*/);
extern bool dead_fcd_directive_p(entity /*f*/);
extern bool fcd_directive_string_p(const char */*s*/);
extern bool fcd_directive_p(entity /*f*/);
extern bool keep_directive_in_code_p(const char */*s*/);
/* convex_hull.c */
extern Psysteme cute_convex_union(Psysteme /*s1*/, Psysteme /*s2*/);
/* clean.c */
extern void GenericCleanEntities(list /*el*/, entity /*function*/, bool /*fortran_p*/);
extern void GenericCleanLocalEntities(entity /*function*/, bool /*fortran_p*/);
extern void CleanLocalEntities(entity /*function*/);
extern void CCleanLocalEntities(entity /*function*/);
extern void RemoveLocalEntities(entity /*function*/);
/* clone_statement.c */
extern statement clone_statement(statement /*s*/, clone_context /*cc*/);
/* allocatable.c */
extern bool entity_allocatable_p(entity /*e*/);
extern bool expression_allocatable_data_access_p(expression /*e*/);
extern expression get_allocatable_data_expr(entity /*e*/);
extern entity get_allocatable_data_entity(entity /*e*/);
/* replace.c */
extern void replace_entities(void */*s*/, hash_table /*ht*/);
extern void replace_entity(void */*s*/, entity /*old*/, entity /*new*/);
extern void replace_reference(void */*s*/, reference /*old*/, entity /*new*/);
extern void replace_entity_by_expression_with_filter(void */*s*/, entity /*ent*/, expression /*exp*/, bool (* /*filter*/)(expression));
extern void replace_entity_by_expression(void */*s*/, entity /*ent*/, expression /*exp*/);
extern void replace_entities_by_expression(void */*s*/, hash_table /*ht*/);
#endif /*  ri_util_header_included */
