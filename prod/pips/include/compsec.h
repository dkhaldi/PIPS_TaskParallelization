#ifndef _newgen_compsec_included
#define _newgen_compsec_included
#define _gen_compsec_start 151
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_reference_domain_defined_)
#define _newgen_reference_domain_defined_
#define REFERENCE_NEWGEN_DOMAIN (reference_domain)
#define reference_NEWGEN_DOMAIN (reference_domain)
typedef struct _newgen_struct_reference_ * reference;
#endif /* _newgen_reference_domain_defined_ */

#if !defined(_newgen_action_domain_defined_)
#define _newgen_action_domain_defined_
#define ACTION_NEWGEN_DOMAIN (action_domain)
#define action_NEWGEN_DOMAIN (action_domain)
typedef struct _newgen_struct_action_ * action;
#endif /* _newgen_action_domain_defined_ */

#if !defined(_newgen_Pvecteur_domain_defined_)
#define _newgen_Pvecteur_domain_defined_
#define newgen_Pvecteur(p) (p) /* old hack compatible */
#define PVECTEUR_NEWGEN_EXTERNAL (_gen_compsec_start+0)
#define PVECTEUR_NEWGEN_DOMAIN (PVECTEUR_NEWGEN_EXTERNAL)
#define Pvecteur_NEWGEN_DOMAIN (PVECTEUR_NEWGEN_EXTERNAL)
#endif /* _newgen_Pvecteur_domain_defined_ */

#define bound_pair_domain (_gen_compsec_start+1)
#if !defined(_newgen_bound_pair_domain_defined_)
#define _newgen_bound_pair_domain_defined_
#define BOUND_PAIR_NEWGEN_DOMAIN (bound_pair_domain)
#define bound_pair_NEWGEN_DOMAIN (bound_pair_domain)
typedef struct _newgen_struct_bound_pair_ * bound_pair;
#endif /* _newgen_bound_pair_domain_defined_ */

#define comp_desc_domain (_gen_compsec_start+2)
#if !defined(_newgen_comp_desc_domain_defined_)
#define _newgen_comp_desc_domain_defined_
#define COMP_DESC_NEWGEN_DOMAIN (comp_desc_domain)
#define comp_desc_NEWGEN_DOMAIN (comp_desc_domain)
typedef struct _newgen_struct_comp_desc_ * comp_desc;
#endif /* _newgen_comp_desc_domain_defined_ */

#define comp_desc_set_domain (_gen_compsec_start+3)
#if !defined(_newgen_comp_desc_set_domain_defined_)
#define _newgen_comp_desc_set_domain_defined_
#define COMP_DESC_SET_NEWGEN_DOMAIN (comp_desc_set_domain)
#define comp_desc_set_NEWGEN_DOMAIN (comp_desc_set_domain)
typedef struct _newgen_struct_comp_desc_set_ * comp_desc_set;
#endif /* _newgen_comp_desc_set_domain_defined_ */

#define comp_sec_domain (_gen_compsec_start+4)
#if !defined(_newgen_comp_sec_domain_defined_)
#define _newgen_comp_sec_domain_defined_
#define COMP_SEC_NEWGEN_DOMAIN (comp_sec_domain)
#define comp_sec_NEWGEN_DOMAIN (comp_sec_domain)
typedef struct _newgen_struct_comp_sec_ * comp_sec;
#endif /* _newgen_comp_sec_domain_defined_ */

#define context_info_domain (_gen_compsec_start+5)
#if !defined(_newgen_context_info_domain_defined_)
#define _newgen_context_info_domain_defined_
#define CONTEXT_INFO_NEWGEN_DOMAIN (context_info_domain)
#define context_info_NEWGEN_DOMAIN (context_info_domain)
typedef struct _newgen_struct_context_info_ * context_info;
#endif /* _newgen_context_info_domain_defined_ */

#define dad_struct_domain (_gen_compsec_start+6)
#if !defined(_newgen_dad_struct_domain_defined_)
#define _newgen_dad_struct_domain_defined_
#define DAD_STRUCT_NEWGEN_DOMAIN (dad_struct_domain)
#define dad_struct_NEWGEN_DOMAIN (dad_struct_domain)
typedef struct _newgen_struct_dad_struct_ * dad_struct;
#endif /* _newgen_dad_struct_domain_defined_ */

#define ref_temp_domain (_gen_compsec_start+7)
#if !defined(_newgen_ref_temp_domain_defined_)
#define _newgen_ref_temp_domain_defined_
#define REF_TEMP_NEWGEN_DOMAIN (ref_temp_domain)
#define ref_temp_NEWGEN_DOMAIN (ref_temp_domain)
typedef struct _newgen_struct_ref_temp_ * ref_temp;
#endif /* _newgen_ref_temp_domain_defined_ */

#define rtype_domain (_gen_compsec_start+8)
#if !defined(_newgen_rtype_domain_defined_)
#define _newgen_rtype_domain_defined_
#define RTYPE_NEWGEN_DOMAIN (rtype_domain)
#define rtype_NEWGEN_DOMAIN (rtype_domain)
typedef struct _newgen_struct_rtype_ * rtype;
#endif /* _newgen_rtype_domain_defined_ */

#define simple_section_domain (_gen_compsec_start+9)
#if !defined(_newgen_simple_section_domain_defined_)
#define _newgen_simple_section_domain_defined_
#define SIMPLE_SECTION_NEWGEN_DOMAIN (simple_section_domain)
#define simple_section_NEWGEN_DOMAIN (simple_section_domain)
typedef struct _newgen_struct_simple_section_ * simple_section;
#endif /* _newgen_simple_section_domain_defined_ */


/* BOUND_PAIR
 */
#define BOUND_PAIR(x) ((bound_pair)((x).p))
#define bound_pair_CAST(x) BOUND_PAIR(x)
#define BOUND_PAIR_CAST(x) BOUND_PAIR(x)
#define BOUND_PAIR_(x) ((x).e)
#define BOUND_PAIR_TYPE bound_pair
#define bound_pair_TYPE bound_pair
#define bound_pair_undefined ((bound_pair)gen_chunk_undefined)
#define bound_pair_undefined_p(x) ((x)==bound_pair_undefined)

extern bound_pair copy_bound_pair(bound_pair);
extern void free_bound_pair(bound_pair);
extern bound_pair check_bound_pair(bound_pair);
extern bool bound_pair_consistent_p(bound_pair);
extern bool bound_pair_defined_p(bound_pair);
#define gen_BOUND_PAIR_cons gen_bound_pair_cons
extern list gen_bound_pair_cons(bound_pair, list);
extern void bound_pair_assign_contents(bound_pair, bound_pair);
extern void bound_pair_non_recursive_free(bound_pair);
extern void write_bound_pair(FILE*, bound_pair);
extern bound_pair read_bound_pair(FILE*);
extern bound_pair make_bound_pair(intptr_t, Pvecteur, Pvecteur);

struct _newgen_struct_bound_pair_ {
  intptr_t _type_;
  intptr_t _bound_pair_index_; /* index:int */
  Pvecteur _bound_pair_lb_; /* lb:Pvecteur */
  Pvecteur _bound_pair_ub_; /* ub:Pvecteur */
};

#define bound_pair_domain_number(x) ((x)->_type_)
#define bound_pair_index_(x) bound_pair_index(x) /* old hack compatible */
#define bound_pair_index(x) ((x)->_bound_pair_index_)
#define bound_pair_lb_(x) bound_pair_lb(x) /* old hack compatible */
#define bound_pair_lb(x) ((x)->_bound_pair_lb_)
#define bound_pair_ub_(x) bound_pair_ub(x) /* old hack compatible */
#define bound_pair_ub(x) ((x)->_bound_pair_ub_)

/* COMP_DESC
 */
#define COMP_DESC(x) ((comp_desc)((x).p))
#define comp_desc_CAST(x) COMP_DESC(x)
#define COMP_DESC_CAST(x) COMP_DESC(x)
#define COMP_DESC_(x) ((x).e)
#define COMP_DESC_TYPE comp_desc
#define comp_desc_TYPE comp_desc
#define comp_desc_undefined ((comp_desc)gen_chunk_undefined)
#define comp_desc_undefined_p(x) ((x)==comp_desc_undefined)

extern comp_desc copy_comp_desc(comp_desc);
extern void free_comp_desc(comp_desc);
extern comp_desc check_comp_desc(comp_desc);
extern bool comp_desc_consistent_p(comp_desc);
extern bool comp_desc_defined_p(comp_desc);
#define gen_COMP_DESC_cons gen_comp_desc_cons
extern list gen_comp_desc_cons(comp_desc, list);
extern void comp_desc_assign_contents(comp_desc, comp_desc);
extern void comp_desc_non_recursive_free(comp_desc);
extern void write_comp_desc(FILE*, comp_desc);
extern comp_desc read_comp_desc(FILE*);
extern comp_desc make_comp_desc(reference, action, comp_sec);

struct _newgen_struct_comp_desc_ {
  intptr_t _type_;
  reference _comp_desc_reference_; /* reference:reference */
  action _comp_desc_action_; /* action:action */
  comp_sec _comp_desc_section_; /* section:comp_sec */
};

#define comp_desc_domain_number(x) ((x)->_type_)
#define comp_desc_reference_(x) comp_desc_reference(x) /* old hack compatible */
#define comp_desc_reference(x) ((x)->_comp_desc_reference_)
#define comp_desc_action_(x) comp_desc_action(x) /* old hack compatible */
#define comp_desc_action(x) ((x)->_comp_desc_action_)
#define comp_desc_section_(x) comp_desc_section(x) /* old hack compatible */
#define comp_desc_section(x) ((x)->_comp_desc_section_)

/* COMP_DESC_SET
 */
#define COMP_DESC_SET(x) ((comp_desc_set)((x).p))
#define comp_desc_set_CAST(x) COMP_DESC_SET(x)
#define COMP_DESC_SET_CAST(x) COMP_DESC_SET(x)
#define COMP_DESC_SET_(x) ((x).e)
#define COMP_DESC_SET_TYPE comp_desc_set
#define comp_desc_set_TYPE comp_desc_set
#define comp_desc_set_undefined ((comp_desc_set)gen_chunk_undefined)
#define comp_desc_set_undefined_p(x) ((x)==comp_desc_set_undefined)

extern comp_desc_set copy_comp_desc_set(comp_desc_set);
extern void free_comp_desc_set(comp_desc_set);
extern comp_desc_set check_comp_desc_set(comp_desc_set);
extern bool comp_desc_set_consistent_p(comp_desc_set);
extern bool comp_desc_set_defined_p(comp_desc_set);
#define gen_COMP_DESC_SET_cons gen_comp_desc_set_cons
extern list gen_comp_desc_set_cons(comp_desc_set, list);
extern void comp_desc_set_assign_contents(comp_desc_set, comp_desc_set);
extern void comp_desc_set_non_recursive_free(comp_desc_set);
extern void write_comp_desc_set(FILE*, comp_desc_set);
extern comp_desc_set read_comp_desc_set(FILE*);
extern comp_desc_set make_comp_desc_set(list);

struct _newgen_struct_comp_desc_set_ {
  intptr_t _type_;
  list _comp_desc_set_holder_;
};

#define comp_desc_set_domain_number(x) ((x)->_type_)
#define comp_desc_set_comp_descs(x) ((x)->_comp_desc_set_holder_)

/* COMP_SEC
 */
#define COMP_SEC(x) ((comp_sec)((x).p))
#define comp_sec_CAST(x) COMP_SEC(x)
#define COMP_SEC_CAST(x) COMP_SEC(x)
#define COMP_SEC_(x) ((x).e)
#define COMP_SEC_TYPE comp_sec
#define comp_sec_TYPE comp_sec
#define comp_sec_undefined ((comp_sec)gen_chunk_undefined)
#define comp_sec_undefined_p(x) ((x)==comp_sec_undefined)

extern comp_sec copy_comp_sec(comp_sec);
extern void free_comp_sec(comp_sec);
extern comp_sec check_comp_sec(comp_sec);
extern bool comp_sec_consistent_p(comp_sec);
extern bool comp_sec_defined_p(comp_sec);
#define gen_COMP_SEC_cons gen_comp_sec_cons
extern list gen_comp_sec_cons(comp_sec, list);
extern void comp_sec_assign_contents(comp_sec, comp_sec);
extern void comp_sec_non_recursive_free(comp_sec);
extern void write_comp_sec(FILE*, comp_sec);
extern comp_sec read_comp_sec(FILE*);
extern comp_sec make_comp_sec(simple_section, list);

struct _newgen_struct_comp_sec_ {
  intptr_t _type_;
  simple_section _comp_sec_hull_; /* hull:simple_section */
  list _comp_sec_complements_; /* complements:simple_section* */
};

#define comp_sec_domain_number(x) ((x)->_type_)
#define comp_sec_hull_(x) comp_sec_hull(x) /* old hack compatible */
#define comp_sec_hull(x) ((x)->_comp_sec_hull_)
#define comp_sec_complements_(x) comp_sec_complements(x) /* old hack compatible */
#define comp_sec_complements(x) ((x)->_comp_sec_complements_)

/* CONTEXT_INFO
 */
#define CONTEXT_INFO(x) ((context_info)((x).p))
#define context_info_CAST(x) CONTEXT_INFO(x)
#define CONTEXT_INFO_CAST(x) CONTEXT_INFO(x)
#define CONTEXT_INFO_(x) ((x).e)
#define CONTEXT_INFO_TYPE context_info
#define context_info_TYPE context_info
#define context_info_undefined ((context_info)gen_chunk_undefined)
#define context_info_undefined_p(x) ((x)==context_info_undefined)

extern context_info copy_context_info(context_info);
extern void free_context_info(context_info);
extern context_info check_context_info(context_info);
extern bool context_info_consistent_p(context_info);
extern bool context_info_defined_p(context_info);
#define gen_CONTEXT_INFO_cons gen_context_info_cons
extern list gen_context_info_cons(context_info, list);
extern void context_info_assign_contents(context_info, context_info);
extern void context_info_non_recursive_free(context_info);
extern void write_context_info(FILE*, context_info);
extern context_info read_context_info(FILE*);
extern context_info make_context_info(intptr_t, intptr_t, intptr_t);

struct _newgen_struct_context_info_ {
  intptr_t _type_;
  intptr_t _context_info_line_; /* line:int */
  intptr_t _context_info_rank_; /* rank:int */
  intptr_t _context_info_nest_; /* nest:int */
};

#define context_info_domain_number(x) ((x)->_type_)
#define context_info_line_(x) context_info_line(x) /* old hack compatible */
#define context_info_line(x) ((x)->_context_info_line_)
#define context_info_rank_(x) context_info_rank(x) /* old hack compatible */
#define context_info_rank(x) ((x)->_context_info_rank_)
#define context_info_nest_(x) context_info_nest(x) /* old hack compatible */
#define context_info_nest(x) ((x)->_context_info_nest_)

/* DAD_STRUCT
 */
#define DAD_STRUCT(x) ((dad_struct)((x).p))
#define dad_struct_CAST(x) DAD_STRUCT(x)
#define DAD_STRUCT_CAST(x) DAD_STRUCT(x)
#define DAD_STRUCT_(x) ((x).e)
#define DAD_STRUCT_TYPE dad_struct
#define dad_struct_TYPE dad_struct
#define dad_struct_undefined ((dad_struct)gen_chunk_undefined)
#define dad_struct_undefined_p(x) ((x)==dad_struct_undefined)

extern dad_struct copy_dad_struct(dad_struct);
extern void free_dad_struct(dad_struct);
extern dad_struct check_dad_struct(dad_struct);
extern bool dad_struct_consistent_p(dad_struct);
extern bool dad_struct_defined_p(dad_struct);
#define gen_DAD_STRUCT_cons gen_dad_struct_cons
extern list gen_dad_struct_cons(dad_struct, list);
extern void dad_struct_assign_contents(dad_struct, dad_struct);
extern void dad_struct_non_recursive_free(dad_struct);
extern void write_dad_struct(FILE*, dad_struct);
extern dad_struct read_dad_struct(FILE*);
extern dad_struct make_dad_struct(list, list);

struct _newgen_struct_dad_struct_ {
  intptr_t _type_;
  list _dad_struct_rtemps_; /* rtemps:ref_temp* */
  list _dad_struct_shape_; /* shape:bound_pair* */
};

#define dad_struct_domain_number(x) ((x)->_type_)
#define dad_struct_rtemps_(x) dad_struct_rtemps(x) /* old hack compatible */
#define dad_struct_rtemps(x) ((x)->_dad_struct_rtemps_)
#define dad_struct_shape_(x) dad_struct_shape(x) /* old hack compatible */
#define dad_struct_shape(x) ((x)->_dad_struct_shape_)

/* REF_TEMP
 */
#define REF_TEMP(x) ((ref_temp)((x).p))
#define ref_temp_CAST(x) REF_TEMP(x)
#define REF_TEMP_CAST(x) REF_TEMP(x)
#define REF_TEMP_(x) ((x).e)
#define REF_TEMP_TYPE ref_temp
#define ref_temp_TYPE ref_temp
#define ref_temp_undefined ((ref_temp)gen_chunk_undefined)
#define ref_temp_undefined_p(x) ((x)==ref_temp_undefined)

extern ref_temp copy_ref_temp(ref_temp);
extern void free_ref_temp(ref_temp);
extern ref_temp check_ref_temp(ref_temp);
extern bool ref_temp_consistent_p(ref_temp);
extern bool ref_temp_defined_p(ref_temp);
#define gen_REF_TEMP_cons gen_ref_temp_cons
extern list gen_ref_temp_cons(ref_temp, list);
extern void ref_temp_assign_contents(ref_temp, ref_temp);
extern void ref_temp_non_recursive_free(ref_temp);
extern void write_ref_temp(FILE*, ref_temp);
extern ref_temp read_ref_temp(FILE*);
extern ref_temp make_ref_temp(intptr_t, rtype);

struct _newgen_struct_ref_temp_ {
  intptr_t _type_;
  intptr_t _ref_temp_index_; /* index:int */
  rtype _ref_temp_rtype_; /* rtype:rtype */
};

#define ref_temp_domain_number(x) ((x)->_type_)
#define ref_temp_index_(x) ref_temp_index(x) /* old hack compatible */
#define ref_temp_index(x) ((x)->_ref_temp_index_)
#define ref_temp_rtype_(x) ref_temp_rtype(x) /* old hack compatible */
#define ref_temp_rtype(x) ((x)->_ref_temp_rtype_)

/* RTYPE
 */
#define RTYPE(x) ((rtype)((x).p))
#define rtype_CAST(x) RTYPE(x)
#define RTYPE_CAST(x) RTYPE(x)
#define RTYPE_(x) ((x).e)
#define RTYPE_TYPE rtype
#define rtype_TYPE rtype
#define rtype_undefined ((rtype)gen_chunk_undefined)
#define rtype_undefined_p(x) ((x)==rtype_undefined)

extern rtype copy_rtype(rtype);
extern void free_rtype(rtype);
extern rtype check_rtype(rtype);
extern bool rtype_consistent_p(rtype);
extern bool rtype_defined_p(rtype);
#define gen_RTYPE_cons gen_rtype_cons
extern list gen_rtype_cons(rtype, list);
extern void rtype_assign_contents(rtype, rtype);
extern void rtype_non_recursive_free(rtype);
extern void write_rtype(FILE*, rtype);
extern rtype read_rtype(FILE*);
enum rtype_utype {
  is_rtype_nonlinear,
  is_rtype_linvariant,
  is_rtype_lininvariant
};
extern string rtype_tag_as_string(enum rtype_utype);
extern rtype make_rtype(enum rtype_utype, void *);
extern rtype make_rtype_nonlinear(void);
extern rtype make_rtype_linvariant(void);
extern rtype make_rtype_lininvariant(void);

struct _newgen_struct_rtype_ {
  intptr_t _type_;
  enum rtype_utype _rtype_tag__;
  union {
    gen_chunk _rtype_nonlinear_; /* nonlinear:unit */
    gen_chunk _rtype_linvariant_; /* linvariant:unit */
    gen_chunk _rtype_lininvariant_; /* lininvariant:unit */
  } _rtype_union_;
};

#define rtype_domain_number(x) ((x)->_type_)
#define rtype_tag(x) ((x)->_rtype_tag__)
#define rtype_nonlinear_p(x) (rtype_tag(x)==is_rtype_nonlinear)
#define rtype_nonlinear_(x) rtype_nonlinear(x) /* old hack compatible */
#define rtype_nonlinear(x) ((x)->_rtype_union_._rtype_nonlinear_.u)
#define rtype_linvariant_p(x) (rtype_tag(x)==is_rtype_linvariant)
#define rtype_linvariant_(x) rtype_linvariant(x) /* old hack compatible */
#define rtype_linvariant(x) ((x)->_rtype_union_._rtype_linvariant_.u)
#define rtype_lininvariant_p(x) (rtype_tag(x)==is_rtype_lininvariant)
#define rtype_lininvariant_(x) rtype_lininvariant(x) /* old hack compatible */
#define rtype_lininvariant(x) ((x)->_rtype_union_._rtype_lininvariant_.u)

/* SIMPLE_SECTION
 */
#define SIMPLE_SECTION(x) ((simple_section)((x).p))
#define simple_section_CAST(x) SIMPLE_SECTION(x)
#define SIMPLE_SECTION_CAST(x) SIMPLE_SECTION(x)
#define SIMPLE_SECTION_(x) ((x).e)
#define SIMPLE_SECTION_TYPE simple_section
#define simple_section_TYPE simple_section
#define simple_section_undefined ((simple_section)gen_chunk_undefined)
#define simple_section_undefined_p(x) ((x)==simple_section_undefined)

extern simple_section copy_simple_section(simple_section);
extern void free_simple_section(simple_section);
extern simple_section check_simple_section(simple_section);
extern bool simple_section_consistent_p(simple_section);
extern bool simple_section_defined_p(simple_section);
#define gen_SIMPLE_SECTION_cons gen_simple_section_cons
extern list gen_simple_section_cons(simple_section, list);
extern void simple_section_assign_contents(simple_section, simple_section);
extern void simple_section_non_recursive_free(simple_section);
extern void write_simple_section(FILE*, simple_section);
extern simple_section read_simple_section(FILE*);
extern simple_section make_simple_section(context_info, dad_struct);

struct _newgen_struct_simple_section_ {
  intptr_t _type_;
  context_info _simple_section_context_; /* context:context_info */
  dad_struct _simple_section_dad_; /* dad:dad_struct */
};

#define simple_section_domain_number(x) ((x)->_type_)
#define simple_section_context_(x) simple_section_context(x) /* old hack compatible */
#define simple_section_context(x) ((x)->_simple_section_context_)
#define simple_section_dad_(x) simple_section_dad(x) /* old hack compatible */
#define simple_section_dad(x) ((x)->_simple_section_dad_)

#define compsec_spec "\
--NEWGEN-START 151\n\
import reference from \"ri.newgen\";\n\
import action from \"ri.newgen\";\n\
external Pvecteur;\n\
bound_pair = index:int x lb:Pvecteur x ub:Pvecteur;\n\
comp_desc = persistant reference:reference x action:action x section:comp_sec;\n\
comp_desc_set = comp_descs:comp_desc*;\n\
comp_sec = hull:simple_section x complements:simple_section*;\n\
context_info = line:int x rank:int x nest:int;\n\
dad_struct = rtemps:ref_temp* x shape:bound_pair*;\n\
ref_temp = index:int x rtype:rtype;\n\
rtype = nonlinear:unit + linvariant:unit + lininvariant:unit;\n\
simple_section = context:context_info x dad:dad_struct;\n\
"
#endif
