/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "points_to_private.h"

/* POINTS_TO_GRAPH
 */
points_to_graph copy_points_to_graph(points_to_graph p) {
  return (points_to_graph) gen_copy_tree((gen_chunk*) p);
}
void free_points_to_graph(points_to_graph p) {
  gen_free((gen_chunk*) p);
}
points_to_graph check_points_to_graph(points_to_graph p) {
  return (points_to_graph) gen_check((gen_chunk*) p, points_to_graph_domain);
}
bool points_to_graph_consistent_p(points_to_graph p) {
  check_points_to_graph(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool points_to_graph_defined_p(points_to_graph p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_points_to_graph_cons(points_to_graph p, list l) {
  return gen_typed_cons(POINTS_TO_GRAPH_NEWGEN_DOMAIN, p, l);
}
void points_to_graph_assign_contents(points_to_graph r, points_to_graph v) {
  check_points_to_graph(r);
  check_points_to_graph(v);
  message_assert("defined references to domain points_to_graph",
                 points_to_graph_defined_p(r) && points_to_graph_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_points_to_graph_));
}
void points_to_graph_non_recursive_free(points_to_graph p) {
  // should clear up contents...
  free(p);
}
void write_points_to_graph(FILE* f, points_to_graph p) {
  gen_write(f, (gen_chunk*) p);
}
points_to_graph read_points_to_graph(FILE* f) {
  return (points_to_graph) gen_read(f);
}
points_to_graph make_points_to_graph(bool a1, set a2) {
  return (points_to_graph) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, points_to_graph_domain, a1, a2);
}

/* POINTS_TO_LIST
 */
points_to_list copy_points_to_list(points_to_list p) {
  return (points_to_list) gen_copy_tree((gen_chunk*) p);
}
void free_points_to_list(points_to_list p) {
  gen_free((gen_chunk*) p);
}
points_to_list check_points_to_list(points_to_list p) {
  return (points_to_list) gen_check((gen_chunk*) p, points_to_list_domain);
}
bool points_to_list_consistent_p(points_to_list p) {
  check_points_to_list(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool points_to_list_defined_p(points_to_list p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_points_to_list_cons(points_to_list p, list l) {
  return gen_typed_cons(POINTS_TO_LIST_NEWGEN_DOMAIN, p, l);
}
void points_to_list_assign_contents(points_to_list r, points_to_list v) {
  check_points_to_list(r);
  check_points_to_list(v);
  message_assert("defined references to domain points_to_list",
                 points_to_list_defined_p(r) && points_to_list_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_points_to_list_));
}
void points_to_list_non_recursive_free(points_to_list p) {
  // should clear up contents...
  free(p);
}
void write_points_to_list(FILE* f, points_to_list p) {
  gen_write(f, (gen_chunk*) p);
}
points_to_list read_points_to_list(FILE* f) {
  return (points_to_list) gen_read(f);
}
points_to_list make_points_to_list(bool a1, list a2) {
  return (points_to_list) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, points_to_list_domain, a1, a2);
}

/* POINTS_TO
 */
points_to copy_points_to(points_to p) {
  return (points_to) gen_copy_tree((gen_chunk*) p);
}
void free_points_to(points_to p) {
  gen_free((gen_chunk*) p);
}
points_to check_points_to(points_to p) {
  return (points_to) gen_check((gen_chunk*) p, points_to_domain);
}
bool points_to_consistent_p(points_to p) {
  check_points_to(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool points_to_defined_p(points_to p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_points_to_cons(points_to p, list l) {
  return gen_typed_cons(POINTS_TO_NEWGEN_DOMAIN, p, l);
}
void points_to_assign_contents(points_to r, points_to v) {
  check_points_to(r);
  check_points_to(v);
  message_assert("defined references to domain points_to",
                 points_to_defined_p(r) && points_to_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_points_to_));
}
void points_to_non_recursive_free(points_to p) {
  // should clear up contents...
  free(p);
}
void write_points_to(FILE* f, points_to p) {
  gen_write(f, (gen_chunk*) p);
}
points_to read_points_to(FILE* f) {
  return (points_to) gen_read(f);
}
points_to make_points_to(cell a1, cell a2, approximation a3, descriptor a4) {
  return (points_to) gen_alloc(5*sizeof(gen_chunk), GEN_CHECK_ALLOC, points_to_domain, a1, a2, a3, a4);
}

/* STATEMENT_POINTS_TO
 */
statement_points_to copy_statement_points_to(statement_points_to p) {
  return (statement_points_to) gen_copy_tree((gen_chunk*) p);
}
void free_statement_points_to(statement_points_to p) {
  gen_free((gen_chunk*) p);
}
statement_points_to check_statement_points_to(statement_points_to p) {
  return (statement_points_to) gen_check((gen_chunk*) p, statement_points_to_domain);
}
bool statement_points_to_consistent_p(statement_points_to p) {
  check_statement_points_to(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool statement_points_to_defined_p(statement_points_to p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_statement_points_to_cons(statement_points_to p, list l) {
  return gen_typed_cons(STATEMENT_POINTS_TO_NEWGEN_DOMAIN, p, l);
}
void statement_points_to_assign_contents(statement_points_to r, statement_points_to v) {
  check_statement_points_to(r);
  check_statement_points_to(v);
  message_assert("defined references to domain statement_points_to",
                 statement_points_to_defined_p(r) && statement_points_to_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_statement_points_to_));
}
void statement_points_to_non_recursive_free(statement_points_to p) {
  // should clear up contents...
  free(p);
}
void write_statement_points_to(FILE* f, statement_points_to p) {
  gen_write(f, (gen_chunk*) p);
}
statement_points_to read_statement_points_to(FILE* f) {
  return (statement_points_to) gen_read(f);
}
statement_points_to make_statement_points_to(void) {
  return (statement_points_to) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, statement_points_to_domain);
}
points_to_list apply_statement_points_to(statement_points_to f, statement k) {
  return (points_to_list) (intptr_t)HASH_GET(p, p, statement_points_to_hash_table(f), k);
}
void update_statement_points_to(statement_points_to f, statement k, points_to_list v) {
  HASH_UPDATE(p, p, statement_points_to_hash_table(f), k, (intptr_t)v);
}
void extend_statement_points_to(statement_points_to f, statement k, points_to_list v) {
  HASH_EXTEND(p, p, statement_points_to_hash_table(f), k, (intptr_t)v);
}
points_to_list delete_statement_points_to(statement_points_to f, statement k) {
  return (points_to_list)(intptr_t) HASH_DELETE(p, p, statement_points_to_hash_table(f), k);
}
bool bound_statement_points_to_p(statement_points_to f, statement k) {
  return (intptr_t)HASH_BOUND_P(p, p, statement_points_to_hash_table(f), k);
}

