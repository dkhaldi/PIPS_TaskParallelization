#ifndef _newgen_sac_private_included
#define _newgen_sac_private_included
#define _gen_sac_private_start 174
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_entity_domain_defined_)
#define _newgen_entity_domain_defined_
#define ENTITY_NEWGEN_DOMAIN (entity_domain)
#define entity_NEWGEN_DOMAIN (entity_domain)
typedef struct _newgen_struct_entity_ * entity;
#endif /* _newgen_entity_domain_defined_ */

#if !defined(_newgen_expression_domain_defined_)
#define _newgen_expression_domain_defined_
#define EXPRESSION_NEWGEN_DOMAIN (expression_domain)
#define expression_NEWGEN_DOMAIN (expression_domain)
typedef struct _newgen_struct_expression_ * expression;
#endif /* _newgen_expression_domain_defined_ */

#if !defined(_newgen_statement_domain_defined_)
#define _newgen_statement_domain_defined_
#define STATEMENT_NEWGEN_DOMAIN (statement_domain)
#define statement_NEWGEN_DOMAIN (statement_domain)
typedef struct _newgen_struct_statement_ * statement;
#endif /* _newgen_statement_domain_defined_ */

#if !defined(_newgen_reference_domain_defined_)
#define _newgen_reference_domain_defined_
#define REFERENCE_NEWGEN_DOMAIN (reference_domain)
#define reference_NEWGEN_DOMAIN (reference_domain)
typedef struct _newgen_struct_reference_ * reference;
#endif /* _newgen_reference_domain_defined_ */

#if !defined(_newgen_reduction_domain_defined_)
#define _newgen_reduction_domain_defined_
#define REDUCTION_NEWGEN_DOMAIN (reduction_domain)
#define reduction_NEWGEN_DOMAIN (reduction_domain)
typedef struct _newgen_struct_reduction_ * reduction;
#endif /* _newgen_reduction_domain_defined_ */

#if !defined(_newgen_operator_id_sons_domain_defined_)
#define _newgen_operator_id_sons_domain_defined_
#define newgen_operator_id_sons(p) (p) /* old hack compatible */
#define OPERATOR_ID_SONS_NEWGEN_EXTERNAL (_gen_sac_private_start+0)
#define OPERATOR_ID_SONS_NEWGEN_DOMAIN (OPERATOR_ID_SONS_NEWGEN_EXTERNAL)
#define operator_id_sons_NEWGEN_DOMAIN (OPERATOR_ID_SONS_NEWGEN_EXTERNAL)
#endif /* _newgen_operator_id_sons_domain_defined_ */

#define matchTree_domain (_gen_sac_private_start+1)
#if !defined(_newgen_matchTree_domain_defined_)
#define _newgen_matchTree_domain_defined_
#define MATCHTREE_NEWGEN_DOMAIN (matchTree_domain)
#define matchTree_NEWGEN_DOMAIN (matchTree_domain)
typedef struct _newgen_struct_matchTree_ * matchTree;
#endif /* _newgen_matchTree_domain_defined_ */

#define matchTreeSons_domain (_gen_sac_private_start+2)
#if !defined(_newgen_matchTreeSons_domain_defined_)
#define _newgen_matchTreeSons_domain_defined_
#define MATCHTREESONS_NEWGEN_DOMAIN (matchTreeSons_domain)
#define matchTreeSons_NEWGEN_DOMAIN (matchTreeSons_domain)
typedef struct _newgen_struct_matchTreeSons_ * matchTreeSons;
#endif /* _newgen_matchTreeSons_domain_defined_ */

#define match_domain (_gen_sac_private_start+3)
#if !defined(_newgen_match_domain_defined_)
#define _newgen_match_domain_defined_
#define MATCH_NEWGEN_DOMAIN (match_domain)
#define match_NEWGEN_DOMAIN (match_domain)
typedef struct _newgen_struct_match_ * match;
#endif /* _newgen_match_domain_defined_ */

#define opcode_domain (_gen_sac_private_start+4)
#if !defined(_newgen_opcode_domain_defined_)
#define _newgen_opcode_domain_defined_
#define OPCODE_NEWGEN_DOMAIN (opcode_domain)
#define opcode_NEWGEN_DOMAIN (opcode_domain)
typedef struct _newgen_struct_opcode_ * opcode;
#endif /* _newgen_opcode_domain_defined_ */

#define operator_id_tree_domain (_gen_sac_private_start+5)
#if !defined(_newgen_operator_id_tree_domain_defined_)
#define _newgen_operator_id_tree_domain_defined_
#define OPERATOR_ID_TREE_NEWGEN_DOMAIN (operator_id_tree_domain)
#define operator_id_tree_NEWGEN_DOMAIN (operator_id_tree_domain)
typedef struct _newgen_struct_operator_id_tree_ * operator_id_tree;
#endif /* _newgen_operator_id_tree_domain_defined_ */

#define patternArg_domain (_gen_sac_private_start+6)
#if !defined(_newgen_patternArg_domain_defined_)
#define _newgen_patternArg_domain_defined_
#define PATTERNARG_NEWGEN_DOMAIN (patternArg_domain)
#define patternArg_NEWGEN_DOMAIN (patternArg_domain)
typedef struct _newgen_struct_patternArg_ * patternArg;
#endif /* _newgen_patternArg_domain_defined_ */

#define patternx_domain (_gen_sac_private_start+7)
#if !defined(_newgen_patternx_domain_defined_)
#define _newgen_patternx_domain_defined_
#define PATTERNX_NEWGEN_DOMAIN (patternx_domain)
#define patternx_NEWGEN_DOMAIN (patternx_domain)
typedef struct _newgen_struct_patternx_ * patternx;
#endif /* _newgen_patternx_domain_defined_ */

#define reductionInfo_domain (_gen_sac_private_start+8)
#if !defined(_newgen_reductionInfo_domain_defined_)
#define _newgen_reductionInfo_domain_defined_
#define REDUCTIONINFO_NEWGEN_DOMAIN (reductionInfo_domain)
#define reductionInfo_NEWGEN_DOMAIN (reductionInfo_domain)
typedef struct _newgen_struct_reductionInfo_ * reductionInfo;
#endif /* _newgen_reductionInfo_domain_defined_ */

#define simdstatement_domain (_gen_sac_private_start+9)
#if !defined(_newgen_simdstatement_domain_defined_)
#define _newgen_simdstatement_domain_defined_
#define SIMDSTATEMENT_NEWGEN_DOMAIN (simdstatement_domain)
#define simdstatement_NEWGEN_DOMAIN (simdstatement_domain)
typedef struct _newgen_struct_simdstatement_ * simdstatement;
#endif /* _newgen_simdstatement_domain_defined_ */

#define opcodeClass_domain (_gen_sac_private_start+10)
#if !defined(_newgen_opcodeClass_domain_defined_)
#define _newgen_opcodeClass_domain_defined_
#define OPCODECLASS_NEWGEN_DOMAIN (opcodeClass_domain)
#define opcodeClass_NEWGEN_DOMAIN (opcodeClass_domain)
typedef struct _newgen_struct_opcodeClass_ * opcodeClass;
#endif /* _newgen_opcodeClass_domain_defined_ */

#define transformation_domain (_gen_sac_private_start+11)
#if !defined(_newgen_transformation_domain_defined_)
#define _newgen_transformation_domain_defined_
#define TRANSFORMATION_NEWGEN_DOMAIN (transformation_domain)
#define transformation_NEWGEN_DOMAIN (transformation_domain)
typedef struct _newgen_struct_transformation_ * transformation;
#endif /* _newgen_transformation_domain_defined_ */


/* MATCHTREE
 */
#define MATCHTREE(x) ((matchTree)((x).p))
#define matchTree_CAST(x) MATCHTREE(x)
#define MATCHTREE_CAST(x) MATCHTREE(x)
#define MATCHTREE_(x) ((x).e)
#define MATCHTREE_TYPE matchTree
#define matchTree_TYPE matchTree
#define matchTree_undefined ((matchTree)gen_chunk_undefined)
#define matchTree_undefined_p(x) ((x)==matchTree_undefined)

extern matchTree copy_matchTree(matchTree);
extern void free_matchTree(matchTree);
extern matchTree check_matchTree(matchTree);
extern bool matchTree_consistent_p(matchTree);
extern bool matchTree_defined_p(matchTree);
#define gen_MATCHTREE_cons gen_matchTree_cons
extern list gen_matchTree_cons(matchTree, list);
extern void matchTree_assign_contents(matchTree, matchTree);
extern void matchTree_non_recursive_free(matchTree);
extern void write_matchTree(FILE*, matchTree);
extern matchTree read_matchTree(FILE*);
extern matchTree make_matchTree(list, matchTreeSons);

struct _newgen_struct_matchTree_ {
  intptr_t _type_;
  list _matchTree_patterns_; /* patterns:patternx* */
  matchTreeSons _matchTree_sons_; /* sons:matchTreeSons */
};

#define matchTree_domain_number(x) ((x)->_type_)
#define matchTree_patterns_(x) matchTree_patterns(x) /* old hack compatible */
#define matchTree_patterns(x) ((x)->_matchTree_patterns_)
#define matchTree_sons_(x) matchTree_sons(x) /* old hack compatible */
#define matchTree_sons(x) ((x)->_matchTree_sons_)

/* MATCHTREESONS
 */
#define MATCHTREESONS(x) ((matchTreeSons)((x).p))
#define matchTreeSons_CAST(x) MATCHTREESONS(x)
#define MATCHTREESONS_CAST(x) MATCHTREESONS(x)
#define MATCHTREESONS_(x) ((x).e)
#define MATCHTREESONS_TYPE matchTreeSons
#define matchTreeSons_TYPE matchTreeSons
#define matchTreeSons_undefined ((matchTreeSons)gen_chunk_undefined)
#define matchTreeSons_undefined_p(x) ((x)==matchTreeSons_undefined)

extern matchTreeSons copy_matchTreeSons(matchTreeSons);
extern void free_matchTreeSons(matchTreeSons);
extern matchTreeSons check_matchTreeSons(matchTreeSons);
extern bool matchTreeSons_consistent_p(matchTreeSons);
extern bool matchTreeSons_defined_p(matchTreeSons);
#define gen_MATCHTREESONS_cons gen_matchTreeSons_cons
extern list gen_matchTreeSons_cons(matchTreeSons, list);
extern void matchTreeSons_assign_contents(matchTreeSons, matchTreeSons);
extern void matchTreeSons_non_recursive_free(matchTreeSons);
extern void write_matchTreeSons(FILE*, matchTreeSons);
extern matchTreeSons read_matchTreeSons(FILE*);
extern matchTreeSons make_matchTreeSons(void);

struct _newgen_struct_matchTreeSons_ {
  intptr_t _type_;
  hash_table _matchTreeSons_holder_;
};

#define matchTreeSons_domain_number(x) ((x)->_type_)
#define matchTreeSons_hash_table(x) ((x)->_matchTreeSons_holder_)
#define matchTreeSons_key_type intptr_t
#define matchTreeSons_value_type matchTree
#define MATCHTREESONS_MAP(k,v,c,f) FUNCTION_MAP(matchTreeSons,i,p,k,v,c,f)
#define MATCHTREESONS_FOREACH(k,v,f) FUNCTION_FOREACH(matchTreeSons,i,p,k,v,f)
extern matchTree apply_matchTreeSons(matchTreeSons, intptr_t);
extern void update_matchTreeSons(matchTreeSons, intptr_t, matchTree);
extern void extend_matchTreeSons(matchTreeSons, intptr_t, matchTree);
extern matchTree delete_matchTreeSons(matchTreeSons, intptr_t);
extern bool bound_matchTreeSons_p(matchTreeSons, intptr_t);

/* MATCH
 */
#define MATCH(x) ((match)((x).p))
#define match_CAST(x) MATCH(x)
#define MATCH_CAST(x) MATCH(x)
#define MATCH_(x) ((x).e)
#define MATCH_TYPE match
#define match_TYPE match
#define match_undefined ((match)gen_chunk_undefined)
#define match_undefined_p(x) ((x)==match_undefined)

extern match copy_match(match);
extern void free_match(match);
extern match check_match(match);
extern bool match_consistent_p(match);
extern bool match_defined_p(match);
#define gen_MATCH_cons gen_match_cons
extern list gen_match_cons(match, list);
extern void match_assign_contents(match, match);
extern void match_non_recursive_free(match);
extern void write_match(FILE*, match);
extern match read_match(FILE*);
extern match make_match(opcodeClass, list);

struct _newgen_struct_match_ {
  intptr_t _type_;
  opcodeClass _match_type_; /* type:opcodeClass */
  list _match_args_; /* args:expression* */
};

#define match_domain_number(x) ((x)->_type_)
#define match_type_(x) match_type(x) /* old hack compatible */
#define match_type(x) ((x)->_match_type_)
#define match_args_(x) match_args(x) /* old hack compatible */
#define match_args(x) ((x)->_match_args_)

/* OPCODE
 */
#define OPCODE(x) ((opcode)((x).p))
#define opcode_CAST(x) OPCODE(x)
#define OPCODE_CAST(x) OPCODE(x)
#define OPCODE_(x) ((x).e)
#define OPCODE_TYPE opcode
#define opcode_TYPE opcode
#define opcode_undefined ((opcode)gen_chunk_undefined)
#define opcode_undefined_p(x) ((x)==opcode_undefined)

extern opcode copy_opcode(opcode);
extern void free_opcode(opcode);
extern opcode check_opcode(opcode);
extern bool opcode_consistent_p(opcode);
extern bool opcode_defined_p(opcode);
#define gen_OPCODE_cons gen_opcode_cons
extern list gen_opcode_cons(opcode, list);
extern void opcode_assign_contents(opcode, opcode);
extern void opcode_non_recursive_free(opcode);
extern void write_opcode(FILE*, opcode);
extern opcode read_opcode(FILE*);
extern opcode make_opcode(string, intptr_t, list, float);

struct _newgen_struct_opcode_ {
  intptr_t _type_;
  string _opcode_name_; /* name:string */
  intptr_t _opcode_vectorSize_; /* vectorSize:int */
  list _opcode_argType_; /* argType:int* */
  gen_chunk _opcode_cost_; /* cost:float */
};

#define opcode_domain_number(x) ((x)->_type_)
#define opcode_name_(x) opcode_name(x) /* old hack compatible */
#define opcode_name(x) ((x)->_opcode_name_)
#define opcode_vectorSize_(x) opcode_vectorSize(x) /* old hack compatible */
#define opcode_vectorSize(x) ((x)->_opcode_vectorSize_)
#define opcode_argType_(x) opcode_argType(x) /* old hack compatible */
#define opcode_argType(x) ((x)->_opcode_argType_)
#define opcode_cost_(x) opcode_cost(x) /* old hack compatible */
#define opcode_cost(x) ((x)->_opcode_cost_.f)

/* OPERATOR_ID_TREE
 */
#define OPERATOR_ID_TREE(x) ((operator_id_tree)((x).p))
#define operator_id_tree_CAST(x) OPERATOR_ID_TREE(x)
#define OPERATOR_ID_TREE_CAST(x) OPERATOR_ID_TREE(x)
#define OPERATOR_ID_TREE_(x) ((x).e)
#define OPERATOR_ID_TREE_TYPE operator_id_tree
#define operator_id_tree_TYPE operator_id_tree
#define operator_id_tree_undefined ((operator_id_tree)gen_chunk_undefined)
#define operator_id_tree_undefined_p(x) ((x)==operator_id_tree_undefined)

extern operator_id_tree copy_operator_id_tree(operator_id_tree);
extern void free_operator_id_tree(operator_id_tree);
extern operator_id_tree check_operator_id_tree(operator_id_tree);
extern bool operator_id_tree_consistent_p(operator_id_tree);
extern bool operator_id_tree_defined_p(operator_id_tree);
#define gen_OPERATOR_ID_TREE_cons gen_operator_id_tree_cons
extern list gen_operator_id_tree_cons(operator_id_tree, list);
extern void operator_id_tree_assign_contents(operator_id_tree, operator_id_tree);
extern void operator_id_tree_non_recursive_free(operator_id_tree);
extern void write_operator_id_tree(FILE*, operator_id_tree);
extern operator_id_tree read_operator_id_tree(FILE*);
extern operator_id_tree make_operator_id_tree(intptr_t, operator_id_sons);

struct _newgen_struct_operator_id_tree_ {
  intptr_t _type_;
  intptr_t _operator_id_tree_id_; /* id:int */
  operator_id_sons _operator_id_tree_sons_; /* sons:operator_id_sons */
};

#define operator_id_tree_domain_number(x) ((x)->_type_)
#define operator_id_tree_id_(x) operator_id_tree_id(x) /* old hack compatible */
#define operator_id_tree_id(x) ((x)->_operator_id_tree_id_)
#define operator_id_tree_sons_(x) operator_id_tree_sons(x) /* old hack compatible */
#define operator_id_tree_sons(x) ((x)->_operator_id_tree_sons_)

/* PATTERNARG
 */
#define PATTERNARG(x) ((patternArg)((x).p))
#define patternArg_CAST(x) PATTERNARG(x)
#define PATTERNARG_CAST(x) PATTERNARG(x)
#define PATTERNARG_(x) ((x).e)
#define PATTERNARG_TYPE patternArg
#define patternArg_TYPE patternArg
#define patternArg_undefined ((patternArg)gen_chunk_undefined)
#define patternArg_undefined_p(x) ((x)==patternArg_undefined)

extern patternArg copy_patternArg(patternArg);
extern void free_patternArg(patternArg);
extern patternArg check_patternArg(patternArg);
extern bool patternArg_consistent_p(patternArg);
extern bool patternArg_defined_p(patternArg);
#define gen_PATTERNARG_cons gen_patternArg_cons
extern list gen_patternArg_cons(patternArg, list);
extern void patternArg_assign_contents(patternArg, patternArg);
extern void patternArg_non_recursive_free(patternArg);
extern void write_patternArg(FILE*, patternArg);
extern patternArg read_patternArg(FILE*);
enum patternArg_utype {
  is_patternArg_static,
  is_patternArg_dynamic
};
extern string patternArg_tag_as_string(enum patternArg_utype);
extern patternArg make_patternArg(enum patternArg_utype, void *);
extern patternArg make_patternArg_static(intptr_t);
extern patternArg make_patternArg_dynamic(void);

struct _newgen_struct_patternArg_ {
  intptr_t _type_;
  enum patternArg_utype _patternArg_tag__;
  union {
    intptr_t _patternArg_static_; /* static:int */
    gen_chunk _patternArg_dynamic_; /* dynamic:unit */
  } _patternArg_union_;
};

#define patternArg_domain_number(x) ((x)->_type_)
#define patternArg_tag(x) ((x)->_patternArg_tag__)
#define patternArg_static_p(x) (patternArg_tag(x)==is_patternArg_static)
#define patternArg_static_(x) patternArg_static(x) /* old hack compatible */
#define patternArg_static(x) ((x)->_patternArg_union_._patternArg_static_)
#define patternArg_dynamic_p(x) (patternArg_tag(x)==is_patternArg_dynamic)
#define patternArg_dynamic_(x) patternArg_dynamic(x) /* old hack compatible */
#define patternArg_dynamic(x) ((x)->_patternArg_union_._patternArg_dynamic_.u)

/* PATTERNX
 */
#define PATTERNX(x) ((patternx)((x).p))
#define patternx_CAST(x) PATTERNX(x)
#define PATTERNX_CAST(x) PATTERNX(x)
#define PATTERNX_(x) ((x).e)
#define PATTERNX_TYPE patternx
#define patternx_TYPE patternx
#define patternx_undefined ((patternx)gen_chunk_undefined)
#define patternx_undefined_p(x) ((x)==patternx_undefined)

extern patternx copy_patternx(patternx);
extern void free_patternx(patternx);
extern patternx check_patternx(patternx);
extern bool patternx_consistent_p(patternx);
extern bool patternx_defined_p(patternx);
#define gen_PATTERNX_cons gen_patternx_cons
extern list gen_patternx_cons(patternx, list);
extern void patternx_assign_contents(patternx, patternx);
extern void patternx_non_recursive_free(patternx);
extern void write_patternx(FILE*, patternx);
extern patternx read_patternx(FILE*);
extern patternx make_patternx(opcodeClass, list);

struct _newgen_struct_patternx_ {
  intptr_t _type_;
  opcodeClass _patternx_class_; /* class:opcodeClass */
  list _patternx_args_; /* args:patternArg* */
};

#define patternx_domain_number(x) ((x)->_type_)
#define patternx_class_(x) patternx_class(x) /* old hack compatible */
#define patternx_class(x) ((x)->_patternx_class_)
#define patternx_args_(x) patternx_args(x) /* old hack compatible */
#define patternx_args(x) ((x)->_patternx_args_)

/* REDUCTIONINFO
 */
#define REDUCTIONINFO(x) ((reductionInfo)((x).p))
#define reductionInfo_CAST(x) REDUCTIONINFO(x)
#define REDUCTIONINFO_CAST(x) REDUCTIONINFO(x)
#define REDUCTIONINFO_(x) ((x).e)
#define REDUCTIONINFO_TYPE reductionInfo
#define reductionInfo_TYPE reductionInfo
#define reductionInfo_undefined ((reductionInfo)gen_chunk_undefined)
#define reductionInfo_undefined_p(x) ((x)==reductionInfo_undefined)

extern reductionInfo copy_reductionInfo(reductionInfo);
extern void free_reductionInfo(reductionInfo);
extern reductionInfo check_reductionInfo(reductionInfo);
extern bool reductionInfo_consistent_p(reductionInfo);
extern bool reductionInfo_defined_p(reductionInfo);
#define gen_REDUCTIONINFO_cons gen_reductionInfo_cons
extern list gen_reductionInfo_cons(reductionInfo, list);
extern void reductionInfo_assign_contents(reductionInfo, reductionInfo);
extern void reductionInfo_non_recursive_free(reductionInfo);
extern void write_reductionInfo(FILE*, reductionInfo);
extern reductionInfo read_reductionInfo(FILE*);
extern reductionInfo make_reductionInfo(reduction, intptr_t, entity);

struct _newgen_struct_reductionInfo_ {
  intptr_t _type_;
  reduction _reductionInfo_reduction_; /* reduction:reduction */
  intptr_t _reductionInfo_count_; /* count:int */
  entity _reductionInfo_vector_; /* vector:entity */
};

#define reductionInfo_domain_number(x) ((x)->_type_)
#define reductionInfo_reduction_(x) reductionInfo_reduction(x) /* old hack compatible */
#define reductionInfo_reduction(x) ((x)->_reductionInfo_reduction_)
#define reductionInfo_count_(x) reductionInfo_count(x) /* old hack compatible */
#define reductionInfo_count(x) ((x)->_reductionInfo_count_)
#define reductionInfo_vector_(x) reductionInfo_vector(x) /* old hack compatible */
#define reductionInfo_vector(x) ((x)->_reductionInfo_vector_)

/* SIMDSTATEMENT
 */
#define SIMDSTATEMENT(x) ((simdstatement)((x).p))
#define simdstatement_CAST(x) SIMDSTATEMENT(x)
#define SIMDSTATEMENT_CAST(x) SIMDSTATEMENT(x)
#define SIMDSTATEMENT_(x) ((x).e)
#define SIMDSTATEMENT_TYPE simdstatement
#define simdstatement_TYPE simdstatement
#define simdstatement_undefined ((simdstatement)gen_chunk_undefined)
#define simdstatement_undefined_p(x) ((x)==simdstatement_undefined)

extern simdstatement copy_simdstatement(simdstatement);
extern void free_simdstatement(simdstatement);
extern simdstatement check_simdstatement(simdstatement);
extern bool simdstatement_consistent_p(simdstatement);
extern bool simdstatement_defined_p(simdstatement);
#define gen_SIMDSTATEMENT_cons gen_simdstatement_cons
extern list gen_simdstatement_cons(simdstatement, list);
extern void simdstatement_assign_contents(simdstatement, simdstatement);
extern void simdstatement_non_recursive_free(simdstatement);
extern void write_simdstatement(FILE*, simdstatement);
extern simdstatement read_simdstatement(FILE*);
extern simdstatement make_simdstatement(opcode, intptr_t, entity *, expression *);

struct _newgen_struct_simdstatement_ {
  intptr_t _type_;
  opcode _simdstatement_opcode_; /* opcode:opcode */
  intptr_t _simdstatement_nbArgs_; /* nbArgs:int */
  entity * _simdstatement_vectors_; /* vectors:entity[] */
  expression * _simdstatement_arguments_; /* arguments:expression[] */
};

#define simdstatement_domain_number(x) ((x)->_type_)
#define simdstatement_opcode_(x) simdstatement_opcode(x) /* old hack compatible */
#define simdstatement_opcode(x) ((x)->_simdstatement_opcode_)
#define simdstatement_nbArgs_(x) simdstatement_nbArgs(x) /* old hack compatible */
#define simdstatement_nbArgs(x) ((x)->_simdstatement_nbArgs_)
#define simdstatement_vectors_(x) simdstatement_vectors(x) /* old hack compatible */
#define simdstatement_vectors(x) ((x)->_simdstatement_vectors_)
#define simdstatement_arguments_(x) simdstatement_arguments(x) /* old hack compatible */
#define simdstatement_arguments(x) ((x)->_simdstatement_arguments_)

/* OPCODECLASS
 */
#define OPCODECLASS(x) ((opcodeClass)((x).p))
#define opcodeClass_CAST(x) OPCODECLASS(x)
#define OPCODECLASS_CAST(x) OPCODECLASS(x)
#define OPCODECLASS_(x) ((x).e)
#define OPCODECLASS_TYPE opcodeClass
#define opcodeClass_TYPE opcodeClass
#define opcodeClass_undefined ((opcodeClass)gen_chunk_undefined)
#define opcodeClass_undefined_p(x) ((x)==opcodeClass_undefined)

extern opcodeClass copy_opcodeClass(opcodeClass);
extern void free_opcodeClass(opcodeClass);
extern opcodeClass check_opcodeClass(opcodeClass);
extern bool opcodeClass_consistent_p(opcodeClass);
extern bool opcodeClass_defined_p(opcodeClass);
#define gen_OPCODECLASS_cons gen_opcodeClass_cons
extern list gen_opcodeClass_cons(opcodeClass, list);
extern void opcodeClass_assign_contents(opcodeClass, opcodeClass);
extern void opcodeClass_non_recursive_free(opcodeClass);
extern opcodeClass gen_find_opcodeClass(char *);
extern void write_tabulated_opcodeClass(FILE *);
extern void read_tabulated_opcodeClass(FILE *);
extern opcodeClass make_opcodeClass(string, intptr_t, list);

struct _newgen_struct_opcodeClass_ {
  intptr_t _type_;
  intptr_t _opcodeClass_index__;
  string _opcodeClass_name_; /* name:string */
  intptr_t _opcodeClass_nbArgs_; /* nbArgs:int */
  list _opcodeClass_opcodes_; /* opcodes:opcode* */
};

#define opcodeClass_domain_number(x) ((x)->_type_)
#define opcodeClass_name_(x) opcodeClass_name(x) /* old hack compatible */
#define opcodeClass_name(x) ((x)->_opcodeClass_name_)
#define opcodeClass_nbArgs_(x) opcodeClass_nbArgs(x) /* old hack compatible */
#define opcodeClass_nbArgs(x) ((x)->_opcodeClass_nbArgs_)
#define opcodeClass_opcodes_(x) opcodeClass_opcodes(x) /* old hack compatible */
#define opcodeClass_opcodes(x) ((x)->_opcodeClass_opcodes_)

/* TRANSFORMATION
 */
#define TRANSFORMATION(x) ((transformation)((x).p))
#define transformation_CAST(x) TRANSFORMATION(x)
#define TRANSFORMATION_CAST(x) TRANSFORMATION(x)
#define TRANSFORMATION_(x) ((x).e)
#define TRANSFORMATION_TYPE transformation
#define transformation_TYPE transformation
#define transformation_undefined ((transformation)gen_chunk_undefined)
#define transformation_undefined_p(x) ((x)==transformation_undefined)

extern transformation copy_transformation(transformation);
extern void free_transformation(transformation);
extern transformation check_transformation(transformation);
extern bool transformation_consistent_p(transformation);
extern bool transformation_defined_p(transformation);
#define gen_TRANSFORMATION_cons gen_transformation_cons
extern list gen_transformation_cons(transformation, list);
extern void transformation_assign_contents(transformation, transformation);
extern void transformation_non_recursive_free(transformation);
extern void write_transformation(FILE*, transformation);
extern transformation read_transformation(FILE*);
extern transformation make_transformation(string, intptr_t, intptr_t, intptr_t, intptr_t, intptr_t, int *);

struct _newgen_struct_transformation_ {
  intptr_t _type_;
  string _transformation_name_; /* name:string */
  intptr_t _transformation_vectorLengthOut_; /* vectorLengthOut:int */
  intptr_t _transformation_subwordSizeOut_; /* subwordSizeOut:int */
  intptr_t _transformation_vectorLengthIn_; /* vectorLengthIn:int */
  intptr_t _transformation_subwordSizeIn_; /* subwordSizeIn:int */
  intptr_t _transformation_nbArgs_; /* nbArgs:int */
  int * _transformation_mapping_; /* mapping:int[] */
};

#define transformation_domain_number(x) ((x)->_type_)
#define transformation_name_(x) transformation_name(x) /* old hack compatible */
#define transformation_name(x) ((x)->_transformation_name_)
#define transformation_vectorLengthOut_(x) transformation_vectorLengthOut(x) /* old hack compatible */
#define transformation_vectorLengthOut(x) ((x)->_transformation_vectorLengthOut_)
#define transformation_subwordSizeOut_(x) transformation_subwordSizeOut(x) /* old hack compatible */
#define transformation_subwordSizeOut(x) ((x)->_transformation_subwordSizeOut_)
#define transformation_vectorLengthIn_(x) transformation_vectorLengthIn(x) /* old hack compatible */
#define transformation_vectorLengthIn(x) ((x)->_transformation_vectorLengthIn_)
#define transformation_subwordSizeIn_(x) transformation_subwordSizeIn(x) /* old hack compatible */
#define transformation_subwordSizeIn(x) ((x)->_transformation_subwordSizeIn_)
#define transformation_nbArgs_(x) transformation_nbArgs(x) /* old hack compatible */
#define transformation_nbArgs(x) ((x)->_transformation_nbArgs_)
#define transformation_mapping_(x) transformation_mapping(x) /* old hack compatible */
#define transformation_mapping(x) ((x)->_transformation_mapping_)

#define sac_private_spec "\
--NEWGEN-START 174\n\
import entity from \"ri.newgen\";\n\
import expression from \"ri.newgen\";\n\
import statement from \"ri.newgen\";\n\
import reference from \"ri.newgen\";\n\
import reduction from \"reductions_private.newgen\";\n\
external operator_id_sons;\n\
matchTree = patterns:patternx* x sons:matchTreeSons;\n\
matchTreeSons = int:int -> matchTree:matchTree;\n\
match = type:opcodeClass x args:expression*;\n\
opcode = name:string x vectorSize:int x argType:int* x cost:float;\n\
operator_id_tree = id:int x sons:operator_id_sons;\n\
patternArg = static:int + dynamic:unit;\n\
patternx = class:opcodeClass x args:patternArg*;\n\
reductionInfo = persistant reduction:reduction x count:int x persistant vector:entity;\n\
simdstatement = opcode:opcode x nbArgs:int x vectors:entity[16] x arguments:expression[48];\n\
tabulated opcodeClass = name:string x nbArgs:int x opcodes:opcode*;\n\
transformation = name:string x vectorLengthOut:int x subwordSizeOut:int x vectorLengthIn:int x subwordSizeIn:int x nbArgs:int x mapping:int[16];\n\
"
#endif
