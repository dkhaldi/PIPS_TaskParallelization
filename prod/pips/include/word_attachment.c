/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

typedef void * void_star;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "genC.h"
#include "word_attachment.h"


/* ATTACHEE
 */
attachee copy_attachee(attachee p) {
  return (attachee) gen_copy_tree((gen_chunk*) p);
}
void free_attachee(attachee p) {
  gen_free((gen_chunk*) p);
}
attachee check_attachee(attachee p) {
  return (attachee) gen_check((gen_chunk*) p, attachee_domain);
}
bool attachee_consistent_p(attachee p) {
  check_attachee(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool attachee_defined_p(attachee p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_attachee_cons(attachee p, list l) {
  return gen_typed_cons(ATTACHEE_NEWGEN_DOMAIN, p, l);
}
void attachee_assign_contents(attachee r, attachee v) {
  check_attachee(r);
  check_attachee(v);
  message_assert("defined references to domain attachee",
                 attachee_defined_p(r) && attachee_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_attachee_));
}
void attachee_non_recursive_free(attachee p) {
  // should clear up contents...
  free(p);
}
void write_attachee(FILE* f, attachee p) {
  gen_write(f, (gen_chunk*) p);
}
attachee read_attachee(FILE* f) {
  return (attachee) gen_read(f);
}
string attachee_tag_as_string(enum attachee_utype tag) {
  switch (tag) {
  case is_attachee_statement_line_number: return "statement_line_number";
  case is_attachee_reference: return "reference";
  case is_attachee_call: return "call";
  case is_attachee_declaration: return "declaration";
  case is_attachee_type: return "type";
  case is_attachee_loop: return "loop";
  case is_attachee_module_head: return "module_head";
  case is_attachee_complementary_sections: return "complementary_sections";
  case is_attachee_complexities: return "complexities";
  case is_attachee_continuation_conditions: return "continuation_conditions";
  case is_attachee_cumulated_effects: return "cumulated_effects";
  case is_attachee_out_regions: return "out_regions";
  case is_attachee_preconditions: return "preconditions";
  case is_attachee_privatized_regions: return "privatized_regions";
  case is_attachee_proper_effects: return "proper_effects";
  case is_attachee_proper_regions: return "proper_regions";
  case is_attachee_regions: return "regions";
  case is_attachee_static_control: return "static_control";
  case is_attachee_transformers: return "transformers";
  case is_attachee_decoration: return "decoration";
  case is_attachee_comment: return "comment";
  default: return string_undefined;
  }
}
attachee make_attachee(enum attachee_utype tag, void * val) {
  return (attachee) gen_alloc(3*sizeof(gen_chunk), GEN_CHECK_ALLOC, attachee_domain, tag, val);
}
attachee make_attachee_statement_line_number(intptr_t _field_) {
  return make_attachee(is_attachee_statement_line_number, (void*)(intptr_t) _field_);
}
attachee make_attachee_reference(reference _field_) {
  return make_attachee(is_attachee_reference, (void*)(intptr_t) _field_);
}
attachee make_attachee_call(call _field_) {
  return make_attachee(is_attachee_call, (void*)(intptr_t) _field_);
}
attachee make_attachee_declaration(entity _field_) {
  return make_attachee(is_attachee_declaration, (void*)(intptr_t) _field_);
}
attachee make_attachee_type(string _field_) {
  return make_attachee(is_attachee_type, (void*)(intptr_t) _field_);
}
attachee make_attachee_loop(loop _field_) {
  return make_attachee(is_attachee_loop, (void*)(intptr_t) _field_);
}
attachee make_attachee_module_head(entity _field_) {
  return make_attachee(is_attachee_module_head, (void*)(intptr_t) _field_);
}
attachee make_attachee_complementary_sections(void) {
  return make_attachee(is_attachee_complementary_sections, UU);
}
attachee make_attachee_complexities(void) {
  return make_attachee(is_attachee_complexities, UU);
}
attachee make_attachee_continuation_conditions(void) {
  return make_attachee(is_attachee_continuation_conditions, UU);
}
attachee make_attachee_cumulated_effects(void) {
  return make_attachee(is_attachee_cumulated_effects, UU);
}
attachee make_attachee_out_regions(void) {
  return make_attachee(is_attachee_out_regions, UU);
}
attachee make_attachee_preconditions(void) {
  return make_attachee(is_attachee_preconditions, UU);
}
attachee make_attachee_privatized_regions(void) {
  return make_attachee(is_attachee_privatized_regions, UU);
}
attachee make_attachee_proper_effects(void) {
  return make_attachee(is_attachee_proper_effects, UU);
}
attachee make_attachee_proper_regions(void) {
  return make_attachee(is_attachee_proper_regions, UU);
}
attachee make_attachee_regions(void) {
  return make_attachee(is_attachee_regions, UU);
}
attachee make_attachee_static_control(void) {
  return make_attachee(is_attachee_static_control, UU);
}
attachee make_attachee_transformers(void) {
  return make_attachee(is_attachee_transformers, UU);
}
attachee make_attachee_decoration(void) {
  return make_attachee(is_attachee_decoration, UU);
}
attachee make_attachee_comment(void) {
  return make_attachee(is_attachee_comment, UU);
}

/* ATTACHMENT
 */
attachment copy_attachment(attachment p) {
  return (attachment) gen_copy_tree((gen_chunk*) p);
}
void free_attachment(attachment p) {
  gen_free((gen_chunk*) p);
}
attachment check_attachment(attachment p) {
  return (attachment) gen_check((gen_chunk*) p, attachment_domain);
}
bool attachment_consistent_p(attachment p) {
  check_attachment(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool attachment_defined_p(attachment p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_attachment_cons(attachment p, list l) {
  return gen_typed_cons(ATTACHMENT_NEWGEN_DOMAIN, p, l);
}
void attachment_assign_contents(attachment r, attachment v) {
  check_attachment(r);
  check_attachment(v);
  message_assert("defined references to domain attachment",
                 attachment_defined_p(r) && attachment_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_attachment_));
}
void attachment_non_recursive_free(attachment p) {
  // should clear up contents...
  free(p);
}
void write_attachment(FILE* f, attachment p) {
  gen_write(f, (gen_chunk*) p);
}
attachment read_attachment(FILE* f) {
  return (attachment) gen_read(f);
}
attachment make_attachment(attachee a1, intptr_t a2, intptr_t a3) {
  return (attachment) gen_alloc(4*sizeof(gen_chunk), GEN_CHECK_ALLOC, attachment_domain, a1, a2, a3);
}

/* ATTACHMENTS
 */
attachments copy_attachments(attachments p) {
  return (attachments) gen_copy_tree((gen_chunk*) p);
}
void free_attachments(attachments p) {
  gen_free((gen_chunk*) p);
}
attachments check_attachments(attachments p) {
  return (attachments) gen_check((gen_chunk*) p, attachments_domain);
}
bool attachments_consistent_p(attachments p) {
  check_attachments(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool attachments_defined_p(attachments p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_attachments_cons(attachments p, list l) {
  return gen_typed_cons(ATTACHMENTS_NEWGEN_DOMAIN, p, l);
}
void attachments_assign_contents(attachments r, attachments v) {
  check_attachments(r);
  check_attachments(v);
  message_assert("defined references to domain attachments",
                 attachments_defined_p(r) && attachments_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_attachments_));
}
void attachments_non_recursive_free(attachments p) {
  // should clear up contents...
  free(p);
}
void write_attachments(FILE* f, attachments p) {
  gen_write(f, (gen_chunk*) p);
}
attachments read_attachments(FILE* f) {
  return (attachments) gen_read(f);
}
attachments make_attachments(list a) {
  return (attachments) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, attachments_domain, a);
}

/* WORD_TO_ATTACHMENTS
 */
word_to_attachments copy_word_to_attachments(word_to_attachments p) {
  return (word_to_attachments) gen_copy_tree((gen_chunk*) p);
}
void free_word_to_attachments(word_to_attachments p) {
  gen_free((gen_chunk*) p);
}
word_to_attachments check_word_to_attachments(word_to_attachments p) {
  return (word_to_attachments) gen_check((gen_chunk*) p, word_to_attachments_domain);
}
bool word_to_attachments_consistent_p(word_to_attachments p) {
  check_word_to_attachments(p);
  return gen_consistent_p((gen_chunk*) p);
}
bool word_to_attachments_defined_p(word_to_attachments p) {
  return gen_defined_p((gen_chunk*) p);
}
list gen_word_to_attachments_cons(word_to_attachments p, list l) {
  return gen_typed_cons(WORD_TO_ATTACHMENTS_NEWGEN_DOMAIN, p, l);
}
void word_to_attachments_assign_contents(word_to_attachments r, word_to_attachments v) {
  check_word_to_attachments(r);
  check_word_to_attachments(v);
  message_assert("defined references to domain word_to_attachments",
                 word_to_attachments_defined_p(r) && word_to_attachments_defined_p(v));
       memcpy(r, v, sizeof(struct _newgen_struct_word_to_attachments_));
}
void word_to_attachments_non_recursive_free(word_to_attachments p) {
  // should clear up contents...
  free(p);
}
void write_word_to_attachments(FILE* f, word_to_attachments p) {
  gen_write(f, (gen_chunk*) p);
}
word_to_attachments read_word_to_attachments(FILE* f) {
  return (word_to_attachments) gen_read(f);
}
word_to_attachments make_word_to_attachments(void) {
  return (word_to_attachments) gen_alloc(2*sizeof(gen_chunk), GEN_CHECK_ALLOC, word_to_attachments_domain);
}
attachments apply_word_to_attachments(word_to_attachments f, void_star k) {
  return (attachments) (intptr_t)HASH_GET(p, p, word_to_attachments_hash_table(f), k);
}
void update_word_to_attachments(word_to_attachments f, void_star k, attachments v) {
  HASH_UPDATE(p, p, word_to_attachments_hash_table(f), k, (intptr_t)v);
}
void extend_word_to_attachments(word_to_attachments f, void_star k, attachments v) {
  HASH_EXTEND(p, p, word_to_attachments_hash_table(f), k, (intptr_t)v);
}
attachments delete_word_to_attachments(word_to_attachments f, void_star k) {
  return (attachments)(intptr_t) HASH_DELETE(p, p, word_to_attachments_hash_table(f), k);
}
bool bound_word_to_attachments_p(word_to_attachments f, void_star k) {
  return (intptr_t)HASH_BOUND_P(p, p, word_to_attachments_hash_table(f), k);
}

