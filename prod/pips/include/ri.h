#ifndef _newgen_ri_included
#define _newgen_ri_included
#define _gen_ri_start 27
/*
 * THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY NEWGEN.
 *
 * PLEASE DO NOT MODIFY IT.
 */

#if !defined(_newgen_Pvecteur_domain_defined_)
#define _newgen_Pvecteur_domain_defined_
#define newgen_Pvecteur(p) (p) /* old hack compatible */
#define PVECTEUR_NEWGEN_EXTERNAL (_gen_ri_start+0)
#define PVECTEUR_NEWGEN_DOMAIN (PVECTEUR_NEWGEN_EXTERNAL)
#define Pvecteur_NEWGEN_DOMAIN (PVECTEUR_NEWGEN_EXTERNAL)
#endif /* _newgen_Pvecteur_domain_defined_ */

#if !defined(_newgen_Psysteme_domain_defined_)
#define _newgen_Psysteme_domain_defined_
#define newgen_Psysteme(p) (p) /* old hack compatible */
#define PSYSTEME_NEWGEN_EXTERNAL (_gen_ri_start+1)
#define PSYSTEME_NEWGEN_DOMAIN (PSYSTEME_NEWGEN_EXTERNAL)
#define Psysteme_NEWGEN_DOMAIN (PSYSTEME_NEWGEN_EXTERNAL)
#endif /* _newgen_Psysteme_domain_defined_ */

#define application_domain (_gen_ri_start+2)
#if !defined(_newgen_application_domain_defined_)
#define _newgen_application_domain_defined_
#define APPLICATION_NEWGEN_DOMAIN (application_domain)
#define application_NEWGEN_DOMAIN (application_domain)
typedef struct _newgen_struct_application_ * application;
#endif /* _newgen_application_domain_defined_ */

#define area_domain (_gen_ri_start+3)
#if !defined(_newgen_area_domain_defined_)
#define _newgen_area_domain_defined_
#define AREA_NEWGEN_DOMAIN (area_domain)
#define area_NEWGEN_DOMAIN (area_domain)
typedef struct _newgen_struct_area_ * area;
#endif /* _newgen_area_domain_defined_ */

#define basic_domain (_gen_ri_start+4)
#if !defined(_newgen_basic_domain_defined_)
#define _newgen_basic_domain_defined_
#define BASIC_NEWGEN_DOMAIN (basic_domain)
#define basic_NEWGEN_DOMAIN (basic_domain)
typedef struct _newgen_struct_basic_ * basic;
#endif /* _newgen_basic_domain_defined_ */

#define callees_domain (_gen_ri_start+5)
#if !defined(_newgen_callees_domain_defined_)
#define _newgen_callees_domain_defined_
#define CALLEES_NEWGEN_DOMAIN (callees_domain)
#define callees_NEWGEN_DOMAIN (callees_domain)
typedef struct _newgen_struct_callees_ * callees;
#endif /* _newgen_callees_domain_defined_ */

#define call_domain (_gen_ri_start+6)
#if !defined(_newgen_call_domain_defined_)
#define _newgen_call_domain_defined_
#define CALL_NEWGEN_DOMAIN (call_domain)
#define call_NEWGEN_DOMAIN (call_domain)
typedef struct _newgen_struct_call_ * call;
#endif /* _newgen_call_domain_defined_ */

#define cast_domain (_gen_ri_start+7)
#if !defined(_newgen_cast_domain_defined_)
#define _newgen_cast_domain_defined_
#define CAST_NEWGEN_DOMAIN (cast_domain)
#define cast_NEWGEN_DOMAIN (cast_domain)
typedef struct _newgen_struct_cast_ * cast;
#endif /* _newgen_cast_domain_defined_ */

#define code_domain (_gen_ri_start+8)
#if !defined(_newgen_code_domain_defined_)
#define _newgen_code_domain_defined_
#define CODE_NEWGEN_DOMAIN (code_domain)
#define code_NEWGEN_DOMAIN (code_domain)
typedef struct _newgen_struct_code_ * code;
#endif /* _newgen_code_domain_defined_ */

#define constant_domain (_gen_ri_start+9)
#if !defined(_newgen_constant_domain_defined_)
#define _newgen_constant_domain_defined_
#define CONSTANT_NEWGEN_DOMAIN (constant_domain)
#define constant_NEWGEN_DOMAIN (constant_domain)
typedef struct _newgen_struct_constant_ * constant;
#endif /* _newgen_constant_domain_defined_ */

#define controlmap_domain (_gen_ri_start+10)
#if !defined(_newgen_controlmap_domain_defined_)
#define _newgen_controlmap_domain_defined_
#define CONTROLMAP_NEWGEN_DOMAIN (controlmap_domain)
#define controlmap_NEWGEN_DOMAIN (controlmap_domain)
typedef struct _newgen_struct_controlmap_ * controlmap;
#endif /* _newgen_controlmap_domain_defined_ */

#define control_domain (_gen_ri_start+11)
#if !defined(_newgen_control_domain_defined_)
#define _newgen_control_domain_defined_
#define CONTROL_NEWGEN_DOMAIN (control_domain)
#define control_NEWGEN_DOMAIN (control_domain)
typedef struct _newgen_struct_control_ * control;
#endif /* _newgen_control_domain_defined_ */

#define dimension_domain (_gen_ri_start+12)
#if !defined(_newgen_dimension_domain_defined_)
#define _newgen_dimension_domain_defined_
#define DIMENSION_NEWGEN_DOMAIN (dimension_domain)
#define dimension_NEWGEN_DOMAIN (dimension_domain)
typedef struct _newgen_struct_dimension_ * dimension;
#endif /* _newgen_dimension_domain_defined_ */

#define dummy_domain (_gen_ri_start+13)
#if !defined(_newgen_dummy_domain_defined_)
#define _newgen_dummy_domain_defined_
#define DUMMY_NEWGEN_DOMAIN (dummy_domain)
#define dummy_NEWGEN_DOMAIN (dummy_domain)
typedef struct _newgen_struct_dummy_ * dummy;
#endif /* _newgen_dummy_domain_defined_ */

#define entity_int_domain (_gen_ri_start+14)
#if !defined(_newgen_entity_int_domain_defined_)
#define _newgen_entity_int_domain_defined_
#define ENTITY_INT_NEWGEN_DOMAIN (entity_int_domain)
#define entity_int_NEWGEN_DOMAIN (entity_int_domain)
typedef struct _newgen_struct_entity_int_ * entity_int;
#endif /* _newgen_entity_int_domain_defined_ */

#define evaluation_domain (_gen_ri_start+15)
#if !defined(_newgen_evaluation_domain_defined_)
#define _newgen_evaluation_domain_defined_
#define EVALUATION_NEWGEN_DOMAIN (evaluation_domain)
#define evaluation_NEWGEN_DOMAIN (evaluation_domain)
typedef struct _newgen_struct_evaluation_ * evaluation;
#endif /* _newgen_evaluation_domain_defined_ */

#define execution_domain (_gen_ri_start+16)
#if !defined(_newgen_execution_domain_defined_)
#define _newgen_execution_domain_defined_
#define EXECUTION_NEWGEN_DOMAIN (execution_domain)
#define execution_NEWGEN_DOMAIN (execution_domain)
typedef struct _newgen_struct_execution_ * execution;
#endif /* _newgen_execution_domain_defined_ */

#define expression_domain (_gen_ri_start+17)
#if !defined(_newgen_expression_domain_defined_)
#define _newgen_expression_domain_defined_
#define EXPRESSION_NEWGEN_DOMAIN (expression_domain)
#define expression_NEWGEN_DOMAIN (expression_domain)
typedef struct _newgen_struct_expression_ * expression;
#endif /* _newgen_expression_domain_defined_ */

#define extension_domain (_gen_ri_start+18)
#if !defined(_newgen_extension_domain_defined_)
#define _newgen_extension_domain_defined_
#define EXTENSION_NEWGEN_DOMAIN (extension_domain)
#define extension_NEWGEN_DOMAIN (extension_domain)
typedef struct _newgen_struct_extension_ * extension;
#endif /* _newgen_extension_domain_defined_ */

#define extensions_domain (_gen_ri_start+19)
#if !defined(_newgen_extensions_domain_defined_)
#define _newgen_extensions_domain_defined_
#define EXTENSIONS_NEWGEN_DOMAIN (extensions_domain)
#define extensions_NEWGEN_DOMAIN (extensions_domain)
typedef struct _newgen_struct_extensions_ * extensions;
#endif /* _newgen_extensions_domain_defined_ */

#define forloop_domain (_gen_ri_start+20)
#if !defined(_newgen_forloop_domain_defined_)
#define _newgen_forloop_domain_defined_
#define FORLOOP_NEWGEN_DOMAIN (forloop_domain)
#define forloop_NEWGEN_DOMAIN (forloop_domain)
typedef struct _newgen_struct_forloop_ * forloop;
#endif /* _newgen_forloop_domain_defined_ */

#define formal_domain (_gen_ri_start+21)
#if !defined(_newgen_formal_domain_defined_)
#define _newgen_formal_domain_defined_
#define FORMAL_NEWGEN_DOMAIN (formal_domain)
#define formal_NEWGEN_DOMAIN (formal_domain)
typedef struct _newgen_struct_formal_ * formal;
#endif /* _newgen_formal_domain_defined_ */

#define functional_domain (_gen_ri_start+22)
#if !defined(_newgen_functional_domain_defined_)
#define _newgen_functional_domain_defined_
#define FUNCTIONAL_NEWGEN_DOMAIN (functional_domain)
#define functional_NEWGEN_DOMAIN (functional_domain)
typedef struct _newgen_struct_functional_ * functional;
#endif /* _newgen_functional_domain_defined_ */

#define instruction_domain (_gen_ri_start+23)
#if !defined(_newgen_instruction_domain_defined_)
#define _newgen_instruction_domain_defined_
#define INSTRUCTION_NEWGEN_DOMAIN (instruction_domain)
#define instruction_NEWGEN_DOMAIN (instruction_domain)
typedef struct _newgen_struct_instruction_ * instruction;
#endif /* _newgen_instruction_domain_defined_ */

#define language_domain (_gen_ri_start+24)
#if !defined(_newgen_language_domain_defined_)
#define _newgen_language_domain_defined_
#define LANGUAGE_NEWGEN_DOMAIN (language_domain)
#define language_NEWGEN_DOMAIN (language_domain)
typedef struct _newgen_struct_language_ * language;
#endif /* _newgen_language_domain_defined_ */

#define loop_domain (_gen_ri_start+25)
#if !defined(_newgen_loop_domain_defined_)
#define _newgen_loop_domain_defined_
#define LOOP_NEWGEN_DOMAIN (loop_domain)
#define loop_NEWGEN_DOMAIN (loop_domain)
typedef struct _newgen_struct_loop_ * loop;
#endif /* _newgen_loop_domain_defined_ */

#define mode_domain (_gen_ri_start+26)
#if !defined(_newgen_mode_domain_defined_)
#define _newgen_mode_domain_defined_
#define MODE_NEWGEN_DOMAIN (mode_domain)
#define mode_NEWGEN_DOMAIN (mode_domain)
typedef struct _newgen_struct_mode_ * mode;
#endif /* _newgen_mode_domain_defined_ */

#define multitest_domain (_gen_ri_start+27)
#if !defined(_newgen_multitest_domain_defined_)
#define _newgen_multitest_domain_defined_
#define MULTITEST_NEWGEN_DOMAIN (multitest_domain)
#define multitest_NEWGEN_DOMAIN (multitest_domain)
typedef struct _newgen_struct_multitest_ * multitest;
#endif /* _newgen_multitest_domain_defined_ */

#define normalized_domain (_gen_ri_start+28)
#if !defined(_newgen_normalized_domain_defined_)
#define _newgen_normalized_domain_defined_
#define NORMALIZED_NEWGEN_DOMAIN (normalized_domain)
#define normalized_NEWGEN_DOMAIN (normalized_domain)
typedef struct _newgen_struct_normalized_ * normalized;
#endif /* _newgen_normalized_domain_defined_ */

#define parameter_domain (_gen_ri_start+29)
#if !defined(_newgen_parameter_domain_defined_)
#define _newgen_parameter_domain_defined_
#define PARAMETER_NEWGEN_DOMAIN (parameter_domain)
#define parameter_NEWGEN_DOMAIN (parameter_domain)
typedef struct _newgen_struct_parameter_ * parameter;
#endif /* _newgen_parameter_domain_defined_ */

#define persistant_statement_to_cluster_domain (_gen_ri_start+30)
#if !defined(_newgen_persistant_statement_to_cluster_domain_defined_)
#define _newgen_persistant_statement_to_cluster_domain_defined_
#define PERSISTANT_STATEMENT_TO_CLUSTER_NEWGEN_DOMAIN (persistant_statement_to_cluster_domain)
#define persistant_statement_to_cluster_NEWGEN_DOMAIN (persistant_statement_to_cluster_domain)
typedef struct _newgen_struct_persistant_statement_to_cluster_ * persistant_statement_to_cluster;
#endif /* _newgen_persistant_statement_to_cluster_domain_defined_ */

#define persistant_statement_to_control_domain (_gen_ri_start+31)
#if !defined(_newgen_persistant_statement_to_control_domain_defined_)
#define _newgen_persistant_statement_to_control_domain_defined_
#define PERSISTANT_STATEMENT_TO_CONTROL_NEWGEN_DOMAIN (persistant_statement_to_control_domain)
#define persistant_statement_to_control_NEWGEN_DOMAIN (persistant_statement_to_control_domain)
typedef struct _newgen_struct_persistant_statement_to_control_ * persistant_statement_to_control;
#endif /* _newgen_persistant_statement_to_control_domain_defined_ */

#define persistant_statement_to_int_domain (_gen_ri_start+32)
#if !defined(_newgen_persistant_statement_to_int_domain_defined_)
#define _newgen_persistant_statement_to_int_domain_defined_
#define PERSISTANT_STATEMENT_TO_INT_NEWGEN_DOMAIN (persistant_statement_to_int_domain)
#define persistant_statement_to_int_NEWGEN_DOMAIN (persistant_statement_to_int_domain)
typedef struct _newgen_struct_persistant_statement_to_int_ * persistant_statement_to_int;
#endif /* _newgen_persistant_statement_to_int_domain_defined_ */

#define persistant_statement_to_statement_domain (_gen_ri_start+33)
#if !defined(_newgen_persistant_statement_to_statement_domain_defined_)
#define _newgen_persistant_statement_to_statement_domain_defined_
#define PERSISTANT_STATEMENT_TO_STATEMENT_NEWGEN_DOMAIN (persistant_statement_to_statement_domain)
#define persistant_statement_to_statement_NEWGEN_DOMAIN (persistant_statement_to_statement_domain)
typedef struct _newgen_struct_persistant_statement_to_statement_ * persistant_statement_to_statement;
#endif /* _newgen_persistant_statement_to_statement_domain_defined_ */

#define pragma_domain (_gen_ri_start+34)
#if !defined(_newgen_pragma_domain_defined_)
#define _newgen_pragma_domain_defined_
#define PRAGMA_NEWGEN_DOMAIN (pragma_domain)
#define pragma_NEWGEN_DOMAIN (pragma_domain)
typedef struct _newgen_struct_pragma_ * pragma;
#endif /* _newgen_pragma_domain_defined_ */

#define predicate_domain (_gen_ri_start+35)
#if !defined(_newgen_predicate_domain_defined_)
#define _newgen_predicate_domain_defined_
#define PREDICATE_NEWGEN_DOMAIN (predicate_domain)
#define predicate_NEWGEN_DOMAIN (predicate_domain)
typedef struct _newgen_struct_predicate_ * predicate;
#endif /* _newgen_predicate_domain_defined_ */

#define preference_domain (_gen_ri_start+36)
#if !defined(_newgen_preference_domain_defined_)
#define _newgen_preference_domain_defined_
#define PREFERENCE_NEWGEN_DOMAIN (preference_domain)
#define preference_NEWGEN_DOMAIN (preference_domain)
typedef struct _newgen_struct_preference_ * preference;
#endif /* _newgen_preference_domain_defined_ */

#define qualifier_domain (_gen_ri_start+37)
#if !defined(_newgen_qualifier_domain_defined_)
#define _newgen_qualifier_domain_defined_
#define QUALIFIER_NEWGEN_DOMAIN (qualifier_domain)
#define qualifier_NEWGEN_DOMAIN (qualifier_domain)
typedef struct _newgen_struct_qualifier_ * qualifier;
#endif /* _newgen_qualifier_domain_defined_ */

#define ram_domain (_gen_ri_start+38)
#if !defined(_newgen_ram_domain_defined_)
#define _newgen_ram_domain_defined_
#define RAM_NEWGEN_DOMAIN (ram_domain)
#define ram_NEWGEN_DOMAIN (ram_domain)
typedef struct _newgen_struct_ram_ * ram;
#endif /* _newgen_ram_domain_defined_ */

#define range_domain (_gen_ri_start+39)
#if !defined(_newgen_range_domain_defined_)
#define _newgen_range_domain_defined_
#define RANGE_NEWGEN_DOMAIN (range_domain)
#define range_NEWGEN_DOMAIN (range_domain)
typedef struct _newgen_struct_range_ * range;
#endif /* _newgen_range_domain_defined_ */

#define reference_domain (_gen_ri_start+40)
#if !defined(_newgen_reference_domain_defined_)
#define _newgen_reference_domain_defined_
#define REFERENCE_NEWGEN_DOMAIN (reference_domain)
#define reference_NEWGEN_DOMAIN (reference_domain)
typedef struct _newgen_struct_reference_ * reference;
#endif /* _newgen_reference_domain_defined_ */

#define sequence_domain (_gen_ri_start+41)
#if !defined(_newgen_sequence_domain_defined_)
#define _newgen_sequence_domain_defined_
#define SEQUENCE_NEWGEN_DOMAIN (sequence_domain)
#define sequence_NEWGEN_DOMAIN (sequence_domain)
typedef struct _newgen_struct_sequence_ * sequence;
#endif /* _newgen_sequence_domain_defined_ */

#define sizeofexpression_domain (_gen_ri_start+42)
#if !defined(_newgen_sizeofexpression_domain_defined_)
#define _newgen_sizeofexpression_domain_defined_
#define SIZEOFEXPRESSION_NEWGEN_DOMAIN (sizeofexpression_domain)
#define sizeofexpression_NEWGEN_DOMAIN (sizeofexpression_domain)
typedef struct _newgen_struct_sizeofexpression_ * sizeofexpression;
#endif /* _newgen_sizeofexpression_domain_defined_ */

#define statement_domain (_gen_ri_start+43)
#if !defined(_newgen_statement_domain_defined_)
#define _newgen_statement_domain_defined_
#define STATEMENT_NEWGEN_DOMAIN (statement_domain)
#define statement_NEWGEN_DOMAIN (statement_domain)
typedef struct _newgen_struct_statement_ * statement;
#endif /* _newgen_statement_domain_defined_ */

#define storage_domain (_gen_ri_start+44)
#if !defined(_newgen_storage_domain_defined_)
#define _newgen_storage_domain_defined_
#define STORAGE_NEWGEN_DOMAIN (storage_domain)
#define storage_NEWGEN_DOMAIN (storage_domain)
typedef struct _newgen_struct_storage_ * storage;
#endif /* _newgen_storage_domain_defined_ */

#define subscript_domain (_gen_ri_start+45)
#if !defined(_newgen_subscript_domain_defined_)
#define _newgen_subscript_domain_defined_
#define SUBSCRIPT_NEWGEN_DOMAIN (subscript_domain)
#define subscript_NEWGEN_DOMAIN (subscript_domain)
typedef struct _newgen_struct_subscript_ * subscript;
#endif /* _newgen_subscript_domain_defined_ */

#define symbolic_domain (_gen_ri_start+46)
#if !defined(_newgen_symbolic_domain_defined_)
#define _newgen_symbolic_domain_defined_
#define SYMBOLIC_NEWGEN_DOMAIN (symbolic_domain)
#define symbolic_NEWGEN_DOMAIN (symbolic_domain)
typedef struct _newgen_struct_symbolic_ * symbolic;
#endif /* _newgen_symbolic_domain_defined_ */

#define synchronization_domain (_gen_ri_start+47)
#if !defined(_newgen_synchronization_domain_defined_)
#define _newgen_synchronization_domain_defined_
#define SYNCHRONIZATION_NEWGEN_DOMAIN (synchronization_domain)
#define synchronization_NEWGEN_DOMAIN (synchronization_domain)
typedef struct _newgen_struct_synchronization_ * synchronization;
#endif /* _newgen_synchronization_domain_defined_ */

#define syntax_domain (_gen_ri_start+48)
#if !defined(_newgen_syntax_domain_defined_)
#define _newgen_syntax_domain_defined_
#define SYNTAX_NEWGEN_DOMAIN (syntax_domain)
#define syntax_NEWGEN_DOMAIN (syntax_domain)
typedef struct _newgen_struct_syntax_ * syntax;
#endif /* _newgen_syntax_domain_defined_ */

#define entity_domain (_gen_ri_start+49)
#if !defined(_newgen_entity_domain_defined_)
#define _newgen_entity_domain_defined_
#define ENTITY_NEWGEN_DOMAIN (entity_domain)
#define entity_NEWGEN_DOMAIN (entity_domain)
typedef struct _newgen_struct_entity_ * entity;
#endif /* _newgen_entity_domain_defined_ */

#define test_domain (_gen_ri_start+50)
#if !defined(_newgen_test_domain_defined_)
#define _newgen_test_domain_defined_
#define TEST_NEWGEN_DOMAIN (test_domain)
#define test_NEWGEN_DOMAIN (test_domain)
typedef struct _newgen_struct_test_ * test;
#endif /* _newgen_test_domain_defined_ */

#define transformer_domain (_gen_ri_start+51)
#if !defined(_newgen_transformer_domain_defined_)
#define _newgen_transformer_domain_defined_
#define TRANSFORMER_NEWGEN_DOMAIN (transformer_domain)
#define transformer_NEWGEN_DOMAIN (transformer_domain)
typedef struct _newgen_struct_transformer_ * transformer;
#endif /* _newgen_transformer_domain_defined_ */

#define type_domain (_gen_ri_start+52)
#if !defined(_newgen_type_domain_defined_)
#define _newgen_type_domain_defined_
#define TYPE_NEWGEN_DOMAIN (type_domain)
#define type_NEWGEN_DOMAIN (type_domain)
typedef struct _newgen_struct_type_ * type;
#endif /* _newgen_type_domain_defined_ */

#define unstructured_domain (_gen_ri_start+53)
#if !defined(_newgen_unstructured_domain_defined_)
#define _newgen_unstructured_domain_defined_
#define UNSTRUCTURED_NEWGEN_DOMAIN (unstructured_domain)
#define unstructured_NEWGEN_DOMAIN (unstructured_domain)
typedef struct _newgen_struct_unstructured_ * unstructured;
#endif /* _newgen_unstructured_domain_defined_ */

#define value_domain (_gen_ri_start+54)
#if !defined(_newgen_value_domain_defined_)
#define _newgen_value_domain_defined_
#define VALUE_NEWGEN_DOMAIN (value_domain)
#define value_NEWGEN_DOMAIN (value_domain)
typedef struct _newgen_struct_value_ * value;
#endif /* _newgen_value_domain_defined_ */

#define variable_domain (_gen_ri_start+55)
#if !defined(_newgen_variable_domain_defined_)
#define _newgen_variable_domain_defined_
#define VARIABLE_NEWGEN_DOMAIN (variable_domain)
#define variable_NEWGEN_DOMAIN (variable_domain)
typedef struct _newgen_struct_variable_ * variable;
#endif /* _newgen_variable_domain_defined_ */

#define whileloop_domain (_gen_ri_start+56)
#if !defined(_newgen_whileloop_domain_defined_)
#define _newgen_whileloop_domain_defined_
#define WHILELOOP_NEWGEN_DOMAIN (whileloop_domain)
#define whileloop_NEWGEN_DOMAIN (whileloop_domain)
typedef struct _newgen_struct_whileloop_ * whileloop;
#endif /* _newgen_whileloop_domain_defined_ */



/* APPLICATION
 */
#define APPLICATION(x) ((application)((x).p))
#define application_CAST(x) APPLICATION(x)
#define APPLICATION_CAST(x) APPLICATION(x)
#define APPLICATION_(x) ((x).e)
#define APPLICATION_TYPE application
#define application_TYPE application
#define application_undefined ((application)gen_chunk_undefined)
#define application_undefined_p(x) ((x)==application_undefined)

extern application copy_application(application);
extern void free_application(application);
extern application check_application(application);
extern bool application_consistent_p(application);
extern bool application_defined_p(application);
#define gen_APPLICATION_cons gen_application_cons
extern list gen_application_cons(application, list);
extern void application_assign_contents(application, application);
extern void application_non_recursive_free(application);
extern void write_application(FILE*, application);
extern application read_application(FILE*);
extern application make_application(expression, list);

struct _newgen_struct_application_ {
  intptr_t _type_;
  expression _application_function_; /* function:expression */
  list _application_arguments_; /* arguments:expression* */
};

#define application_domain_number(x) ((x)->_type_)
#define application_function_(x) application_function(x) /* old hack compatible */
#define application_function(x) ((x)->_application_function_)
#define application_arguments_(x) application_arguments(x) /* old hack compatible */
#define application_arguments(x) ((x)->_application_arguments_)

/* AREA
 */
#define AREA(x) ((area)((x).p))
#define area_CAST(x) AREA(x)
#define AREA_CAST(x) AREA(x)
#define AREA_(x) ((x).e)
#define AREA_TYPE area
#define area_TYPE area
#define area_undefined ((area)gen_chunk_undefined)
#define area_undefined_p(x) ((x)==area_undefined)

extern area copy_area(area);
extern void free_area(area);
extern area check_area(area);
extern bool area_consistent_p(area);
extern bool area_defined_p(area);
#define gen_AREA_cons gen_area_cons
extern list gen_area_cons(area, list);
extern void area_assign_contents(area, area);
extern void area_non_recursive_free(area);
extern void write_area(FILE*, area);
extern area read_area(FILE*);
extern area make_area(intptr_t, list);

struct _newgen_struct_area_ {
  intptr_t _type_;
  intptr_t _area_size_; /* size:int */
  list _area_layout_; /* layout:entity* */
};

#define area_domain_number(x) ((x)->_type_)
#define area_size_(x) area_size(x) /* old hack compatible */
#define area_size(x) ((x)->_area_size_)
#define area_layout_(x) area_layout(x) /* old hack compatible */
#define area_layout(x) ((x)->_area_layout_)

/* BASIC
 */
#define BASIC(x) ((basic)((x).p))
#define basic_CAST(x) BASIC(x)
#define BASIC_CAST(x) BASIC(x)
#define BASIC_(x) ((x).e)
#define BASIC_TYPE basic
#define basic_TYPE basic
#define basic_undefined ((basic)gen_chunk_undefined)
#define basic_undefined_p(x) ((x)==basic_undefined)

extern basic copy_basic(basic);
extern void free_basic(basic);
extern basic check_basic(basic);
extern bool basic_consistent_p(basic);
extern bool basic_defined_p(basic);
#define gen_BASIC_cons gen_basic_cons
extern list gen_basic_cons(basic, list);
extern void basic_assign_contents(basic, basic);
extern void basic_non_recursive_free(basic);
extern void write_basic(FILE*, basic);
extern basic read_basic(FILE*);
enum basic_utype {
  is_basic_int,
  is_basic_float,
  is_basic_logical,
  is_basic_overloaded,
  is_basic_complex,
  is_basic_string,
  is_basic_bit,
  is_basic_pointer,
  is_basic_derived,
  is_basic_typedef
};
extern string basic_tag_as_string(enum basic_utype);
extern basic make_basic(enum basic_utype, void *);
extern basic make_basic_int(intptr_t);
extern basic make_basic_float(intptr_t);
extern basic make_basic_logical(intptr_t);
extern basic make_basic_overloaded(void);
extern basic make_basic_complex(intptr_t);
extern basic make_basic_string(value);
extern basic make_basic_bit(symbolic);
extern basic make_basic_pointer(type);
extern basic make_basic_derived(entity);
extern basic make_basic_typedef(entity);

struct _newgen_struct_basic_ {
  intptr_t _type_;
  enum basic_utype _basic_tag__;
  union {
    intptr_t _basic_int_; /* int:int */
    intptr_t _basic_float_; /* float:int */
    intptr_t _basic_logical_; /* logical:int */
    gen_chunk _basic_overloaded_; /* overloaded:unit */
    intptr_t _basic_complex_; /* complex:int */
    value _basic_string_; /* string:value */
    symbolic _basic_bit_; /* bit:symbolic */
    type _basic_pointer_; /* pointer:type */
    entity _basic_derived_; /* derived:entity */
    entity _basic_typedef_; /* typedef:entity */
  } _basic_union_;
};

#define basic_domain_number(x) ((x)->_type_)
#define basic_tag(x) ((x)->_basic_tag__)
#define basic_int_p(x) (basic_tag(x)==is_basic_int)
#define basic_int_(x) basic_int(x) /* old hack compatible */
#define basic_int(x) ((x)->_basic_union_._basic_int_)
#define basic_float_p(x) (basic_tag(x)==is_basic_float)
#define basic_float_(x) basic_float(x) /* old hack compatible */
#define basic_float(x) ((x)->_basic_union_._basic_float_)
#define basic_logical_p(x) (basic_tag(x)==is_basic_logical)
#define basic_logical_(x) basic_logical(x) /* old hack compatible */
#define basic_logical(x) ((x)->_basic_union_._basic_logical_)
#define basic_overloaded_p(x) (basic_tag(x)==is_basic_overloaded)
#define basic_overloaded_(x) basic_overloaded(x) /* old hack compatible */
#define basic_overloaded(x) ((x)->_basic_union_._basic_overloaded_.u)
#define basic_complex_p(x) (basic_tag(x)==is_basic_complex)
#define basic_complex_(x) basic_complex(x) /* old hack compatible */
#define basic_complex(x) ((x)->_basic_union_._basic_complex_)
#define basic_string_p(x) (basic_tag(x)==is_basic_string)
#define basic_string_(x) basic_string(x) /* old hack compatible */
#define basic_string(x) ((x)->_basic_union_._basic_string_)
#define basic_bit_p(x) (basic_tag(x)==is_basic_bit)
#define basic_bit_(x) basic_bit(x) /* old hack compatible */
#define basic_bit(x) ((x)->_basic_union_._basic_bit_)
#define basic_pointer_p(x) (basic_tag(x)==is_basic_pointer)
#define basic_pointer_(x) basic_pointer(x) /* old hack compatible */
#define basic_pointer(x) ((x)->_basic_union_._basic_pointer_)
#define basic_derived_p(x) (basic_tag(x)==is_basic_derived)
#define basic_derived_(x) basic_derived(x) /* old hack compatible */
#define basic_derived(x) ((x)->_basic_union_._basic_derived_)
#define basic_typedef_p(x) (basic_tag(x)==is_basic_typedef)
#define basic_typedef_(x) basic_typedef(x) /* old hack compatible */
#define basic_typedef(x) ((x)->_basic_union_._basic_typedef_)

/* CALLEES
 */
#define CALLEES(x) ((callees)((x).p))
#define callees_CAST(x) CALLEES(x)
#define CALLEES_CAST(x) CALLEES(x)
#define CALLEES_(x) ((x).e)
#define CALLEES_TYPE callees
#define callees_TYPE callees
#define callees_undefined ((callees)gen_chunk_undefined)
#define callees_undefined_p(x) ((x)==callees_undefined)

extern callees copy_callees(callees);
extern void free_callees(callees);
extern callees check_callees(callees);
extern bool callees_consistent_p(callees);
extern bool callees_defined_p(callees);
#define gen_CALLEES_cons gen_callees_cons
extern list gen_callees_cons(callees, list);
extern void callees_assign_contents(callees, callees);
extern void callees_non_recursive_free(callees);
extern void write_callees(FILE*, callees);
extern callees read_callees(FILE*);
extern callees make_callees(list);

struct _newgen_struct_callees_ {
  intptr_t _type_;
  list _callees_holder_;
};

#define callees_domain_number(x) ((x)->_type_)
#define callees_callees(x) ((x)->_callees_holder_)

/* CALL
 */
#define CALL(x) ((call)((x).p))
#define call_CAST(x) CALL(x)
#define CALL_CAST(x) CALL(x)
#define CALL_(x) ((x).e)
#define CALL_TYPE call
#define call_TYPE call
#define call_undefined ((call)gen_chunk_undefined)
#define call_undefined_p(x) ((x)==call_undefined)

extern call copy_call(call);
extern void free_call(call);
extern call check_call(call);
extern bool call_consistent_p(call);
extern bool call_defined_p(call);
#define gen_CALL_cons gen_call_cons
extern list gen_call_cons(call, list);
extern void call_assign_contents(call, call);
extern void call_non_recursive_free(call);
extern void write_call(FILE*, call);
extern call read_call(FILE*);
extern call make_call(entity, list);

struct _newgen_struct_call_ {
  intptr_t _type_;
  entity _call_function_; /* function:entity */
  list _call_arguments_; /* arguments:expression* */
};

#define call_domain_number(x) ((x)->_type_)
#define call_function_(x) call_function(x) /* old hack compatible */
#define call_function(x) ((x)->_call_function_)
#define call_arguments_(x) call_arguments(x) /* old hack compatible */
#define call_arguments(x) ((x)->_call_arguments_)

/* CAST
 */
#define CAST(x) ((cast)((x).p))
#define cast_CAST(x) CAST(x)
#define CAST_CAST(x) CAST(x)
#define CAST_(x) ((x).e)
#define CAST_TYPE cast
#define cast_TYPE cast
#define cast_undefined ((cast)gen_chunk_undefined)
#define cast_undefined_p(x) ((x)==cast_undefined)

extern cast copy_cast(cast);
extern void free_cast(cast);
extern cast check_cast(cast);
extern bool cast_consistent_p(cast);
extern bool cast_defined_p(cast);
#define gen_CAST_cons gen_cast_cons
extern list gen_cast_cons(cast, list);
extern void cast_assign_contents(cast, cast);
extern void cast_non_recursive_free(cast);
extern void write_cast(FILE*, cast);
extern cast read_cast(FILE*);
extern cast make_cast(type, expression);

struct _newgen_struct_cast_ {
  intptr_t _type_;
  type _cast_type_; /* type:type */
  expression _cast_expression_; /* expression:expression */
};

#define cast_domain_number(x) ((x)->_type_)
#define cast_type_(x) cast_type(x) /* old hack compatible */
#define cast_type(x) ((x)->_cast_type_)
#define cast_expression_(x) cast_expression(x) /* old hack compatible */
#define cast_expression(x) ((x)->_cast_expression_)

/* CODE
 */
#define CODE(x) ((code)((x).p))
#define code_CAST(x) CODE(x)
#define CODE_CAST(x) CODE(x)
#define CODE_(x) ((x).e)
#define CODE_TYPE code
#define code_TYPE code
#define code_undefined ((code)gen_chunk_undefined)
#define code_undefined_p(x) ((x)==code_undefined)

extern code copy_code(code);
extern void free_code(code);
extern code check_code(code);
extern bool code_consistent_p(code);
extern bool code_defined_p(code);
#define gen_CODE_cons gen_code_cons
extern list gen_code_cons(code, list);
extern void code_assign_contents(code, code);
extern void code_non_recursive_free(code);
extern void write_code(FILE*, code);
extern code read_code(FILE*);
extern code make_code(list, string, sequence, list, language);

struct _newgen_struct_code_ {
  intptr_t _type_;
  list _code_declarations_; /* declarations:entity* */
  string _code_decls_text_; /* decls_text:string */
  sequence _code_initializations_; /* initializations:sequence */
  list _code_externs_; /* externs:entity* */
  language _code_language_; /* language:language */
};

#define code_domain_number(x) ((x)->_type_)
#define code_declarations_(x) code_declarations(x) /* old hack compatible */
#define code_declarations(x) ((x)->_code_declarations_)
#define code_decls_text_(x) code_decls_text(x) /* old hack compatible */
#define code_decls_text(x) ((x)->_code_decls_text_)
#define code_initializations_(x) code_initializations(x) /* old hack compatible */
#define code_initializations(x) ((x)->_code_initializations_)
#define code_externs_(x) code_externs(x) /* old hack compatible */
#define code_externs(x) ((x)->_code_externs_)
#define code_language_(x) code_language(x) /* old hack compatible */
#define code_language(x) ((x)->_code_language_)

/* CONSTANT
 */
#define CONSTANT(x) ((constant)((x).p))
#define constant_CAST(x) CONSTANT(x)
#define CONSTANT_CAST(x) CONSTANT(x)
#define CONSTANT_(x) ((x).e)
#define CONSTANT_TYPE constant
#define constant_TYPE constant
#define constant_undefined ((constant)gen_chunk_undefined)
#define constant_undefined_p(x) ((x)==constant_undefined)

extern constant copy_constant(constant);
extern void free_constant(constant);
extern constant check_constant(constant);
extern bool constant_consistent_p(constant);
extern bool constant_defined_p(constant);
#define gen_CONSTANT_cons gen_constant_cons
extern list gen_constant_cons(constant, list);
extern void constant_assign_contents(constant, constant);
extern void constant_non_recursive_free(constant);
extern void write_constant(FILE*, constant);
extern constant read_constant(FILE*);
enum constant_utype {
  is_constant_int,
  is_constant_float,
  is_constant_logical,
  is_constant_litteral,
  is_constant_call,
  is_constant_unknown
};
extern string constant_tag_as_string(enum constant_utype);
extern constant make_constant(enum constant_utype, void *);
extern constant make_constant_int(intptr_t);
extern constant make_constant_float(float);
extern constant make_constant_logical(intptr_t);
extern constant make_constant_litteral(void);
extern constant make_constant_call(entity);
extern constant make_constant_unknown(void);

struct _newgen_struct_constant_ {
  intptr_t _type_;
  enum constant_utype _constant_tag__;
  union {
    intptr_t _constant_int_; /* int:int */
    gen_chunk _constant_float_; /* float:float */
    intptr_t _constant_logical_; /* logical:int */
    gen_chunk _constant_litteral_; /* litteral:unit */
    entity _constant_call_; /* call:entity */
    gen_chunk _constant_unknown_; /* unknown:unit */
  } _constant_union_;
};

#define constant_domain_number(x) ((x)->_type_)
#define constant_tag(x) ((x)->_constant_tag__)
#define constant_int_p(x) (constant_tag(x)==is_constant_int)
#define constant_int_(x) constant_int(x) /* old hack compatible */
#define constant_int(x) ((x)->_constant_union_._constant_int_)
#define constant_float_p(x) (constant_tag(x)==is_constant_float)
#define constant_float_(x) constant_float(x) /* old hack compatible */
#define constant_float(x) ((x)->_constant_union_._constant_float_.f)
#define constant_logical_p(x) (constant_tag(x)==is_constant_logical)
#define constant_logical_(x) constant_logical(x) /* old hack compatible */
#define constant_logical(x) ((x)->_constant_union_._constant_logical_)
#define constant_litteral_p(x) (constant_tag(x)==is_constant_litteral)
#define constant_litteral_(x) constant_litteral(x) /* old hack compatible */
#define constant_litteral(x) ((x)->_constant_union_._constant_litteral_.u)
#define constant_call_p(x) (constant_tag(x)==is_constant_call)
#define constant_call_(x) constant_call(x) /* old hack compatible */
#define constant_call(x) ((x)->_constant_union_._constant_call_)
#define constant_unknown_p(x) (constant_tag(x)==is_constant_unknown)
#define constant_unknown_(x) constant_unknown(x) /* old hack compatible */
#define constant_unknown(x) ((x)->_constant_union_._constant_unknown_.u)

/* CONTROLMAP
 */
#define CONTROLMAP(x) ((controlmap)((x).p))
#define controlmap_CAST(x) CONTROLMAP(x)
#define CONTROLMAP_CAST(x) CONTROLMAP(x)
#define CONTROLMAP_(x) ((x).e)
#define CONTROLMAP_TYPE controlmap
#define controlmap_TYPE controlmap
#define controlmap_undefined ((controlmap)gen_chunk_undefined)
#define controlmap_undefined_p(x) ((x)==controlmap_undefined)

extern controlmap copy_controlmap(controlmap);
extern void free_controlmap(controlmap);
extern controlmap check_controlmap(controlmap);
extern bool controlmap_consistent_p(controlmap);
extern bool controlmap_defined_p(controlmap);
#define gen_CONTROLMAP_cons gen_controlmap_cons
extern list gen_controlmap_cons(controlmap, list);
extern void controlmap_assign_contents(controlmap, controlmap);
extern void controlmap_non_recursive_free(controlmap);
extern void write_controlmap(FILE*, controlmap);
extern controlmap read_controlmap(FILE*);
extern controlmap make_controlmap(void);

struct _newgen_struct_controlmap_ {
  intptr_t _type_;
  hash_table _controlmap_holder_;
};

#define controlmap_domain_number(x) ((x)->_type_)
#define controlmap_hash_table(x) ((x)->_controlmap_holder_)
#define controlmap_key_type statement
#define controlmap_value_type control
#define CONTROLMAP_MAP(k,v,c,f) FUNCTION_MAP(controlmap,p,p,k,v,c,f)
#define CONTROLMAP_FOREACH(k,v,f) FUNCTION_FOREACH(controlmap,p,p,k,v,f)
extern control apply_controlmap(controlmap, statement);
extern void update_controlmap(controlmap, statement, control);
extern void extend_controlmap(controlmap, statement, control);
extern control delete_controlmap(controlmap, statement);
extern bool bound_controlmap_p(controlmap, statement);

/* CONTROL
 */
#define CONTROL(x) ((control)((x).p))
#define control_CAST(x) CONTROL(x)
#define CONTROL_CAST(x) CONTROL(x)
#define CONTROL_(x) ((x).e)
#define CONTROL_TYPE control
#define control_TYPE control
#define control_undefined ((control)gen_chunk_undefined)
#define control_undefined_p(x) ((x)==control_undefined)

extern control copy_control(control);
extern void free_control(control);
extern control check_control(control);
extern bool control_consistent_p(control);
extern bool control_defined_p(control);
#define gen_CONTROL_cons gen_control_cons
extern list gen_control_cons(control, list);
extern void control_assign_contents(control, control);
extern void control_non_recursive_free(control);
extern void write_control(FILE*, control);
extern control read_control(FILE*);
extern control make_control(statement, list, list);

struct _newgen_struct_control_ {
  intptr_t _type_;
  statement _control_statement_; /* statement:statement */
  list _control_predecessors_; /* predecessors:control* */
  list _control_successors_; /* successors:control* */
};

#define control_domain_number(x) ((x)->_type_)
#define control_statement_(x) control_statement(x) /* old hack compatible */
#define control_statement(x) ((x)->_control_statement_)
#define control_predecessors_(x) control_predecessors(x) /* old hack compatible */
#define control_predecessors(x) ((x)->_control_predecessors_)
#define control_successors_(x) control_successors(x) /* old hack compatible */
#define control_successors(x) ((x)->_control_successors_)

/* DIMENSION
 */
#define DIMENSION(x) ((dimension)((x).p))
#define dimension_CAST(x) DIMENSION(x)
#define DIMENSION_CAST(x) DIMENSION(x)
#define DIMENSION_(x) ((x).e)
#define DIMENSION_TYPE dimension
#define dimension_TYPE dimension
#define dimension_undefined ((dimension)gen_chunk_undefined)
#define dimension_undefined_p(x) ((x)==dimension_undefined)

extern dimension copy_dimension(dimension);
extern void free_dimension(dimension);
extern dimension check_dimension(dimension);
extern bool dimension_consistent_p(dimension);
extern bool dimension_defined_p(dimension);
#define gen_DIMENSION_cons gen_dimension_cons
extern list gen_dimension_cons(dimension, list);
extern void dimension_assign_contents(dimension, dimension);
extern void dimension_non_recursive_free(dimension);
extern void write_dimension(FILE*, dimension);
extern dimension read_dimension(FILE*);
extern dimension make_dimension(expression, expression, list);

struct _newgen_struct_dimension_ {
  intptr_t _type_;
  expression _dimension_lower_; /* lower:expression */
  expression _dimension_upper_; /* upper:expression */
  list _dimension_qualifiers_; /* qualifiers:qualifier* */
};

#define dimension_domain_number(x) ((x)->_type_)
#define dimension_lower_(x) dimension_lower(x) /* old hack compatible */
#define dimension_lower(x) ((x)->_dimension_lower_)
#define dimension_upper_(x) dimension_upper(x) /* old hack compatible */
#define dimension_upper(x) ((x)->_dimension_upper_)
#define dimension_qualifiers_(x) dimension_qualifiers(x) /* old hack compatible */
#define dimension_qualifiers(x) ((x)->_dimension_qualifiers_)

/* DUMMY
 */
#define DUMMY(x) ((dummy)((x).p))
#define dummy_CAST(x) DUMMY(x)
#define DUMMY_CAST(x) DUMMY(x)
#define DUMMY_(x) ((x).e)
#define DUMMY_TYPE dummy
#define dummy_TYPE dummy
#define dummy_undefined ((dummy)gen_chunk_undefined)
#define dummy_undefined_p(x) ((x)==dummy_undefined)

extern dummy copy_dummy(dummy);
extern void free_dummy(dummy);
extern dummy check_dummy(dummy);
extern bool dummy_consistent_p(dummy);
extern bool dummy_defined_p(dummy);
#define gen_DUMMY_cons gen_dummy_cons
extern list gen_dummy_cons(dummy, list);
extern void dummy_assign_contents(dummy, dummy);
extern void dummy_non_recursive_free(dummy);
extern void write_dummy(FILE*, dummy);
extern dummy read_dummy(FILE*);
enum dummy_utype {
  is_dummy_unknown,
  is_dummy_identifier
};
extern string dummy_tag_as_string(enum dummy_utype);
extern dummy make_dummy(enum dummy_utype, void *);
extern dummy make_dummy_unknown(void);
extern dummy make_dummy_identifier(entity);

struct _newgen_struct_dummy_ {
  intptr_t _type_;
  enum dummy_utype _dummy_tag__;
  union {
    gen_chunk _dummy_unknown_; /* unknown:unit */
    entity _dummy_identifier_; /* identifier:entity */
  } _dummy_union_;
};

#define dummy_domain_number(x) ((x)->_type_)
#define dummy_tag(x) ((x)->_dummy_tag__)
#define dummy_unknown_p(x) (dummy_tag(x)==is_dummy_unknown)
#define dummy_unknown_(x) dummy_unknown(x) /* old hack compatible */
#define dummy_unknown(x) ((x)->_dummy_union_._dummy_unknown_.u)
#define dummy_identifier_p(x) (dummy_tag(x)==is_dummy_identifier)
#define dummy_identifier_(x) dummy_identifier(x) /* old hack compatible */
#define dummy_identifier(x) ((x)->_dummy_union_._dummy_identifier_)

/* ENTITY_INT
 */
#define ENTITY_INT(x) ((entity_int)((x).p))
#define entity_int_CAST(x) ENTITY_INT(x)
#define ENTITY_INT_CAST(x) ENTITY_INT(x)
#define ENTITY_INT_(x) ((x).e)
#define ENTITY_INT_TYPE entity_int
#define entity_int_TYPE entity_int
#define entity_int_undefined ((entity_int)gen_chunk_undefined)
#define entity_int_undefined_p(x) ((x)==entity_int_undefined)

extern entity_int copy_entity_int(entity_int);
extern void free_entity_int(entity_int);
extern entity_int check_entity_int(entity_int);
extern bool entity_int_consistent_p(entity_int);
extern bool entity_int_defined_p(entity_int);
#define gen_ENTITY_INT_cons gen_entity_int_cons
extern list gen_entity_int_cons(entity_int, list);
extern void entity_int_assign_contents(entity_int, entity_int);
extern void entity_int_non_recursive_free(entity_int);
extern void write_entity_int(FILE*, entity_int);
extern entity_int read_entity_int(FILE*);
extern entity_int make_entity_int(void);

struct _newgen_struct_entity_int_ {
  intptr_t _type_;
  hash_table _entity_int_holder_;
};

#define entity_int_domain_number(x) ((x)->_type_)
#define entity_int_hash_table(x) ((x)->_entity_int_holder_)
#define entity_int_key_type entity
#define entity_int_value_type intptr_t
#define ENTITY_INT_MAP(k,v,c,f) FUNCTION_MAP(entity_int,p,i,k,v,c,f)
#define ENTITY_INT_FOREACH(k,v,f) FUNCTION_FOREACH(entity_int,p,i,k,v,f)
extern intptr_t apply_entity_int(entity_int, entity);
extern void update_entity_int(entity_int, entity, intptr_t);
extern void extend_entity_int(entity_int, entity, intptr_t);
extern intptr_t delete_entity_int(entity_int, entity);
extern bool bound_entity_int_p(entity_int, entity);

/* EVALUATION
 */
#define EVALUATION(x) ((evaluation)((x).p))
#define evaluation_CAST(x) EVALUATION(x)
#define EVALUATION_CAST(x) EVALUATION(x)
#define EVALUATION_(x) ((x).e)
#define EVALUATION_TYPE evaluation
#define evaluation_TYPE evaluation
#define evaluation_undefined ((evaluation)gen_chunk_undefined)
#define evaluation_undefined_p(x) ((x)==evaluation_undefined)

extern evaluation copy_evaluation(evaluation);
extern void free_evaluation(evaluation);
extern evaluation check_evaluation(evaluation);
extern bool evaluation_consistent_p(evaluation);
extern bool evaluation_defined_p(evaluation);
#define gen_EVALUATION_cons gen_evaluation_cons
extern list gen_evaluation_cons(evaluation, list);
extern void evaluation_assign_contents(evaluation, evaluation);
extern void evaluation_non_recursive_free(evaluation);
extern void write_evaluation(FILE*, evaluation);
extern evaluation read_evaluation(FILE*);
enum evaluation_utype {
  is_evaluation_before,
  is_evaluation_after
};
extern string evaluation_tag_as_string(enum evaluation_utype);
extern evaluation make_evaluation(enum evaluation_utype, void *);
extern evaluation make_evaluation_before(void);
extern evaluation make_evaluation_after(void);

struct _newgen_struct_evaluation_ {
  intptr_t _type_;
  enum evaluation_utype _evaluation_tag__;
  union {
    gen_chunk _evaluation_before_; /* before:unit */
    gen_chunk _evaluation_after_; /* after:unit */
  } _evaluation_union_;
};

#define evaluation_domain_number(x) ((x)->_type_)
#define evaluation_tag(x) ((x)->_evaluation_tag__)
#define evaluation_before_p(x) (evaluation_tag(x)==is_evaluation_before)
#define evaluation_before_(x) evaluation_before(x) /* old hack compatible */
#define evaluation_before(x) ((x)->_evaluation_union_._evaluation_before_.u)
#define evaluation_after_p(x) (evaluation_tag(x)==is_evaluation_after)
#define evaluation_after_(x) evaluation_after(x) /* old hack compatible */
#define evaluation_after(x) ((x)->_evaluation_union_._evaluation_after_.u)

/* EXECUTION
 */
#define EXECUTION(x) ((execution)((x).p))
#define execution_CAST(x) EXECUTION(x)
#define EXECUTION_CAST(x) EXECUTION(x)
#define EXECUTION_(x) ((x).e)
#define EXECUTION_TYPE execution
#define execution_TYPE execution
#define execution_undefined ((execution)gen_chunk_undefined)
#define execution_undefined_p(x) ((x)==execution_undefined)

extern execution copy_execution(execution);
extern void free_execution(execution);
extern execution check_execution(execution);
extern bool execution_consistent_p(execution);
extern bool execution_defined_p(execution);
#define gen_EXECUTION_cons gen_execution_cons
extern list gen_execution_cons(execution, list);
extern void execution_assign_contents(execution, execution);
extern void execution_non_recursive_free(execution);
extern void write_execution(FILE*, execution);
extern execution read_execution(FILE*);
enum execution_utype {
  is_execution_sequential,
  is_execution_parallel
};
extern string execution_tag_as_string(enum execution_utype);
extern execution make_execution(enum execution_utype, void *);
extern execution make_execution_sequential(void);
extern execution make_execution_parallel(void);

struct _newgen_struct_execution_ {
  intptr_t _type_;
  enum execution_utype _execution_tag__;
  union {
    gen_chunk _execution_sequential_; /* sequential:unit */
    gen_chunk _execution_parallel_; /* parallel:unit */
  } _execution_union_;
};

#define execution_domain_number(x) ((x)->_type_)
#define execution_tag(x) ((x)->_execution_tag__)
#define execution_sequential_p(x) (execution_tag(x)==is_execution_sequential)
#define execution_sequential_(x) execution_sequential(x) /* old hack compatible */
#define execution_sequential(x) ((x)->_execution_union_._execution_sequential_.u)
#define execution_parallel_p(x) (execution_tag(x)==is_execution_parallel)
#define execution_parallel_(x) execution_parallel(x) /* old hack compatible */
#define execution_parallel(x) ((x)->_execution_union_._execution_parallel_.u)

/* EXPRESSION
 */
#define EXPRESSION(x) ((expression)((x).p))
#define expression_CAST(x) EXPRESSION(x)
#define EXPRESSION_CAST(x) EXPRESSION(x)
#define EXPRESSION_(x) ((x).e)
#define EXPRESSION_TYPE expression
#define expression_TYPE expression
#define expression_undefined ((expression)gen_chunk_undefined)
#define expression_undefined_p(x) ((x)==expression_undefined)

extern expression copy_expression(expression);
extern void free_expression(expression);
extern expression check_expression(expression);
extern bool expression_consistent_p(expression);
extern bool expression_defined_p(expression);
#define gen_EXPRESSION_cons gen_expression_cons
extern list gen_expression_cons(expression, list);
extern void expression_assign_contents(expression, expression);
extern void expression_non_recursive_free(expression);
extern void write_expression(FILE*, expression);
extern expression read_expression(FILE*);
extern expression make_expression(syntax, normalized);

struct _newgen_struct_expression_ {
  intptr_t _type_;
  syntax _expression_syntax_; /* syntax:syntax */
  normalized _expression_normalized_; /* normalized:normalized */
};

#define expression_domain_number(x) ((x)->_type_)
#define expression_syntax_(x) expression_syntax(x) /* old hack compatible */
#define expression_syntax(x) ((x)->_expression_syntax_)
#define expression_normalized_(x) expression_normalized(x) /* old hack compatible */
#define expression_normalized(x) ((x)->_expression_normalized_)

/* EXTENSION
 */
#define EXTENSION(x) ((extension)((x).p))
#define extension_CAST(x) EXTENSION(x)
#define EXTENSION_CAST(x) EXTENSION(x)
#define EXTENSION_(x) ((x).e)
#define EXTENSION_TYPE extension
#define extension_TYPE extension
#define extension_undefined ((extension)gen_chunk_undefined)
#define extension_undefined_p(x) ((x)==extension_undefined)

extern extension copy_extension(extension);
extern void free_extension(extension);
extern extension check_extension(extension);
extern bool extension_consistent_p(extension);
extern bool extension_defined_p(extension);
#define gen_EXTENSION_cons gen_extension_cons
extern list gen_extension_cons(extension, list);
extern void extension_assign_contents(extension, extension);
extern void extension_non_recursive_free(extension);
extern void write_extension(FILE*, extension);
extern extension read_extension(FILE*);
enum extension_utype {
  is_extension_pragma,
  is_extension_unknown
};
extern string extension_tag_as_string(enum extension_utype);
extern extension make_extension(enum extension_utype, void *);
extern extension make_extension_pragma(pragma);
extern extension make_extension_unknown(void);

struct _newgen_struct_extension_ {
  intptr_t _type_;
  enum extension_utype _extension_tag__;
  union {
    pragma _extension_pragma_; /* pragma:pragma */
    gen_chunk _extension_unknown_; /* unknown:unit */
  } _extension_union_;
};

#define extension_domain_number(x) ((x)->_type_)
#define extension_tag(x) ((x)->_extension_tag__)
#define extension_pragma_p(x) (extension_tag(x)==is_extension_pragma)
#define extension_pragma_(x) extension_pragma(x) /* old hack compatible */
#define extension_pragma(x) ((x)->_extension_union_._extension_pragma_)
#define extension_unknown_p(x) (extension_tag(x)==is_extension_unknown)
#define extension_unknown_(x) extension_unknown(x) /* old hack compatible */
#define extension_unknown(x) ((x)->_extension_union_._extension_unknown_.u)

/* EXTENSIONS
 */
#define EXTENSIONS(x) ((extensions)((x).p))
#define extensions_CAST(x) EXTENSIONS(x)
#define EXTENSIONS_CAST(x) EXTENSIONS(x)
#define EXTENSIONS_(x) ((x).e)
#define EXTENSIONS_TYPE extensions
#define extensions_TYPE extensions
#define extensions_undefined ((extensions)gen_chunk_undefined)
#define extensions_undefined_p(x) ((x)==extensions_undefined)

extern extensions copy_extensions(extensions);
extern void free_extensions(extensions);
extern extensions check_extensions(extensions);
extern bool extensions_consistent_p(extensions);
extern bool extensions_defined_p(extensions);
#define gen_EXTENSIONS_cons gen_extensions_cons
extern list gen_extensions_cons(extensions, list);
extern void extensions_assign_contents(extensions, extensions);
extern void extensions_non_recursive_free(extensions);
extern void write_extensions(FILE*, extensions);
extern extensions read_extensions(FILE*);
extern extensions make_extensions(list);

struct _newgen_struct_extensions_ {
  intptr_t _type_;
  list _extensions_holder_;
};

#define extensions_domain_number(x) ((x)->_type_)
#define extensions_extension(x) ((x)->_extensions_holder_)

/* FORLOOP
 */
#define FORLOOP(x) ((forloop)((x).p))
#define forloop_CAST(x) FORLOOP(x)
#define FORLOOP_CAST(x) FORLOOP(x)
#define FORLOOP_(x) ((x).e)
#define FORLOOP_TYPE forloop
#define forloop_TYPE forloop
#define forloop_undefined ((forloop)gen_chunk_undefined)
#define forloop_undefined_p(x) ((x)==forloop_undefined)

extern forloop copy_forloop(forloop);
extern void free_forloop(forloop);
extern forloop check_forloop(forloop);
extern bool forloop_consistent_p(forloop);
extern bool forloop_defined_p(forloop);
#define gen_FORLOOP_cons gen_forloop_cons
extern list gen_forloop_cons(forloop, list);
extern void forloop_assign_contents(forloop, forloop);
extern void forloop_non_recursive_free(forloop);
extern void write_forloop(FILE*, forloop);
extern forloop read_forloop(FILE*);
extern forloop make_forloop(expression, expression, expression, statement);

struct _newgen_struct_forloop_ {
  intptr_t _type_;
  expression _forloop_initialization_; /* initialization:expression */
  expression _forloop_condition_; /* condition:expression */
  expression _forloop_increment_; /* increment:expression */
  statement _forloop_body_; /* body:statement */
};

#define forloop_domain_number(x) ((x)->_type_)
#define forloop_initialization_(x) forloop_initialization(x) /* old hack compatible */
#define forloop_initialization(x) ((x)->_forloop_initialization_)
#define forloop_condition_(x) forloop_condition(x) /* old hack compatible */
#define forloop_condition(x) ((x)->_forloop_condition_)
#define forloop_increment_(x) forloop_increment(x) /* old hack compatible */
#define forloop_increment(x) ((x)->_forloop_increment_)
#define forloop_body_(x) forloop_body(x) /* old hack compatible */
#define forloop_body(x) ((x)->_forloop_body_)

/* FORMAL
 */
#define FORMAL(x) ((formal)((x).p))
#define formal_CAST(x) FORMAL(x)
#define FORMAL_CAST(x) FORMAL(x)
#define FORMAL_(x) ((x).e)
#define FORMAL_TYPE formal
#define formal_TYPE formal
#define formal_undefined ((formal)gen_chunk_undefined)
#define formal_undefined_p(x) ((x)==formal_undefined)

extern formal copy_formal(formal);
extern void free_formal(formal);
extern formal check_formal(formal);
extern bool formal_consistent_p(formal);
extern bool formal_defined_p(formal);
#define gen_FORMAL_cons gen_formal_cons
extern list gen_formal_cons(formal, list);
extern void formal_assign_contents(formal, formal);
extern void formal_non_recursive_free(formal);
extern void write_formal(FILE*, formal);
extern formal read_formal(FILE*);
extern formal make_formal(entity, intptr_t);

struct _newgen_struct_formal_ {
  intptr_t _type_;
  entity _formal_function_; /* function:entity */
  intptr_t _formal_offset_; /* offset:int */
};

#define formal_domain_number(x) ((x)->_type_)
#define formal_function_(x) formal_function(x) /* old hack compatible */
#define formal_function(x) ((x)->_formal_function_)
#define formal_offset_(x) formal_offset(x) /* old hack compatible */
#define formal_offset(x) ((x)->_formal_offset_)

/* FUNCTIONAL
 */
#define FUNCTIONAL(x) ((functional)((x).p))
#define functional_CAST(x) FUNCTIONAL(x)
#define FUNCTIONAL_CAST(x) FUNCTIONAL(x)
#define FUNCTIONAL_(x) ((x).e)
#define FUNCTIONAL_TYPE functional
#define functional_TYPE functional
#define functional_undefined ((functional)gen_chunk_undefined)
#define functional_undefined_p(x) ((x)==functional_undefined)

extern functional copy_functional(functional);
extern void free_functional(functional);
extern functional check_functional(functional);
extern bool functional_consistent_p(functional);
extern bool functional_defined_p(functional);
#define gen_FUNCTIONAL_cons gen_functional_cons
extern list gen_functional_cons(functional, list);
extern void functional_assign_contents(functional, functional);
extern void functional_non_recursive_free(functional);
extern void write_functional(FILE*, functional);
extern functional read_functional(FILE*);
extern functional make_functional(list, type);

struct _newgen_struct_functional_ {
  intptr_t _type_;
  list _functional_parameters_; /* parameters:parameter* */
  type _functional_result_; /* result:type */
};

#define functional_domain_number(x) ((x)->_type_)
#define functional_parameters_(x) functional_parameters(x) /* old hack compatible */
#define functional_parameters(x) ((x)->_functional_parameters_)
#define functional_result_(x) functional_result(x) /* old hack compatible */
#define functional_result(x) ((x)->_functional_result_)

/* INSTRUCTION
 */
#define INSTRUCTION(x) ((instruction)((x).p))
#define instruction_CAST(x) INSTRUCTION(x)
#define INSTRUCTION_CAST(x) INSTRUCTION(x)
#define INSTRUCTION_(x) ((x).e)
#define INSTRUCTION_TYPE instruction
#define instruction_TYPE instruction
#define instruction_undefined ((instruction)gen_chunk_undefined)
#define instruction_undefined_p(x) ((x)==instruction_undefined)

extern instruction copy_instruction(instruction);
extern void free_instruction(instruction);
extern instruction check_instruction(instruction);
extern bool instruction_consistent_p(instruction);
extern bool instruction_defined_p(instruction);
#define gen_INSTRUCTION_cons gen_instruction_cons
extern list gen_instruction_cons(instruction, list);
extern void instruction_assign_contents(instruction, instruction);
extern void instruction_non_recursive_free(instruction);
extern void write_instruction(FILE*, instruction);
extern instruction read_instruction(FILE*);
enum instruction_utype {
  is_instruction_sequence,
  is_instruction_test,
  is_instruction_loop,
  is_instruction_whileloop,
  is_instruction_goto,
  is_instruction_call,
  is_instruction_unstructured,
  is_instruction_multitest,
  is_instruction_forloop,
  is_instruction_expression
};
extern string instruction_tag_as_string(enum instruction_utype);
extern instruction make_instruction(enum instruction_utype, void *);
extern instruction make_instruction_sequence(sequence);
extern instruction make_instruction_test(test);
extern instruction make_instruction_loop(loop);
extern instruction make_instruction_whileloop(whileloop);
extern instruction make_instruction_goto(statement);
extern instruction make_instruction_call(call);
extern instruction make_instruction_unstructured(unstructured);
extern instruction make_instruction_multitest(multitest);
extern instruction make_instruction_forloop(forloop);
extern instruction make_instruction_expression(expression);

struct _newgen_struct_instruction_ {
  intptr_t _type_;
  enum instruction_utype _instruction_tag__;
  union {
    sequence _instruction_sequence_; /* sequence:sequence */
    test _instruction_test_; /* test:test */
    loop _instruction_loop_; /* loop:loop */
    whileloop _instruction_whileloop_; /* whileloop:whileloop */
    statement _instruction_goto_; /* goto:statement */
    call _instruction_call_; /* call:call */
    unstructured _instruction_unstructured_; /* unstructured:unstructured */
    multitest _instruction_multitest_; /* multitest:multitest */
    forloop _instruction_forloop_; /* forloop:forloop */
    expression _instruction_expression_; /* expression:expression */
  } _instruction_union_;
};

#define instruction_domain_number(x) ((x)->_type_)
#define instruction_tag(x) ((x)->_instruction_tag__)
#define instruction_sequence_p(x) (instruction_tag(x)==is_instruction_sequence)
#define instruction_sequence_(x) instruction_sequence(x) /* old hack compatible */
#define instruction_sequence(x) ((x)->_instruction_union_._instruction_sequence_)
#define instruction_test_p(x) (instruction_tag(x)==is_instruction_test)
#define instruction_test_(x) instruction_test(x) /* old hack compatible */
#define instruction_test(x) ((x)->_instruction_union_._instruction_test_)
#define instruction_loop_p(x) (instruction_tag(x)==is_instruction_loop)
#define instruction_loop_(x) instruction_loop(x) /* old hack compatible */
#define instruction_loop(x) ((x)->_instruction_union_._instruction_loop_)
#define instruction_whileloop_p(x) (instruction_tag(x)==is_instruction_whileloop)
#define instruction_whileloop_(x) instruction_whileloop(x) /* old hack compatible */
#define instruction_whileloop(x) ((x)->_instruction_union_._instruction_whileloop_)
#define instruction_goto_p(x) (instruction_tag(x)==is_instruction_goto)
#define instruction_goto_(x) instruction_goto(x) /* old hack compatible */
#define instruction_goto(x) ((x)->_instruction_union_._instruction_goto_)
#define instruction_call_p(x) (instruction_tag(x)==is_instruction_call)
#define instruction_call_(x) instruction_call(x) /* old hack compatible */
#define instruction_call(x) ((x)->_instruction_union_._instruction_call_)
#define instruction_unstructured_p(x) (instruction_tag(x)==is_instruction_unstructured)
#define instruction_unstructured_(x) instruction_unstructured(x) /* old hack compatible */
#define instruction_unstructured(x) ((x)->_instruction_union_._instruction_unstructured_)
#define instruction_multitest_p(x) (instruction_tag(x)==is_instruction_multitest)
#define instruction_multitest_(x) instruction_multitest(x) /* old hack compatible */
#define instruction_multitest(x) ((x)->_instruction_union_._instruction_multitest_)
#define instruction_forloop_p(x) (instruction_tag(x)==is_instruction_forloop)
#define instruction_forloop_(x) instruction_forloop(x) /* old hack compatible */
#define instruction_forloop(x) ((x)->_instruction_union_._instruction_forloop_)
#define instruction_expression_p(x) (instruction_tag(x)==is_instruction_expression)
#define instruction_expression_(x) instruction_expression(x) /* old hack compatible */
#define instruction_expression(x) ((x)->_instruction_union_._instruction_expression_)

/* LANGUAGE
 */
#define LANGUAGE(x) ((language)((x).p))
#define language_CAST(x) LANGUAGE(x)
#define LANGUAGE_CAST(x) LANGUAGE(x)
#define LANGUAGE_(x) ((x).e)
#define LANGUAGE_TYPE language
#define language_TYPE language
#define language_undefined ((language)gen_chunk_undefined)
#define language_undefined_p(x) ((x)==language_undefined)

extern language copy_language(language);
extern void free_language(language);
extern language check_language(language);
extern bool language_consistent_p(language);
extern bool language_defined_p(language);
#define gen_LANGUAGE_cons gen_language_cons
extern list gen_language_cons(language, list);
extern void language_assign_contents(language, language);
extern void language_non_recursive_free(language);
extern void write_language(FILE*, language);
extern language read_language(FILE*);
enum language_utype {
  is_language_fortran,
  is_language_c,
  is_language_fortran95,
  is_language_unknown
};
extern string language_tag_as_string(enum language_utype);
extern language make_language(enum language_utype, void *);
extern language make_language_fortran(void);
extern language make_language_c(void);
extern language make_language_fortran95(void);
extern language make_language_unknown(void);

struct _newgen_struct_language_ {
  intptr_t _type_;
  enum language_utype _language_tag__;
  union {
    gen_chunk _language_fortran_; /* fortran:unit */
    gen_chunk _language_c_; /* c:unit */
    gen_chunk _language_fortran95_; /* fortran95:unit */
    gen_chunk _language_unknown_; /* unknown:unit */
  } _language_union_;
};

#define language_domain_number(x) ((x)->_type_)
#define language_tag(x) ((x)->_language_tag__)
#define language_fortran_p(x) (language_tag(x)==is_language_fortran)
#define language_fortran_(x) language_fortran(x) /* old hack compatible */
#define language_fortran(x) ((x)->_language_union_._language_fortran_.u)
#define language_c_p(x) (language_tag(x)==is_language_c)
#define language_c_(x) language_c(x) /* old hack compatible */
#define language_c(x) ((x)->_language_union_._language_c_.u)
#define language_fortran95_p(x) (language_tag(x)==is_language_fortran95)
#define language_fortran95_(x) language_fortran95(x) /* old hack compatible */
#define language_fortran95(x) ((x)->_language_union_._language_fortran95_.u)
#define language_unknown_p(x) (language_tag(x)==is_language_unknown)
#define language_unknown_(x) language_unknown(x) /* old hack compatible */
#define language_unknown(x) ((x)->_language_union_._language_unknown_.u)

/* LOOP
 */
#define LOOP(x) ((loop)((x).p))
#define loop_CAST(x) LOOP(x)
#define LOOP_CAST(x) LOOP(x)
#define LOOP_(x) ((x).e)
#define LOOP_TYPE loop
#define loop_TYPE loop
#define loop_undefined ((loop)gen_chunk_undefined)
#define loop_undefined_p(x) ((x)==loop_undefined)

extern loop copy_loop(loop);
extern void free_loop(loop);
extern loop check_loop(loop);
extern bool loop_consistent_p(loop);
extern bool loop_defined_p(loop);
#define gen_LOOP_cons gen_loop_cons
extern list gen_loop_cons(loop, list);
extern void loop_assign_contents(loop, loop);
extern void loop_non_recursive_free(loop);
extern void write_loop(FILE*, loop);
extern loop read_loop(FILE*);
extern loop make_loop(entity, range, statement, entity, execution, list);

struct _newgen_struct_loop_ {
  intptr_t _type_;
  entity _loop_index_; /* index:entity */
  range _loop_range_; /* range:range */
  statement _loop_body_; /* body:statement */
  entity _loop_label_; /* label:entity */
  execution _loop_execution_; /* execution:execution */
  list _loop_locals_; /* locals:entity* */
};

#define loop_domain_number(x) ((x)->_type_)
#define loop_index_(x) loop_index(x) /* old hack compatible */
#define loop_index(x) ((x)->_loop_index_)
#define loop_range_(x) loop_range(x) /* old hack compatible */
#define loop_range(x) ((x)->_loop_range_)
#define loop_body_(x) loop_body(x) /* old hack compatible */
#define loop_body(x) ((x)->_loop_body_)
#define loop_label_(x) loop_label(x) /* old hack compatible */
#define loop_label(x) ((x)->_loop_label_)
#define loop_execution_(x) loop_execution(x) /* old hack compatible */
#define loop_execution(x) ((x)->_loop_execution_)
#define loop_locals_(x) loop_locals(x) /* old hack compatible */
#define loop_locals(x) ((x)->_loop_locals_)

/* MODE
 */
#define MODE(x) ((mode)((x).p))
#define mode_CAST(x) MODE(x)
#define MODE_CAST(x) MODE(x)
#define MODE_(x) ((x).e)
#define MODE_TYPE mode
#define mode_TYPE mode
#define mode_undefined ((mode)gen_chunk_undefined)
#define mode_undefined_p(x) ((x)==mode_undefined)

extern mode copy_mode(mode);
extern void free_mode(mode);
extern mode check_mode(mode);
extern bool mode_consistent_p(mode);
extern bool mode_defined_p(mode);
#define gen_MODE_cons gen_mode_cons
extern list gen_mode_cons(mode, list);
extern void mode_assign_contents(mode, mode);
extern void mode_non_recursive_free(mode);
extern void write_mode(FILE*, mode);
extern mode read_mode(FILE*);
enum mode_utype {
  is_mode_value,
  is_mode_reference
};
extern string mode_tag_as_string(enum mode_utype);
extern mode make_mode(enum mode_utype, void *);
extern mode make_mode_value(void);
extern mode make_mode_reference(void);

struct _newgen_struct_mode_ {
  intptr_t _type_;
  enum mode_utype _mode_tag__;
  union {
    gen_chunk _mode_value_; /* value:unit */
    gen_chunk _mode_reference_; /* reference:unit */
  } _mode_union_;
};

#define mode_domain_number(x) ((x)->_type_)
#define mode_tag(x) ((x)->_mode_tag__)
#define mode_value_p(x) (mode_tag(x)==is_mode_value)
#define mode_value_(x) mode_value(x) /* old hack compatible */
#define mode_value(x) ((x)->_mode_union_._mode_value_.u)
#define mode_reference_p(x) (mode_tag(x)==is_mode_reference)
#define mode_reference_(x) mode_reference(x) /* old hack compatible */
#define mode_reference(x) ((x)->_mode_union_._mode_reference_.u)

/* MULTITEST
 */
#define MULTITEST(x) ((multitest)((x).p))
#define multitest_CAST(x) MULTITEST(x)
#define MULTITEST_CAST(x) MULTITEST(x)
#define MULTITEST_(x) ((x).e)
#define MULTITEST_TYPE multitest
#define multitest_TYPE multitest
#define multitest_undefined ((multitest)gen_chunk_undefined)
#define multitest_undefined_p(x) ((x)==multitest_undefined)

extern multitest copy_multitest(multitest);
extern void free_multitest(multitest);
extern multitest check_multitest(multitest);
extern bool multitest_consistent_p(multitest);
extern bool multitest_defined_p(multitest);
#define gen_MULTITEST_cons gen_multitest_cons
extern list gen_multitest_cons(multitest, list);
extern void multitest_assign_contents(multitest, multitest);
extern void multitest_non_recursive_free(multitest);
extern void write_multitest(FILE*, multitest);
extern multitest read_multitest(FILE*);
extern multitest make_multitest(expression, statement);

struct _newgen_struct_multitest_ {
  intptr_t _type_;
  expression _multitest_controller_; /* controller:expression */
  statement _multitest_body_; /* body:statement */
};

#define multitest_domain_number(x) ((x)->_type_)
#define multitest_controller_(x) multitest_controller(x) /* old hack compatible */
#define multitest_controller(x) ((x)->_multitest_controller_)
#define multitest_body_(x) multitest_body(x) /* old hack compatible */
#define multitest_body(x) ((x)->_multitest_body_)

/* NORMALIZED
 */
#define NORMALIZED(x) ((normalized)((x).p))
#define normalized_CAST(x) NORMALIZED(x)
#define NORMALIZED_CAST(x) NORMALIZED(x)
#define NORMALIZED_(x) ((x).e)
#define NORMALIZED_TYPE normalized
#define normalized_TYPE normalized
#define normalized_undefined ((normalized)gen_chunk_undefined)
#define normalized_undefined_p(x) ((x)==normalized_undefined)

extern normalized copy_normalized(normalized);
extern void free_normalized(normalized);
extern normalized check_normalized(normalized);
extern bool normalized_consistent_p(normalized);
extern bool normalized_defined_p(normalized);
#define gen_NORMALIZED_cons gen_normalized_cons
extern list gen_normalized_cons(normalized, list);
extern void normalized_assign_contents(normalized, normalized);
extern void normalized_non_recursive_free(normalized);
extern void write_normalized(FILE*, normalized);
extern normalized read_normalized(FILE*);
enum normalized_utype {
  is_normalized_linear,
  is_normalized_complex
};
extern string normalized_tag_as_string(enum normalized_utype);
extern normalized make_normalized(enum normalized_utype, void *);
extern normalized make_normalized_linear(Pvecteur);
extern normalized make_normalized_complex(void);

struct _newgen_struct_normalized_ {
  intptr_t _type_;
  enum normalized_utype _normalized_tag__;
  union {
    Pvecteur _normalized_linear_; /* linear:Pvecteur */
    gen_chunk _normalized_complex_; /* complex:unit */
  } _normalized_union_;
};

#define normalized_domain_number(x) ((x)->_type_)
#define normalized_tag(x) ((x)->_normalized_tag__)
#define normalized_linear_p(x) (normalized_tag(x)==is_normalized_linear)
#define normalized_linear_(x) normalized_linear(x) /* old hack compatible */
#define normalized_linear(x) ((x)->_normalized_union_._normalized_linear_)
#define normalized_complex_p(x) (normalized_tag(x)==is_normalized_complex)
#define normalized_complex_(x) normalized_complex(x) /* old hack compatible */
#define normalized_complex(x) ((x)->_normalized_union_._normalized_complex_.u)

/* PARAMETER
 */
#define PARAMETER(x) ((parameter)((x).p))
#define parameter_CAST(x) PARAMETER(x)
#define PARAMETER_CAST(x) PARAMETER(x)
#define PARAMETER_(x) ((x).e)
#define PARAMETER_TYPE parameter
#define parameter_TYPE parameter
#define parameter_undefined ((parameter)gen_chunk_undefined)
#define parameter_undefined_p(x) ((x)==parameter_undefined)

extern parameter copy_parameter(parameter);
extern void free_parameter(parameter);
extern parameter check_parameter(parameter);
extern bool parameter_consistent_p(parameter);
extern bool parameter_defined_p(parameter);
#define gen_PARAMETER_cons gen_parameter_cons
extern list gen_parameter_cons(parameter, list);
extern void parameter_assign_contents(parameter, parameter);
extern void parameter_non_recursive_free(parameter);
extern void write_parameter(FILE*, parameter);
extern parameter read_parameter(FILE*);
extern parameter make_parameter(type, mode, dummy);

struct _newgen_struct_parameter_ {
  intptr_t _type_;
  type _parameter_type_; /* type:type */
  mode _parameter_mode_; /* mode:mode */
  dummy _parameter_dummy_; /* dummy:dummy */
};

#define parameter_domain_number(x) ((x)->_type_)
#define parameter_type_(x) parameter_type(x) /* old hack compatible */
#define parameter_type(x) ((x)->_parameter_type_)
#define parameter_mode_(x) parameter_mode(x) /* old hack compatible */
#define parameter_mode(x) ((x)->_parameter_mode_)
#define parameter_dummy_(x) parameter_dummy(x) /* old hack compatible */
#define parameter_dummy(x) ((x)->_parameter_dummy_)

/* PERSISTANT_STATEMENT_TO_CLUSTER
 */
#define PERSISTANT_STATEMENT_TO_CLUSTER(x) ((persistant_statement_to_cluster)((x).p))
#define persistant_statement_to_cluster_CAST(x) PERSISTANT_STATEMENT_TO_CLUSTER(x)
#define PERSISTANT_STATEMENT_TO_CLUSTER_CAST(x) PERSISTANT_STATEMENT_TO_CLUSTER(x)
#define PERSISTANT_STATEMENT_TO_CLUSTER_(x) ((x).e)
#define PERSISTANT_STATEMENT_TO_CLUSTER_TYPE persistant_statement_to_cluster
#define persistant_statement_to_cluster_TYPE persistant_statement_to_cluster
#define persistant_statement_to_cluster_undefined ((persistant_statement_to_cluster)gen_chunk_undefined)
#define persistant_statement_to_cluster_undefined_p(x) ((x)==persistant_statement_to_cluster_undefined)

extern persistant_statement_to_cluster copy_persistant_statement_to_cluster(persistant_statement_to_cluster);
extern void free_persistant_statement_to_cluster(persistant_statement_to_cluster);
extern persistant_statement_to_cluster check_persistant_statement_to_cluster(persistant_statement_to_cluster);
extern bool persistant_statement_to_cluster_consistent_p(persistant_statement_to_cluster);
extern bool persistant_statement_to_cluster_defined_p(persistant_statement_to_cluster);
#define gen_PERSISTANT_STATEMENT_TO_CLUSTER_cons gen_persistant_statement_to_cluster_cons
extern list gen_persistant_statement_to_cluster_cons(persistant_statement_to_cluster, list);
extern void persistant_statement_to_cluster_assign_contents(persistant_statement_to_cluster, persistant_statement_to_cluster);
extern void persistant_statement_to_cluster_non_recursive_free(persistant_statement_to_cluster);
extern void write_persistant_statement_to_cluster(FILE*, persistant_statement_to_cluster);
extern persistant_statement_to_cluster read_persistant_statement_to_cluster(FILE*);
extern persistant_statement_to_cluster make_persistant_statement_to_cluster(void);

struct _newgen_struct_persistant_statement_to_cluster_ {
  intptr_t _type_;
  hash_table _persistant_statement_to_cluster_holder_;
};

#define persistant_statement_to_cluster_domain_number(x) ((x)->_type_)
#define persistant_statement_to_cluster_hash_table(x) ((x)->_persistant_statement_to_cluster_holder_)
#define persistant_statement_to_cluster_key_type intptr_t
#define persistant_statement_to_cluster_value_type intptr_t
#define PERSISTANT_STATEMENT_TO_CLUSTER_MAP(k,v,c,f) FUNCTION_MAP(persistant_statement_to_cluster,i,i,k,v,c,f)
#define PERSISTANT_STATEMENT_TO_CLUSTER_FOREACH(k,v,f) FUNCTION_FOREACH(persistant_statement_to_cluster,i,i,k,v,f)
extern intptr_t apply_persistant_statement_to_cluster(persistant_statement_to_cluster, intptr_t);
extern void update_persistant_statement_to_cluster(persistant_statement_to_cluster, intptr_t, intptr_t);
extern void extend_persistant_statement_to_cluster(persistant_statement_to_cluster, intptr_t, intptr_t);
extern intptr_t delete_persistant_statement_to_cluster(persistant_statement_to_cluster, intptr_t);
extern bool bound_persistant_statement_to_cluster_p(persistant_statement_to_cluster, intptr_t);

/* PERSISTANT_STATEMENT_TO_CONTROL
 */
#define PERSISTANT_STATEMENT_TO_CONTROL(x) ((persistant_statement_to_control)((x).p))
#define persistant_statement_to_control_CAST(x) PERSISTANT_STATEMENT_TO_CONTROL(x)
#define PERSISTANT_STATEMENT_TO_CONTROL_CAST(x) PERSISTANT_STATEMENT_TO_CONTROL(x)
#define PERSISTANT_STATEMENT_TO_CONTROL_(x) ((x).e)
#define PERSISTANT_STATEMENT_TO_CONTROL_TYPE persistant_statement_to_control
#define persistant_statement_to_control_TYPE persistant_statement_to_control
#define persistant_statement_to_control_undefined ((persistant_statement_to_control)gen_chunk_undefined)
#define persistant_statement_to_control_undefined_p(x) ((x)==persistant_statement_to_control_undefined)

extern persistant_statement_to_control copy_persistant_statement_to_control(persistant_statement_to_control);
extern void free_persistant_statement_to_control(persistant_statement_to_control);
extern persistant_statement_to_control check_persistant_statement_to_control(persistant_statement_to_control);
extern bool persistant_statement_to_control_consistent_p(persistant_statement_to_control);
extern bool persistant_statement_to_control_defined_p(persistant_statement_to_control);
#define gen_PERSISTANT_STATEMENT_TO_CONTROL_cons gen_persistant_statement_to_control_cons
extern list gen_persistant_statement_to_control_cons(persistant_statement_to_control, list);
extern void persistant_statement_to_control_assign_contents(persistant_statement_to_control, persistant_statement_to_control);
extern void persistant_statement_to_control_non_recursive_free(persistant_statement_to_control);
extern void write_persistant_statement_to_control(FILE*, persistant_statement_to_control);
extern persistant_statement_to_control read_persistant_statement_to_control(FILE*);
extern persistant_statement_to_control make_persistant_statement_to_control(void);

struct _newgen_struct_persistant_statement_to_control_ {
  intptr_t _type_;
  hash_table _persistant_statement_to_control_holder_;
};

#define persistant_statement_to_control_domain_number(x) ((x)->_type_)
#define persistant_statement_to_control_hash_table(x) ((x)->_persistant_statement_to_control_holder_)
#define persistant_statement_to_control_key_type statement
#define persistant_statement_to_control_value_type control
#define PERSISTANT_STATEMENT_TO_CONTROL_MAP(k,v,c,f) FUNCTION_MAP(persistant_statement_to_control,p,p,k,v,c,f)
#define PERSISTANT_STATEMENT_TO_CONTROL_FOREACH(k,v,f) FUNCTION_FOREACH(persistant_statement_to_control,p,p,k,v,f)
extern control apply_persistant_statement_to_control(persistant_statement_to_control, statement);
extern void update_persistant_statement_to_control(persistant_statement_to_control, statement, control);
extern void extend_persistant_statement_to_control(persistant_statement_to_control, statement, control);
extern control delete_persistant_statement_to_control(persistant_statement_to_control, statement);
extern bool bound_persistant_statement_to_control_p(persistant_statement_to_control, statement);

/* PERSISTANT_STATEMENT_TO_INT
 */
#define PERSISTANT_STATEMENT_TO_INT(x) ((persistant_statement_to_int)((x).p))
#define persistant_statement_to_int_CAST(x) PERSISTANT_STATEMENT_TO_INT(x)
#define PERSISTANT_STATEMENT_TO_INT_CAST(x) PERSISTANT_STATEMENT_TO_INT(x)
#define PERSISTANT_STATEMENT_TO_INT_(x) ((x).e)
#define PERSISTANT_STATEMENT_TO_INT_TYPE persistant_statement_to_int
#define persistant_statement_to_int_TYPE persistant_statement_to_int
#define persistant_statement_to_int_undefined ((persistant_statement_to_int)gen_chunk_undefined)
#define persistant_statement_to_int_undefined_p(x) ((x)==persistant_statement_to_int_undefined)

extern persistant_statement_to_int copy_persistant_statement_to_int(persistant_statement_to_int);
extern void free_persistant_statement_to_int(persistant_statement_to_int);
extern persistant_statement_to_int check_persistant_statement_to_int(persistant_statement_to_int);
extern bool persistant_statement_to_int_consistent_p(persistant_statement_to_int);
extern bool persistant_statement_to_int_defined_p(persistant_statement_to_int);
#define gen_PERSISTANT_STATEMENT_TO_INT_cons gen_persistant_statement_to_int_cons
extern list gen_persistant_statement_to_int_cons(persistant_statement_to_int, list);
extern void persistant_statement_to_int_assign_contents(persistant_statement_to_int, persistant_statement_to_int);
extern void persistant_statement_to_int_non_recursive_free(persistant_statement_to_int);
extern void write_persistant_statement_to_int(FILE*, persistant_statement_to_int);
extern persistant_statement_to_int read_persistant_statement_to_int(FILE*);
extern persistant_statement_to_int make_persistant_statement_to_int(void);

struct _newgen_struct_persistant_statement_to_int_ {
  intptr_t _type_;
  hash_table _persistant_statement_to_int_holder_;
};

#define persistant_statement_to_int_domain_number(x) ((x)->_type_)
#define persistant_statement_to_int_hash_table(x) ((x)->_persistant_statement_to_int_holder_)
#define persistant_statement_to_int_key_type statement
#define persistant_statement_to_int_value_type intptr_t
#define PERSISTANT_STATEMENT_TO_INT_MAP(k,v,c,f) FUNCTION_MAP(persistant_statement_to_int,p,i,k,v,c,f)
#define PERSISTANT_STATEMENT_TO_INT_FOREACH(k,v,f) FUNCTION_FOREACH(persistant_statement_to_int,p,i,k,v,f)
extern intptr_t apply_persistant_statement_to_int(persistant_statement_to_int, statement);
extern void update_persistant_statement_to_int(persistant_statement_to_int, statement, intptr_t);
extern void extend_persistant_statement_to_int(persistant_statement_to_int, statement, intptr_t);
extern intptr_t delete_persistant_statement_to_int(persistant_statement_to_int, statement);
extern bool bound_persistant_statement_to_int_p(persistant_statement_to_int, statement);

/* PERSISTANT_STATEMENT_TO_STATEMENT
 */
#define PERSISTANT_STATEMENT_TO_STATEMENT(x) ((persistant_statement_to_statement)((x).p))
#define persistant_statement_to_statement_CAST(x) PERSISTANT_STATEMENT_TO_STATEMENT(x)
#define PERSISTANT_STATEMENT_TO_STATEMENT_CAST(x) PERSISTANT_STATEMENT_TO_STATEMENT(x)
#define PERSISTANT_STATEMENT_TO_STATEMENT_(x) ((x).e)
#define PERSISTANT_STATEMENT_TO_STATEMENT_TYPE persistant_statement_to_statement
#define persistant_statement_to_statement_TYPE persistant_statement_to_statement
#define persistant_statement_to_statement_undefined ((persistant_statement_to_statement)gen_chunk_undefined)
#define persistant_statement_to_statement_undefined_p(x) ((x)==persistant_statement_to_statement_undefined)

extern persistant_statement_to_statement copy_persistant_statement_to_statement(persistant_statement_to_statement);
extern void free_persistant_statement_to_statement(persistant_statement_to_statement);
extern persistant_statement_to_statement check_persistant_statement_to_statement(persistant_statement_to_statement);
extern bool persistant_statement_to_statement_consistent_p(persistant_statement_to_statement);
extern bool persistant_statement_to_statement_defined_p(persistant_statement_to_statement);
#define gen_PERSISTANT_STATEMENT_TO_STATEMENT_cons gen_persistant_statement_to_statement_cons
extern list gen_persistant_statement_to_statement_cons(persistant_statement_to_statement, list);
extern void persistant_statement_to_statement_assign_contents(persistant_statement_to_statement, persistant_statement_to_statement);
extern void persistant_statement_to_statement_non_recursive_free(persistant_statement_to_statement);
extern void write_persistant_statement_to_statement(FILE*, persistant_statement_to_statement);
extern persistant_statement_to_statement read_persistant_statement_to_statement(FILE*);
extern persistant_statement_to_statement make_persistant_statement_to_statement(void);

struct _newgen_struct_persistant_statement_to_statement_ {
  intptr_t _type_;
  hash_table _persistant_statement_to_statement_holder_;
};

#define persistant_statement_to_statement_domain_number(x) ((x)->_type_)
#define persistant_statement_to_statement_hash_table(x) ((x)->_persistant_statement_to_statement_holder_)
#define persistant_statement_to_statement_key_type statement
#define persistant_statement_to_statement_value_type statement
#define PERSISTANT_STATEMENT_TO_STATEMENT_MAP(k,v,c,f) FUNCTION_MAP(persistant_statement_to_statement,p,p,k,v,c,f)
#define PERSISTANT_STATEMENT_TO_STATEMENT_FOREACH(k,v,f) FUNCTION_FOREACH(persistant_statement_to_statement,p,p,k,v,f)
extern statement apply_persistant_statement_to_statement(persistant_statement_to_statement, statement);
extern void update_persistant_statement_to_statement(persistant_statement_to_statement, statement, statement);
extern void extend_persistant_statement_to_statement(persistant_statement_to_statement, statement, statement);
extern statement delete_persistant_statement_to_statement(persistant_statement_to_statement, statement);
extern bool bound_persistant_statement_to_statement_p(persistant_statement_to_statement, statement);

/* PRAGMA
 */
#define PRAGMA(x) ((pragma)((x).p))
#define pragma_CAST(x) PRAGMA(x)
#define PRAGMA_CAST(x) PRAGMA(x)
#define PRAGMA_(x) ((x).e)
#define PRAGMA_TYPE pragma
#define pragma_TYPE pragma
#define pragma_undefined ((pragma)gen_chunk_undefined)
#define pragma_undefined_p(x) ((x)==pragma_undefined)

extern pragma copy_pragma(pragma);
extern void free_pragma(pragma);
extern pragma check_pragma(pragma);
extern bool pragma_consistent_p(pragma);
extern bool pragma_defined_p(pragma);
#define gen_PRAGMA_cons gen_pragma_cons
extern list gen_pragma_cons(pragma, list);
extern void pragma_assign_contents(pragma, pragma);
extern void pragma_non_recursive_free(pragma);
extern void write_pragma(FILE*, pragma);
extern pragma read_pragma(FILE*);
enum pragma_utype {
  is_pragma_string,
  is_pragma_expression
};
extern string pragma_tag_as_string(enum pragma_utype);
extern pragma make_pragma(enum pragma_utype, void *);
extern pragma make_pragma_string(string);
extern pragma make_pragma_expression(list);

struct _newgen_struct_pragma_ {
  intptr_t _type_;
  enum pragma_utype _pragma_tag__;
  union {
    string _pragma_string_; /* string:string */
    list _pragma_expression_; /* expression:expression* */
  } _pragma_union_;
};

#define pragma_domain_number(x) ((x)->_type_)
#define pragma_tag(x) ((x)->_pragma_tag__)
#define pragma_string_p(x) (pragma_tag(x)==is_pragma_string)
#define pragma_string_(x) pragma_string(x) /* old hack compatible */
#define pragma_string(x) ((x)->_pragma_union_._pragma_string_)
#define pragma_expression_p(x) (pragma_tag(x)==is_pragma_expression)
#define pragma_expression_(x) pragma_expression(x) /* old hack compatible */
#define pragma_expression(x) ((x)->_pragma_union_._pragma_expression_)

/* PREDICATE
 */
#define PREDICATE(x) ((predicate)((x).p))
#define predicate_CAST(x) PREDICATE(x)
#define PREDICATE_CAST(x) PREDICATE(x)
#define PREDICATE_(x) ((x).e)
#define PREDICATE_TYPE predicate
#define predicate_TYPE predicate
#define predicate_undefined ((predicate)gen_chunk_undefined)
#define predicate_undefined_p(x) ((x)==predicate_undefined)

extern predicate copy_predicate(predicate);
extern void free_predicate(predicate);
extern predicate check_predicate(predicate);
extern bool predicate_consistent_p(predicate);
extern bool predicate_defined_p(predicate);
#define gen_PREDICATE_cons gen_predicate_cons
extern list gen_predicate_cons(predicate, list);
extern void predicate_assign_contents(predicate, predicate);
extern void predicate_non_recursive_free(predicate);
extern void write_predicate(FILE*, predicate);
extern predicate read_predicate(FILE*);
extern predicate make_predicate(Psysteme);

struct _newgen_struct_predicate_ {
  intptr_t _type_;
  Psysteme _predicate_system_; /* system:Psysteme */
};

#define predicate_domain_number(x) ((x)->_type_)
#define predicate_system_(x) predicate_system(x) /* old hack compatible */
#define predicate_system(x) ((x)->_predicate_system_)

/* PREFERENCE
 */
#define PREFERENCE(x) ((preference)((x).p))
#define preference_CAST(x) PREFERENCE(x)
#define PREFERENCE_CAST(x) PREFERENCE(x)
#define PREFERENCE_(x) ((x).e)
#define PREFERENCE_TYPE preference
#define preference_TYPE preference
#define preference_undefined ((preference)gen_chunk_undefined)
#define preference_undefined_p(x) ((x)==preference_undefined)

extern preference copy_preference(preference);
extern void free_preference(preference);
extern preference check_preference(preference);
extern bool preference_consistent_p(preference);
extern bool preference_defined_p(preference);
#define gen_PREFERENCE_cons gen_preference_cons
extern list gen_preference_cons(preference, list);
extern void preference_assign_contents(preference, preference);
extern void preference_non_recursive_free(preference);
extern void write_preference(FILE*, preference);
extern preference read_preference(FILE*);
extern preference make_preference(reference);

struct _newgen_struct_preference_ {
  intptr_t _type_;
  reference _preference_reference_; /* reference:reference */
};

#define preference_domain_number(x) ((x)->_type_)
#define preference_reference_(x) preference_reference(x) /* old hack compatible */
#define preference_reference(x) ((x)->_preference_reference_)

/* QUALIFIER
 */
#define QUALIFIER(x) ((qualifier)((x).p))
#define qualifier_CAST(x) QUALIFIER(x)
#define QUALIFIER_CAST(x) QUALIFIER(x)
#define QUALIFIER_(x) ((x).e)
#define QUALIFIER_TYPE qualifier
#define qualifier_TYPE qualifier
#define qualifier_undefined ((qualifier)gen_chunk_undefined)
#define qualifier_undefined_p(x) ((x)==qualifier_undefined)

extern qualifier copy_qualifier(qualifier);
extern void free_qualifier(qualifier);
extern qualifier check_qualifier(qualifier);
extern bool qualifier_consistent_p(qualifier);
extern bool qualifier_defined_p(qualifier);
#define gen_QUALIFIER_cons gen_qualifier_cons
extern list gen_qualifier_cons(qualifier, list);
extern void qualifier_assign_contents(qualifier, qualifier);
extern void qualifier_non_recursive_free(qualifier);
extern void write_qualifier(FILE*, qualifier);
extern qualifier read_qualifier(FILE*);
enum qualifier_utype {
  is_qualifier_const,
  is_qualifier_restrict,
  is_qualifier_volatile,
  is_qualifier_register,
  is_qualifier_auto,
  is_qualifier_thread,
  is_qualifier_asm,
  is_qualifier_static_dimension,
  is_qualifier_local,
  is_qualifier_global,
  is_qualifier_constant,
  is_qualifier_private
};
extern string qualifier_tag_as_string(enum qualifier_utype);
extern qualifier make_qualifier(enum qualifier_utype, void *);
extern qualifier make_qualifier_const(void);
extern qualifier make_qualifier_restrict(void);
extern qualifier make_qualifier_volatile(void);
extern qualifier make_qualifier_register(void);
extern qualifier make_qualifier_auto(void);
extern qualifier make_qualifier_thread(void);
extern qualifier make_qualifier_asm(string);
extern qualifier make_qualifier_static_dimension(void);
extern qualifier make_qualifier_local(void);
extern qualifier make_qualifier_global(void);
extern qualifier make_qualifier_constant(void);
extern qualifier make_qualifier_private(void);

struct _newgen_struct_qualifier_ {
  intptr_t _type_;
  enum qualifier_utype _qualifier_tag__;
  union {
    gen_chunk _qualifier_const_; /* const:unit */
    gen_chunk _qualifier_restrict_; /* restrict:unit */
    gen_chunk _qualifier_volatile_; /* volatile:unit */
    gen_chunk _qualifier_register_; /* register:unit */
    gen_chunk _qualifier_auto_; /* auto:unit */
    gen_chunk _qualifier_thread_; /* thread:unit */
    string _qualifier_asm_; /* asm:string */
    gen_chunk _qualifier_static_dimension_; /* static_dimension:unit */
    gen_chunk _qualifier_local_; /* local:unit */
    gen_chunk _qualifier_global_; /* global:unit */
    gen_chunk _qualifier_constant_; /* constant:unit */
    gen_chunk _qualifier_private_; /* private:unit */
  } _qualifier_union_;
};

#define qualifier_domain_number(x) ((x)->_type_)
#define qualifier_tag(x) ((x)->_qualifier_tag__)
#define qualifier_const_p(x) (qualifier_tag(x)==is_qualifier_const)
#define qualifier_const_(x) qualifier_const(x) /* old hack compatible */
#define qualifier_const(x) ((x)->_qualifier_union_._qualifier_const_.u)
#define qualifier_restrict_p(x) (qualifier_tag(x)==is_qualifier_restrict)
#define qualifier_restrict_(x) qualifier_restrict(x) /* old hack compatible */
#define qualifier_restrict(x) ((x)->_qualifier_union_._qualifier_restrict_.u)
#define qualifier_volatile_p(x) (qualifier_tag(x)==is_qualifier_volatile)
#define qualifier_volatile_(x) qualifier_volatile(x) /* old hack compatible */
#define qualifier_volatile(x) ((x)->_qualifier_union_._qualifier_volatile_.u)
#define qualifier_register_p(x) (qualifier_tag(x)==is_qualifier_register)
#define qualifier_register_(x) qualifier_register(x) /* old hack compatible */
#define qualifier_register(x) ((x)->_qualifier_union_._qualifier_register_.u)
#define qualifier_auto_p(x) (qualifier_tag(x)==is_qualifier_auto)
#define qualifier_auto_(x) qualifier_auto(x) /* old hack compatible */
#define qualifier_auto(x) ((x)->_qualifier_union_._qualifier_auto_.u)
#define qualifier_thread_p(x) (qualifier_tag(x)==is_qualifier_thread)
#define qualifier_thread_(x) qualifier_thread(x) /* old hack compatible */
#define qualifier_thread(x) ((x)->_qualifier_union_._qualifier_thread_.u)
#define qualifier_asm_p(x) (qualifier_tag(x)==is_qualifier_asm)
#define qualifier_asm_(x) qualifier_asm(x) /* old hack compatible */
#define qualifier_asm(x) ((x)->_qualifier_union_._qualifier_asm_)
#define qualifier_static_dimension_p(x) (qualifier_tag(x)==is_qualifier_static_dimension)
#define qualifier_static_dimension_(x) qualifier_static_dimension(x) /* old hack compatible */
#define qualifier_static_dimension(x) ((x)->_qualifier_union_._qualifier_static_dimension_.u)
#define qualifier_local_p(x) (qualifier_tag(x)==is_qualifier_local)
#define qualifier_local_(x) qualifier_local(x) /* old hack compatible */
#define qualifier_local(x) ((x)->_qualifier_union_._qualifier_local_.u)
#define qualifier_global_p(x) (qualifier_tag(x)==is_qualifier_global)
#define qualifier_global_(x) qualifier_global(x) /* old hack compatible */
#define qualifier_global(x) ((x)->_qualifier_union_._qualifier_global_.u)
#define qualifier_constant_p(x) (qualifier_tag(x)==is_qualifier_constant)
#define qualifier_constant_(x) qualifier_constant(x) /* old hack compatible */
#define qualifier_constant(x) ((x)->_qualifier_union_._qualifier_constant_.u)
#define qualifier_private_p(x) (qualifier_tag(x)==is_qualifier_private)
#define qualifier_private_(x) qualifier_private(x) /* old hack compatible */
#define qualifier_private(x) ((x)->_qualifier_union_._qualifier_private_.u)

/* RAM
 */
#define RAM(x) ((ram)((x).p))
#define ram_CAST(x) RAM(x)
#define RAM_CAST(x) RAM(x)
#define RAM_(x) ((x).e)
#define RAM_TYPE ram
#define ram_TYPE ram
#define ram_undefined ((ram)gen_chunk_undefined)
#define ram_undefined_p(x) ((x)==ram_undefined)

extern ram copy_ram(ram);
extern void free_ram(ram);
extern ram check_ram(ram);
extern bool ram_consistent_p(ram);
extern bool ram_defined_p(ram);
#define gen_RAM_cons gen_ram_cons
extern list gen_ram_cons(ram, list);
extern void ram_assign_contents(ram, ram);
extern void ram_non_recursive_free(ram);
extern void write_ram(FILE*, ram);
extern ram read_ram(FILE*);
extern ram make_ram(entity, entity, intptr_t, list);

struct _newgen_struct_ram_ {
  intptr_t _type_;
  entity _ram_function_; /* function:entity */
  entity _ram_section_; /* section:entity */
  intptr_t _ram_offset_; /* offset:int */
  list _ram_shared_; /* shared:entity* */
};

#define ram_domain_number(x) ((x)->_type_)
#define ram_function_(x) ram_function(x) /* old hack compatible */
#define ram_function(x) ((x)->_ram_function_)
#define ram_section_(x) ram_section(x) /* old hack compatible */
#define ram_section(x) ((x)->_ram_section_)
#define ram_offset_(x) ram_offset(x) /* old hack compatible */
#define ram_offset(x) ((x)->_ram_offset_)
#define ram_shared_(x) ram_shared(x) /* old hack compatible */
#define ram_shared(x) ((x)->_ram_shared_)

/* RANGE
 */
#define RANGE(x) ((range)((x).p))
#define range_CAST(x) RANGE(x)
#define RANGE_CAST(x) RANGE(x)
#define RANGE_(x) ((x).e)
#define RANGE_TYPE range
#define range_TYPE range
#define range_undefined ((range)gen_chunk_undefined)
#define range_undefined_p(x) ((x)==range_undefined)

extern range copy_range(range);
extern void free_range(range);
extern range check_range(range);
extern bool range_consistent_p(range);
extern bool range_defined_p(range);
#define gen_RANGE_cons gen_range_cons
extern list gen_range_cons(range, list);
extern void range_assign_contents(range, range);
extern void range_non_recursive_free(range);
extern void write_range(FILE*, range);
extern range read_range(FILE*);
extern range make_range(expression, expression, expression);

struct _newgen_struct_range_ {
  intptr_t _type_;
  expression _range_lower_; /* lower:expression */
  expression _range_upper_; /* upper:expression */
  expression _range_increment_; /* increment:expression */
};

#define range_domain_number(x) ((x)->_type_)
#define range_lower_(x) range_lower(x) /* old hack compatible */
#define range_lower(x) ((x)->_range_lower_)
#define range_upper_(x) range_upper(x) /* old hack compatible */
#define range_upper(x) ((x)->_range_upper_)
#define range_increment_(x) range_increment(x) /* old hack compatible */
#define range_increment(x) ((x)->_range_increment_)

/* REFERENCE
 */
#define REFERENCE(x) ((reference)((x).p))
#define reference_CAST(x) REFERENCE(x)
#define REFERENCE_CAST(x) REFERENCE(x)
#define REFERENCE_(x) ((x).e)
#define REFERENCE_TYPE reference
#define reference_TYPE reference
#define reference_undefined ((reference)gen_chunk_undefined)
#define reference_undefined_p(x) ((x)==reference_undefined)

extern reference copy_reference(reference);
extern void free_reference(reference);
extern reference check_reference(reference);
extern bool reference_consistent_p(reference);
extern bool reference_defined_p(reference);
#define gen_REFERENCE_cons gen_reference_cons
extern list gen_reference_cons(reference, list);
extern void reference_assign_contents(reference, reference);
extern void reference_non_recursive_free(reference);
extern void write_reference(FILE*, reference);
extern reference read_reference(FILE*);
extern reference make_reference(entity, list);

struct _newgen_struct_reference_ {
  intptr_t _type_;
  entity _reference_variable_; /* variable:entity */
  list _reference_indices_; /* indices:expression* */
};

#define reference_domain_number(x) ((x)->_type_)
#define reference_variable_(x) reference_variable(x) /* old hack compatible */
#define reference_variable(x) ((x)->_reference_variable_)
#define reference_indices_(x) reference_indices(x) /* old hack compatible */
#define reference_indices(x) ((x)->_reference_indices_)

/* SEQUENCE
 */
#define SEQUENCE(x) ((sequence)((x).p))
#define sequence_CAST(x) SEQUENCE(x)
#define SEQUENCE_CAST(x) SEQUENCE(x)
#define SEQUENCE_(x) ((x).e)
#define SEQUENCE_TYPE sequence
#define sequence_TYPE sequence
#define sequence_undefined ((sequence)gen_chunk_undefined)
#define sequence_undefined_p(x) ((x)==sequence_undefined)

extern sequence copy_sequence(sequence);
extern void free_sequence(sequence);
extern sequence check_sequence(sequence);
extern bool sequence_consistent_p(sequence);
extern bool sequence_defined_p(sequence);
#define gen_SEQUENCE_cons gen_sequence_cons
extern list gen_sequence_cons(sequence, list);
extern void sequence_assign_contents(sequence, sequence);
extern void sequence_non_recursive_free(sequence);
extern void write_sequence(FILE*, sequence);
extern sequence read_sequence(FILE*);
extern sequence make_sequence(list);

struct _newgen_struct_sequence_ {
  intptr_t _type_;
  list _sequence_holder_;
};

#define sequence_domain_number(x) ((x)->_type_)
#define sequence_statements(x) ((x)->_sequence_holder_)

/* SIZEOFEXPRESSION
 */
#define SIZEOFEXPRESSION(x) ((sizeofexpression)((x).p))
#define sizeofexpression_CAST(x) SIZEOFEXPRESSION(x)
#define SIZEOFEXPRESSION_CAST(x) SIZEOFEXPRESSION(x)
#define SIZEOFEXPRESSION_(x) ((x).e)
#define SIZEOFEXPRESSION_TYPE sizeofexpression
#define sizeofexpression_TYPE sizeofexpression
#define sizeofexpression_undefined ((sizeofexpression)gen_chunk_undefined)
#define sizeofexpression_undefined_p(x) ((x)==sizeofexpression_undefined)

extern sizeofexpression copy_sizeofexpression(sizeofexpression);
extern void free_sizeofexpression(sizeofexpression);
extern sizeofexpression check_sizeofexpression(sizeofexpression);
extern bool sizeofexpression_consistent_p(sizeofexpression);
extern bool sizeofexpression_defined_p(sizeofexpression);
#define gen_SIZEOFEXPRESSION_cons gen_sizeofexpression_cons
extern list gen_sizeofexpression_cons(sizeofexpression, list);
extern void sizeofexpression_assign_contents(sizeofexpression, sizeofexpression);
extern void sizeofexpression_non_recursive_free(sizeofexpression);
extern void write_sizeofexpression(FILE*, sizeofexpression);
extern sizeofexpression read_sizeofexpression(FILE*);
enum sizeofexpression_utype {
  is_sizeofexpression_type,
  is_sizeofexpression_expression
};
extern string sizeofexpression_tag_as_string(enum sizeofexpression_utype);
extern sizeofexpression make_sizeofexpression(enum sizeofexpression_utype, void *);
extern sizeofexpression make_sizeofexpression_type(type);
extern sizeofexpression make_sizeofexpression_expression(expression);

struct _newgen_struct_sizeofexpression_ {
  intptr_t _type_;
  enum sizeofexpression_utype _sizeofexpression_tag__;
  union {
    type _sizeofexpression_type_; /* type:type */
    expression _sizeofexpression_expression_; /* expression:expression */
  } _sizeofexpression_union_;
};

#define sizeofexpression_domain_number(x) ((x)->_type_)
#define sizeofexpression_tag(x) ((x)->_sizeofexpression_tag__)
#define sizeofexpression_type_p(x) (sizeofexpression_tag(x)==is_sizeofexpression_type)
#define sizeofexpression_type_(x) sizeofexpression_type(x) /* old hack compatible */
#define sizeofexpression_type(x) ((x)->_sizeofexpression_union_._sizeofexpression_type_)
#define sizeofexpression_expression_p(x) (sizeofexpression_tag(x)==is_sizeofexpression_expression)
#define sizeofexpression_expression_(x) sizeofexpression_expression(x) /* old hack compatible */
#define sizeofexpression_expression(x) ((x)->_sizeofexpression_union_._sizeofexpression_expression_)

/* STATEMENT
 */
#define STATEMENT(x) ((statement)((x).p))
#define statement_CAST(x) STATEMENT(x)
#define STATEMENT_CAST(x) STATEMENT(x)
#define STATEMENT_(x) ((x).e)
#define STATEMENT_TYPE statement
#define statement_TYPE statement
#define statement_undefined ((statement)gen_chunk_undefined)
#define statement_undefined_p(x) ((x)==statement_undefined)

extern statement copy_statement(statement);
extern void free_statement(statement);
extern statement check_statement(statement);
extern bool statement_consistent_p(statement);
extern bool statement_defined_p(statement);
#define gen_STATEMENT_cons gen_statement_cons
extern list gen_statement_cons(statement, list);
extern void statement_assign_contents(statement, statement);
extern void statement_non_recursive_free(statement);
extern void write_statement(FILE*, statement);
extern statement read_statement(FILE*);
extern statement make_statement(entity, intptr_t, intptr_t, string, instruction, list, string, extensions, synchronization);

struct _newgen_struct_statement_ {
  intptr_t _type_;
  entity _statement_label_; /* label:entity */
  intptr_t _statement_number_; /* number:int */
  intptr_t _statement_ordering_; /* ordering:int */
  string _statement_comments_; /* comments:string */
  instruction _statement_instruction_; /* instruction:instruction */
  list _statement_declarations_; /* declarations:entity* */
  string _statement_decls_text_; /* decls_text:string */
  extensions _statement_extensions_; /* extensions:extensions */
  synchronization _statement_synchronization_; /* synchronization:synchronization */
};

#define statement_domain_number(x) ((x)->_type_)
#define statement_label_(x) statement_label(x) /* old hack compatible */
#define statement_label(x) ((x)->_statement_label_)
#define statement_number_(x) statement_number(x) /* old hack compatible */
#define statement_number(x) ((x)->_statement_number_)
#define statement_ordering_(x) statement_ordering(x) /* old hack compatible */
#define statement_ordering(x) ((x)->_statement_ordering_)
#define statement_comments_(x) statement_comments(x) /* old hack compatible */
#define statement_comments(x) ((x)->_statement_comments_)
#define statement_instruction_(x) statement_instruction(x) /* old hack compatible */
#define statement_instruction(x) ((x)->_statement_instruction_)
#define statement_declarations_(x) statement_declarations(x) /* old hack compatible */
#define statement_declarations(x) ((x)->_statement_declarations_)
#define statement_decls_text_(x) statement_decls_text(x) /* old hack compatible */
#define statement_decls_text(x) ((x)->_statement_decls_text_)
#define statement_extensions_(x) statement_extensions(x) /* old hack compatible */
#define statement_extensions(x) ((x)->_statement_extensions_)
#define statement_synchronization_(x) statement_synchronization(x) /* old hack compatible */
#define statement_synchronization(x) ((x)->_statement_synchronization_)

/* STORAGE
 */
#define STORAGE(x) ((storage)((x).p))
#define storage_CAST(x) STORAGE(x)
#define STORAGE_CAST(x) STORAGE(x)
#define STORAGE_(x) ((x).e)
#define STORAGE_TYPE storage
#define storage_TYPE storage
#define storage_undefined ((storage)gen_chunk_undefined)
#define storage_undefined_p(x) ((x)==storage_undefined)

extern storage copy_storage(storage);
extern void free_storage(storage);
extern storage check_storage(storage);
extern bool storage_consistent_p(storage);
extern bool storage_defined_p(storage);
#define gen_STORAGE_cons gen_storage_cons
extern list gen_storage_cons(storage, list);
extern void storage_assign_contents(storage, storage);
extern void storage_non_recursive_free(storage);
extern void write_storage(FILE*, storage);
extern storage read_storage(FILE*);
enum storage_utype {
  is_storage_return,
  is_storage_ram,
  is_storage_formal,
  is_storage_rom
};
extern string storage_tag_as_string(enum storage_utype);
extern storage make_storage(enum storage_utype, void *);
extern storage make_storage_return(entity);
extern storage make_storage_ram(ram);
extern storage make_storage_formal(formal);
extern storage make_storage_rom(void);

struct _newgen_struct_storage_ {
  intptr_t _type_;
  enum storage_utype _storage_tag__;
  union {
    entity _storage_return_; /* return:entity */
    ram _storage_ram_; /* ram:ram */
    formal _storage_formal_; /* formal:formal */
    gen_chunk _storage_rom_; /* rom:unit */
  } _storage_union_;
};

#define storage_domain_number(x) ((x)->_type_)
#define storage_tag(x) ((x)->_storage_tag__)
#define storage_return_p(x) (storage_tag(x)==is_storage_return)
#define storage_return_(x) storage_return(x) /* old hack compatible */
#define storage_return(x) ((x)->_storage_union_._storage_return_)
#define storage_ram_p(x) (storage_tag(x)==is_storage_ram)
#define storage_ram_(x) storage_ram(x) /* old hack compatible */
#define storage_ram(x) ((x)->_storage_union_._storage_ram_)
#define storage_formal_p(x) (storage_tag(x)==is_storage_formal)
#define storage_formal_(x) storage_formal(x) /* old hack compatible */
#define storage_formal(x) ((x)->_storage_union_._storage_formal_)
#define storage_rom_p(x) (storage_tag(x)==is_storage_rom)
#define storage_rom_(x) storage_rom(x) /* old hack compatible */
#define storage_rom(x) ((x)->_storage_union_._storage_rom_.u)

/* SUBSCRIPT
 */
#define SUBSCRIPT(x) ((subscript)((x).p))
#define subscript_CAST(x) SUBSCRIPT(x)
#define SUBSCRIPT_CAST(x) SUBSCRIPT(x)
#define SUBSCRIPT_(x) ((x).e)
#define SUBSCRIPT_TYPE subscript
#define subscript_TYPE subscript
#define subscript_undefined ((subscript)gen_chunk_undefined)
#define subscript_undefined_p(x) ((x)==subscript_undefined)

extern subscript copy_subscript(subscript);
extern void free_subscript(subscript);
extern subscript check_subscript(subscript);
extern bool subscript_consistent_p(subscript);
extern bool subscript_defined_p(subscript);
#define gen_SUBSCRIPT_cons gen_subscript_cons
extern list gen_subscript_cons(subscript, list);
extern void subscript_assign_contents(subscript, subscript);
extern void subscript_non_recursive_free(subscript);
extern void write_subscript(FILE*, subscript);
extern subscript read_subscript(FILE*);
extern subscript make_subscript(expression, list);

struct _newgen_struct_subscript_ {
  intptr_t _type_;
  expression _subscript_array_; /* array:expression */
  list _subscript_indices_; /* indices:expression* */
};

#define subscript_domain_number(x) ((x)->_type_)
#define subscript_array_(x) subscript_array(x) /* old hack compatible */
#define subscript_array(x) ((x)->_subscript_array_)
#define subscript_indices_(x) subscript_indices(x) /* old hack compatible */
#define subscript_indices(x) ((x)->_subscript_indices_)

/* SYMBOLIC
 */
#define SYMBOLIC(x) ((symbolic)((x).p))
#define symbolic_CAST(x) SYMBOLIC(x)
#define SYMBOLIC_CAST(x) SYMBOLIC(x)
#define SYMBOLIC_(x) ((x).e)
#define SYMBOLIC_TYPE symbolic
#define symbolic_TYPE symbolic
#define symbolic_undefined ((symbolic)gen_chunk_undefined)
#define symbolic_undefined_p(x) ((x)==symbolic_undefined)

extern symbolic copy_symbolic(symbolic);
extern void free_symbolic(symbolic);
extern symbolic check_symbolic(symbolic);
extern bool symbolic_consistent_p(symbolic);
extern bool symbolic_defined_p(symbolic);
#define gen_SYMBOLIC_cons gen_symbolic_cons
extern list gen_symbolic_cons(symbolic, list);
extern void symbolic_assign_contents(symbolic, symbolic);
extern void symbolic_non_recursive_free(symbolic);
extern void write_symbolic(FILE*, symbolic);
extern symbolic read_symbolic(FILE*);
extern symbolic make_symbolic(expression, constant);

struct _newgen_struct_symbolic_ {
  intptr_t _type_;
  expression _symbolic_expression_; /* expression:expression */
  constant _symbolic_constant_; /* constant:constant */
};

#define symbolic_domain_number(x) ((x)->_type_)
#define symbolic_expression_(x) symbolic_expression(x) /* old hack compatible */
#define symbolic_expression(x) ((x)->_symbolic_expression_)
#define symbolic_constant_(x) symbolic_constant(x) /* old hack compatible */
#define symbolic_constant(x) ((x)->_symbolic_constant_)

/* SYNCHRONIZATION
 */
#define SYNCHRONIZATION(x) ((synchronization)((x).p))
#define synchronization_CAST(x) SYNCHRONIZATION(x)
#define SYNCHRONIZATION_CAST(x) SYNCHRONIZATION(x)
#define SYNCHRONIZATION_(x) ((x).e)
#define SYNCHRONIZATION_TYPE synchronization
#define synchronization_TYPE synchronization
#define synchronization_undefined ((synchronization)gen_chunk_undefined)
#define synchronization_undefined_p(x) ((x)==synchronization_undefined)

extern synchronization copy_synchronization(synchronization);
extern void free_synchronization(synchronization);
extern synchronization check_synchronization(synchronization);
extern bool synchronization_consistent_p(synchronization);
extern bool synchronization_defined_p(synchronization);
#define gen_SYNCHRONIZATION_cons gen_synchronization_cons
extern list gen_synchronization_cons(synchronization, list);
extern void synchronization_assign_contents(synchronization, synchronization);
extern void synchronization_non_recursive_free(synchronization);
extern void write_synchronization(FILE*, synchronization);
extern synchronization read_synchronization(FILE*);
enum synchronization_utype {
  is_synchronization_none,
  is_synchronization_spawn,
  is_synchronization_barrier,
  is_synchronization_single,
  is_synchronization_critical
};
extern string synchronization_tag_as_string(enum synchronization_utype);
extern synchronization make_synchronization(enum synchronization_utype, void *);
extern synchronization make_synchronization_none(void);
extern synchronization make_synchronization_spawn(entity);
extern synchronization make_synchronization_barrier(void);
extern synchronization make_synchronization_single(bool);
extern synchronization make_synchronization_critical(reference);

struct _newgen_struct_synchronization_ {
  intptr_t _type_;
  enum synchronization_utype _synchronization_tag__;
  union {
    gen_chunk _synchronization_none_; /* none:unit */
    entity _synchronization_spawn_; /* spawn:entity */
    gen_chunk _synchronization_barrier_; /* barrier:unit */
    gen_chunk _synchronization_single_; /* single:bool */
    reference _synchronization_critical_; /* critical:reference */
  } _synchronization_union_;
};

#define synchronization_domain_number(x) ((x)->_type_)
#define synchronization_tag(x) ((x)->_synchronization_tag__)
#define synchronization_none_p(x) (synchronization_tag(x)==is_synchronization_none)
#define synchronization_none_(x) synchronization_none(x) /* old hack compatible */
#define synchronization_none(x) ((x)->_synchronization_union_._synchronization_none_.u)
#define synchronization_spawn_p(x) (synchronization_tag(x)==is_synchronization_spawn)
#define synchronization_spawn_(x) synchronization_spawn(x) /* old hack compatible */
#define synchronization_spawn(x) ((x)->_synchronization_union_._synchronization_spawn_)
#define synchronization_barrier_p(x) (synchronization_tag(x)==is_synchronization_barrier)
#define synchronization_barrier_(x) synchronization_barrier(x) /* old hack compatible */
#define synchronization_barrier(x) ((x)->_synchronization_union_._synchronization_barrier_.u)
#define synchronization_single_p(x) (synchronization_tag(x)==is_synchronization_single)
#define synchronization_single_(x) synchronization_single(x) /* old hack compatible */
#define synchronization_single(x) ((x)->_synchronization_union_._synchronization_single_.b)
#define synchronization_critical_p(x) (synchronization_tag(x)==is_synchronization_critical)
#define synchronization_critical_(x) synchronization_critical(x) /* old hack compatible */
#define synchronization_critical(x) ((x)->_synchronization_union_._synchronization_critical_)

/* SYNTAX
 */
#define SYNTAX(x) ((syntax)((x).p))
#define syntax_CAST(x) SYNTAX(x)
#define SYNTAX_CAST(x) SYNTAX(x)
#define SYNTAX_(x) ((x).e)
#define SYNTAX_TYPE syntax
#define syntax_TYPE syntax
#define syntax_undefined ((syntax)gen_chunk_undefined)
#define syntax_undefined_p(x) ((x)==syntax_undefined)

extern syntax copy_syntax(syntax);
extern void free_syntax(syntax);
extern syntax check_syntax(syntax);
extern bool syntax_consistent_p(syntax);
extern bool syntax_defined_p(syntax);
#define gen_SYNTAX_cons gen_syntax_cons
extern list gen_syntax_cons(syntax, list);
extern void syntax_assign_contents(syntax, syntax);
extern void syntax_non_recursive_free(syntax);
extern void write_syntax(FILE*, syntax);
extern syntax read_syntax(FILE*);
enum syntax_utype {
  is_syntax_reference,
  is_syntax_range,
  is_syntax_call,
  is_syntax_cast,
  is_syntax_sizeofexpression,
  is_syntax_subscript,
  is_syntax_application,
  is_syntax_va_arg
};
extern string syntax_tag_as_string(enum syntax_utype);
extern syntax make_syntax(enum syntax_utype, void *);
extern syntax make_syntax_reference(reference);
extern syntax make_syntax_range(range);
extern syntax make_syntax_call(call);
extern syntax make_syntax_cast(cast);
extern syntax make_syntax_sizeofexpression(sizeofexpression);
extern syntax make_syntax_subscript(subscript);
extern syntax make_syntax_application(application);
extern syntax make_syntax_va_arg(list);

struct _newgen_struct_syntax_ {
  intptr_t _type_;
  enum syntax_utype _syntax_tag__;
  union {
    reference _syntax_reference_; /* reference:reference */
    range _syntax_range_; /* range:range */
    call _syntax_call_; /* call:call */
    cast _syntax_cast_; /* cast:cast */
    sizeofexpression _syntax_sizeofexpression_; /* sizeofexpression:sizeofexpression */
    subscript _syntax_subscript_; /* subscript:subscript */
    application _syntax_application_; /* application:application */
    list _syntax_va_arg_; /* va_arg:sizeofexpression* */
  } _syntax_union_;
};

#define syntax_domain_number(x) ((x)->_type_)
#define syntax_tag(x) ((x)->_syntax_tag__)
#define syntax_reference_p(x) (syntax_tag(x)==is_syntax_reference)
#define syntax_reference_(x) syntax_reference(x) /* old hack compatible */
#define syntax_reference(x) ((x)->_syntax_union_._syntax_reference_)
#define syntax_range_p(x) (syntax_tag(x)==is_syntax_range)
#define syntax_range_(x) syntax_range(x) /* old hack compatible */
#define syntax_range(x) ((x)->_syntax_union_._syntax_range_)
#define syntax_call_p(x) (syntax_tag(x)==is_syntax_call)
#define syntax_call_(x) syntax_call(x) /* old hack compatible */
#define syntax_call(x) ((x)->_syntax_union_._syntax_call_)
#define syntax_cast_p(x) (syntax_tag(x)==is_syntax_cast)
#define syntax_cast_(x) syntax_cast(x) /* old hack compatible */
#define syntax_cast(x) ((x)->_syntax_union_._syntax_cast_)
#define syntax_sizeofexpression_p(x) (syntax_tag(x)==is_syntax_sizeofexpression)
#define syntax_sizeofexpression_(x) syntax_sizeofexpression(x) /* old hack compatible */
#define syntax_sizeofexpression(x) ((x)->_syntax_union_._syntax_sizeofexpression_)
#define syntax_subscript_p(x) (syntax_tag(x)==is_syntax_subscript)
#define syntax_subscript_(x) syntax_subscript(x) /* old hack compatible */
#define syntax_subscript(x) ((x)->_syntax_union_._syntax_subscript_)
#define syntax_application_p(x) (syntax_tag(x)==is_syntax_application)
#define syntax_application_(x) syntax_application(x) /* old hack compatible */
#define syntax_application(x) ((x)->_syntax_union_._syntax_application_)
#define syntax_va_arg_p(x) (syntax_tag(x)==is_syntax_va_arg)
#define syntax_va_arg_(x) syntax_va_arg(x) /* old hack compatible */
#define syntax_va_arg(x) ((x)->_syntax_union_._syntax_va_arg_)

/* ENTITY
 */
#define ENTITY(x) ((entity)((x).p))
#define entity_CAST(x) ENTITY(x)
#define ENTITY_CAST(x) ENTITY(x)
#define ENTITY_(x) ((x).e)
#define ENTITY_TYPE entity
#define entity_TYPE entity
#define entity_undefined ((entity)gen_chunk_undefined)
#define entity_undefined_p(x) ((x)==entity_undefined)

extern entity copy_entity(entity);
extern void free_entity(entity);
extern entity check_entity(entity);
extern bool entity_consistent_p(entity);
extern bool entity_defined_p(entity);
#define gen_ENTITY_cons gen_entity_cons
extern list gen_entity_cons(entity, list);
extern void entity_assign_contents(entity, entity);
extern void entity_non_recursive_free(entity);
extern entity gen_find_entity(char *);
extern void write_tabulated_entity(FILE *);
extern void read_tabulated_entity(FILE *);
extern entity make_entity(string, type, storage, value, intptr_t);

struct _newgen_struct_entity_ {
  intptr_t _type_;
  intptr_t _entity_index__;
  string _entity_name_; /* name:string */
  type _entity_type_; /* type:type */
  storage _entity_storage_; /* storage:storage */
  value _entity_initial_; /* initial:value */
  intptr_t _entity_kind_; /* kind:int */
};

#define entity_domain_number(x) ((x)->_type_)
#define entity_name_(x) entity_name(x) /* old hack compatible */
#define entity_name(x) ((x)->_entity_name_)
#define entity_type_(x) entity_type(x) /* old hack compatible */
#define entity_type(x) ((x)->_entity_type_)
#define entity_storage_(x) entity_storage(x) /* old hack compatible */
#define entity_storage(x) ((x)->_entity_storage_)
#define entity_initial_(x) entity_initial(x) /* old hack compatible */
#define entity_initial(x) ((x)->_entity_initial_)
#define entity_kind_(x) entity_kind(x) /* old hack compatible */
#define entity_kind(x) ((x)->_entity_kind_)

/* TEST
 */
#define TEST(x) ((test)((x).p))
#define test_CAST(x) TEST(x)
#define TEST_CAST(x) TEST(x)
#define TEST_(x) ((x).e)
#define TEST_TYPE test
#define test_TYPE test
#define test_undefined ((test)gen_chunk_undefined)
#define test_undefined_p(x) ((x)==test_undefined)

extern test copy_test(test);
extern void free_test(test);
extern test check_test(test);
extern bool test_consistent_p(test);
extern bool test_defined_p(test);
#define gen_TEST_cons gen_test_cons
extern list gen_test_cons(test, list);
extern void test_assign_contents(test, test);
extern void test_non_recursive_free(test);
extern void write_test(FILE*, test);
extern test read_test(FILE*);
extern test make_test(expression, statement, statement);

struct _newgen_struct_test_ {
  intptr_t _type_;
  expression _test_condition_; /* condition:expression */
  statement _test_true_; /* true:statement */
  statement _test_false_; /* false:statement */
};

#define test_domain_number(x) ((x)->_type_)
#define test_condition_(x) test_condition(x) /* old hack compatible */
#define test_condition(x) ((x)->_test_condition_)
#define test_true_(x) test_true(x) /* old hack compatible */
#define test_true(x) ((x)->_test_true_)
#define test_false_(x) test_false(x) /* old hack compatible */
#define test_false(x) ((x)->_test_false_)

/* TRANSFORMER
 */
#define TRANSFORMER(x) ((transformer)((x).p))
#define transformer_CAST(x) TRANSFORMER(x)
#define TRANSFORMER_CAST(x) TRANSFORMER(x)
#define TRANSFORMER_(x) ((x).e)
#define TRANSFORMER_TYPE transformer
#define transformer_TYPE transformer
#define transformer_undefined ((transformer)gen_chunk_undefined)
#define transformer_undefined_p(x) ((x)==transformer_undefined)

extern transformer copy_transformer(transformer);
extern void free_transformer(transformer);
extern transformer check_transformer(transformer);
extern bool transformer_consistent_p(transformer);
extern bool transformer_defined_p(transformer);
#define gen_TRANSFORMER_cons gen_transformer_cons
extern list gen_transformer_cons(transformer, list);
extern void transformer_assign_contents(transformer, transformer);
extern void transformer_non_recursive_free(transformer);
extern void write_transformer(FILE*, transformer);
extern transformer read_transformer(FILE*);
extern transformer make_transformer(list, predicate);

struct _newgen_struct_transformer_ {
  intptr_t _type_;
  list _transformer_arguments_; /* arguments:entity* */
  predicate _transformer_relation_; /* relation:predicate */
};

#define transformer_domain_number(x) ((x)->_type_)
#define transformer_arguments_(x) transformer_arguments(x) /* old hack compatible */
#define transformer_arguments(x) ((x)->_transformer_arguments_)
#define transformer_relation_(x) transformer_relation(x) /* old hack compatible */
#define transformer_relation(x) ((x)->_transformer_relation_)

/* TYPE
 */
#define TYPE(x) ((type)((x).p))
#define type_CAST(x) TYPE(x)
#define TYPE_CAST(x) TYPE(x)
#define TYPE_(x) ((x).e)
#define TYPE_TYPE type
#define type_TYPE type
#define type_undefined ((type)gen_chunk_undefined)
#define type_undefined_p(x) ((x)==type_undefined)

extern type copy_type(type);
extern void free_type(type);
extern type check_type(type);
extern bool type_consistent_p(type);
extern bool type_defined_p(type);
#define gen_TYPE_cons gen_type_cons
extern list gen_type_cons(type, list);
extern void type_assign_contents(type, type);
extern void type_non_recursive_free(type);
extern void write_type(FILE*, type);
extern type read_type(FILE*);
enum type_utype {
  is_type_statement,
  is_type_area,
  is_type_variable,
  is_type_functional,
  is_type_varargs,
  is_type_unknown,
  is_type_void,
  is_type_struct,
  is_type_union,
  is_type_enum
};
extern string type_tag_as_string(enum type_utype);
extern type make_type(enum type_utype, void *);
extern type make_type_statement(void);
extern type make_type_area(area);
extern type make_type_variable(variable);
extern type make_type_functional(functional);
extern type make_type_varargs(type);
extern type make_type_unknown(void);
extern type make_type_void(list);
extern type make_type_struct(list);
extern type make_type_union(list);
extern type make_type_enum(list);

struct _newgen_struct_type_ {
  intptr_t _type_;
  enum type_utype _type_tag__;
  union {
    gen_chunk _type_statement_; /* statement:unit */
    area _type_area_; /* area:area */
    variable _type_variable_; /* variable:variable */
    functional _type_functional_; /* functional:functional */
    type _type_varargs_; /* varargs:type */
    gen_chunk _type_unknown_; /* unknown:unit */
    list _type_void_; /* void:qualifier* */
    list _type_struct_; /* struct:entity* */
    list _type_union_; /* union:entity* */
    list _type_enum_; /* enum:entity* */
  } _type_union_;
};

#define type_domain_number(x) ((x)->_type_)
#define type_tag(x) ((x)->_type_tag__)
#define type_statement_p(x) (type_tag(x)==is_type_statement)
#define type_statement_(x) type_statement(x) /* old hack compatible */
#define type_statement(x) ((x)->_type_union_._type_statement_.u)
#define type_area_p(x) (type_tag(x)==is_type_area)
#define type_area_(x) type_area(x) /* old hack compatible */
#define type_area(x) ((x)->_type_union_._type_area_)
#define type_variable_p(x) (type_tag(x)==is_type_variable)
#define type_variable_(x) type_variable(x) /* old hack compatible */
#define type_variable(x) ((x)->_type_union_._type_variable_)
#define type_functional_p(x) (type_tag(x)==is_type_functional)
#define type_functional_(x) type_functional(x) /* old hack compatible */
#define type_functional(x) ((x)->_type_union_._type_functional_)
#define type_varargs_p(x) (type_tag(x)==is_type_varargs)
#define type_varargs_(x) type_varargs(x) /* old hack compatible */
#define type_varargs(x) ((x)->_type_union_._type_varargs_)
#define type_unknown_p(x) (type_tag(x)==is_type_unknown)
#define type_unknown_(x) type_unknown(x) /* old hack compatible */
#define type_unknown(x) ((x)->_type_union_._type_unknown_.u)
#define type_void_p(x) (type_tag(x)==is_type_void)
#define type_void_(x) type_void(x) /* old hack compatible */
#define type_void(x) ((x)->_type_union_._type_void_)
#define type_struct_p(x) (type_tag(x)==is_type_struct)
#define type_struct_(x) type_struct(x) /* old hack compatible */
#define type_struct(x) ((x)->_type_union_._type_struct_)
#define type_union_p(x) (type_tag(x)==is_type_union)
#define type_union_(x) type_union(x) /* old hack compatible */
#define type_union(x) ((x)->_type_union_._type_union_)
#define type_enum_p(x) (type_tag(x)==is_type_enum)
#define type_enum_(x) type_enum(x) /* old hack compatible */
#define type_enum(x) ((x)->_type_union_._type_enum_)

/* UNSTRUCTURED
 */
#define UNSTRUCTURED(x) ((unstructured)((x).p))
#define unstructured_CAST(x) UNSTRUCTURED(x)
#define UNSTRUCTURED_CAST(x) UNSTRUCTURED(x)
#define UNSTRUCTURED_(x) ((x).e)
#define UNSTRUCTURED_TYPE unstructured
#define unstructured_TYPE unstructured
#define unstructured_undefined ((unstructured)gen_chunk_undefined)
#define unstructured_undefined_p(x) ((x)==unstructured_undefined)

extern unstructured copy_unstructured(unstructured);
extern void free_unstructured(unstructured);
extern unstructured check_unstructured(unstructured);
extern bool unstructured_consistent_p(unstructured);
extern bool unstructured_defined_p(unstructured);
#define gen_UNSTRUCTURED_cons gen_unstructured_cons
extern list gen_unstructured_cons(unstructured, list);
extern void unstructured_assign_contents(unstructured, unstructured);
extern void unstructured_non_recursive_free(unstructured);
extern void write_unstructured(FILE*, unstructured);
extern unstructured read_unstructured(FILE*);
extern unstructured make_unstructured(control, control);

struct _newgen_struct_unstructured_ {
  intptr_t _type_;
  control _unstructured_entry_; /* entry:control */
  control _unstructured_exit_; /* exit:control */
};

#define unstructured_domain_number(x) ((x)->_type_)
#define unstructured_entry_(x) unstructured_entry(x) /* old hack compatible */
#define unstructured_entry(x) ((x)->_unstructured_entry_)
#define unstructured_exit_(x) unstructured_exit(x) /* old hack compatible */
#define unstructured_exit(x) ((x)->_unstructured_exit_)

/* VALUE
 */
#define VALUE(x) ((value)((x).p))
#define value_CAST(x) VALUE(x)
#define VALUE_CAST(x) VALUE(x)
#define VALUE_(x) ((x).e)
#define VALUE_TYPE value
#define value_TYPE value
#define value_undefined ((value)gen_chunk_undefined)
#define value_undefined_p(x) ((x)==value_undefined)

extern value copy_value(value);
extern void free_value(value);
extern value check_value(value);
extern bool value_consistent_p(value);
extern bool value_defined_p(value);
#define gen_VALUE_cons gen_value_cons
extern list gen_value_cons(value, list);
extern void value_assign_contents(value, value);
extern void value_non_recursive_free(value);
extern void write_value(FILE*, value);
extern value read_value(FILE*);
enum value_utype {
  is_value_code,
  is_value_symbolic,
  is_value_constant,
  is_value_intrinsic,
  is_value_unknown,
  is_value_expression
};
extern string value_tag_as_string(enum value_utype);
extern value make_value(enum value_utype, void *);
extern value make_value_code(code);
extern value make_value_symbolic(symbolic);
extern value make_value_constant(constant);
extern value make_value_intrinsic(void);
extern value make_value_unknown(void);
extern value make_value_expression(expression);

struct _newgen_struct_value_ {
  intptr_t _type_;
  enum value_utype _value_tag__;
  union {
    code _value_code_; /* code:code */
    symbolic _value_symbolic_; /* symbolic:symbolic */
    constant _value_constant_; /* constant:constant */
    gen_chunk _value_intrinsic_; /* intrinsic:unit */
    gen_chunk _value_unknown_; /* unknown:unit */
    expression _value_expression_; /* expression:expression */
  } _value_union_;
};

#define value_domain_number(x) ((x)->_type_)
#define value_tag(x) ((x)->_value_tag__)
#define value_code_p(x) (value_tag(x)==is_value_code)
#define value_code_(x) value_code(x) /* old hack compatible */
#define value_code(x) ((x)->_value_union_._value_code_)
#define value_symbolic_p(x) (value_tag(x)==is_value_symbolic)
#define value_symbolic_(x) value_symbolic(x) /* old hack compatible */
#define value_symbolic(x) ((x)->_value_union_._value_symbolic_)
#define value_constant_p(x) (value_tag(x)==is_value_constant)
#define value_constant_(x) value_constant(x) /* old hack compatible */
#define value_constant(x) ((x)->_value_union_._value_constant_)
#define value_intrinsic_p(x) (value_tag(x)==is_value_intrinsic)
#define value_intrinsic_(x) value_intrinsic(x) /* old hack compatible */
#define value_intrinsic(x) ((x)->_value_union_._value_intrinsic_.u)
#define value_unknown_p(x) (value_tag(x)==is_value_unknown)
#define value_unknown_(x) value_unknown(x) /* old hack compatible */
#define value_unknown(x) ((x)->_value_union_._value_unknown_.u)
#define value_expression_p(x) (value_tag(x)==is_value_expression)
#define value_expression_(x) value_expression(x) /* old hack compatible */
#define value_expression(x) ((x)->_value_union_._value_expression_)

/* VARIABLE
 */
#define VARIABLE(x) ((variable)((x).p))
#define variable_CAST(x) VARIABLE(x)
#define VARIABLE_CAST(x) VARIABLE(x)
#define VARIABLE_(x) ((x).e)
#define VARIABLE_TYPE variable
#define variable_TYPE variable
#define variable_undefined ((variable)gen_chunk_undefined)
#define variable_undefined_p(x) ((x)==variable_undefined)

extern variable copy_variable(variable);
extern void free_variable(variable);
extern variable check_variable(variable);
extern bool variable_consistent_p(variable);
extern bool variable_defined_p(variable);
#define gen_VARIABLE_cons gen_variable_cons
extern list gen_variable_cons(variable, list);
extern void variable_assign_contents(variable, variable);
extern void variable_non_recursive_free(variable);
extern void write_variable(FILE*, variable);
extern variable read_variable(FILE*);
extern variable make_variable(basic, list, list);

struct _newgen_struct_variable_ {
  intptr_t _type_;
  basic _variable_basic_; /* basic:basic */
  list _variable_dimensions_; /* dimensions:dimension* */
  list _variable_qualifiers_; /* qualifiers:qualifier* */
};

#define variable_domain_number(x) ((x)->_type_)
#define variable_basic_(x) variable_basic(x) /* old hack compatible */
#define variable_basic(x) ((x)->_variable_basic_)
#define variable_dimensions_(x) variable_dimensions(x) /* old hack compatible */
#define variable_dimensions(x) ((x)->_variable_dimensions_)
#define variable_qualifiers_(x) variable_qualifiers(x) /* old hack compatible */
#define variable_qualifiers(x) ((x)->_variable_qualifiers_)

/* WHILELOOP
 */
#define WHILELOOP(x) ((whileloop)((x).p))
#define whileloop_CAST(x) WHILELOOP(x)
#define WHILELOOP_CAST(x) WHILELOOP(x)
#define WHILELOOP_(x) ((x).e)
#define WHILELOOP_TYPE whileloop
#define whileloop_TYPE whileloop
#define whileloop_undefined ((whileloop)gen_chunk_undefined)
#define whileloop_undefined_p(x) ((x)==whileloop_undefined)

extern whileloop copy_whileloop(whileloop);
extern void free_whileloop(whileloop);
extern whileloop check_whileloop(whileloop);
extern bool whileloop_consistent_p(whileloop);
extern bool whileloop_defined_p(whileloop);
#define gen_WHILELOOP_cons gen_whileloop_cons
extern list gen_whileloop_cons(whileloop, list);
extern void whileloop_assign_contents(whileloop, whileloop);
extern void whileloop_non_recursive_free(whileloop);
extern void write_whileloop(FILE*, whileloop);
extern whileloop read_whileloop(FILE*);
extern whileloop make_whileloop(expression, statement, entity, evaluation);

struct _newgen_struct_whileloop_ {
  intptr_t _type_;
  expression _whileloop_condition_; /* condition:expression */
  statement _whileloop_body_; /* body:statement */
  entity _whileloop_label_; /* label:entity */
  evaluation _whileloop_evaluation_; /* evaluation:evaluation */
};

#define whileloop_domain_number(x) ((x)->_type_)
#define whileloop_condition_(x) whileloop_condition(x) /* old hack compatible */
#define whileloop_condition(x) ((x)->_whileloop_condition_)
#define whileloop_body_(x) whileloop_body(x) /* old hack compatible */
#define whileloop_body(x) ((x)->_whileloop_body_)
#define whileloop_label_(x) whileloop_label(x) /* old hack compatible */
#define whileloop_label(x) ((x)->_whileloop_label_)
#define whileloop_evaluation_(x) whileloop_evaluation(x) /* old hack compatible */
#define whileloop_evaluation(x) ((x)->_whileloop_evaluation_)

#define ri_spec "\
--NEWGEN-START 27\n\
external Pvecteur;\n\
external Psysteme;\n\
application = function:expression x arguments:expression*;\n\
area = size:int x layout:entity*;\n\
basic = int:int + float:int + logical:int + overloaded:unit + complex:int + string:value + bit:symbolic + pointer:type + derived:entity + typedef:entity;\n\
callees = callees:string*;\n\
call = function:entity x arguments:expression*;\n\
cast = type:type x expression:expression;\n\
code = declarations:entity* x decls_text:string x initializations:sequence x externs:entity* x language:language;\n\
constant = int:int + float:float + logical:int + litteral:unit + call:entity + unknown:unit;\n\
controlmap = persistant statement:statement -> control:control;\n\
control = statement:statement x predecessors:control* x successors:control*;\n\
dimension = lower:expression x upper:expression x qualifiers:qualifier*;\n\
dummy = unknown:unit + identifier:entity;\n\
entity_int = entity:entity -> int:int;\n\
evaluation = before:unit + after:unit;\n\
execution = sequential:unit + parallel:unit;\n\
expression = syntax:syntax x normalized:normalized;\n\
extension = pragma:pragma + unknown:unit;\n\
extensions = extension:extension*;\n\
forloop = initialization:expression x condition:expression x increment:expression x body:statement;\n\
formal = function:entity x offset:int;\n\
functional = parameters:parameter* x result:type;\n\
instruction = sequence:sequence + test:test + loop:loop + whileloop:whileloop + goto:statement + call:call + unstructured:unstructured + multitest:multitest + forloop:forloop + expression:expression;\n\
language = fortran:unit + c:unit + fortran95:unit + unknown:unit;\n\
loop = index:entity x range:range x body:statement x label:entity x execution:execution x locals:entity*;\n\
mode = value:unit + reference:unit;\n\
multitest = controller:expression x body:statement;\n\
normalized = linear:Pvecteur + complex:unit;\n\
parameter = type:type x mode:mode x dummy:dummy;\n\
persistant_statement_to_cluster = statement:int -> number:int;\n\
persistant_statement_to_control = persistant statement:statement -> persistant control:control;\n\
persistant_statement_to_int = persistant statement:statement -> int:int;\n\
persistant_statement_to_statement = persistant statement:statement -> persistant statement:statement;\n\
pragma = string:string + expression:expression*;\n\
predicate = system:Psysteme;\n\
preference = persistant reference:reference;\n\
qualifier = const:unit + restrict:unit + volatile:unit + register:unit + auto:unit + thread:unit + asm:string + static_dimension:unit + local:unit + global:unit + constant:unit + private:unit;\n\
ram = function:entity x section:entity x offset:int x shared:entity*;\n\
range = lower:expression x upper:expression x increment:expression;\n\
reference = variable:entity x indices:expression*;\n\
sequence = statements:statement*;\n\
sizeofexpression = type:type + expression:expression;\n\
statement = label:entity x number:int x ordering:int x comments:string x instruction:instruction x declarations:entity* x decls_text:string x extensions:extensions x synchronization:synchronization;\n\
storage = return:entity + ram:ram + formal:formal + rom:unit;\n\
subscript = array:expression x indices:expression*;\n\
symbolic = expression:expression x constant:constant;\n\
synchronization = none:unit + spawn:entity + barrier:unit + single:bool + critical:reference;\n\
syntax = reference:reference + range:range + call:call + cast:cast + sizeofexpression:sizeofexpression + subscript:subscript + application:application + va_arg:sizeofexpression*;\n\
tabulated entity = name:string x type:type x storage:storage x initial:value x kind:int;\n\
test = condition:expression x true:statement x false:statement;\n\
transformer = arguments:entity* x relation:predicate;\n\
type = statement:unit + area:area + variable:variable + functional:functional + varargs:type + unknown:unit + void:qualifier* + struct:entity* + union:entity* + enum:entity*;\n\
unstructured = entry:control x exit:control;\n\
value = code:code + symbolic:symbolic + constant:constant + intrinsic:unit + unknown:unit + expression:expression;\n\
variable = basic:basic x dimensions:dimension* x qualifiers:qualifier*;\n\
whileloop = condition:expression x body:statement x label:entity x evaluation:evaluation;\n\
"
#endif
